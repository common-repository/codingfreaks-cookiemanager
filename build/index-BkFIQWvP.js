(function () {
    const c = document.createElement("link").relList;
    if (c && c.supports && c.supports("modulepreload")) return;
    for (const C of document.querySelectorAll('link[rel="modulepreload"]')) b(C);
    new MutationObserver(C => {
        for (const k of C) if (k.type === "childList") for (const A of k.addedNodes) A.tagName === "LINK" && A.rel === "modulepreload" && b(A)
    }).observe(document, {childList: !0, subtree: !0});

    function h(C) {
        const k = {};
        return C.integrity && (k.integrity = C.integrity), C.referrerPolicy && (k.referrerPolicy = C.referrerPolicy), C.crossOrigin === "use-credentials" ? k.credentials = "include" : C.crossOrigin === "anonymous" ? k.credentials = "omit" : k.credentials = "same-origin", k
    }

    function b(C) {
        if (C.ep) return;
        C.ep = !0;
        const k = h(C);
        fetch(C.href, k)
    }
})();

function vi(a, c) {
    const h = Object.create(null), b = a.split(",");
    for (let C = 0; C < b.length; C++) h[b[C]] = !0;
    return c ? C => !!h[C.toLowerCase()] : C => !!h[C]
}

const an = {}, Iu = [], mi = () => {
    }, Ap = () => !1,
    pc = a => a.charCodeAt(0) === 111 && a.charCodeAt(1) === 110 && (a.charCodeAt(2) > 122 || a.charCodeAt(2) < 97),
    a0 = a => a.startsWith("onUpdate:"), nn = Object.assign, l0 = (a, c) => {
        const h = a.indexOf(c);
        h > -1 && a.splice(h, 1)
    }, bL = Object.prototype.hasOwnProperty, en = (a, c) => bL.call(a, c), ut = Array.isArray,
    Mu = a => Uu(a) === "[object Map]", mc = a => Uu(a) === "[object Set]", k2 = a => Uu(a) === "[object Date]",
    kL = a => Uu(a) === "[object RegExp]", St = a => typeof a == "function", Pt = a => typeof a == "string",
    Eo = a => typeof a == "symbol", vn = a => a !== null && typeof a == "object",
    c0 = a => (vn(a) || St(a)) && St(a.then) && St(a.catch), MD = Object.prototype.toString, Uu = a => MD.call(a),
    vL = a => Uu(a).slice(8, -1), BD = a => Uu(a) === "[object Object]",
    u0 = a => Pt(a) && a !== "NaN" && a[0] !== "-" && "" + parseInt(a, 10) === a,
    ic = vi(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    wL = vi("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), Qp = a => {
        const c = Object.create(null);
        return h => c[h] || (c[h] = a(h))
    }, AL = /-(\w)/g, sr = Qp(a => a.replace(AL, (c, h) => h ? h.toUpperCase() : "")), CL = /\B([A-Z])/g,
    Li = Qp(a => a.replace(CL, "-$1").toLowerCase()), Xa = Qp(a => a.charAt(0).toUpperCase() + a.slice(1)),
    oc = Qp(a => a ? `on${Xa(a)}` : ""), $a = (a, c) => !Object.is(a, c), Bu = (a, c) => {
        for (let h = 0; h < a.length; h++) a[h](c)
    }, Ep = (a, c, h) => {
        Object.defineProperty(a, c, {configurable: !0, enumerable: !1, value: h})
    }, Sp = a => {
        const c = parseFloat(a);
        return isNaN(c) ? a : c
    }, Tp = a => {
        const c = Pt(a) ? Number(a) : NaN;
        return isNaN(c) ? a : c
    };
let v2;
const Mk = () => v2 || (v2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}),
    _L = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console",
    yL = vi(_L);

function bc(a) {
    if (ut(a)) {
        const c = {};
        for (let h = 0; h < a.length; h++) {
            const b = a[h], C = Pt(b) ? ND(b) : bc(b);
            if (C) for (const k in C) c[k] = C[k]
        }
        return c
    } else if (Pt(a) || vn(a)) return a
}

const DL = /;(?![^(]*\))/g, xL = /:([^]+)/, EL = /\/\*[^]*?\*\//g;

function ND(a) {
    const c = {};
    return a.replace(EL, "").split(DL).forEach(h => {
        if (h) {
            const b = h.split(xL);
            b.length > 1 && (c[b[0].trim()] = b[1].trim())
        }
    }), c
}

function On(a) {
    let c = "";
    if (Pt(a)) c = a; else if (ut(a)) for (let h = 0; h < a.length; h++) {
        const b = On(a[h]);
        b && (c += b + " ")
    } else if (vn(a)) for (const h in a) a[h] && (c += h + " ");
    return c.trim()
}

function LD(a) {
    if (!a) return null;
    let {class: c, style: h} = a;
    return c && !Pt(c) && (a.class = On(c)), h && (a.style = bc(h)), a
}

const SL = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",
    TL = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",
    IL = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", ML = vi(SL), BL = vi(TL), NL = vi(IL),
    LL = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", PL = vi(LL);

function PD(a) {
    return !!a || a === ""
}

function OL(a, c) {
    if (a.length !== c.length) return !1;
    let h = !0;
    for (let b = 0; h && b < a.length; b++) h = Ga(a[b], c[b]);
    return h
}

function Ga(a, c) {
    if (a === c) return !0;
    let h = k2(a), b = k2(c);
    if (h || b) return h && b ? a.getTime() === c.getTime() : !1;
    if (h = Eo(a), b = Eo(c), h || b) return a === c;
    if (h = ut(a), b = ut(c), h || b) return h && b ? OL(a, c) : !1;
    if (h = vn(a), b = vn(c), h || b) {
        if (!h || !b) return !1;
        const C = Object.keys(a).length, k = Object.keys(c).length;
        if (C !== k) return !1;
        for (const A in a) {
            const y = a.hasOwnProperty(A), w = c.hasOwnProperty(A);
            if (y && !w || !y && w || !Ga(a[A], c[A])) return !1
        }
    }
    return String(a) === String(c)
}

function Jp(a, c) {
    return a.findIndex(h => Ga(h, c))
}

const Fn = a => Pt(a) ? a : a == null ? "" : ut(a) || vn(a) && (a.toString === MD || !St(a.toString)) ? JSON.stringify(a, OD, 2) : String(a),
    OD = (a, c) => c && c.__v_isRef ? OD(a, c.value) : Mu(c) ? {[`Map(${c.size})`]: [...c.entries()].reduce((h, [b, C], k) => (h[kk(b, k) + " =>"] = C, h), {})} : mc(c) ? {[`Set(${c.size})`]: [...c.values()].map(h => kk(h))} : Eo(c) ? kk(c) : vn(c) && !ut(c) && !BD(c) ? String(c) : c,
    kk = (a, c = "") => {
        var h;
        return Eo(a) ? `Symbol(${(h = a.description) != null ? h : c})` : a
    };
let Bi;

class Xp {
    constructor(c = !1) {
        this.detached = c, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Bi, !c && Bi && (this.index = (Bi.scopes || (Bi.scopes = [])).push(this) - 1)
    }

    get active() {
        return this._active
    }

    run(c) {
        if (this._active) {
            const h = Bi;
            try {
                return Bi = this, c()
            } finally {
                Bi = h
            }
        }
    }

    on() {
        Bi = this
    }

    off() {
        Bi = this.parent
    }

    stop(c) {
        if (this._active) {
            let h, b;
            for (h = 0, b = this.effects.length; h < b; h++) this.effects[h].stop();
            for (h = 0, b = this.cleanups.length; h < b; h++) this.cleanups[h]();
            if (this.scopes) for (h = 0, b = this.scopes.length; h < b; h++) this.scopes[h].stop(!0);
            if (!this.detached && this.parent && !c) {
                const C = this.parent.scopes.pop();
                C && C !== this && (this.parent.scopes[this.index] = C, C.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function FD(a) {
    return new Xp(a)
}

function RD(a, c = Bi) {
    c && c.active && c.effects.push(a)
}

function d0() {
    return Bi
}

function zD(a) {
    Bi && Bi.cleanups.push(a)
}

const h0 = a => {
    const c = new Set(a);
    return c.w = 0, c.n = 0, c
}, jD = a => (a.w & Ka) > 0, VD = a => (a.n & Ka) > 0, FL = ({deps: a}) => {
    if (a.length) for (let c = 0; c < a.length; c++) a[c].w |= Ka
}, RL = a => {
    const {deps: c} = a;
    if (c.length) {
        let h = 0;
        for (let b = 0; b < c.length; b++) {
            const C = c[b];
            jD(C) && !VD(C) ? C.delete(a) : c[h++] = C, C.w &= ~Ka, C.n &= ~Ka
        }
        c.length = h
    }
}, Ip = new WeakMap;
let Ch = 0, Ka = 1;
const Bk = 30;
let yo;
const sc = Symbol(""), Nk = Symbol("");

class cc {
    constructor(c, h = null, b) {
        this.fn = c, this.scheduler = h, this.active = !0, this.deps = [], this.parent = void 0, RD(this, b)
    }

    run() {
        if (!this.active) return this.fn();
        let c = yo, h = Va;
        for (; c;) {
            if (c === this) return;
            c = c.parent
        }
        try {
            return this.parent = yo, yo = this, Va = !0, Ka = 1 << ++Ch, Ch <= Bk ? FL(this) : w2(this), this.fn()
        } finally {
            Ch <= Bk && RL(this), Ka = 1 << --Ch, yo = this.parent, Va = h, this.parent = void 0, this.deferStop && this.stop()
        }
    }

    stop() {
        yo === this ? this.deferStop = !0 : this.active && (w2(this), this.onStop && this.onStop(), this.active = !1)
    }
}

function w2(a) {
    const {deps: c} = a;
    if (c.length) {
        for (let h = 0; h < c.length; h++) c[h].delete(a);
        c.length = 0
    }
}

function HD(a, c) {
    a.effect instanceof cc && (a = a.effect.fn);
    const h = new cc(a);
    c && (nn(h, c), c.scope && RD(h, c.scope)), (!c || !c.lazy) && h.run();
    const b = h.run.bind(h);
    return b.effect = h, b
}

function UD(a) {
    a.effect.stop()
}

let Va = !0;
const qD = [];

function qu() {
    qD.push(Va), Va = !1
}

function Wu() {
    const a = qD.pop();
    Va = a === void 0 ? !0 : a
}

function ki(a, c, h) {
    if (Va && yo) {
        let b = Ip.get(a);
        b || Ip.set(a, b = new Map);
        let C = b.get(h);
        C || b.set(h, C = h0()), WD(C)
    }
}

function WD(a, c) {
    let h = !1;
    Ch <= Bk ? VD(a) || (a.n |= Ka, h = !jD(a)) : h = !a.has(yo), h && (a.add(yo), yo.deps.push(a))
}

function Us(a, c, h, b, C, k) {
    const A = Ip.get(a);
    if (!A) return;
    let y = [];
    if (c === "clear") y = [...A.values()]; else if (h === "length" && ut(a)) {
        const w = Number(b);
        A.forEach((S, I) => {
            (I === "length" || !Eo(I) && I >= w) && y.push(S)
        })
    } else switch (h !== void 0 && y.push(A.get(h)), c) {
        case"add":
            ut(a) ? u0(h) && y.push(A.get("length")) : (y.push(A.get(sc)), Mu(a) && y.push(A.get(Nk)));
            break;
        case"delete":
            ut(a) || (y.push(A.get(sc)), Mu(a) && y.push(A.get(Nk)));
            break;
        case"set":
            Mu(a) && y.push(A.get(sc));
            break
    }
    if (y.length === 1) y[0] && Lk(y[0]); else {
        const w = [];
        for (const S of y) S && w.push(...S);
        Lk(h0(w))
    }
}

function Lk(a, c) {
    const h = ut(a) ? a : [...a];
    for (const b of h) b.computed && A2(b);
    for (const b of h) b.computed || A2(b)
}

function A2(a, c) {
    (a !== yo || a.allowRecurse) && (a.scheduler ? a.scheduler() : a.run())
}

function zL(a, c) {
    var h;
    return (h = Ip.get(a)) == null ? void 0 : h.get(c)
}

const jL = vi("__proto__,__v_isRef,__isVue"),
    $D = new Set(Object.getOwnPropertyNames(Symbol).filter(a => a !== "arguments" && a !== "caller").map(a => Symbol[a]).filter(Eo)),
    C2 = VL();

function VL() {
    const a = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(c => {
        a[c] = function (...h) {
            const b = Wt(this);
            for (let k = 0, A = this.length; k < A; k++) ki(b, "get", k + "");
            const C = b[c](...h);
            return C === -1 || C === !1 ? b[c](...h.map(Wt)) : C
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(c => {
        a[c] = function (...h) {
            qu();
            const b = Wt(this)[c].apply(this, h);
            return Wu(), b
        }
    }), a
}

function HL(a) {
    const c = Wt(this);
    return ki(c, "has", a), c.hasOwnProperty(a)
}

class GD {
    constructor(c = !1, h = !1) {
        this._isReadonly = c, this._shallow = h
    }

    get(c, h, b) {
        const C = this._isReadonly, k = this._shallow;
        if (h === "__v_isReactive") return !C;
        if (h === "__v_isReadonly") return C;
        if (h === "__v_isShallow") return k;
        if (h === "__v_raw") return b === (C ? k ? XD : JD : k ? QD : YD).get(c) || Object.getPrototypeOf(c) === Object.getPrototypeOf(b) ? c : void 0;
        const A = ut(c);
        if (!C) {
            if (A && en(C2, h)) return Reflect.get(C2, h, b);
            if (h === "hasOwnProperty") return HL
        }
        const y = Reflect.get(c, h, b);
        return (Eo(h) ? $D.has(h) : jL(h)) || (C || ki(c, "get", h), k) ? y : ar(y) ? A && u0(h) ? y : y.value : vn(y) ? C ? nm(y) : jr(y) : y
    }
}

class KD extends GD {
    constructor(c = !1) {
        super(!1, c)
    }

    set(c, h, b, C) {
        let k = c[h];
        if (!this._shallow) {
            const w = $s(k);
            if (!Pu(b) && !$s(b) && (k = Wt(k), b = Wt(b)), !ut(c) && ar(k) && !ar(b)) return w ? !1 : (k.value = b, !0)
        }
        const A = ut(c) && u0(h) ? Number(h) < c.length : en(c, h), y = Reflect.set(c, h, b, C);
        return c === Wt(C) && (A ? $a(b, k) && Us(c, "set", h, b) : Us(c, "add", h, b)), y
    }

    deleteProperty(c, h) {
        const b = en(c, h);
        c[h];
        const C = Reflect.deleteProperty(c, h);
        return C && b && Us(c, "delete", h, void 0), C
    }

    has(c, h) {
        const b = Reflect.has(c, h);
        return (!Eo(h) || !$D.has(h)) && ki(c, "has", h), b
    }

    ownKeys(c) {
        return ki(c, "iterate", ut(c) ? "length" : sc), Reflect.ownKeys(c)
    }
}

class ZD extends GD {
    constructor(c = !1) {
        super(!0, c)
    }

    set(c, h) {
        return !0
    }

    deleteProperty(c, h) {
        return !0
    }
}

const UL = new KD, qL = new ZD, WL = new KD(!0), $L = new ZD(!0), f0 = a => a, em = a => Reflect.getPrototypeOf(a);

function op(a, c, h = !1, b = !1) {
    a = a.__v_raw;
    const C = Wt(a), k = Wt(c);
    h || ($a(c, k) && ki(C, "get", c), ki(C, "get", k));
    const {has: A} = em(C), y = b ? f0 : h ? p0 : Mh;
    if (A.call(C, c)) return y(a.get(c));
    if (A.call(C, k)) return y(a.get(k));
    a !== C && a.get(c)
}

function sp(a, c = !1) {
    const h = this.__v_raw, b = Wt(h), C = Wt(a);
    return c || ($a(a, C) && ki(b, "has", a), ki(b, "has", C)), a === C ? h.has(a) : h.has(a) || h.has(C)
}

function ap(a, c = !1) {
    return a = a.__v_raw, !c && ki(Wt(a), "iterate", sc), Reflect.get(a, "size", a)
}

function _2(a) {
    a = Wt(a);
    const c = Wt(this);
    return em(c).has.call(c, a) || (c.add(a), Us(c, "add", a, a)), this
}

function y2(a, c) {
    c = Wt(c);
    const h = Wt(this), {has: b, get: C} = em(h);
    let k = b.call(h, a);
    k || (a = Wt(a), k = b.call(h, a));
    const A = C.call(h, a);
    return h.set(a, c), k ? $a(c, A) && Us(h, "set", a, c) : Us(h, "add", a, c), this
}

function D2(a) {
    const c = Wt(this), {has: h, get: b} = em(c);
    let C = h.call(c, a);
    C || (a = Wt(a), C = h.call(c, a)), b && b.call(c, a);
    const k = c.delete(a);
    return C && Us(c, "delete", a, void 0), k
}

function x2() {
    const a = Wt(this), c = a.size !== 0, h = a.clear();
    return c && Us(a, "clear", void 0, void 0), h
}

function lp(a, c) {
    return function (b, C) {
        const k = this, A = k.__v_raw, y = Wt(A), w = c ? f0 : a ? p0 : Mh;
        return !a && ki(y, "iterate", sc), A.forEach((S, I) => b.call(C, w(S), w(I), k))
    }
}

function cp(a, c, h) {
    return function (...b) {
        const C = this.__v_raw, k = Wt(C), A = Mu(k), y = a === "entries" || a === Symbol.iterator && A,
            w = a === "keys" && A, S = C[a](...b), I = h ? f0 : c ? p0 : Mh;
        return !c && ki(k, "iterate", w ? Nk : sc), {
            next() {
                const {value: T, done: D} = S.next();
                return D ? {value: T, done: D} : {value: y ? [I(T[0]), I(T[1])] : I(T), done: D}
            }, [Symbol.iterator]() {
                return this
            }
        }
    }
}

function La(a) {
    return function (...c) {
        return a === "delete" ? !1 : a === "clear" ? void 0 : this
    }
}

function GL() {
    const a = {
        get(k) {
            return op(this, k)
        }, get size() {
            return ap(this)
        }, has: sp, add: _2, set: y2, delete: D2, clear: x2, forEach: lp(!1, !1)
    }, c = {
        get(k) {
            return op(this, k, !1, !0)
        }, get size() {
            return ap(this)
        }, has: sp, add: _2, set: y2, delete: D2, clear: x2, forEach: lp(!1, !0)
    }, h = {
        get(k) {
            return op(this, k, !0)
        }, get size() {
            return ap(this, !0)
        }, has(k) {
            return sp.call(this, k, !0)
        }, add: La("add"), set: La("set"), delete: La("delete"), clear: La("clear"), forEach: lp(!0, !1)
    }, b = {
        get(k) {
            return op(this, k, !0, !0)
        }, get size() {
            return ap(this, !0)
        }, has(k) {
            return sp.call(this, k, !0)
        }, add: La("add"), set: La("set"), delete: La("delete"), clear: La("clear"), forEach: lp(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(k => {
        a[k] = cp(k, !1, !1), h[k] = cp(k, !0, !1), c[k] = cp(k, !1, !0), b[k] = cp(k, !0, !0)
    }), [a, h, c, b]
}

const [KL, ZL, YL, QL] = GL();

function tm(a, c) {
    const h = c ? a ? QL : YL : a ? ZL : KL;
    return (b, C, k) => C === "__v_isReactive" ? !a : C === "__v_isReadonly" ? a : C === "__v_raw" ? b : Reflect.get(en(h, C) && C in b ? h : b, C, k)
}

const JL = {get: tm(!1, !1)}, XL = {get: tm(!1, !0)}, eP = {get: tm(!0, !1)}, tP = {get: tm(!0, !0)}, YD = new WeakMap,
    QD = new WeakMap, JD = new WeakMap, XD = new WeakMap;

function nP(a) {
    switch (a) {
        case"Object":
        case"Array":
            return 1;
        case"Map":
        case"Set":
        case"WeakMap":
        case"WeakSet":
            return 2;
        default:
            return 0
    }
}

function rP(a) {
    return a.__v_skip || !Object.isExtensible(a) ? 0 : nP(vL(a))
}

function jr(a) {
    return $s(a) ? a : rm(a, !1, UL, JL, YD)
}

function g0(a) {
    return rm(a, !1, WL, XL, QD)
}

function nm(a) {
    return rm(a, !0, qL, eP, JD)
}

function ex(a) {
    return rm(a, !0, $L, tP, XD)
}

function rm(a, c, h, b, C) {
    if (!vn(a) || a.__v_raw && !(c && a.__v_isReactive)) return a;
    const k = C.get(a);
    if (k) return k;
    const A = rP(a);
    if (A === 0) return a;
    const y = new Proxy(a, A === 2 ? b : h);
    return C.set(a, y), y
}

function qs(a) {
    return $s(a) ? qs(a.__v_raw) : !!(a && a.__v_isReactive)
}

function $s(a) {
    return !!(a && a.__v_isReadonly)
}

function Pu(a) {
    return !!(a && a.__v_isShallow)
}

function im(a) {
    return qs(a) || $s(a)
}

function Wt(a) {
    const c = a && a.__v_raw;
    return c ? Wt(c) : a
}

function Gs(a) {
    return Ep(a, "__v_skip", !0), a
}

const Mh = a => vn(a) ? jr(a) : a, p0 = a => vn(a) ? nm(a) : a;

function m0(a) {
    Va && yo && (a = Wt(a), WD(a.dep || (a.dep = h0())))
}

function om(a, c) {
    a = Wt(a);
    const h = a.dep;
    h && Lk(h)
}

function ar(a) {
    return !!(a && a.__v_isRef === !0)
}

function yt(a) {
    return tx(a, !1)
}

function b0(a) {
    return tx(a, !0)
}

function tx(a, c) {
    return ar(a) ? a : new iP(a, c)
}

class iP {
    constructor(c, h) {
        this.__v_isShallow = h, this.dep = void 0, this.__v_isRef = !0, this._rawValue = h ? c : Wt(c), this._value = h ? c : Mh(c)
    }

    get value() {
        return m0(this), this._value
    }

    set value(c) {
        const h = this.__v_isShallow || Pu(c) || $s(c);
        c = h ? c : Wt(c), $a(c, this._rawValue) && (this._rawValue = c, this._value = h ? c : Mh(c), om(this))
    }
}

function nx(a) {
    om(a)
}

function xt(a) {
    return ar(a) ? a.value : a
}

function rx(a) {
    return St(a) ? a() : xt(a)
}

const oP = {
    get: (a, c, h) => xt(Reflect.get(a, c, h)), set: (a, c, h, b) => {
        const C = a[c];
        return ar(C) && !ar(h) ? (C.value = h, !0) : Reflect.set(a, c, h, b)
    }
};

function sm(a) {
    return qs(a) ? a : new Proxy(a, oP)
}

class sP {
    constructor(c) {
        this.dep = void 0, this.__v_isRef = !0;
        const {get: h, set: b} = c(() => m0(this), () => om(this));
        this._get = h, this._set = b
    }

    get value() {
        return this._get()
    }

    set value(c) {
        this._set(c)
    }
}

function ix(a) {
    return new sP(a)
}

function ox(a) {
    const c = ut(a) ? new Array(a.length) : {};
    for (const h in a) c[h] = ax(a, h);
    return c
}

class aP {
    constructor(c, h, b) {
        this._object = c, this._key = h, this._defaultValue = b, this.__v_isRef = !0
    }

    get value() {
        const c = this._object[this._key];
        return c === void 0 ? this._defaultValue : c
    }

    set value(c) {
        this._object[this._key] = c
    }

    get dep() {
        return zL(Wt(this._object), this._key)
    }
}

class lP {
    constructor(c) {
        this._getter = c, this.__v_isRef = !0, this.__v_isReadonly = !0
    }

    get value() {
        return this._getter()
    }
}

function sx(a, c, h) {
    return ar(a) ? a : St(a) ? new lP(a) : vn(a) && arguments.length > 1 ? ax(a, c, h) : yt(a)
}

function ax(a, c, h) {
    const b = a[c];
    return ar(b) ? b : new aP(a, c, h)
}

class cP {
    constructor(c, h, b, C) {
        this._setter = h, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new cc(c, () => {
            this._dirty || (this._dirty = !0, om(this))
        }), this.effect.computed = this, this.effect.active = this._cacheable = !C, this.__v_isReadonly = b
    }

    get value() {
        const c = Wt(this);
        return m0(c), (c._dirty || !c._cacheable) && (c._dirty = !1, c._value = c.effect.run()), c._value
    }

    set value(c) {
        this._setter(c)
    }
}

function uP(a, c, h = !1) {
    let b, C;
    const k = St(a);
    return k ? (b = a, C = mi) : (b = a.get, C = a.set), new cP(b, C, k || !C, h)
}

function lx(a, ...c) {
}

function cx(a, c) {
}

function os(a, c, h, b) {
    let C;
    try {
        C = b ? a(...b) : a()
    } catch (k) {
        el(k, c, h)
    }
    return C
}

function bi(a, c, h, b) {
    if (St(a)) {
        const k = os(a, c, h, b);
        return k && c0(k) && k.catch(A => {
            el(A, c, h)
        }), k
    }
    const C = [];
    for (let k = 0; k < a.length; k++) C.push(bi(a[k], c, h, b));
    return C
}

function el(a, c, h, b = !0) {
    const C = c ? c.vnode : null;
    if (c) {
        let k = c.parent;
        const A = c.proxy, y = h;
        for (; k;) {
            const S = k.ec;
            if (S) {
                for (let I = 0; I < S.length; I++) if (S[I](a, A, y) === !1) return
            }
            k = k.parent
        }
        const w = c.appContext.config.errorHandler;
        if (w) {
            os(w, null, 10, [a, A, y]);
            return
        }
    }
    dP(a, h, C, b)
}

function dP(a, c, h, b = !0) {
    console.error(a)
}

let Bh = !1, Pk = !1;
const Wr = [];
let is = 0;
const Nu = [];
let js = null, Xl = 0;
const ux = Promise.resolve();
let k0 = null;

function uc(a) {
    const c = k0 || ux;
    return a ? c.then(this ? a.bind(this) : a) : c
}

function hP(a) {
    let c = is + 1, h = Wr.length;
    for (; c < h;) {
        const b = c + h >>> 1, C = Wr[b], k = Lh(C);
        k < a || k === a && C.pre ? c = b + 1 : h = b
    }
    return c
}

function am(a) {
    (!Wr.length || !Wr.includes(a, Bh && a.allowRecurse ? is + 1 : is)) && (a.id == null ? Wr.push(a) : Wr.splice(hP(a.id), 0, a), dx())
}

function dx() {
    !Bh && !Pk && (Pk = !0, k0 = ux.then(hx))
}

function fP(a) {
    const c = Wr.indexOf(a);
    c > is && Wr.splice(c, 1)
}

function Nh(a) {
    ut(a) ? Nu.push(...a) : (!js || !js.includes(a, a.allowRecurse ? Xl + 1 : Xl)) && Nu.push(a), dx()
}

function E2(a, c, h = Bh ? is + 1 : 0) {
    for (; h < Wr.length; h++) {
        const b = Wr[h];
        if (b && b.pre) {
            if (a && b.id !== a.uid) continue;
            Wr.splice(h, 1), h--, b()
        }
    }
}

function Mp(a) {
    if (Nu.length) {
        const c = [...new Set(Nu)];
        if (Nu.length = 0, js) {
            js.push(...c);
            return
        }
        for (js = c, js.sort((h, b) => Lh(h) - Lh(b)), Xl = 0; Xl < js.length; Xl++) js[Xl]();
        js = null, Xl = 0
    }
}

const Lh = a => a.id == null ? 1 / 0 : a.id, gP = (a, c) => {
    const h = Lh(a) - Lh(c);
    if (h === 0) {
        if (a.pre && !c.pre) return -1;
        if (c.pre && !a.pre) return 1
    }
    return h
};

function hx(a) {
    Pk = !1, Bh = !0, Wr.sort(gP);
    try {
        for (is = 0; is < Wr.length; is++) {
            const c = Wr[is];
            c && c.active !== !1 && os(c, null, 14)
        }
    } finally {
        is = 0, Wr.length = 0, Mp(), Bh = !1, k0 = null, (Wr.length || Nu.length) && hx()
    }
}

let ec, up = [];

function v0(a, c) {
    var h, b;
    ec = a, ec ? (ec.enabled = !0, up.forEach(({
                                                   event: C,
                                                   args: k
                                               }) => ec.emit(C, ...k)), up = []) : typeof window < "u" && window.HTMLElement && !((b = (h = window.navigator) == null ? void 0 : h.userAgent) != null && b.includes("jsdom")) ? ((c.__VUE_DEVTOOLS_HOOK_REPLAY__ = c.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(k => {
        v0(k, c)
    }), setTimeout(() => {
        ec || (c.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, up = [])
    }, 3e3)) : up = []
}

function pP(a, c, ...h) {
    if (a.isUnmounted) return;
    const b = a.vnode.props || an;
    let C = h;
    const k = c.startsWith("update:"), A = k && c.slice(7);
    if (A && A in b) {
        const I = `${A === "modelValue" ? "model" : A}Modifiers`, {number: T, trim: D} = b[I] || an;
        D && (C = h.map(B => Pt(B) ? B.trim() : B)), T && (C = h.map(Sp))
    }
    let y, w = b[y = oc(c)] || b[y = oc(sr(c))];
    !w && k && (w = b[y = oc(Li(c))]), w && bi(w, a, 6, C);
    const S = b[y + "Once"];
    if (S) {
        if (!a.emitted) a.emitted = {}; else if (a.emitted[y]) return;
        a.emitted[y] = !0, bi(S, a, 6, C)
    }
}

function fx(a, c, h = !1) {
    const b = c.emitsCache, C = b.get(a);
    if (C !== void 0) return C;
    const k = a.emits;
    let A = {}, y = !1;
    if (!St(a)) {
        const w = S => {
            const I = fx(S, c, !0);
            I && (y = !0, nn(A, I))
        };
        !h && c.mixins.length && c.mixins.forEach(w), a.extends && w(a.extends), a.mixins && a.mixins.forEach(w)
    }
    return !k && !y ? (vn(a) && b.set(a, null), null) : (ut(k) ? k.forEach(w => A[w] = null) : nn(A, k), vn(a) && b.set(a, A), A)
}

function lm(a, c) {
    return !a || !pc(c) ? !1 : (c = c.slice(2).replace(/Once$/, ""), en(a, c[0].toLowerCase() + c.slice(1)) || en(a, Li(c)) || en(a, c))
}

let Er = null, cm = null;

function Ph(a) {
    const c = Er;
    return Er = a, cm = a && a.type.__scopeId || null, c
}

function $u(a) {
    cm = a
}

function Gu() {
    cm = null
}

const gx = a => Sr;

function Sr(a, c = Er, h) {
    if (!c || a._n) return a;
    const b = (...C) => {
        b._d && Lp(-1);
        const k = Ph(c);
        let A;
        try {
            A = a(...C)
        } finally {
            Ph(k), b._d && Lp(1)
        }
        return A
    };
    return b._n = !0, b._c = !0, b._d = !0, b
}

function Cp(a) {
    const {
        type: c,
        vnode: h,
        proxy: b,
        withProxy: C,
        props: k,
        propsOptions: [A],
        slots: y,
        attrs: w,
        emit: S,
        render: I,
        renderCache: T,
        data: D,
        setupState: B,
        ctx: L,
        inheritAttrs: z
    } = a;
    let q, Q;
    const G = Ph(a);
    try {
        if (h.shapeFlag & 4) {
            const Y = C || b, ce = Y;
            q = Ni(I.call(ce, Y, T, k, B, D, L)), Q = w
        } else {
            const Y = c;
            q = Ni(Y.length > 1 ? Y(k, {attrs: w, slots: y, emit: S}) : Y(k, null)), Q = c.props ? w : bP(w)
        }
    } catch (Y) {
        Eh.length = 0, el(Y, a, 1), q = lt(Vr)
    }
    let Z = q;
    if (Q && z !== !1) {
        const Y = Object.keys(Q), {shapeFlag: ce} = Z;
        Y.length && ce & 7 && (A && Y.some(a0) && (Q = kP(Q, A)), Z = So(Z, Q))
    }
    return h.dirs && (Z = So(Z), Z.dirs = Z.dirs ? Z.dirs.concat(h.dirs) : h.dirs), h.transition && (Z.transition = h.transition), q = Z, Ph(G), q
}

function mP(a) {
    let c;
    for (let h = 0; h < a.length; h++) {
        const b = a[h];
        if (Ks(b)) {
            if (b.type !== Vr || b.children === "v-if") {
                if (c) return;
                c = b
            }
        } else return
    }
    return c
}

const bP = a => {
    let c;
    for (const h in a) (h === "class" || h === "style" || pc(h)) && ((c || (c = {}))[h] = a[h]);
    return c
}, kP = (a, c) => {
    const h = {};
    for (const b in a) (!a0(b) || !(b.slice(9) in c)) && (h[b] = a[b]);
    return h
};

function vP(a, c, h) {
    const {props: b, children: C, component: k} = a, {props: A, children: y, patchFlag: w} = c, S = k.emitsOptions;
    if (c.dirs || c.transition) return !0;
    if (h && w >= 0) {
        if (w & 1024) return !0;
        if (w & 16) return b ? S2(b, A, S) : !!A;
        if (w & 8) {
            const I = c.dynamicProps;
            for (let T = 0; T < I.length; T++) {
                const D = I[T];
                if (A[D] !== b[D] && !lm(S, D)) return !0
            }
        }
    } else return (C || y) && (!y || !y.$stable) ? !0 : b === A ? !1 : b ? A ? S2(b, A, S) : !0 : !!A;
    return !1
}

function S2(a, c, h) {
    const b = Object.keys(c);
    if (b.length !== Object.keys(a).length) return !0;
    for (let C = 0; C < b.length; C++) {
        const k = b[C];
        if (c[k] !== a[k] && !lm(h, k)) return !0
    }
    return !1
}

function w0({vnode: a, parent: c}, h) {
    for (; c && c.subTree === a;) (a = c.vnode).el = h, c = c.parent
}

const A0 = "components", wP = "directives";

function Nn(a, c) {
    return C0(A0, a, !0, c) || a
}

const px = Symbol.for("v-ndc");

function Oh(a) {
    return Pt(a) ? C0(A0, a, !1) || a : a || px
}

function mx(a) {
    return C0(wP, a)
}

function C0(a, c, h = !0, b = !1) {
    const C = Er || pr;
    if (C) {
        const k = C.type;
        if (a === A0) {
            const y = qk(k, !1);
            if (y && (y === c || y === sr(c) || y === Xa(sr(c)))) return k
        }
        const A = T2(C[a] || k[a], c) || T2(C.appContext[a], c);
        return !A && b ? k : A
    }
}

function T2(a, c) {
    return a && (a[c] || a[sr(c)] || a[Xa(sr(c))])
}

const bx = a => a.__isSuspense, AP = {
    name: "Suspense", __isSuspense: !0, process(a, c, h, b, C, k, A, y, w, S) {
        a == null ? CP(c, h, b, C, k, A, y, w, S) : _P(a, c, h, b, C, A, y, w, S)
    }, hydrate: yP, create: _0, normalize: DP
}, kx = AP;

function Fh(a, c) {
    const h = a.props && a.props[c];
    St(h) && h()
}

function CP(a, c, h, b, C, k, A, y, w) {
    const {p: S, o: {createElement: I}} = w, T = I("div"), D = a.suspense = _0(a, C, b, c, T, h, k, A, y, w);
    S(null, D.pendingBranch = a.ssContent, T, null, b, D, k, A), D.deps > 0 ? (Fh(a, "onPending"), Fh(a, "onFallback"), S(null, a.ssFallback, c, h, b, null, k, A), Lu(D, a.ssFallback)) : D.resolve(!1, !0)
}

function _P(a, c, h, b, C, k, A, y, {p: w, um: S, o: {createElement: I}}) {
    const T = c.suspense = a.suspense;
    T.vnode = c, c.el = a.el;
    const D = c.ssContent, B = c.ssFallback, {activeBranch: L, pendingBranch: z, isInFallback: q, isHydrating: Q} = T;
    if (z) T.pendingBranch = D, Do(D, z) ? (w(z, D, T.hiddenContainer, null, C, T, k, A, y), T.deps <= 0 ? T.resolve() : q && (w(L, B, h, b, C, null, k, A, y), Lu(T, B))) : (T.pendingId++, Q ? (T.isHydrating = !1, T.activeBranch = z) : S(z, C, T), T.deps = 0, T.effects.length = 0, T.hiddenContainer = I("div"), q ? (w(null, D, T.hiddenContainer, null, C, T, k, A, y), T.deps <= 0 ? T.resolve() : (w(L, B, h, b, C, null, k, A, y), Lu(T, B))) : L && Do(D, L) ? (w(L, D, h, b, C, T, k, A, y), T.resolve(!0)) : (w(null, D, T.hiddenContainer, null, C, T, k, A, y), T.deps <= 0 && T.resolve())); else if (L && Do(D, L)) w(L, D, h, b, C, T, k, A, y), Lu(T, D); else if (Fh(c, "onPending"), T.pendingBranch = D, T.pendingId++, w(null, D, T.hiddenContainer, null, C, T, k, A, y), T.deps <= 0) T.resolve(); else {
        const {timeout: G, pendingId: Z} = T;
        G > 0 ? setTimeout(() => {
            T.pendingId === Z && T.fallback(B)
        }, G) : G === 0 && T.fallback(B)
    }
}

function _0(a, c, h, b, C, k, A, y, w, S, I = !1) {
    const {p: T, m: D, um: B, n: L, o: {parentNode: z, remove: q}} = S;
    let Q;
    const G = xP(a);
    G && c != null && c.pendingBranch && (Q = c.pendingId, c.deps++);
    const Z = a.props ? Tp(a.props.timeout) : void 0, Y = {
        vnode: a,
        parent: c,
        parentComponent: h,
        isSVG: A,
        container: b,
        hiddenContainer: C,
        anchor: k,
        deps: 0,
        pendingId: 0,
        timeout: typeof Z == "number" ? Z : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !I,
        isHydrating: I,
        isUnmounted: !1,
        effects: [],
        resolve(ce = !1, Ce = !1) {
            const {
                vnode: me,
                activeBranch: R,
                pendingBranch: ae,
                pendingId: ue,
                effects: ve,
                parentComponent: ke,
                container: le
            } = Y;
            let ye = !1;
            if (Y.isHydrating) Y.isHydrating = !1; else if (!ce) {
                ye = R && ae.transition && ae.transition.mode === "out-in", ye && (R.transition.afterLeave = () => {
                    ue === Y.pendingId && (D(ae, le, L(R), 0), Nh(ve))
                });
                let {anchor: Ze} = Y;
                R && (Ze = L(R), B(R, ke, Y, !0)), ye || D(ae, le, Ze, 0)
            }
            Lu(Y, ae), Y.pendingBranch = null, Y.isInFallback = !1;
            let ee = Y.parent, qe = !1;
            for (; ee;) {
                if (ee.pendingBranch) {
                    ee.effects.push(...ve), qe = !0;
                    break
                }
                ee = ee.parent
            }
            !qe && !ye && Nh(ve), Y.effects = [], G && c && c.pendingBranch && Q === c.pendingId && (c.deps--, c.deps === 0 && !Ce && c.resolve()), Fh(me, "onResolve")
        },
        fallback(ce) {
            if (!Y.pendingBranch) return;
            const {vnode: Ce, activeBranch: me, parentComponent: R, container: ae, isSVG: ue} = Y;
            Fh(Ce, "onFallback");
            const ve = L(me), ke = () => {
                Y.isInFallback && (T(null, ce, ae, ve, R, null, ue, y, w), Lu(Y, ce))
            }, le = ce.transition && ce.transition.mode === "out-in";
            le && (me.transition.afterLeave = ke), Y.isInFallback = !0, B(me, R, null, !0), le || ke()
        },
        move(ce, Ce, me) {
            Y.activeBranch && D(Y.activeBranch, ce, Ce, me), Y.container = ce
        },
        next() {
            return Y.activeBranch && L(Y.activeBranch)
        },
        registerDep(ce, Ce) {
            const me = !!Y.pendingBranch;
            me && Y.deps++;
            const R = ce.vnode.el;
            ce.asyncDep.catch(ae => {
                el(ae, ce, 0)
            }).then(ae => {
                if (ce.isUnmounted || Y.isUnmounted || Y.pendingId !== ce.suspenseId) return;
                ce.asyncResolved = !0;
                const {vnode: ue} = ce;
                Hk(ce, ae, !1), R && (ue.el = R);
                const ve = !R && ce.subTree.el;
                Ce(ce, ue, z(R || ce.subTree.el), R ? null : L(ce.subTree), Y, A, w), ve && q(ve), w0(ce, ue.el), me && --Y.deps === 0 && Y.resolve()
            })
        },
        unmount(ce, Ce) {
            Y.isUnmounted = !0, Y.activeBranch && B(Y.activeBranch, h, ce, Ce), Y.pendingBranch && B(Y.pendingBranch, h, ce, Ce)
        }
    };
    return Y
}

function yP(a, c, h, b, C, k, A, y, w) {
    const S = c.suspense = _0(c, b, h, a.parentNode, document.createElement("div"), null, C, k, A, y, !0),
        I = w(a, S.pendingBranch = c.ssContent, h, S, k, A);
    return S.deps === 0 && S.resolve(!1, !0), I
}

function DP(a) {
    const {shapeFlag: c, children: h} = a, b = c & 32;
    a.ssContent = I2(b ? h.default : h), a.ssFallback = b ? I2(h.fallback) : lt(Vr)
}

function I2(a) {
    let c;
    if (St(a)) {
        const h = fc && a._c;
        h && (a._d = !1, He()), a = a(), h && (a._d = !0, c = gi, rE())
    }
    return ut(a) && (a = mP(a)), a = Ni(a), c && !a.dynamicChildren && (a.dynamicChildren = c.filter(h => h !== a)), a
}

function vx(a, c) {
    c && c.pendingBranch ? ut(a) ? c.effects.push(...a) : c.effects.push(a) : Nh(a)
}

function Lu(a, c) {
    a.activeBranch = c;
    const {vnode: h, parentComponent: b} = a, C = h.el = c.el;
    b && b.subTree === h && (b.vnode.el = C, w0(b, C))
}

function xP(a) {
    var c;
    return ((c = a.props) == null ? void 0 : c.suspensible) != null && a.props.suspensible !== !1
}

function wx(a, c) {
    return Kh(a, null, c)
}

function y0(a, c) {
    return Kh(a, null, {flush: "post"})
}

function Ax(a, c) {
    return Kh(a, null, {flush: "sync"})
}

const dp = {};

function or(a, c, h) {
    return Kh(a, c, h)
}

function Kh(a, c, {immediate: h, deep: b, flush: C, onTrack: k, onTrigger: A} = an) {
    var y;
    const w = d0() === ((y = pr) == null ? void 0 : y.scope) ? pr : null;
    let S, I = !1, T = !1;
    if (ar(a) ? (S = () => a.value, I = Pu(a)) : qs(a) ? (S = () => a, b = !0) : ut(a) ? (T = !0, I = a.some(Y => qs(Y) || Pu(Y)), S = () => a.map(Y => {
        if (ar(Y)) return Y.value;
        if (qs(Y)) return nc(Y);
        if (St(Y)) return os(Y, w, 2)
    })) : St(a) ? c ? S = () => os(a, w, 2) : S = () => {
        if (!(w && w.isUnmounted)) return D && D(), bi(a, w, 3, [B])
    } : S = mi, c && b) {
        const Y = S;
        S = () => nc(Y())
    }
    let D, B = Y => {
        D = G.onStop = () => {
            os(Y, w, 4), D = G.onStop = void 0
        }
    }, L;
    if (Ou) if (B = mi, c ? h && bi(c, w, 3, [S(), T ? [] : void 0, B]) : S(), C === "sync") {
        const Y = $0();
        L = Y.__watcherHandles || (Y.__watcherHandles = [])
    } else return mi;
    let z = T ? new Array(a.length).fill(dp) : dp;
    const q = () => {
        if (G.active) if (c) {
            const Y = G.run();
            (b || I || (T ? Y.some((ce, Ce) => $a(ce, z[Ce])) : $a(Y, z))) && (D && D(), bi(c, w, 3, [Y, z === dp ? void 0 : T && z[0] === dp ? [] : z, B]), z = Y)
        } else G.run()
    };
    q.allowRecurse = !!c;
    let Q;
    C === "sync" ? Q = q : C === "post" ? Q = () => zr(q, w && w.suspense) : (q.pre = !0, w && (q.id = w.uid), Q = () => am(q));
    const G = new cc(S, Q);
    c ? h ? q() : z = G.run() : C === "post" ? zr(G.run.bind(G), w && w.suspense) : G.run();
    const Z = () => {
        G.stop(), w && w.scope && l0(w.scope.effects, G)
    };
    return L && L.push(Z), Z
}

function EP(a, c, h) {
    const b = this.proxy, C = Pt(a) ? a.includes(".") ? Cx(b, a) : () => b[a] : a.bind(b, b);
    let k;
    St(c) ? k = c : (k = c.handler, h = c);
    const A = pr;
    Qa(this);
    const y = Kh(C, k.bind(b), h);
    return A ? Qa(A) : qa(), y
}

function Cx(a, c) {
    const h = c.split(".");
    return () => {
        let b = a;
        for (let C = 0; C < h.length && b; C++) b = b[h[C]];
        return b
    }
}

function nc(a, c) {
    if (!vn(a) || a.__v_skip || (c = c || new Set, c.has(a))) return a;
    if (c.add(a), ar(a)) nc(a.value, c); else if (ut(a)) for (let h = 0; h < a.length; h++) nc(a[h], c); else if (mc(a) || Mu(a)) a.forEach(h => {
        nc(h, c)
    }); else if (BD(a)) for (const h in a) nc(a[h], c);
    return a
}

function Bt(a, c) {
    const h = Er;
    if (h === null) return a;
    const b = mm(h) || h.proxy, C = a.dirs || (a.dirs = []);
    for (let k = 0; k < c.length; k++) {
        let [A, y, w, S = an] = c[k];
        A && (St(A) && (A = {mounted: A, updated: A}), A.deep && nc(y), C.push({
            dir: A,
            instance: b,
            value: y,
            oldValue: void 0,
            arg: w,
            modifiers: S
        }))
    }
    return a
}

function rs(a, c, h, b) {
    const C = a.dirs, k = c && c.dirs;
    for (let A = 0; A < C.length; A++) {
        const y = C[A];
        k && (y.oldValue = k[A].value);
        let w = y.dir[b];
        w && (qu(), bi(w, h, 8, [a.el, y, a, c]), Wu())
    }
}

const Ra = Symbol("_leaveCb"), hp = Symbol("_enterCb");

function um() {
    const a = {isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map};
    return Oi(() => {
        a.isMounted = !0
    }), kc(() => {
        a.isUnmounting = !0
    }), a
}

const eo = [Function, Array], dm = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: eo,
    onEnter: eo,
    onAfterEnter: eo,
    onEnterCancelled: eo,
    onBeforeLeave: eo,
    onLeave: eo,
    onAfterLeave: eo,
    onLeaveCancelled: eo,
    onBeforeAppear: eo,
    onAppear: eo,
    onAfterAppear: eo,
    onAppearCancelled: eo
}, SP = {
    name: "BaseTransition", props: dm, setup(a, {slots: c}) {
        const h = co(), b = um();
        let C;
        return () => {
            const k = c.default && Zh(c.default(), !0);
            if (!k || !k.length) return;
            let A = k[0];
            if (k.length > 1) {
                for (const z of k) if (z.type !== Vr) {
                    A = z;
                    break
                }
            }
            const y = Wt(a), {mode: w} = y;
            if (b.isLeaving) return vk(A);
            const S = M2(A);
            if (!S) return vk(A);
            const I = dc(S, y, b, h);
            Za(S, I);
            const T = h.subTree, D = T && M2(T);
            let B = !1;
            const {getTransitionKey: L} = S.type;
            if (L) {
                const z = L();
                C === void 0 ? C = z : z !== C && (C = z, B = !0)
            }
            if (D && D.type !== Vr && (!Do(S, D) || B)) {
                const z = dc(D, y, b, h);
                if (Za(D, z), w === "out-in") return b.isLeaving = !0, z.afterLeave = () => {
                    b.isLeaving = !1, h.update.active !== !1 && h.update()
                }, vk(A);
                w === "in-out" && S.type !== Vr && (z.delayLeave = (q, Q, G) => {
                    const Z = _x(b, D);
                    Z[String(D.key)] = D, q[Ra] = () => {
                        Q(), q[Ra] = void 0, delete I.delayedLeave
                    }, I.delayedLeave = G
                })
            }
            return A
        }
    }
}, D0 = SP;

function _x(a, c) {
    const {leavingVNodes: h} = a;
    let b = h.get(c.type);
    return b || (b = Object.create(null), h.set(c.type, b)), b
}

function dc(a, c, h, b) {
    const {
        appear: C,
        mode: k,
        persisted: A = !1,
        onBeforeEnter: y,
        onEnter: w,
        onAfterEnter: S,
        onEnterCancelled: I,
        onBeforeLeave: T,
        onLeave: D,
        onAfterLeave: B,
        onLeaveCancelled: L,
        onBeforeAppear: z,
        onAppear: q,
        onAfterAppear: Q,
        onAppearCancelled: G
    } = c, Z = String(a.key), Y = _x(h, a), ce = (R, ae) => {
        R && bi(R, b, 9, ae)
    }, Ce = (R, ae) => {
        const ue = ae[1];
        ce(R, ae), ut(R) ? R.every(ve => ve.length <= 1) && ue() : R.length <= 1 && ue()
    }, me = {
        mode: k, persisted: A, beforeEnter(R) {
            let ae = y;
            if (!h.isMounted) if (C) ae = z || y; else return;
            R[Ra] && R[Ra](!0);
            const ue = Y[Z];
            ue && Do(a, ue) && ue.el[Ra] && ue.el[Ra](), ce(ae, [R])
        }, enter(R) {
            let ae = w, ue = S, ve = I;
            if (!h.isMounted) if (C) ae = q || w, ue = Q || S, ve = G || I; else return;
            let ke = !1;
            const le = R[hp] = ye => {
                ke || (ke = !0, ye ? ce(ve, [R]) : ce(ue, [R]), me.delayedLeave && me.delayedLeave(), R[hp] = void 0)
            };
            ae ? Ce(ae, [R, le]) : le()
        }, leave(R, ae) {
            const ue = String(a.key);
            if (R[hp] && R[hp](!0), h.isUnmounting) return ae();
            ce(T, [R]);
            let ve = !1;
            const ke = R[Ra] = le => {
                ve || (ve = !0, ae(), le ? ce(L, [R]) : ce(B, [R]), R[Ra] = void 0, Y[ue] === a && delete Y[ue])
            };
            Y[ue] = a, D ? Ce(D, [R, ke]) : ke()
        }, clone(R) {
            return dc(R, c, h, b)
        }
    };
    return me
}

function vk(a) {
    if (Yh(a)) return a = So(a), a.children = null, a
}

function M2(a) {
    return Yh(a) ? a.children ? a.children[0] : void 0 : a
}

function Za(a, c) {
    a.shapeFlag & 6 && a.component ? Za(a.component.subTree, c) : a.shapeFlag & 128 ? (a.ssContent.transition = c.clone(a.ssContent), a.ssFallback.transition = c.clone(a.ssFallback)) : a.transition = c
}

function Zh(a, c = !1, h) {
    let b = [], C = 0;
    for (let k = 0; k < a.length; k++) {
        let A = a[k];
        const y = h == null ? A.key : String(h) + String(A.key != null ? A.key : k);
        A.type === ln ? (A.patchFlag & 128 && C++, b = b.concat(Zh(A.children, c, y))) : (c || A.type !== Vr) && b.push(y != null ? So(A, {key: y}) : A)
    }
    if (C > 1) for (let k = 0; k < b.length; k++) b[k].patchFlag = -2;
    return b
}/*! #__NO_SIDE_EFFECTS__ */
function tl(a, c) {
    return St(a) ? nn({name: a.name}, c, {setup: a}) : a
}

const ac = a => !!a.type.__asyncLoader;/*! #__NO_SIDE_EFFECTS__ */
function yx(a) {
    St(a) && (a = {loader: a});
    const {
        loader: c,
        loadingComponent: h,
        errorComponent: b,
        delay: C = 200,
        timeout: k,
        suspensible: A = !0,
        onError: y
    } = a;
    let w = null, S, I = 0;
    const T = () => (I++, w = null, D()), D = () => {
        let B;
        return w || (B = w = c().catch(L => {
            if (L = L instanceof Error ? L : new Error(String(L)), y) return new Promise((z, q) => {
                y(L, () => z(T()), () => q(L), I + 1)
            });
            throw L
        }).then(L => B !== w && w ? w : (L && (L.__esModule || L[Symbol.toStringTag] === "Module") && (L = L.default), S = L, L)))
    };
    return tl({
        name: "AsyncComponentWrapper", __asyncLoader: D, get __asyncResolved() {
            return S
        }, setup() {
            const B = pr;
            if (S) return () => wk(S, B);
            const L = G => {
                w = null, el(G, B, 13, !b)
            };
            if (A && B.suspense || Ou) return D().then(G => () => wk(G, B)).catch(G => (L(G), () => b ? lt(b, {error: G}) : null));
            const z = yt(!1), q = yt(), Q = yt(!!C);
            return C && setTimeout(() => {
                Q.value = !1
            }, C), k != null && setTimeout(() => {
                if (!z.value && !q.value) {
                    const G = new Error(`Async component timed out after ${k}ms.`);
                    L(G), q.value = G
                }
            }, k), D().then(() => {
                z.value = !0, B.parent && Yh(B.parent.vnode) && am(B.parent.update)
            }).catch(G => {
                L(G), q.value = G
            }), () => {
                if (z.value && S) return wk(S, B);
                if (q.value && b) return lt(b, {error: q.value});
                if (h && !Q.value) return lt(h)
            }
        }
    })
}

function wk(a, c) {
    const {ref: h, props: b, children: C, ce: k} = c.vnode, A = lt(a, b, C);
    return A.ref = h, A.ce = k, delete c.vnode.ce, A
}

const Yh = a => a.type.__isKeepAlive, TP = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number]},
    setup(a, {slots: c}) {
        const h = co(), b = h.ctx;
        if (!b.renderer) return () => {
            const G = c.default && c.default();
            return G && G.length === 1 ? G[0] : G
        };
        const C = new Map, k = new Set;
        let A = null;
        const y = h.suspense, {renderer: {p: w, m: S, um: I, o: {createElement: T}}} = b, D = T("div");
        b.activate = (G, Z, Y, ce, Ce) => {
            const me = G.component;
            S(G, Z, Y, 0, y), w(me.vnode, G, Z, Y, me, y, ce, G.slotScopeIds, Ce), zr(() => {
                me.isDeactivated = !1, me.a && Bu(me.a);
                const R = G.props && G.props.onVnodeMounted;
                R && fi(R, me.parent, G)
            }, y)
        }, b.deactivate = G => {
            const Z = G.component;
            S(G, D, null, 1, y), zr(() => {
                Z.da && Bu(Z.da);
                const Y = G.props && G.props.onVnodeUnmounted;
                Y && fi(Y, Z.parent, G), Z.isDeactivated = !0
            }, y)
        };

        function B(G) {
            Ak(G), I(G, h, y, !0)
        }

        function L(G) {
            C.forEach((Z, Y) => {
                const ce = qk(Z.type);
                ce && (!G || !G(ce)) && z(Y)
            })
        }

        function z(G) {
            const Z = C.get(G);
            !A || !Do(Z, A) ? B(Z) : A && Ak(A), C.delete(G), k.delete(G)
        }

        or(() => [a.include, a.exclude], ([G, Z]) => {
            G && L(Y => _h(G, Y)), Z && L(Y => !_h(Z, Y))
        }, {flush: "post", deep: !0});
        let q = null;
        const Q = () => {
            q != null && C.set(q, Ck(h.subTree))
        };
        return Oi(Q), Qh(Q), kc(() => {
            C.forEach(G => {
                const {subTree: Z, suspense: Y} = h, ce = Ck(Z);
                if (G.type === ce.type && G.key === ce.key) {
                    Ak(ce);
                    const Ce = ce.component.da;
                    Ce && zr(Ce, Y);
                    return
                }
                B(G)
            })
        }), () => {
            if (q = null, !c.default) return null;
            const G = c.default(), Z = G[0];
            if (G.length > 1) return A = null, G;
            if (!Ks(Z) || !(Z.shapeFlag & 4) && !(Z.shapeFlag & 128)) return A = null, Z;
            let Y = Ck(Z);
            const ce = Y.type, Ce = qk(ac(Y) ? Y.type.__asyncResolved || {} : ce), {
                include: me,
                exclude: R,
                max: ae
            } = a;
            if (me && (!Ce || !_h(me, Ce)) || R && Ce && _h(R, Ce)) return A = Y, Z;
            const ue = Y.key == null ? ce : Y.key, ve = C.get(ue);
            return Y.el && (Y = So(Y), Z.shapeFlag & 128 && (Z.ssContent = Y)), q = ue, ve ? (Y.el = ve.el, Y.component = ve.component, Y.transition && Za(Y, Y.transition), Y.shapeFlag |= 512, k.delete(ue), k.add(ue)) : (k.add(ue), ae && k.size > parseInt(ae, 10) && z(k.values().next().value)), Y.shapeFlag |= 256, A = Y, bx(Z.type) ? Z : Y
        }
    }
}, Dx = TP;

function _h(a, c) {
    return ut(a) ? a.some(h => _h(h, c)) : Pt(a) ? a.split(",").includes(c) : kL(a) ? a.test(c) : !1
}

function x0(a, c) {
    xx(a, "a", c)
}

function E0(a, c) {
    xx(a, "da", c)
}

function xx(a, c, h = pr) {
    const b = a.__wdc || (a.__wdc = () => {
        let C = h;
        for (; C;) {
            if (C.isDeactivated) return;
            C = C.parent
        }
        return a()
    });
    if (hm(c, b, h), h) {
        let C = h.parent;
        for (; C && C.parent;) Yh(C.parent.vnode) && IP(b, c, h, C), C = C.parent
    }
}

function IP(a, c, h, b) {
    const C = hm(c, a, b, !0);
    Jh(() => {
        l0(b[c], C)
    }, h)
}

function Ak(a) {
    a.shapeFlag &= -257, a.shapeFlag &= -513
}

function Ck(a) {
    return a.shapeFlag & 128 ? a.ssContent : a
}

function hm(a, c, h = pr, b = !1) {
    if (h) {
        const C = h[a] || (h[a] = []), k = c.__weh || (c.__weh = (...A) => {
            if (h.isUnmounted) return;
            qu(), Qa(h);
            const y = bi(c, h, a, A);
            return qa(), Wu(), y
        });
        return b ? C.unshift(k) : C.push(k), k
    }
}

const Zs = a => (c, h = pr) => (!Ou || a === "sp") && hm(a, (...b) => c(...b), h), fm = Zs("bm"), Oi = Zs("m"),
    S0 = Zs("bu"), Qh = Zs("u"), kc = Zs("bum"), Jh = Zs("um"), T0 = Zs("sp"), I0 = Zs("rtg"), M0 = Zs("rtc");

function B0(a, c = pr) {
    hm("ec", a, c)
}

function so(a, c, h, b) {
    let C;
    const k = h && h[b];
    if (ut(a) || Pt(a)) {
        C = new Array(a.length);
        for (let A = 0, y = a.length; A < y; A++) C[A] = c(a[A], A, void 0, k && k[A])
    } else if (typeof a == "number") {
        C = new Array(a);
        for (let A = 0; A < a; A++) C[A] = c(A + 1, A, void 0, k && k[A])
    } else if (vn(a)) if (a[Symbol.iterator]) C = Array.from(a, (A, y) => c(A, y, void 0, k && k[y])); else {
        const A = Object.keys(a);
        C = new Array(A.length);
        for (let y = 0, w = A.length; y < w; y++) {
            const S = A[y];
            C[y] = c(a[S], S, y, k && k[y])
        }
    } else C = [];
    return h && (h[b] = C), C
}

function Ex(a, c) {
    for (let h = 0; h < c.length; h++) {
        const b = c[h];
        if (ut(b)) for (let C = 0; C < b.length; C++) a[b[C].name] = b[C].fn; else b && (a[b.name] = b.key ? (...C) => {
            const k = b.fn(...C);
            return k && (k.key = b.key), k
        } : b.fn)
    }
    return a
}

function N0(a, c, h = {}, b, C) {
    if (Er.isCE || Er.parent && ac(Er.parent) && Er.parent.isCE) return c !== "default" && (h.name = c), lt("slot", h, b && b());
    let k = a[c];
    k && k._c && (k._d = !1), He();
    const A = k && Sx(k(h)),
        y = gr(ln, {key: h.key || A && A.key || `_${c}`}, A || (b ? b() : []), A && a._ === 1 ? 64 : -2);
    return !C && y.scopeId && (y.slotScopeIds = [y.scopeId + "-s"]), k && k._c && (k._d = !0), y
}

function Sx(a) {
    return a.some(c => Ks(c) ? !(c.type === Vr || c.type === ln && !Sx(c.children)) : !0) ? a : null
}

function Tx(a, c) {
    const h = {};
    for (const b in a) h[c && /[A-Z]/.test(b) ? `on:${b}` : oc(b)] = a[b];
    return h
}

const Ok = a => a ? lE(a) ? mm(a) || a.proxy : Ok(a.parent) : null, Dh = nn(Object.create(null), {
    $: a => a,
    $el: a => a.vnode.el,
    $data: a => a.data,
    $props: a => a.props,
    $attrs: a => a.attrs,
    $slots: a => a.slots,
    $refs: a => a.refs,
    $parent: a => Ok(a.parent),
    $root: a => Ok(a.root),
    $emit: a => a.emit,
    $options: a => L0(a),
    $forceUpdate: a => a.f || (a.f = () => am(a.update)),
    $nextTick: a => a.n || (a.n = uc.bind(a.proxy)),
    $watch: a => EP.bind(a)
}), _k = (a, c) => a !== an && !a.__isScriptSetup && en(a, c), Fk = {
    get({_: a}, c) {
        const {ctx: h, setupState: b, data: C, props: k, accessCache: A, type: y, appContext: w} = a;
        let S;
        if (c[0] !== "$") {
            const B = A[c];
            if (B !== void 0) switch (B) {
                case 1:
                    return b[c];
                case 2:
                    return C[c];
                case 4:
                    return h[c];
                case 3:
                    return k[c]
            } else {
                if (_k(b, c)) return A[c] = 1, b[c];
                if (C !== an && en(C, c)) return A[c] = 2, C[c];
                if ((S = a.propsOptions[0]) && en(S, c)) return A[c] = 3, k[c];
                if (h !== an && en(h, c)) return A[c] = 4, h[c];
                Rk && (A[c] = 0)
            }
        }
        const I = Dh[c];
        let T, D;
        if (I) return c === "$attrs" && ki(a, "get", c), I(a);
        if ((T = y.__cssModules) && (T = T[c])) return T;
        if (h !== an && en(h, c)) return A[c] = 4, h[c];
        if (D = w.config.globalProperties, en(D, c)) return D[c]
    }, set({_: a}, c, h) {
        const {data: b, setupState: C, ctx: k} = a;
        return _k(C, c) ? (C[c] = h, !0) : b !== an && en(b, c) ? (b[c] = h, !0) : en(a.props, c) || c[0] === "$" && c.slice(1) in a ? !1 : (k[c] = h, !0)
    }, has({_: {data: a, setupState: c, accessCache: h, ctx: b, appContext: C, propsOptions: k}}, A) {
        let y;
        return !!h[A] || a !== an && en(a, A) || _k(c, A) || (y = k[0]) && en(y, A) || en(b, A) || en(Dh, A) || en(C.config.globalProperties, A)
    }, defineProperty(a, c, h) {
        return h.get != null ? a._.accessCache[c] = 0 : en(h, "value") && this.set(a, c, h.value, null), Reflect.defineProperty(a, c, h)
    }
}, MP = nn({}, Fk, {
    get(a, c) {
        if (c !== Symbol.unscopables) return Fk.get(a, c, a)
    }, has(a, c) {
        return c[0] !== "_" && !yL(c)
    }
});

function Ix() {
    return null
}

function Mx() {
    return null
}

function Bx(a) {
}

function Nx(a) {
}

function Lx() {
    return null
}

function Px() {
}

function Ox(a, c) {
    return null
}

function Fx() {
    return jx().slots
}

function Rx() {
    return jx().attrs
}

function zx(a, c, h) {
    const b = co();
    if (h && h.local) {
        const C = yt(a[c]);
        return or(() => a[c], k => C.value = k), or(C, k => {
            k !== a[c] && b.emit(`update:${c}`, k)
        }), C
    } else return {
        __v_isRef: !0, get value() {
            return a[c]
        }, set value(C) {
            b.emit(`update:${c}`, C)
        }
    }
}

function jx() {
    const a = co();
    return a.setupContext || (a.setupContext = hE(a))
}

function Rh(a) {
    return ut(a) ? a.reduce((c, h) => (c[h] = null, c), {}) : a
}

function Vx(a, c) {
    const h = Rh(a);
    for (const b in c) {
        if (b.startsWith("__skip")) continue;
        let C = h[b];
        C ? ut(C) || St(C) ? C = h[b] = {
            type: C,
            default: c[b]
        } : C.default = c[b] : C === null && (C = h[b] = {default: c[b]}), C && c[`__skip_${b}`] && (C.skipFactory = !0)
    }
    return h
}

function Hx(a, c) {
    return !a || !c ? a || c : ut(a) && ut(c) ? a.concat(c) : nn({}, Rh(a), Rh(c))
}

function Ux(a, c) {
    const h = {};
    for (const b in a) c.includes(b) || Object.defineProperty(h, b, {enumerable: !0, get: () => a[b]});
    return h
}

function qx(a) {
    const c = co();
    let h = a();
    return qa(), c0(h) && (h = h.catch(b => {
        throw Qa(c), b
    })), [h, () => Qa(c)]
}

let Rk = !0;

function BP(a) {
    const c = L0(a), h = a.proxy, b = a.ctx;
    Rk = !1, c.beforeCreate && B2(c.beforeCreate, a, "bc");
    const {
        data: C,
        computed: k,
        methods: A,
        watch: y,
        provide: w,
        inject: S,
        created: I,
        beforeMount: T,
        mounted: D,
        beforeUpdate: B,
        updated: L,
        activated: z,
        deactivated: q,
        beforeDestroy: Q,
        beforeUnmount: G,
        destroyed: Z,
        unmounted: Y,
        render: ce,
        renderTracked: Ce,
        renderTriggered: me,
        errorCaptured: R,
        serverPrefetch: ae,
        expose: ue,
        inheritAttrs: ve,
        components: ke,
        directives: le,
        filters: ye
    } = c;
    if (S && NP(S, b, null), A) for (const Ze in A) {
        const Xe = A[Ze];
        St(Xe) && (b[Ze] = Xe.bind(h))
    }
    if (C) {
        const Ze = C.call(h, h);
        vn(Ze) && (a.data = jr(Ze))
    }
    if (Rk = !0, k) for (const Ze in k) {
        const Xe = k[Ze], Le = St(Xe) ? Xe.bind(h, h) : St(Xe.get) ? Xe.get.bind(h, h) : mi,
            it = !St(Xe) && St(Xe.set) ? Xe.set.bind(h) : mi, _t = tn({get: Le, set: it});
        Object.defineProperty(b, Ze, {enumerable: !0, configurable: !0, get: () => _t.value, set: Tt => _t.value = Tt})
    }
    if (y) for (const Ze in y) Wx(y[Ze], b, h, Ze);
    if (w) {
        const Ze = St(w) ? w.call(h) : w;
        Reflect.ownKeys(Ze).forEach(Xe => {
            hc(Xe, Ze[Xe])
        })
    }
    I && B2(I, a, "c");

    function qe(Ze, Xe) {
        ut(Xe) ? Xe.forEach(Le => Ze(Le.bind(h))) : Xe && Ze(Xe.bind(h))
    }

    if (qe(fm, T), qe(Oi, D), qe(S0, B), qe(Qh, L), qe(x0, z), qe(E0, q), qe(B0, R), qe(M0, Ce), qe(I0, me), qe(kc, G), qe(Jh, Y), qe(T0, ae), ut(ue)) if (ue.length) {
        const Ze = a.exposed || (a.exposed = {});
        ue.forEach(Xe => {
            Object.defineProperty(Ze, Xe, {get: () => h[Xe], set: Le => h[Xe] = Le})
        })
    } else a.exposed || (a.exposed = {});
    ce && a.render === mi && (a.render = ce), ve != null && (a.inheritAttrs = ve), ke && (a.components = ke), le && (a.directives = le)
}

function NP(a, c, h = mi) {
    ut(a) && (a = zk(a));
    for (const b in a) {
        const C = a[b];
        let k;
        vn(C) ? "default" in C ? k = Ha(C.from || b, C.default, !0) : k = Ha(C.from || b) : k = Ha(C), ar(k) ? Object.defineProperty(c, b, {
            enumerable: !0,
            configurable: !0,
            get: () => k.value,
            set: A => k.value = A
        }) : c[b] = k
    }
}

function B2(a, c, h) {
    bi(ut(a) ? a.map(b => b.bind(c.proxy)) : a.bind(c.proxy), c, h)
}

function Wx(a, c, h, b) {
    const C = b.includes(".") ? Cx(h, b) : () => h[b];
    if (Pt(a)) {
        const k = c[a];
        St(k) && or(C, k)
    } else if (St(a)) or(C, a.bind(h)); else if (vn(a)) if (ut(a)) a.forEach(k => Wx(k, c, h, b)); else {
        const k = St(a.handler) ? a.handler.bind(h) : c[a.handler];
        St(k) && or(C, k, a)
    }
}

function L0(a) {
    const c = a.type, {mixins: h, extends: b} = c, {
        mixins: C,
        optionsCache: k,
        config: {optionMergeStrategies: A}
    } = a.appContext, y = k.get(c);
    let w;
    return y ? w = y : !C.length && !h && !b ? w = c : (w = {}, C.length && C.forEach(S => Bp(w, S, A, !0)), Bp(w, c, A)), vn(c) && k.set(c, w), w
}

function Bp(a, c, h, b = !1) {
    const {mixins: C, extends: k} = c;
    k && Bp(a, k, h, !0), C && C.forEach(A => Bp(a, A, h, !0));
    for (const A in c) if (!(b && A === "expose")) {
        const y = LP[A] || h && h[A];
        a[A] = y ? y(a[A], c[A]) : c[A]
    }
    return a
}

const LP = {
    data: N2,
    props: L2,
    emits: L2,
    methods: yh,
    computed: yh,
    beforeCreate: Xr,
    created: Xr,
    beforeMount: Xr,
    mounted: Xr,
    beforeUpdate: Xr,
    updated: Xr,
    beforeDestroy: Xr,
    beforeUnmount: Xr,
    destroyed: Xr,
    unmounted: Xr,
    activated: Xr,
    deactivated: Xr,
    errorCaptured: Xr,
    serverPrefetch: Xr,
    components: yh,
    directives: yh,
    watch: OP,
    provide: N2,
    inject: PP
};

function N2(a, c) {
    return c ? a ? function () {
        return nn(St(a) ? a.call(this, this) : a, St(c) ? c.call(this, this) : c)
    } : c : a
}

function PP(a, c) {
    return yh(zk(a), zk(c))
}

function zk(a) {
    if (ut(a)) {
        const c = {};
        for (let h = 0; h < a.length; h++) c[a[h]] = a[h];
        return c
    }
    return a
}

function Xr(a, c) {
    return a ? [...new Set([].concat(a, c))] : c
}

function yh(a, c) {
    return a ? nn(Object.create(null), a, c) : c
}

function L2(a, c) {
    return a ? ut(a) && ut(c) ? [...new Set([...a, ...c])] : nn(Object.create(null), Rh(a), Rh(c ?? {})) : c
}

function OP(a, c) {
    if (!a) return c;
    if (!c) return a;
    const h = nn(Object.create(null), a);
    for (const b in c) h[b] = Xr(a[b], c[b]);
    return h
}

function $x() {
    return {
        app: null,
        config: {
            isNativeTag: Ap,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}

let FP = 0;

function RP(a, c) {
    return function (b, C = null) {
        St(b) || (b = nn({}, b)), C != null && !vn(C) && (C = null);
        const k = $x(), A = new WeakSet;
        let y = !1;
        const w = k.app = {
            _uid: FP++,
            _component: b,
            _props: C,
            _container: null,
            _context: k,
            _instance: null,
            version: K0,
            get config() {
                return k.config
            },
            set config(S) {
            },
            use(S, ...I) {
                return A.has(S) || (S && St(S.install) ? (A.add(S), S.install(w, ...I)) : St(S) && (A.add(S), S(w, ...I))), w
            },
            mixin(S) {
                return k.mixins.includes(S) || k.mixins.push(S), w
            },
            component(S, I) {
                return I ? (k.components[S] = I, w) : k.components[S]
            },
            directive(S, I) {
                return I ? (k.directives[S] = I, w) : k.directives[S]
            },
            mount(S, I, T) {
                if (!y) {
                    const D = lt(b, C);
                    return D.appContext = k, I && c ? c(D, S) : a(D, S, T), y = !0, w._container = S, S.__vue_app__ = w, mm(D.component) || D.component.proxy
                }
            },
            unmount() {
                y && (a(null, w._container), delete w._container.__vue_app__)
            },
            provide(S, I) {
                return k.provides[S] = I, w
            },
            runWithContext(S) {
                zh = w;
                try {
                    return S()
                } finally {
                    zh = null
                }
            }
        };
        return w
    }
}

let zh = null;

function hc(a, c) {
    if (pr) {
        let h = pr.provides;
        const b = pr.parent && pr.parent.provides;
        b === h && (h = pr.provides = Object.create(b)), h[a] = c
    }
}

function Ha(a, c, h = !1) {
    const b = pr || Er;
    if (b || zh) {
        const C = b ? b.parent == null ? b.vnode.appContext && b.vnode.appContext.provides : b.parent.provides : zh._context.provides;
        if (C && a in C) return C[a];
        if (arguments.length > 1) return h && St(c) ? c.call(b && b.proxy) : c
    }
}

function Gx() {
    return !!(pr || Er || zh)
}

function zP(a, c, h, b = !1) {
    const C = {}, k = {};
    Ep(k, gm, 1), a.propsDefaults = Object.create(null), Kx(a, c, C, k);
    for (const A in a.propsOptions[0]) A in C || (C[A] = void 0);
    h ? a.props = b ? C : g0(C) : a.type.props ? a.props = C : a.props = k, a.attrs = k
}

function jP(a, c, h, b) {
    const {props: C, attrs: k, vnode: {patchFlag: A}} = a, y = Wt(C), [w] = a.propsOptions;
    let S = !1;
    if ((b || A > 0) && !(A & 16)) {
        if (A & 8) {
            const I = a.vnode.dynamicProps;
            for (let T = 0; T < I.length; T++) {
                let D = I[T];
                if (lm(a.emitsOptions, D)) continue;
                const B = c[D];
                if (w) if (en(k, D)) B !== k[D] && (k[D] = B, S = !0); else {
                    const L = sr(D);
                    C[L] = jk(w, y, L, B, a, !1)
                } else B !== k[D] && (k[D] = B, S = !0)
            }
        }
    } else {
        Kx(a, c, C, k) && (S = !0);
        let I;
        for (const T in y) (!c || !en(c, T) && ((I = Li(T)) === T || !en(c, I))) && (w ? h && (h[T] !== void 0 || h[I] !== void 0) && (C[T] = jk(w, y, T, void 0, a, !0)) : delete C[T]);
        if (k !== y) for (const T in k) (!c || !en(c, T)) && (delete k[T], S = !0)
    }
    S && Us(a, "set", "$attrs")
}

function Kx(a, c, h, b) {
    const [C, k] = a.propsOptions;
    let A = !1, y;
    if (c) for (let w in c) {
        if (ic(w)) continue;
        const S = c[w];
        let I;
        C && en(C, I = sr(w)) ? !k || !k.includes(I) ? h[I] = S : (y || (y = {}))[I] = S : lm(a.emitsOptions, w) || (!(w in b) || S !== b[w]) && (b[w] = S, A = !0)
    }
    if (k) {
        const w = Wt(h), S = y || an;
        for (let I = 0; I < k.length; I++) {
            const T = k[I];
            h[T] = jk(C, w, T, S[T], a, !en(S, T))
        }
    }
    return A
}

function jk(a, c, h, b, C, k) {
    const A = a[h];
    if (A != null) {
        const y = en(A, "default");
        if (y && b === void 0) {
            const w = A.default;
            if (A.type !== Function && !A.skipFactory && St(w)) {
                const {propsDefaults: S} = C;
                h in S ? b = S[h] : (Qa(C), b = S[h] = w.call(null, c), qa())
            } else b = w
        }
        A[0] && (k && !y ? b = !1 : A[1] && (b === "" || b === Li(h)) && (b = !0))
    }
    return b
}

function Zx(a, c, h = !1) {
    const b = c.propsCache, C = b.get(a);
    if (C) return C;
    const k = a.props, A = {}, y = [];
    let w = !1;
    if (!St(a)) {
        const I = T => {
            w = !0;
            const [D, B] = Zx(T, c, !0);
            nn(A, D), B && y.push(...B)
        };
        !h && c.mixins.length && c.mixins.forEach(I), a.extends && I(a.extends), a.mixins && a.mixins.forEach(I)
    }
    if (!k && !w) return vn(a) && b.set(a, Iu), Iu;
    if (ut(k)) for (let I = 0; I < k.length; I++) {
        const T = sr(k[I]);
        P2(T) && (A[T] = an)
    } else if (k) for (const I in k) {
        const T = sr(I);
        if (P2(T)) {
            const D = k[I], B = A[T] = ut(D) || St(D) ? {type: D} : nn({}, D);
            if (B) {
                const L = R2(Boolean, B.type), z = R2(String, B.type);
                B[0] = L > -1, B[1] = z < 0 || L < z, (L > -1 || en(B, "default")) && y.push(T)
            }
        }
    }
    const S = [A, y];
    return vn(a) && b.set(a, S), S
}

function P2(a) {
    return a[0] !== "$"
}

function O2(a) {
    const c = a && a.toString().match(/^\s*(function|class) (\w+)/);
    return c ? c[2] : a === null ? "null" : ""
}

function F2(a, c) {
    return O2(a) === O2(c)
}

function R2(a, c) {
    return ut(c) ? c.findIndex(h => F2(h, a)) : St(c) && F2(c, a) ? 0 : -1
}

const Yx = a => a[0] === "_" || a === "$stable", P0 = a => ut(a) ? a.map(Ni) : [Ni(a)], VP = (a, c, h) => {
    if (c._n) return c;
    const b = Sr((...C) => P0(c(...C)), h);
    return b._c = !1, b
}, Qx = (a, c, h) => {
    const b = a._ctx;
    for (const C in a) {
        if (Yx(C)) continue;
        const k = a[C];
        if (St(k)) c[C] = VP(C, k, b); else if (k != null) {
            const A = P0(k);
            c[C] = () => A
        }
    }
}, Jx = (a, c) => {
    const h = P0(c);
    a.slots.default = () => h
}, HP = (a, c) => {
    if (a.vnode.shapeFlag & 32) {
        const h = c._;
        h ? (a.slots = Wt(c), Ep(c, "_", h)) : Qx(c, a.slots = {})
    } else a.slots = {}, c && Jx(a, c);
    Ep(a.slots, gm, 1)
}, UP = (a, c, h) => {
    const {vnode: b, slots: C} = a;
    let k = !0, A = an;
    if (b.shapeFlag & 32) {
        const y = c._;
        y ? h && y === 1 ? k = !1 : (nn(C, c), !h && y === 1 && delete C._) : (k = !c.$stable, Qx(c, C)), A = c
    } else c && (Jx(a, c), A = {default: 1});
    if (k) for (const y in C) !Yx(y) && A[y] == null && delete C[y]
};

function Np(a, c, h, b, C = !1) {
    if (ut(a)) {
        a.forEach((D, B) => Np(D, c && (ut(c) ? c[B] : c), h, b, C));
        return
    }
    if (ac(b) && !C) return;
    const k = b.shapeFlag & 4 ? mm(b.component) || b.component.proxy : b.el, A = C ? null : k, {i: y, r: w} = a,
        S = c && c.r, I = y.refs === an ? y.refs = {} : y.refs, T = y.setupState;
    if (S != null && S !== w && (Pt(S) ? (I[S] = null, en(T, S) && (T[S] = null)) : ar(S) && (S.value = null)), St(w)) os(w, y, 12, [A, I]); else {
        const D = Pt(w), B = ar(w);
        if (D || B) {
            const L = () => {
                if (a.f) {
                    const z = D ? en(T, w) ? T[w] : I[w] : w.value;
                    C ? ut(z) && l0(z, k) : ut(z) ? z.includes(k) || z.push(k) : D ? (I[w] = [k], en(T, w) && (T[w] = I[w])) : (w.value = [k], a.k && (I[a.k] = w.value))
                } else D ? (I[w] = A, en(T, w) && (T[w] = A)) : B && (w.value = A, a.k && (I[a.k] = A))
            };
            A ? (L.id = -1, zr(L, h)) : L()
        }
    }
}

let Pa = !1;
const fp = a => /svg/.test(a.namespaceURI) && a.tagName !== "foreignObject", gp = a => a.nodeType === 8;

function qP(a) {
    const {
        mt: c,
        p: h,
        o: {patchProp: b, createText: C, nextSibling: k, parentNode: A, remove: y, insert: w, createComment: S}
    } = a, I = (Z, Y) => {
        if (!Y.hasChildNodes()) {
            h(null, Z, Y), Mp(), Y._vnode = Z;
            return
        }
        Pa = !1, T(Y.firstChild, Z, null, null, null), Mp(), Y._vnode = Z, Pa && console.error("Hydration completed but contains mismatches.")
    }, T = (Z, Y, ce, Ce, me, R = !1) => {
        const ae = gp(Z) && Z.data === "[", ue = () => z(Z, Y, ce, Ce, me, ae), {
            type: ve,
            ref: ke,
            shapeFlag: le,
            patchFlag: ye
        } = Y;
        let ee = Z.nodeType;
        Y.el = Z, ye === -2 && (R = !1, Y.dynamicChildren = null);
        let qe = null;
        switch (ve) {
            case Ya:
                ee !== 3 ? Y.children === "" ? (w(Y.el = C(""), A(Z), Z), qe = Z) : qe = ue() : (Z.data !== Y.children && (Pa = !0, Z.data = Y.children), qe = k(Z));
                break;
            case Vr:
                G(Z) ? (qe = k(Z), Q(Y.el = Z.content.firstChild, Z, ce)) : ee !== 8 || ae ? qe = ue() : qe = k(Z);
                break;
            case Ua:
                if (ae && (Z = k(Z), ee = Z.nodeType), ee === 1 || ee === 3) {
                    qe = Z;
                    const Ze = !Y.children.length;
                    for (let Xe = 0; Xe < Y.staticCount; Xe++) Ze && (Y.children += qe.nodeType === 1 ? qe.outerHTML : qe.data), Xe === Y.staticCount - 1 && (Y.anchor = qe), qe = k(qe);
                    return ae ? k(qe) : qe
                } else ue();
                break;
            case ln:
                ae ? qe = L(Z, Y, ce, Ce, me, R) : qe = ue();
                break;
            default:
                if (le & 1) (ee !== 1 || Y.type.toLowerCase() !== Z.tagName.toLowerCase()) && !G(Z) ? qe = ue() : qe = D(Z, Y, ce, Ce, me, R); else if (le & 6) {
                    Y.slotScopeIds = me;
                    const Ze = A(Z);
                    if (ae ? qe = q(Z) : gp(Z) && Z.data === "teleport start" ? qe = q(Z, Z.data, "teleport end") : qe = k(Z), c(Y, Ze, null, ce, Ce, fp(Ze), R), ac(Y)) {
                        let Xe;
                        ae ? (Xe = lt(ln), Xe.anchor = qe ? qe.previousSibling : Ze.lastChild) : Xe = Z.nodeType === 3 ? Yt("") : lt("div"), Xe.el = Z, Y.component.subTree = Xe
                    }
                } else le & 64 ? ee !== 8 ? qe = ue() : qe = Y.type.hydrate(Z, Y, ce, Ce, me, R, a, B) : le & 128 && (qe = Y.type.hydrate(Z, Y, ce, Ce, fp(A(Z)), me, R, a, T))
        }
        return ke != null && Np(ke, null, Ce, Y), qe
    }, D = (Z, Y, ce, Ce, me, R) => {
        R = R || !!Y.dynamicChildren;
        const {type: ae, props: ue, patchFlag: ve, shapeFlag: ke, dirs: le, transition: ye} = Y,
            ee = ae === "input" || ae === "option";
        if (ee || ve !== -1) {
            le && rs(Y, null, ce, "created");
            let qe = !1;
            if (G(Z)) {
                qe = eE(Ce, ye) && ce && ce.vnode.props && ce.vnode.props.appear;
                const Xe = Z.content.firstChild;
                qe && ye.beforeEnter(Xe), Q(Xe, Z, ce), Y.el = Z = Xe
            }
            if (ue) if (ee || !R || ve & 48) for (const Xe in ue) (ee && (Xe.endsWith("value") || Xe === "indeterminate") || pc(Xe) && !ic(Xe) || Xe[0] === ".") && b(Z, Xe, null, ue[Xe], !1, void 0, ce); else ue.onClick && b(Z, "onClick", null, ue.onClick, !1, void 0, ce);
            let Ze;
            if ((Ze = ue && ue.onVnodeBeforeMount) && fi(Ze, ce, Y), le && rs(Y, null, ce, "beforeMount"), ((Ze = ue && ue.onVnodeMounted) || le || qe) && vx(() => {
                Ze && fi(Ze, ce, Y), qe && ye.enter(Z), le && rs(Y, null, ce, "mounted")
            }, Ce), ke & 16 && !(ue && (ue.innerHTML || ue.textContent))) {
                let Xe = B(Z.firstChild, Y, Z, ce, Ce, me, R);
                for (; Xe;) {
                    Pa = !0;
                    const Le = Xe;
                    Xe = Xe.nextSibling, y(Le)
                }
            } else ke & 8 && Z.textContent !== Y.children && (Pa = !0, Z.textContent = Y.children)
        }
        return Z.nextSibling
    }, B = (Z, Y, ce, Ce, me, R, ae) => {
        ae = ae || !!Y.dynamicChildren;
        const ue = Y.children, ve = ue.length;
        for (let ke = 0; ke < ve; ke++) {
            const le = ae ? ue[ke] : ue[ke] = Ni(ue[ke]);
            if (Z) Z = T(Z, le, Ce, me, R, ae); else {
                if (le.type === Ya && !le.children) continue;
                Pa = !0, h(null, le, ce, null, Ce, me, fp(ce), R)
            }
        }
        return Z
    }, L = (Z, Y, ce, Ce, me, R) => {
        const {slotScopeIds: ae} = Y;
        ae && (me = me ? me.concat(ae) : ae);
        const ue = A(Z), ve = B(k(Z), Y, ue, ce, Ce, me, R);
        return ve && gp(ve) && ve.data === "]" ? k(Y.anchor = ve) : (Pa = !0, w(Y.anchor = S("]"), ue, ve), ve)
    }, z = (Z, Y, ce, Ce, me, R) => {
        if (Pa = !0, Y.el = null, R) {
            const ve = q(Z);
            for (; ;) {
                const ke = k(Z);
                if (ke && ke !== ve) y(ke); else break
            }
        }
        const ae = k(Z), ue = A(Z);
        return y(Z), h(null, Y, ue, ae, ce, Ce, fp(ue), me), ae
    }, q = (Z, Y = "[", ce = "]") => {
        let Ce = 0;
        for (; Z;) if (Z = k(Z), Z && gp(Z) && (Z.data === Y && Ce++, Z.data === ce)) {
            if (Ce === 0) return k(Z);
            Ce--
        }
        return Z
    }, Q = (Z, Y, ce) => {
        const Ce = Y.parentNode;
        Ce && Ce.replaceChild(Z, Y);
        let me = ce;
        for (; me;) me.vnode.el === Y && (me.vnode.el = me.subTree.el = Z), me = me.parent
    }, G = Z => Z.nodeType === 1 && Z.tagName.toLowerCase() === "template";
    return [I, T]
}

const zr = vx;

function O0(a) {
    return Xx(a)
}

function F0(a) {
    return Xx(a, qP)
}

function Xx(a, c) {
    const h = Mk();
    h.__VUE__ = !0;
    const {
            insert: b,
            remove: C,
            patchProp: k,
            createElement: A,
            createText: y,
            createComment: w,
            setText: S,
            setElementText: I,
            parentNode: T,
            nextSibling: D,
            setScopeId: B = mi,
            insertStaticContent: L
        } = a, z = (se, ge, we, Me = null, Be = null, Ue = null, Ge = !1, ze = null, V = !!ge.dynamicChildren) => {
            if (se === ge) return;
            se && !Do(se, ge) && (Me = Oe(se), Tt(se, Be, Ue, !0), se = null), ge.patchFlag === -2 && (V = !1, ge.dynamicChildren = null);
            const {type: $, ref: te, shapeFlag: oe} = ge;
            switch ($) {
                case Ya:
                    q(se, ge, we, Me);
                    break;
                case Vr:
                    Q(se, ge, we, Me);
                    break;
                case Ua:
                    se == null && G(ge, we, Me, Ge);
                    break;
                case ln:
                    ke(se, ge, we, Me, Be, Ue, Ge, ze, V);
                    break;
                default:
                    oe & 1 ? ce(se, ge, we, Me, Be, Ue, Ge, ze, V) : oe & 6 ? le(se, ge, we, Me, Be, Ue, Ge, ze, V) : (oe & 64 || oe & 128) && $.process(se, ge, we, Me, Be, Ue, Ge, ze, V, vt)
            }
            te != null && Be && Np(te, se && se.ref, Ue, ge || se, !ge)
        }, q = (se, ge, we, Me) => {
            if (se == null) b(ge.el = y(ge.children), we, Me); else {
                const Be = ge.el = se.el;
                ge.children !== se.children && S(Be, ge.children)
            }
        }, Q = (se, ge, we, Me) => {
            se == null ? b(ge.el = w(ge.children || ""), we, Me) : ge.el = se.el
        }, G = (se, ge, we, Me) => {
            [se.el, se.anchor] = L(se.children, ge, we, Me, se.el, se.anchor)
        }, Z = ({el: se, anchor: ge}, we, Me) => {
            let Be;
            for (; se && se !== ge;) Be = D(se), b(se, we, Me), se = Be;
            b(ge, we, Me)
        }, Y = ({el: se, anchor: ge}) => {
            let we;
            for (; se && se !== ge;) we = D(se), C(se), se = we;
            C(ge)
        }, ce = (se, ge, we, Me, Be, Ue, Ge, ze, V) => {
            Ge = Ge || ge.type === "svg", se == null ? Ce(ge, we, Me, Be, Ue, Ge, ze, V) : ae(se, ge, Be, Ue, Ge, ze, V)
        }, Ce = (se, ge, we, Me, Be, Ue, Ge, ze) => {
            let V, $;
            const {type: te, props: oe, shapeFlag: de, transition: he, dirs: Ae} = se;
            if (V = se.el = A(se.type, Ue, oe && oe.is, oe), de & 8 ? I(V, se.children) : de & 16 && R(se.children, V, null, Me, Be, Ue && te !== "foreignObject", Ge, ze), Ae && rs(se, null, Me, "created"), me(V, se, se.scopeId, Ge, Me), oe) {
                for (const Ie in oe) Ie !== "value" && !ic(Ie) && k(V, Ie, null, oe[Ie], Ue, se.children, Me, Be, Ye);
                "value" in oe && k(V, "value", null, oe.value), ($ = oe.onVnodeBeforeMount) && fi($, Me, se)
            }
            Ae && rs(se, null, Me, "beforeMount");
            const De = eE(Be, he);
            De && he.beforeEnter(V), b(V, ge, we), (($ = oe && oe.onVnodeMounted) || De || Ae) && zr(() => {
                $ && fi($, Me, se), De && he.enter(V), Ae && rs(se, null, Me, "mounted")
            }, Be)
        }, me = (se, ge, we, Me, Be) => {
            if (we && B(se, we), Me) for (let Ue = 0; Ue < Me.length; Ue++) B(se, Me[Ue]);
            if (Be) {
                let Ue = Be.subTree;
                if (ge === Ue) {
                    const Ge = Be.vnode;
                    me(se, Ge, Ge.scopeId, Ge.slotScopeIds, Be.parent)
                }
            }
        }, R = (se, ge, we, Me, Be, Ue, Ge, ze, V = 0) => {
            for (let $ = V; $ < se.length; $++) {
                const te = se[$] = ze ? za(se[$]) : Ni(se[$]);
                z(null, te, ge, we, Me, Be, Ue, Ge, ze)
            }
        }, ae = (se, ge, we, Me, Be, Ue, Ge) => {
            const ze = ge.el = se.el;
            let {patchFlag: V, dynamicChildren: $, dirs: te} = ge;
            V |= se.patchFlag & 16;
            const oe = se.props || an, de = ge.props || an;
            let he;
            we && Ql(we, !1), (he = de.onVnodeBeforeUpdate) && fi(he, we, ge, se), te && rs(ge, se, we, "beforeUpdate"), we && Ql(we, !0);
            const Ae = Be && ge.type !== "foreignObject";
            if ($ ? ue(se.dynamicChildren, $, ze, we, Me, Ae, Ue) : Ge || Xe(se, ge, ze, null, we, Me, Ae, Ue, !1), V > 0) {
                if (V & 16) ve(ze, ge, oe, de, we, Me, Be); else if (V & 2 && oe.class !== de.class && k(ze, "class", null, de.class, Be), V & 4 && k(ze, "style", oe.style, de.style, Be), V & 8) {
                    const De = ge.dynamicProps;
                    for (let Ie = 0; Ie < De.length; Ie++) {
                        const nt = De[Ie], st = oe[nt], Dt = de[nt];
                        (Dt !== st || nt === "value") && k(ze, nt, st, Dt, Be, se.children, we, Me, Ye)
                    }
                }
                V & 1 && se.children !== ge.children && I(ze, ge.children)
            } else !Ge && $ == null && ve(ze, ge, oe, de, we, Me, Be);
            ((he = de.onVnodeUpdated) || te) && zr(() => {
                he && fi(he, we, ge, se), te && rs(ge, se, we, "updated")
            }, Me)
        }, ue = (se, ge, we, Me, Be, Ue, Ge) => {
            for (let ze = 0; ze < ge.length; ze++) {
                const V = se[ze], $ = ge[ze], te = V.el && (V.type === ln || !Do(V, $) || V.shapeFlag & 70) ? T(V.el) : we;
                z(V, $, te, null, Me, Be, Ue, Ge, !0)
            }
        }, ve = (se, ge, we, Me, Be, Ue, Ge) => {
            if (we !== Me) {
                if (we !== an) for (const ze in we) !ic(ze) && !(ze in Me) && k(se, ze, we[ze], null, Ge, ge.children, Be, Ue, Ye);
                for (const ze in Me) {
                    if (ic(ze)) continue;
                    const V = Me[ze], $ = we[ze];
                    V !== $ && ze !== "value" && k(se, ze, $, V, Ge, ge.children, Be, Ue, Ye)
                }
                "value" in Me && k(se, "value", we.value, Me.value)
            }
        }, ke = (se, ge, we, Me, Be, Ue, Ge, ze, V) => {
            const $ = ge.el = se ? se.el : y(""), te = ge.anchor = se ? se.anchor : y("");
            let {patchFlag: oe, dynamicChildren: de, slotScopeIds: he} = ge;
            he && (ze = ze ? ze.concat(he) : he), se == null ? (b($, we, Me), b(te, we, Me), R(ge.children, we, te, Be, Ue, Ge, ze, V)) : oe > 0 && oe & 64 && de && se.dynamicChildren ? (ue(se.dynamicChildren, de, we, Be, Ue, Ge, ze), (ge.key != null || Be && ge === Be.subTree) && R0(se, ge, !0)) : Xe(se, ge, we, te, Be, Ue, Ge, ze, V)
        }, le = (se, ge, we, Me, Be, Ue, Ge, ze, V) => {
            ge.slotScopeIds = ze, se == null ? ge.shapeFlag & 512 ? Be.ctx.activate(ge, we, Me, Ge, V) : ye(ge, we, Me, Be, Ue, Ge, V) : ee(se, ge, V)
        }, ye = (se, ge, we, Me, Be, Ue, Ge) => {
            const ze = se.component = aE(se, Me, Be);
            if (Yh(se) && (ze.ctx.renderer = vt), cE(ze), ze.asyncDep) {
                if (Be && Be.registerDep(ze, qe), !se.el) {
                    const V = ze.subTree = lt(Vr);
                    Q(null, V, ge, we)
                }
                return
            }
            qe(ze, se, ge, we, Be, Ue, Ge)
        }, ee = (se, ge, we) => {
            const Me = ge.component = se.component;
            if (vP(se, ge, we)) if (Me.asyncDep && !Me.asyncResolved) {
                Ze(Me, ge, we);
                return
            } else Me.next = ge, fP(Me.update), Me.update(); else ge.el = se.el, Me.vnode = ge
        }, qe = (se, ge, we, Me, Be, Ue, Ge) => {
            const ze = () => {
                if (se.isMounted) {
                    let {next: te, bu: oe, u: de, parent: he, vnode: Ae} = se, De = te, Ie;
                    Ql(se, !1), te ? (te.el = Ae.el, Ze(se, te, Ge)) : te = Ae, oe && Bu(oe), (Ie = te.props && te.props.onVnodeBeforeUpdate) && fi(Ie, he, te, Ae), Ql(se, !0);
                    const nt = Cp(se), st = se.subTree;
                    se.subTree = nt, z(st, nt, T(st.el), Oe(st), se, Be, Ue), te.el = nt.el, De === null && w0(se, nt.el), de && zr(de, Be), (Ie = te.props && te.props.onVnodeUpdated) && zr(() => fi(Ie, he, te, Ae), Be)
                } else {
                    let te;
                    const {el: oe, props: de} = ge, {bm: he, m: Ae, parent: De} = se, Ie = ac(ge);
                    if (Ql(se, !1), he && Bu(he), !Ie && (te = de && de.onVnodeBeforeMount) && fi(te, De, ge), Ql(se, !0), oe && ct) {
                        const nt = () => {
                            se.subTree = Cp(se), ct(oe, se.subTree, se, Be, null)
                        };
                        Ie ? ge.type.__asyncLoader().then(() => !se.isUnmounted && nt()) : nt()
                    } else {
                        const nt = se.subTree = Cp(se);
                        z(null, nt, we, Me, se, Be, Ue), ge.el = nt.el
                    }
                    if (Ae && zr(Ae, Be), !Ie && (te = de && de.onVnodeMounted)) {
                        const nt = ge;
                        zr(() => fi(te, De, nt), Be)
                    }
                    (ge.shapeFlag & 256 || De && ac(De.vnode) && De.vnode.shapeFlag & 256) && se.a && zr(se.a, Be), se.isMounted = !0, ge = we = Me = null
                }
            }, V = se.effect = new cc(ze, () => am($), se.scope), $ = se.update = () => V.run();
            $.id = se.uid, Ql(se, !0), $()
        }, Ze = (se, ge, we) => {
            ge.component = se;
            const Me = se.vnode.props;
            se.vnode = ge, se.next = null, jP(se, ge.props, Me, we), UP(se, ge.children, we), qu(), E2(se), Wu()
        }, Xe = (se, ge, we, Me, Be, Ue, Ge, ze, V = !1) => {
            const $ = se && se.children, te = se ? se.shapeFlag : 0, oe = ge.children, {patchFlag: de, shapeFlag: he} = ge;
            if (de > 0) {
                if (de & 128) {
                    it($, oe, we, Me, Be, Ue, Ge, ze, V);
                    return
                } else if (de & 256) {
                    Le($, oe, we, Me, Be, Ue, Ge, ze, V);
                    return
                }
            }
            he & 8 ? (te & 16 && Ye($, Be, Ue), oe !== $ && I(we, oe)) : te & 16 ? he & 16 ? it($, oe, we, Me, Be, Ue, Ge, ze, V) : Ye($, Be, Ue, !0) : (te & 8 && I(we, ""), he & 16 && R(oe, we, Me, Be, Ue, Ge, ze, V))
        }, Le = (se, ge, we, Me, Be, Ue, Ge, ze, V) => {
            se = se || Iu, ge = ge || Iu;
            const $ = se.length, te = ge.length, oe = Math.min($, te);
            let de;
            for (de = 0; de < oe; de++) {
                const he = ge[de] = V ? za(ge[de]) : Ni(ge[de]);
                z(se[de], he, we, null, Be, Ue, Ge, ze, V)
            }
            $ > te ? Ye(se, Be, Ue, !0, !1, oe) : R(ge, we, Me, Be, Ue, Ge, ze, V, oe)
        }, it = (se, ge, we, Me, Be, Ue, Ge, ze, V) => {
            let $ = 0;
            const te = ge.length;
            let oe = se.length - 1, de = te - 1;
            for (; $ <= oe && $ <= de;) {
                const he = se[$], Ae = ge[$] = V ? za(ge[$]) : Ni(ge[$]);
                if (Do(he, Ae)) z(he, Ae, we, null, Be, Ue, Ge, ze, V); else break;
                $++
            }
            for (; $ <= oe && $ <= de;) {
                const he = se[oe], Ae = ge[de] = V ? za(ge[de]) : Ni(ge[de]);
                if (Do(he, Ae)) z(he, Ae, we, null, Be, Ue, Ge, ze, V); else break;
                oe--, de--
            }
            if ($ > oe) {
                if ($ <= de) {
                    const he = de + 1, Ae = he < te ? ge[he].el : Me;
                    for (; $ <= de;) z(null, ge[$] = V ? za(ge[$]) : Ni(ge[$]), we, Ae, Be, Ue, Ge, ze, V), $++
                }
            } else if ($ > de) for (; $ <= oe;) Tt(se[$], Be, Ue, !0), $++; else {
                const he = $, Ae = $, De = new Map;
                for ($ = Ae; $ <= de; $++) {
                    const Ot = ge[$] = V ? za(ge[$]) : Ni(ge[$]);
                    Ot.key != null && De.set(Ot.key, $)
                }
                let Ie, nt = 0;
                const st = de - Ae + 1;
                let Dt = !1, zt = 0;
                const Nt = new Array(st);
                for ($ = 0; $ < st; $++) Nt[$] = 0;
                for ($ = he; $ <= oe; $++) {
                    const Ot = se[$];
                    if (nt >= st) {
                        Tt(Ot, Be, Ue, !0);
                        continue
                    }
                    let Gt;
                    if (Ot.key != null) Gt = De.get(Ot.key); else for (Ie = Ae; Ie <= de; Ie++) if (Nt[Ie - Ae] === 0 && Do(Ot, ge[Ie])) {
                        Gt = Ie;
                        break
                    }
                    Gt === void 0 ? Tt(Ot, Be, Ue, !0) : (Nt[Gt - Ae] = $ + 1, Gt >= zt ? zt = Gt : Dt = !0, z(Ot, ge[Gt], we, null, Be, Ue, Ge, ze, V), nt++)
                }
                const $t = Dt ? WP(Nt) : Iu;
                for (Ie = $t.length - 1, $ = st - 1; $ >= 0; $--) {
                    const Ot = Ae + $, Gt = ge[Ot], ot = Ot + 1 < te ? ge[Ot + 1].el : Me;
                    Nt[$] === 0 ? z(null, Gt, we, ot, Be, Ue, Ge, ze, V) : Dt && (Ie < 0 || $ !== $t[Ie] ? _t(Gt, we, ot, 2) : Ie--)
                }
            }
        }, _t = (se, ge, we, Me, Be = null) => {
            const {el: Ue, type: Ge, transition: ze, children: V, shapeFlag: $} = se;
            if ($ & 6) {
                _t(se.component.subTree, ge, we, Me);
                return
            }
            if ($ & 128) {
                se.suspense.move(ge, we, Me);
                return
            }
            if ($ & 64) {
                Ge.move(se, ge, we, vt);
                return
            }
            if (Ge === ln) {
                b(Ue, ge, we);
                for (let oe = 0; oe < V.length; oe++) _t(V[oe], ge, we, Me);
                b(se.anchor, ge, we);
                return
            }
            if (Ge === Ua) {
                Z(se, ge, we);
                return
            }
            if (Me !== 2 && $ & 1 && ze) if (Me === 0) ze.beforeEnter(Ue), b(Ue, ge, we), zr(() => ze.enter(Ue), Be); else {
                const {leave: oe, delayLeave: de, afterLeave: he} = ze, Ae = () => b(Ue, ge, we), De = () => {
                    oe(Ue, () => {
                        Ae(), he && he()
                    })
                };
                de ? de(Ue, Ae, De) : De()
            } else b(Ue, ge, we)
        }, Tt = (se, ge, we, Me = !1, Be = !1) => {
            const {
                type: Ue,
                props: Ge,
                ref: ze,
                children: V,
                dynamicChildren: $,
                shapeFlag: te,
                patchFlag: oe,
                dirs: de
            } = se;
            if (ze != null && Np(ze, null, we, se, !0), te & 256) {
                ge.ctx.deactivate(se);
                return
            }
            const he = te & 1 && de, Ae = !ac(se);
            let De;
            if (Ae && (De = Ge && Ge.onVnodeBeforeUnmount) && fi(De, ge, se), te & 6) mt(se.component, we, Me); else {
                if (te & 128) {
                    se.suspense.unmount(we, Me);
                    return
                }
                he && rs(se, null, ge, "beforeUnmount"), te & 64 ? se.type.remove(se, ge, we, Be, vt, Me) : $ && (Ue !== ln || oe > 0 && oe & 64) ? Ye($, ge, we, !1, !0) : (Ue === ln && oe & 384 || !Be && te & 16) && Ye(V, ge, we), Me && Pe(se)
            }
            (Ae && (De = Ge && Ge.onVnodeUnmounted) || he) && zr(() => {
                De && fi(De, ge, se), he && rs(se, null, ge, "unmounted")
            }, we)
        }, Pe = se => {
            const {type: ge, el: we, anchor: Me, transition: Be} = se;
            if (ge === ln) {
                At(we, Me);
                return
            }
            if (ge === Ua) {
                Y(se);
                return
            }
            const Ue = () => {
                C(we), Be && !Be.persisted && Be.afterLeave && Be.afterLeave()
            };
            if (se.shapeFlag & 1 && Be && !Be.persisted) {
                const {leave: Ge, delayLeave: ze} = Be, V = () => Ge(we, Ue);
                ze ? ze(se.el, Ue, V) : V()
            } else Ue()
        }, At = (se, ge) => {
            let we;
            for (; se !== ge;) we = D(se), C(se), se = we;
            C(ge)
        }, mt = (se, ge, we) => {
            const {bum: Me, scope: Be, update: Ue, subTree: Ge, um: ze} = se;
            Me && Bu(Me), Be.stop(), Ue && (Ue.active = !1, Tt(Ge, se, ge, we)), ze && zr(ze, ge), zr(() => {
                se.isUnmounted = !0
            }, ge), ge && ge.pendingBranch && !ge.isUnmounted && se.asyncDep && !se.asyncResolved && se.suspenseId === ge.pendingId && (ge.deps--, ge.deps === 0 && ge.resolve())
        }, Ye = (se, ge, we, Me = !1, Be = !1, Ue = 0) => {
            for (let Ge = Ue; Ge < se.length; Ge++) Tt(se[Ge], ge, we, Me, Be)
        },
        Oe = se => se.shapeFlag & 6 ? Oe(se.component.subTree) : se.shapeFlag & 128 ? se.suspense.next() : D(se.anchor || se.el),
        ht = (se, ge, we) => {
            se == null ? ge._vnode && Tt(ge._vnode, null, null, !0) : z(ge._vnode || null, se, ge, null, null, null, we), E2(), Mp(), ge._vnode = se
        }, vt = {p: z, um: Tt, m: _t, r: Pe, mt: ye, mc: R, pc: Xe, pbc: ue, n: Oe, o: a};
    let Vt, ct;
    return c && ([Vt, ct] = c(vt)), {render: ht, hydrate: Vt, createApp: RP(ht, Vt)}
}

function Ql({effect: a, update: c}, h) {
    a.allowRecurse = c.allowRecurse = h
}

function eE(a, c) {
    return (!a || a && !a.pendingBranch) && c && !c.persisted
}

function R0(a, c, h = !1) {
    const b = a.children, C = c.children;
    if (ut(b) && ut(C)) for (let k = 0; k < b.length; k++) {
        const A = b[k];
        let y = C[k];
        y.shapeFlag & 1 && !y.dynamicChildren && ((y.patchFlag <= 0 || y.patchFlag === 32) && (y = C[k] = za(C[k]), y.el = A.el), h || R0(A, y)), y.type === Ya && (y.el = A.el)
    }
}

function WP(a) {
    const c = a.slice(), h = [0];
    let b, C, k, A, y;
    const w = a.length;
    for (b = 0; b < w; b++) {
        const S = a[b];
        if (S !== 0) {
            if (C = h[h.length - 1], a[C] < S) {
                c[b] = C, h.push(b);
                continue
            }
            for (k = 0, A = h.length - 1; k < A;) y = k + A >> 1, a[h[y]] < S ? k = y + 1 : A = y;
            S < a[h[k]] && (k > 0 && (c[b] = h[k - 1]), h[k] = b)
        }
    }
    for (k = h.length, A = h[k - 1]; k-- > 0;) h[k] = A, A = c[A];
    return h
}

const $P = a => a.__isTeleport, xh = a => a && (a.disabled || a.disabled === ""),
    z2 = a => typeof SVGElement < "u" && a instanceof SVGElement, Vk = (a, c) => {
        const h = a && a.to;
        return Pt(h) ? c ? c(h) : null : h
    }, GP = {
        name: "Teleport", __isTeleport: !0, process(a, c, h, b, C, k, A, y, w, S) {
            const {mc: I, pc: T, pbc: D, o: {insert: B, querySelector: L, createText: z, createComment: q}} = S,
                Q = xh(c.props);
            let {shapeFlag: G, children: Z, dynamicChildren: Y} = c;
            if (a == null) {
                const ce = c.el = z(""), Ce = c.anchor = z("");
                B(ce, h, b), B(Ce, h, b);
                const me = c.target = Vk(c.props, L), R = c.targetAnchor = z("");
                me && (B(R, me), A = A || z2(me));
                const ae = (ue, ve) => {
                    G & 16 && I(Z, ue, ve, C, k, A, y, w)
                };
                Q ? ae(h, Ce) : me && ae(me, R)
            } else {
                c.el = a.el;
                const ce = c.anchor = a.anchor, Ce = c.target = a.target, me = c.targetAnchor = a.targetAnchor,
                    R = xh(a.props), ae = R ? h : Ce, ue = R ? ce : me;
                if (A = A || z2(Ce), Y ? (D(a.dynamicChildren, Y, ae, C, k, A, y), R0(a, c, !0)) : w || T(a, c, ae, ue, C, k, A, y, !1), Q) R ? c.props && a.props && c.props.to !== a.props.to && (c.props.to = a.props.to) : pp(c, h, ce, S, 1); else if ((c.props && c.props.to) !== (a.props && a.props.to)) {
                    const ve = c.target = Vk(c.props, L);
                    ve && pp(c, ve, null, S, 0)
                } else R && pp(c, Ce, me, S, 1)
            }
            nE(c)
        }, remove(a, c, h, b, {um: C, o: {remove: k}}, A) {
            const {shapeFlag: y, children: w, anchor: S, targetAnchor: I, target: T, props: D} = a;
            if (T && k(I), A && k(S), y & 16) {
                const B = A || !xh(D);
                for (let L = 0; L < w.length; L++) {
                    const z = w[L];
                    C(z, c, h, B, !!z.dynamicChildren)
                }
            }
        }, move: pp, hydrate: KP
    };

function pp(a, c, h, {o: {insert: b}, m: C}, k = 2) {
    k === 0 && b(a.targetAnchor, c, h);
    const {el: A, anchor: y, shapeFlag: w, children: S, props: I} = a, T = k === 2;
    if (T && b(A, c, h), (!T || xh(I)) && w & 16) for (let D = 0; D < S.length; D++) C(S[D], c, h, 2);
    T && b(y, c, h)
}

function KP(a, c, h, b, C, k, {o: {nextSibling: A, parentNode: y, querySelector: w}}, S) {
    const I = c.target = Vk(c.props, w);
    if (I) {
        const T = I._lpa || I.firstChild;
        if (c.shapeFlag & 16) if (xh(c.props)) c.anchor = S(A(a), c, y(a), h, b, C, k), c.targetAnchor = T; else {
            c.anchor = A(a);
            let D = T;
            for (; D;) if (D = A(D), D && D.nodeType === 8 && D.data === "teleport anchor") {
                c.targetAnchor = D, I._lpa = c.targetAnchor && A(c.targetAnchor);
                break
            }
            S(T, c, I, h, b, C, k)
        }
        nE(c)
    }
    return c.anchor && A(c.anchor)
}

const tE = GP;

function nE(a) {
    const c = a.ctx;
    if (c && c.ut) {
        let h = a.children[0].el;
        for (; h && h !== a.targetAnchor;) h.nodeType === 1 && h.setAttribute("data-v-owner", c.uid), h = h.nextSibling;
        c.ut()
    }
}

const ln = Symbol.for("v-fgt"), Ya = Symbol.for("v-txt"), Vr = Symbol.for("v-cmt"), Ua = Symbol.for("v-stc"), Eh = [];
let gi = null;

function He(a = !1) {
    Eh.push(gi = a ? null : [])
}

function rE() {
    Eh.pop(), gi = Eh[Eh.length - 1] || null
}

let fc = 1;

function Lp(a) {
    fc += a
}

function iE(a) {
    return a.dynamicChildren = fc > 0 ? gi || Iu : null, rE(), fc > 0 && gi && gi.push(a), a
}

function tt(a, c, h, b, C, k) {
    return iE(J(a, c, h, b, C, k, !0))
}

function gr(a, c, h, b, C) {
    return iE(lt(a, c, h, b, C, !0))
}

function Ks(a) {
    return a ? a.__v_isVNode === !0 : !1
}

function Do(a, c) {
    return a.type === c.type && a.key === c.key
}

function oE(a) {
}

const gm = "__vInternal", sE = ({key: a}) => a ?? null, _p = ({
                                                                  ref: a,
                                                                  ref_key: c,
                                                                  ref_for: h
                                                              }) => (typeof a == "number" && (a = "" + a), a != null ? Pt(a) || ar(a) || St(a) ? {
    i: Er,
    r: a,
    k: c,
    f: !!h
} : a : null);

function J(a, c = null, h = null, b = 0, C = null, k = a === ln ? 0 : 1, A = !1, y = !1) {
    const w = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: a,
        props: c,
        key: c && sE(c),
        ref: c && _p(c),
        scopeId: cm,
        slotScopeIds: null,
        children: h,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: k,
        patchFlag: b,
        dynamicProps: C,
        dynamicChildren: null,
        appContext: null,
        ctx: Er
    };
    return y ? (V0(w, h), k & 128 && a.normalize(w)) : h && (w.shapeFlag |= Pt(h) ? 8 : 16), fc > 0 && !A && gi && (w.patchFlag > 0 || k & 6) && w.patchFlag !== 32 && gi.push(w), w
}

const lt = ZP;

function ZP(a, c = null, h = null, b = 0, C = null, k = !1) {
    if ((!a || a === px) && (a = Vr), Ks(a)) {
        const y = So(a, c, !0);
        return h && V0(y, h), fc > 0 && !k && gi && (y.shapeFlag & 6 ? gi[gi.indexOf(a)] = y : gi.push(y)), y.patchFlag |= -2, y
    }
    if (e6(a) && (a = a.__vccOpts), c) {
        c = z0(c);
        let {class: y, style: w} = c;
        y && !Pt(y) && (c.class = On(y)), vn(w) && (im(w) && !ut(w) && (w = nn({}, w)), c.style = bc(w))
    }
    const A = Pt(a) ? 1 : bx(a) ? 128 : $P(a) ? 64 : vn(a) ? 4 : St(a) ? 2 : 0;
    return J(a, c, h, b, C, A, k, !0)
}

function z0(a) {
    return a ? im(a) || gm in a ? nn({}, a) : a : null
}

function So(a, c, h = !1) {
    const {props: b, ref: C, patchFlag: k, children: A} = a, y = c ? pm(b || {}, c) : b;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: a.type,
        props: y,
        key: y && sE(y),
        ref: c && c.ref ? h && C ? ut(C) ? C.concat(_p(c)) : [C, _p(c)] : _p(c) : C,
        scopeId: a.scopeId,
        slotScopeIds: a.slotScopeIds,
        children: A,
        target: a.target,
        targetAnchor: a.targetAnchor,
        staticCount: a.staticCount,
        shapeFlag: a.shapeFlag,
        patchFlag: c && a.type !== ln ? k === -1 ? 16 : k | 16 : k,
        dynamicProps: a.dynamicProps,
        dynamicChildren: a.dynamicChildren,
        appContext: a.appContext,
        dirs: a.dirs,
        transition: a.transition,
        component: a.component,
        suspense: a.suspense,
        ssContent: a.ssContent && So(a.ssContent),
        ssFallback: a.ssFallback && So(a.ssFallback),
        el: a.el,
        anchor: a.anchor,
        ctx: a.ctx,
        ce: a.ce
    }
}

function Yt(a = " ", c = 0) {
    return lt(Ya, null, a, c)
}

function j0(a, c) {
    const h = lt(Ua, null, a);
    return h.staticCount = c, h
}

function Rt(a = "", c = !1) {
    return c ? (He(), gr(Vr, null, a)) : lt(Vr, null, a)
}

function Ni(a) {
    return a == null || typeof a == "boolean" ? lt(Vr) : ut(a) ? lt(ln, null, a.slice()) : typeof a == "object" ? za(a) : lt(Ya, null, String(a))
}

function za(a) {
    return a.el === null && a.patchFlag !== -1 || a.memo ? a : So(a)
}

function V0(a, c) {
    let h = 0;
    const {shapeFlag: b} = a;
    if (c == null) c = null; else if (ut(c)) h = 16; else if (typeof c == "object") if (b & 65) {
        const C = c.default;
        C && (C._c && (C._d = !1), V0(a, C()), C._c && (C._d = !0));
        return
    } else {
        h = 32;
        const C = c._;
        !C && !(gm in c) ? c._ctx = Er : C === 3 && Er && (Er.slots._ === 1 ? c._ = 1 : (c._ = 2, a.patchFlag |= 1024))
    } else St(c) ? (c = {default: c, _ctx: Er}, h = 32) : (c = String(c), b & 64 ? (h = 16, c = [Yt(c)]) : h = 8);
    a.children = c, a.shapeFlag |= h
}

function pm(...a) {
    const c = {};
    for (let h = 0; h < a.length; h++) {
        const b = a[h];
        for (const C in b) if (C === "class") c.class !== b.class && (c.class = On([c.class, b.class])); else if (C === "style") c.style = bc([c.style, b.style]); else if (pc(C)) {
            const k = c[C], A = b[C];
            A && k !== A && !(ut(k) && k.includes(A)) && (c[C] = k ? [].concat(k, A) : A)
        } else C !== "" && (c[C] = b[C])
    }
    return c
}

function fi(a, c, h, b = null) {
    bi(a, c, 7, [h, b])
}

const YP = $x();
let QP = 0;

function aE(a, c, h) {
    const b = a.type, C = (c ? c.appContext : a.appContext) || YP, k = {
        uid: QP++,
        vnode: a,
        type: b,
        parent: c,
        appContext: C,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new Xp(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: c ? c.provides : Object.create(C.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: Zx(b, C),
        emitsOptions: fx(b, C),
        emit: null,
        emitted: null,
        propsDefaults: an,
        inheritAttrs: b.inheritAttrs,
        ctx: an,
        data: an,
        props: an,
        attrs: an,
        slots: an,
        refs: an,
        setupState: an,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: h,
        suspenseId: h ? h.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return k.ctx = {_: k}, k.root = c ? c.root : k, k.emit = pP.bind(null, k), a.ce && a.ce(k), k
}

let pr = null;
const co = () => pr || Er;
let H0, Eu, j2 = "__VUE_INSTANCE_SETTERS__";
(Eu = Mk()[j2]) || (Eu = Mk()[j2] = []), Eu.push(a => pr = a), H0 = a => {
    Eu.length > 1 ? Eu.forEach(c => c(a)) : Eu[0](a)
};
const Qa = a => {
    H0(a), a.scope.on()
}, qa = () => {
    pr && pr.scope.off(), H0(null)
};

function lE(a) {
    return a.vnode.shapeFlag & 4
}

let Ou = !1;

function cE(a, c = !1) {
    Ou = c;
    const {props: h, children: b} = a.vnode, C = lE(a);
    zP(a, h, C, c), HP(a, b);
    const k = C ? JP(a, c) : void 0;
    return Ou = !1, k
}

function JP(a, c) {
    const h = a.type;
    a.accessCache = Object.create(null), a.proxy = Gs(new Proxy(a.ctx, Fk));
    const {setup: b} = h;
    if (b) {
        const C = a.setupContext = b.length > 1 ? hE(a) : null;
        Qa(a), qu();
        const k = os(b, a, 0, [a.props, C]);
        if (Wu(), qa(), c0(k)) {
            if (k.then(qa, qa), c) return k.then(A => {
                Hk(a, A, c)
            }).catch(A => {
                el(A, a, 0)
            });
            a.asyncDep = k
        } else Hk(a, k, c)
    } else dE(a, c)
}

function Hk(a, c, h) {
    St(c) ? a.type.__ssrInlineRender ? a.ssrRender = c : a.render = c : vn(c) && (a.setupState = sm(c)), dE(a, h)
}

let Pp, Uk;

function U0(a) {
    Pp = a, Uk = c => {
        c.render._rc && (c.withProxy = new Proxy(c.ctx, MP))
    }
}

const uE = () => !Pp;

function dE(a, c, h) {
    const b = a.type;
    if (!a.render) {
        if (!c && Pp && !b.render) {
            const C = b.template || L0(a).template;
            if (C) {
                const {isCustomElement: k, compilerOptions: A} = a.appContext.config, {
                    delimiters: y,
                    compilerOptions: w
                } = b, S = nn(nn({isCustomElement: k, delimiters: y}, A), w);
                b.render = Pp(C, S)
            }
        }
        a.render = b.render || mi, Uk && Uk(a)
    }
    {
        Qa(a), qu();
        try {
            BP(a)
        } finally {
            Wu(), qa()
        }
    }
}

function XP(a) {
    return a.attrsProxy || (a.attrsProxy = new Proxy(a.attrs, {
        get(c, h) {
            return ki(a, "get", "$attrs"), c[h]
        }
    }))
}

function hE(a) {
    const c = h => {
        a.exposed = h || {}
    };
    return {
        get attrs() {
            return XP(a)
        }, slots: a.slots, emit: a.emit, expose: c
    }
}

function mm(a) {
    if (a.exposed) return a.exposeProxy || (a.exposeProxy = new Proxy(sm(Gs(a.exposed)), {
        get(c, h) {
            if (h in c) return c[h];
            if (h in Dh) return Dh[h](a)
        }, has(c, h) {
            return h in c || h in Dh
        }
    }))
}

function qk(a, c = !0) {
    return St(a) ? a.displayName || a.name : a.name || c && a.__name
}

function e6(a) {
    return St(a) && "__vccOpts" in a
}

const tn = (a, c) => uP(a, c, Ou);

function q0(a, c, h) {
    const b = arguments.length;
    return b === 2 ? vn(c) && !ut(c) ? Ks(c) ? lt(a, null, [c]) : lt(a, c) : lt(a, null, c) : (b > 3 ? h = Array.prototype.slice.call(arguments, 2) : b === 3 && Ks(h) && (h = [h]), lt(a, c, h))
}

const W0 = Symbol.for("v-scx"), $0 = () => Ha(W0);

function fE() {
}

function gE(a, c, h, b) {
    const C = h[b];
    if (C && G0(C, a)) return C;
    const k = c();
    return k.memo = a.slice(), h[b] = k
}

function G0(a, c) {
    const h = a.memo;
    if (h.length != c.length) return !1;
    for (let b = 0; b < h.length; b++) if ($a(h[b], c[b])) return !1;
    return fc > 0 && gi && gi.push(a), !0
}

const K0 = "3.3.12", t6 = {
        createComponentInstance: aE,
        setupComponent: cE,
        renderComponentRoot: Cp,
        setCurrentRenderingInstance: Ph,
        isVNode: Ks,
        normalizeVNode: Ni
    }, pE = t6, mE = null, bE = null, n6 = "http://www.w3.org/2000/svg", tc = typeof document < "u" ? document : null,
    V2 = tc && tc.createElement("template"), r6 = {
        insert: (a, c, h) => {
            c.insertBefore(a, h || null)
        },
        remove: a => {
            const c = a.parentNode;
            c && c.removeChild(a)
        },
        createElement: (a, c, h, b) => {
            const C = c ? tc.createElementNS(n6, a) : tc.createElement(a, h ? {is: h} : void 0);
            return a === "select" && b && b.multiple != null && C.setAttribute("multiple", b.multiple), C
        },
        createText: a => tc.createTextNode(a),
        createComment: a => tc.createComment(a),
        setText: (a, c) => {
            a.nodeValue = c
        },
        setElementText: (a, c) => {
            a.textContent = c
        },
        parentNode: a => a.parentNode,
        nextSibling: a => a.nextSibling,
        querySelector: a => tc.querySelector(a),
        setScopeId(a, c) {
            a.setAttribute(c, "")
        },
        insertStaticContent(a, c, h, b, C, k) {
            const A = h ? h.previousSibling : c.lastChild;
            if (C && (C === k || C.nextSibling)) for (; c.insertBefore(C.cloneNode(!0), h), !(C === k || !(C = C.nextSibling));) ; else {
                V2.innerHTML = b ? `<svg>${a}</svg>` : a;
                const y = V2.content;
                if (b) {
                    const w = y.firstChild;
                    for (; w.firstChild;) y.appendChild(w.firstChild);
                    y.removeChild(w)
                }
                c.insertBefore(y, h)
            }
            return [A ? A.nextSibling : c.firstChild, h ? h.previousSibling : c.lastChild]
        }
    }, Oa = "transition", vh = "animation", Fu = Symbol("_vtc"), bm = (a, {slots: c}) => q0(D0, vE(a), c);
bm.displayName = "Transition";
const kE = {
    name: String,
    type: String,
    css: {type: Boolean, default: !0},
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}, i6 = bm.props = nn({}, dm, kE), Jl = (a, c = []) => {
    ut(a) ? a.forEach(h => h(...c)) : a && a(...c)
}, H2 = a => a ? ut(a) ? a.some(c => c.length > 1) : a.length > 1 : !1;

function vE(a) {
    const c = {};
    for (const ke in a) ke in kE || (c[ke] = a[ke]);
    if (a.css === !1) return c;
    const {
        name: h = "v",
        type: b,
        duration: C,
        enterFromClass: k = `${h}-enter-from`,
        enterActiveClass: A = `${h}-enter-active`,
        enterToClass: y = `${h}-enter-to`,
        appearFromClass: w = k,
        appearActiveClass: S = A,
        appearToClass: I = y,
        leaveFromClass: T = `${h}-leave-from`,
        leaveActiveClass: D = `${h}-leave-active`,
        leaveToClass: B = `${h}-leave-to`
    } = a, L = o6(C), z = L && L[0], q = L && L[1], {
        onBeforeEnter: Q,
        onEnter: G,
        onEnterCancelled: Z,
        onLeave: Y,
        onLeaveCancelled: ce,
        onBeforeAppear: Ce = Q,
        onAppear: me = G,
        onAppearCancelled: R = Z
    } = c, ae = (ke, le, ye) => {
        Fa(ke, le ? I : y), Fa(ke, le ? S : A), ye && ye()
    }, ue = (ke, le) => {
        ke._isLeaving = !1, Fa(ke, T), Fa(ke, B), Fa(ke, D), le && le()
    }, ve = ke => (le, ye) => {
        const ee = ke ? me : G, qe = () => ae(le, ke, ye);
        Jl(ee, [le, qe]), U2(() => {
            Fa(le, ke ? w : k), zs(le, ke ? I : y), H2(ee) || q2(le, b, z, qe)
        })
    };
    return nn(c, {
        onBeforeEnter(ke) {
            Jl(Q, [ke]), zs(ke, k), zs(ke, A)
        }, onBeforeAppear(ke) {
            Jl(Ce, [ke]), zs(ke, w), zs(ke, S)
        }, onEnter: ve(!1), onAppear: ve(!0), onLeave(ke, le) {
            ke._isLeaving = !0;
            const ye = () => ue(ke, le);
            zs(ke, T), AE(), zs(ke, D), U2(() => {
                ke._isLeaving && (Fa(ke, T), zs(ke, B), H2(Y) || q2(ke, b, q, ye))
            }), Jl(Y, [ke, ye])
        }, onEnterCancelled(ke) {
            ae(ke, !1), Jl(Z, [ke])
        }, onAppearCancelled(ke) {
            ae(ke, !0), Jl(R, [ke])
        }, onLeaveCancelled(ke) {
            ue(ke), Jl(ce, [ke])
        }
    })
}

function o6(a) {
    if (a == null) return null;
    if (vn(a)) return [yk(a.enter), yk(a.leave)];
    {
        const c = yk(a);
        return [c, c]
    }
}

function yk(a) {
    return Tp(a)
}

function zs(a, c) {
    c.split(/\s+/).forEach(h => h && a.classList.add(h)), (a[Fu] || (a[Fu] = new Set)).add(c)
}

function Fa(a, c) {
    c.split(/\s+/).forEach(b => b && a.classList.remove(b));
    const h = a[Fu];
    h && (h.delete(c), h.size || (a[Fu] = void 0))
}

function U2(a) {
    requestAnimationFrame(() => {
        requestAnimationFrame(a)
    })
}

let s6 = 0;

function q2(a, c, h, b) {
    const C = a._endId = ++s6, k = () => {
        C === a._endId && b()
    };
    if (h) return setTimeout(k, h);
    const {type: A, timeout: y, propCount: w} = wE(a, c);
    if (!A) return b();
    const S = A + "end";
    let I = 0;
    const T = () => {
        a.removeEventListener(S, D), k()
    }, D = B => {
        B.target === a && ++I >= w && T()
    };
    setTimeout(() => {
        I < w && T()
    }, y + 1), a.addEventListener(S, D)
}

function wE(a, c) {
    const h = window.getComputedStyle(a), b = L => (h[L] || "").split(", "), C = b(`${Oa}Delay`),
        k = b(`${Oa}Duration`), A = W2(C, k), y = b(`${vh}Delay`), w = b(`${vh}Duration`), S = W2(y, w);
    let I = null, T = 0, D = 0;
    c === Oa ? A > 0 && (I = Oa, T = A, D = k.length) : c === vh ? S > 0 && (I = vh, T = S, D = w.length) : (T = Math.max(A, S), I = T > 0 ? A > S ? Oa : vh : null, D = I ? I === Oa ? k.length : w.length : 0);
    const B = I === Oa && /\b(transform|all)(,|$)/.test(b(`${Oa}Property`).toString());
    return {type: I, timeout: T, propCount: D, hasTransform: B}
}

function W2(a, c) {
    for (; a.length < c.length;) a = a.concat(a);
    return Math.max(...c.map((h, b) => $2(h) + $2(a[b])))
}

function $2(a) {
    return a === "auto" ? 0 : Number(a.slice(0, -1).replace(",", ".")) * 1e3
}

function AE() {
    return document.body.offsetHeight
}

function a6(a, c, h) {
    const b = a[Fu];
    b && (c = (c ? [c, ...b] : [...b]).join(" ")), c == null ? a.removeAttribute("class") : h ? a.setAttribute("class", c) : a.className = c
}

const Z0 = Symbol("_vod"), Hs = {
    beforeMount(a, {value: c}, {transition: h}) {
        a[Z0] = a.style.display === "none" ? "" : a.style.display, h && c ? h.beforeEnter(a) : wh(a, c)
    }, mounted(a, {value: c}, {transition: h}) {
        h && c && h.enter(a)
    }, updated(a, {value: c, oldValue: h}, {transition: b}) {
        !c != !h && (b ? c ? (b.beforeEnter(a), wh(a, !0), b.enter(a)) : b.leave(a, () => {
            wh(a, !1)
        }) : wh(a, c))
    }, beforeUnmount(a, {value: c}) {
        wh(a, c)
    }
};

function wh(a, c) {
    a.style.display = c ? a[Z0] : "none"
}

function l6() {
    Hs.getSSRProps = ({value: a}) => {
        if (!a) return {style: {display: "none"}}
    }
}

const CE = Symbol("");

function _E(a) {
    const c = co();
    if (!c) return;
    const h = c.ut = (C = a(c.proxy)) => {
        Array.from(document.querySelectorAll(`[data-v-owner="${c.uid}"]`)).forEach(k => $k(k, C))
    }, b = () => {
        const C = a(c.proxy);
        Wk(c.subTree, C), h(C)
    };
    y0(b), Oi(() => {
        const C = new MutationObserver(b);
        C.observe(c.subTree.el.parentNode, {childList: !0}), Jh(() => C.disconnect())
    })
}

function Wk(a, c) {
    if (a.shapeFlag & 128) {
        const h = a.suspense;
        a = h.activeBranch, h.pendingBranch && !h.isHydrating && h.effects.push(() => {
            Wk(h.activeBranch, c)
        })
    }
    for (; a.component;) a = a.component.subTree;
    if (a.shapeFlag & 1 && a.el) $k(a.el, c); else if (a.type === ln) a.children.forEach(h => Wk(h, c)); else if (a.type === Ua) {
        let {el: h, anchor: b} = a;
        for (; h && ($k(h, c), h !== b);) h = h.nextSibling
    }
}

function $k(a, c) {
    if (a.nodeType === 1) {
        const h = a.style;
        let b = "";
        for (const C in c) h.setProperty(`--${C}`, c[C]), b += `--${C}: ${c[C]};`;
        h[CE] = b
    }
}

function c6(a, c, h) {
    const b = a.style, C = Pt(h);
    if (h && !C) {
        if (c && !Pt(c)) for (const k in c) h[k] == null && Gk(b, k, "");
        for (const k in h) Gk(b, k, h[k])
    } else {
        const k = b.display;
        if (C) {
            if (c !== h) {
                const A = b[CE];
                A && (h += ";" + A), b.cssText = h
            }
        } else c && a.removeAttribute("style");
        Z0 in a && (b.display = k)
    }
}

const G2 = /\s*!important$/;

function Gk(a, c, h) {
    if (ut(h)) h.forEach(b => Gk(a, c, b)); else if (h == null && (h = ""), c.startsWith("--")) a.setProperty(c, h); else {
        const b = u6(a, c);
        G2.test(h) ? a.setProperty(Li(b), h.replace(G2, ""), "important") : a[b] = h
    }
}

const K2 = ["Webkit", "Moz", "ms"], Dk = {};

function u6(a, c) {
    const h = Dk[c];
    if (h) return h;
    let b = sr(c);
    if (b !== "filter" && b in a) return Dk[c] = b;
    b = Xa(b);
    for (let C = 0; C < K2.length; C++) {
        const k = K2[C] + b;
        if (k in a) return Dk[c] = k
    }
    return c
}

const Z2 = "http://www.w3.org/1999/xlink";

function d6(a, c, h, b, C) {
    if (b && c.startsWith("xlink:")) h == null ? a.removeAttributeNS(Z2, c.slice(6, c.length)) : a.setAttributeNS(Z2, c, h); else {
        const k = PL(c);
        h == null || k && !PD(h) ? a.removeAttribute(c) : a.setAttribute(c, k ? "" : h)
    }
}

function h6(a, c, h, b, C, k, A) {
    if (c === "innerHTML" || c === "textContent") {
        b && A(b, C, k), a[c] = h ?? "";
        return
    }
    const y = a.tagName;
    if (c === "value" && y !== "PROGRESS" && !y.includes("-")) {
        a._value = h;
        const S = y === "OPTION" ? a.getAttribute("value") : a.value, I = h ?? "";
        S !== I && (a.value = I), h == null && a.removeAttribute(c);
        return
    }
    let w = !1;
    if (h === "" || h == null) {
        const S = typeof a[c];
        S === "boolean" ? h = PD(h) : h == null && S === "string" ? (h = "", w = !0) : S === "number" && (h = 0, w = !0)
    }
    try {
        a[c] = h
    } catch {
    }
    w && a.removeAttribute(c)
}

function Vs(a, c, h, b) {
    a.addEventListener(c, h, b)
}

function f6(a, c, h, b) {
    a.removeEventListener(c, h, b)
}

const Y2 = Symbol("_vei");

function g6(a, c, h, b, C = null) {
    const k = a[Y2] || (a[Y2] = {}), A = k[c];
    if (b && A) A.value = b; else {
        const [y, w] = p6(c);
        if (b) {
            const S = k[c] = k6(b, C);
            Vs(a, y, S, w)
        } else A && (f6(a, y, A, w), k[c] = void 0)
    }
}

const Q2 = /(?:Once|Passive|Capture)$/;

function p6(a) {
    let c;
    if (Q2.test(a)) {
        c = {};
        let b;
        for (; b = a.match(Q2);) a = a.slice(0, a.length - b[0].length), c[b[0].toLowerCase()] = !0
    }
    return [a[2] === ":" ? a.slice(3) : Li(a.slice(2)), c]
}

let xk = 0;
const m6 = Promise.resolve(), b6 = () => xk || (m6.then(() => xk = 0), xk = Date.now());

function k6(a, c) {
    const h = b => {
        if (!b._vts) b._vts = Date.now(); else if (b._vts <= h.attached) return;
        bi(v6(b, h.value), c, 5, [b])
    };
    return h.value = a, h.attached = b6(), h
}

function v6(a, c) {
    if (ut(c)) {
        const h = a.stopImmediatePropagation;
        return a.stopImmediatePropagation = () => {
            h.call(a), a._stopped = !0
        }, c.map(b => C => !C._stopped && b && b(C))
    } else return c
}

const J2 = a => a.charCodeAt(0) === 111 && a.charCodeAt(1) === 110 && a.charCodeAt(2) > 96 && a.charCodeAt(2) < 123,
    w6 = (a, c, h, b, C = !1, k, A, y, w) => {
        c === "class" ? a6(a, b, C) : c === "style" ? c6(a, h, b) : pc(c) ? a0(c) || g6(a, c, h, b, A) : (c[0] === "." ? (c = c.slice(1), !0) : c[0] === "^" ? (c = c.slice(1), !1) : A6(a, c, b, C)) ? h6(a, c, b, k, A, y, w) : (c === "true-value" ? a._trueValue = b : c === "false-value" && (a._falseValue = b), d6(a, c, b, C))
    };

function A6(a, c, h, b) {
    if (b) return !!(c === "innerHTML" || c === "textContent" || c in a && J2(c) && St(h));
    if (c === "spellcheck" || c === "draggable" || c === "translate" || c === "form" || c === "list" && a.tagName === "INPUT" || c === "type" && a.tagName === "TEXTAREA") return !1;
    if (c === "width" || c === "height") {
        const C = a.tagName;
        if (C === "IMG" || C === "VIDEO" || C === "CANVAS" || C === "SOURCE") return !1
    }
    return J2(c) && Pt(h) ? !1 : c in a
}/*! #__NO_SIDE_EFFECTS__ */
function Y0(a, c) {
    const h = tl(a);

    class b extends Xh {
        constructor(k) {
            super(h, k, c)
        }
    }

    return b.def = h, b
}/*! #__NO_SIDE_EFFECTS__ */
const yE = a => Y0(a, J0), C6 = typeof HTMLElement < "u" ? HTMLElement : class {
};

class Xh extends C6 {
    constructor(c, h = {}, b) {
        super(), this._def = c, this._props = h, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this._ob = null, this.shadowRoot && b ? b(this._createVNode(), this.shadowRoot) : (this.attachShadow({mode: "open"}), this._def.__asyncLoader || this._resolveProps(this._def))
    }

    connectedCallback() {
        this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef())
    }

    disconnectedCallback() {
        this._connected = !1, this._ob && (this._ob.disconnect(), this._ob = null), uc(() => {
            this._connected || (Fp(null, this.shadowRoot), this._instance = null)
        })
    }

    _resolveDef() {
        this._resolved = !0;
        for (let b = 0; b < this.attributes.length; b++) this._setAttr(this.attributes[b].name);
        this._ob = new MutationObserver(b => {
            for (const C of b) this._setAttr(C.attributeName)
        }), this._ob.observe(this, {attributes: !0});
        const c = (b, C = !1) => {
            const {props: k, styles: A} = b;
            let y;
            if (k && !ut(k)) for (const w in k) {
                const S = k[w];
                (S === Number || S && S.type === Number) && (w in this._props && (this._props[w] = Tp(this._props[w])), (y || (y = Object.create(null)))[sr(w)] = !0)
            }
            this._numberProps = y, C && this._resolveProps(b), this._applyStyles(A), this._update()
        }, h = this._def.__asyncLoader;
        h ? h().then(b => c(b, !0)) : c(this._def)
    }

    _resolveProps(c) {
        const {props: h} = c, b = ut(h) ? h : Object.keys(h || {});
        for (const C of Object.keys(this)) C[0] !== "_" && b.includes(C) && this._setProp(C, this[C], !0, !1);
        for (const C of b.map(sr)) Object.defineProperty(this, C, {
            get() {
                return this._getProp(C)
            }, set(k) {
                this._setProp(C, k)
            }
        })
    }

    _setAttr(c) {
        let h = this.getAttribute(c);
        const b = sr(c);
        this._numberProps && this._numberProps[b] && (h = Tp(h)), this._setProp(b, h, !1)
    }

    _getProp(c) {
        return this._props[c]
    }

    _setProp(c, h, b = !0, C = !0) {
        h !== this._props[c] && (this._props[c] = h, C && this._instance && this._update(), b && (h === !0 ? this.setAttribute(Li(c), "") : typeof h == "string" || typeof h == "number" ? this.setAttribute(Li(c), h + "") : h || this.removeAttribute(Li(c))))
    }

    _update() {
        Fp(this._createVNode(), this.shadowRoot)
    }

    _createVNode() {
        const c = lt(this._def, nn({}, this._props));
        return this._instance || (c.ce = h => {
            this._instance = h, h.isCE = !0;
            const b = (k, A) => {
                this.dispatchEvent(new CustomEvent(k, {detail: A}))
            };
            h.emit = (k, ...A) => {
                b(k, A), Li(k) !== k && b(Li(k), A)
            };
            let C = this;
            for (; C = C && (C.parentNode || C.host);) if (C instanceof Xh) {
                h.parent = C._instance, h.provides = C._instance.provides;
                break
            }
        }), c
    }

    _applyStyles(c) {
        c && c.forEach(h => {
            const b = document.createElement("style");
            b.textContent = h, this.shadowRoot.appendChild(b)
        })
    }
}

function DE(a = "$style") {
    {
        const c = co();
        if (!c) return an;
        const h = c.type.__cssModules;
        if (!h) return an;
        const b = h[a];
        return b || an
    }
}

const xE = new WeakMap, EE = new WeakMap, Op = Symbol("_moveCb"), X2 = Symbol("_enterCb"), SE = {
    name: "TransitionGroup", props: nn({}, i6, {tag: String, moveClass: String}), setup(a, {slots: c}) {
        const h = co(), b = um();
        let C, k;
        return Qh(() => {
            if (!C.length) return;
            const A = a.moveClass || `${a.name || "v"}-move`;
            if (!E6(C[0].el, h.vnode.el, A)) return;
            C.forEach(y6), C.forEach(D6);
            const y = C.filter(x6);
            AE(), y.forEach(w => {
                const S = w.el, I = S.style;
                zs(S, A), I.transform = I.webkitTransform = I.transitionDuration = "";
                const T = S[Op] = D => {
                    D && D.target !== S || (!D || /transform$/.test(D.propertyName)) && (S.removeEventListener("transitionend", T), S[Op] = null, Fa(S, A))
                };
                S.addEventListener("transitionend", T)
            })
        }), () => {
            const A = Wt(a), y = vE(A);
            let w = A.tag || ln;
            C = k, k = c.default ? Zh(c.default()) : [];
            for (let S = 0; S < k.length; S++) {
                const I = k[S];
                I.key != null && Za(I, dc(I, y, b, h))
            }
            if (C) for (let S = 0; S < C.length; S++) {
                const I = C[S];
                Za(I, dc(I, y, b, h)), xE.set(I, I.el.getBoundingClientRect())
            }
            return lt(w, null, k)
        }
    }
}, _6 = a => delete a.mode;
SE.props;
const TE = SE;

function y6(a) {
    const c = a.el;
    c[Op] && c[Op](), c[X2] && c[X2]()
}

function D6(a) {
    EE.set(a, a.el.getBoundingClientRect())
}

function x6(a) {
    const c = xE.get(a), h = EE.get(a), b = c.left - h.left, C = c.top - h.top;
    if (b || C) {
        const k = a.el.style;
        return k.transform = k.webkitTransform = `translate(${b}px,${C}px)`, k.transitionDuration = "0s", a
    }
}

function E6(a, c, h) {
    const b = a.cloneNode(), C = a[Fu];
    C && C.forEach(y => {
        y.split(/\s+/).forEach(w => w && b.classList.remove(w))
    }), h.split(/\s+/).forEach(y => y && b.classList.add(y)), b.style.display = "none";
    const k = c.nodeType === 1 ? c : c.parentNode;
    k.appendChild(b);
    const {hasTransform: A} = wE(b);
    return k.removeChild(b), A
}

const Ja = a => {
    const c = a.props["onUpdate:modelValue"] || !1;
    return ut(c) ? h => Bu(c, h) : c
};

function S6(a) {
    a.target.composing = !0
}

function eD(a) {
    const c = a.target;
    c.composing && (c.composing = !1, c.dispatchEvent(new Event("input")))
}

const ao = Symbol("_assign"), Vn = {
    created(a, {modifiers: {lazy: c, trim: h, number: b}}, C) {
        a[ao] = Ja(C);
        const k = b || C.props && C.props.type === "number";
        Vs(a, c ? "change" : "input", A => {
            if (A.target.composing) return;
            let y = a.value;
            h && (y = y.trim()), k && (y = Sp(y)), a[ao](y)
        }), h && Vs(a, "change", () => {
            a.value = a.value.trim()
        }), c || (Vs(a, "compositionstart", S6), Vs(a, "compositionend", eD), Vs(a, "change", eD))
    }, mounted(a, {value: c}) {
        a.value = c ?? ""
    }, beforeUpdate(a, {value: c, modifiers: {lazy: h, trim: b, number: C}}, k) {
        if (a[ao] = Ja(k), a.composing) return;
        const A = C || a.type === "number" ? Sp(a.value) : a.value, y = c ?? "";
        A !== y && (document.activeElement === a && a.type !== "range" && (h || b && a.value.trim() === y) || (a.value = y))
    }
}, vc = {
    deep: !0, created(a, c, h) {
        a[ao] = Ja(h), Vs(a, "change", () => {
            const b = a._modelValue, C = Ru(a), k = a.checked, A = a[ao];
            if (ut(b)) {
                const y = Jp(b, C), w = y !== -1;
                if (k && !w) A(b.concat(C)); else if (!k && w) {
                    const S = [...b];
                    S.splice(y, 1), A(S)
                }
            } else if (mc(b)) {
                const y = new Set(b);
                k ? y.add(C) : y.delete(C), A(y)
            } else A(IE(a, k))
        })
    }, mounted: tD, beforeUpdate(a, c, h) {
        a[ao] = Ja(h), tD(a, c, h)
    }
};

function tD(a, {value: c, oldValue: h}, b) {
    a._modelValue = c, ut(c) ? a.checked = Jp(c, b.props.value) > -1 : mc(c) ? a.checked = c.has(b.props.value) : c !== h && (a.checked = Ga(c, IE(a, !0)))
}

const km = {
    created(a, {value: c}, h) {
        a.checked = Ga(c, h.props.value), a[ao] = Ja(h), Vs(a, "change", () => {
            a[ao](Ru(a))
        })
    }, beforeUpdate(a, {value: c, oldValue: h}, b) {
        a[ao] = Ja(b), c !== h && (a.checked = Ga(c, b.props.value))
    }
}, xr = {
    deep: !0, created(a, {value: c, modifiers: {number: h}}, b) {
        const C = mc(c);
        Vs(a, "change", () => {
            const k = Array.prototype.filter.call(a.options, A => A.selected).map(A => h ? Sp(Ru(A)) : Ru(A));
            a[ao](a.multiple ? C ? new Set(k) : k : k[0])
        }), a[ao] = Ja(b)
    }, mounted(a, {value: c}) {
        nD(a, c)
    }, beforeUpdate(a, c, h) {
        a[ao] = Ja(h)
    }, updated(a, {value: c}) {
        nD(a, c)
    }
};

function nD(a, c) {
    const h = a.multiple;
    if (!(h && !ut(c) && !mc(c))) {
        for (let b = 0, C = a.options.length; b < C; b++) {
            const k = a.options[b], A = Ru(k);
            if (h) ut(c) ? k.selected = Jp(c, A) > -1 : k.selected = c.has(A); else if (Ga(Ru(k), c)) {
                a.selectedIndex !== b && (a.selectedIndex = b);
                return
            }
        }
        !h && a.selectedIndex !== -1 && (a.selectedIndex = -1)
    }
}

function Ru(a) {
    return "_value" in a ? a._value : a.value
}

function IE(a, c) {
    const h = c ? "_trueValue" : "_falseValue";
    return h in a ? a[h] : c
}

const Q0 = {
    created(a, c, h) {
        mp(a, c, h, null, "created")
    }, mounted(a, c, h) {
        mp(a, c, h, null, "mounted")
    }, beforeUpdate(a, c, h, b) {
        mp(a, c, h, b, "beforeUpdate")
    }, updated(a, c, h, b) {
        mp(a, c, h, b, "updated")
    }
};

function ME(a, c) {
    switch (a) {
        case"SELECT":
            return xr;
        case"TEXTAREA":
            return Vn;
        default:
            switch (c) {
                case"checkbox":
                    return vc;
                case"radio":
                    return km;
                default:
                    return Vn
            }
    }
}

function mp(a, c, h, b, C) {
    const A = ME(a.tagName, h.props && h.props.type)[C];
    A && A(a, c, h, b)
}

function T6() {
    Vn.getSSRProps = ({value: a}) => ({value: a}), km.getSSRProps = ({value: a}, c) => {
        if (c.props && Ga(c.props.value, a)) return {checked: !0}
    }, vc.getSSRProps = ({value: a}, c) => {
        if (ut(a)) {
            if (c.props && Jp(a, c.props.value) > -1) return {checked: !0}
        } else if (mc(a)) {
            if (c.props && a.has(c.props.value)) return {checked: !0}
        } else if (a) return {checked: !0}
    }, Q0.getSSRProps = (a, c) => {
        if (typeof c.type != "string") return;
        const h = ME(c.type.toUpperCase(), c.props && c.props.type);
        if (h.getSSRProps) return h.getSSRProps(a, c)
    }
}

const I6 = ["ctrl", "shift", "alt", "meta"], M6 = {
    stop: a => a.stopPropagation(),
    prevent: a => a.preventDefault(),
    self: a => a.target !== a.currentTarget,
    ctrl: a => !a.ctrlKey,
    shift: a => !a.shiftKey,
    alt: a => !a.altKey,
    meta: a => !a.metaKey,
    left: a => "button" in a && a.button !== 0,
    middle: a => "button" in a && a.button !== 1,
    right: a => "button" in a && a.button !== 2,
    exact: (a, c) => I6.some(h => a[`${h}Key`] && !c.includes(h))
}, vm = (a, c) => a._withMods || (a._withMods = (h, ...b) => {
    for (let C = 0; C < c.length; C++) {
        const k = M6[c[C]];
        if (k && k(h, c)) return
    }
    return a(h, ...b)
}), B6 = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}, BE = (a, c) => a._withKeys || (a._withKeys = h => {
    if (!("key" in h)) return;
    const b = Li(h.key);
    if (c.some(C => C === b || B6[C] === b)) return a(h)
}), NE = nn({patchProp: w6}, r6);
let Sh, rD = !1;

function LE() {
    return Sh || (Sh = O0(NE))
}

function PE() {
    return Sh = rD ? Sh : F0(NE), rD = !0, Sh
}

const Fp = (...a) => {
    LE().render(...a)
}, J0 = (...a) => {
    PE().hydrate(...a)
}, X0 = (...a) => {
    const c = LE().createApp(...a), {mount: h} = c;
    return c.mount = b => {
        const C = FE(b);
        if (!C) return;
        const k = c._component;
        !St(k) && !k.render && !k.template && (k.template = C.innerHTML), C.innerHTML = "";
        const A = h(C, !1, C instanceof SVGElement);
        return C instanceof Element && (C.removeAttribute("v-cloak"), C.setAttribute("data-v-app", "")), A
    }, c
}, OE = (...a) => {
    const c = PE().createApp(...a), {mount: h} = c;
    return c.mount = b => {
        const C = FE(b);
        if (C) return h(C, !0, C instanceof SVGElement)
    }, c
};

function FE(a) {
    return Pt(a) ? document.querySelector(a) : a
}

let iD = !1;
const RE = () => {
    iD || (iD = !0, T6(), l6())
}, N6 = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseTransition: D0,
    BaseTransitionPropsValidators: dm,
    Comment: Vr,
    EffectScope: Xp,
    Fragment: ln,
    KeepAlive: Dx,
    ReactiveEffect: cc,
    Static: Ua,
    Suspense: kx,
    Teleport: tE,
    Text: Ya,
    Transition: bm,
    TransitionGroup: TE,
    VueElement: Xh,
    assertNumber: cx,
    callWithAsyncErrorHandling: bi,
    callWithErrorHandling: os,
    camelize: sr,
    capitalize: Xa,
    cloneVNode: So,
    compatUtils: bE,
    computed: tn,
    createApp: X0,
    createBlock: gr,
    createCommentVNode: Rt,
    createElementBlock: tt,
    createElementVNode: J,
    createHydrationRenderer: F0,
    createPropsRestProxy: Ux,
    createRenderer: O0,
    createSSRApp: OE,
    createSlots: Ex,
    createStaticVNode: j0,
    createTextVNode: Yt,
    createVNode: lt,
    customRef: ix,
    defineAsyncComponent: yx,
    defineComponent: tl,
    defineCustomElement: Y0,
    defineEmits: Mx,
    defineExpose: Bx,
    defineModel: Px,
    defineOptions: Nx,
    defineProps: Ix,
    defineSSRCustomElement: yE,
    defineSlots: Lx,
    get devtools() {
        return ec
    },
    effect: HD,
    effectScope: FD,
    getCurrentInstance: co,
    getCurrentScope: d0,
    getTransitionRawChildren: Zh,
    guardReactiveProps: z0,
    h: q0,
    handleError: el,
    hasInjectionContext: Gx,
    hydrate: J0,
    initCustomFormatter: fE,
    initDirectivesForSSR: RE,
    inject: Ha,
    isMemoSame: G0,
    isProxy: im,
    isReactive: qs,
    isReadonly: $s,
    isRef: ar,
    isRuntimeOnly: uE,
    isShallow: Pu,
    isVNode: Ks,
    markRaw: Gs,
    mergeDefaults: Vx,
    mergeModels: Hx,
    mergeProps: pm,
    nextTick: uc,
    normalizeClass: On,
    normalizeProps: LD,
    normalizeStyle: bc,
    onActivated: x0,
    onBeforeMount: fm,
    onBeforeUnmount: kc,
    onBeforeUpdate: S0,
    onDeactivated: E0,
    onErrorCaptured: B0,
    onMounted: Oi,
    onRenderTracked: M0,
    onRenderTriggered: I0,
    onScopeDispose: zD,
    onServerPrefetch: T0,
    onUnmounted: Jh,
    onUpdated: Qh,
    openBlock: He,
    popScopeId: Gu,
    provide: hc,
    proxyRefs: sm,
    pushScopeId: $u,
    queuePostFlushCb: Nh,
    reactive: jr,
    readonly: nm,
    ref: yt,
    registerRuntimeCompiler: U0,
    render: Fp,
    renderList: so,
    renderSlot: N0,
    resolveComponent: Nn,
    resolveDirective: mx,
    resolveDynamicComponent: Oh,
    resolveFilter: mE,
    resolveTransitionHooks: dc,
    setBlockTracking: Lp,
    setDevtoolsHook: v0,
    setTransitionHooks: Za,
    shallowReactive: g0,
    shallowReadonly: ex,
    shallowRef: b0,
    ssrContextKey: W0,
    ssrUtils: pE,
    stop: UD,
    toDisplayString: Fn,
    toHandlerKey: oc,
    toHandlers: Tx,
    toRaw: Wt,
    toRef: sx,
    toRefs: ox,
    toValue: rx,
    transformVNodeArgs: oE,
    triggerRef: nx,
    unref: xt,
    useAttrs: Rx,
    useCssModule: DE,
    useCssVars: _E,
    useModel: zx,
    useSSRContext: $0,
    useSlots: Fx,
    useTransitionState: um,
    vModelCheckbox: vc,
    vModelDynamic: Q0,
    vModelRadio: km,
    vModelSelect: xr,
    vModelText: Vn,
    vShow: Hs,
    version: K0,
    warn: lx,
    watch: or,
    watchEffect: wx,
    watchPostEffect: y0,
    watchSyncEffect: Ax,
    withAsyncContext: qx,
    withCtx: Sr,
    withDefaults: Ox,
    withDirectives: Bt,
    withKeys: BE,
    withMemo: gE,
    withModifiers: vm,
    withScopeId: gx
}, Symbol.toStringTag, {value: "Module"}));

function ev(a) {
    throw a
}

function zE(a) {
}

function Pn(a, c, h, b) {
    const C = a, k = new SyntaxError(String(C));
    return k.code = a, k.loc = c, k
}

const jh = Symbol(""), Th = Symbol(""), tv = Symbol(""), Rp = Symbol(""), jE = Symbol(""), gc = Symbol(""),
    VE = Symbol(""), HE = Symbol(""), nv = Symbol(""), rv = Symbol(""), ef = Symbol(""), iv = Symbol(""),
    UE = Symbol(""), ov = Symbol(""), zp = Symbol(""), sv = Symbol(""), av = Symbol(""), lv = Symbol(""),
    cv = Symbol(""), qE = Symbol(""), WE = Symbol(""), wm = Symbol(""), jp = Symbol(""), uv = Symbol(""),
    dv = Symbol(""), Vh = Symbol(""), tf = Symbol(""), hv = Symbol(""), Kk = Symbol(""), L6 = Symbol(""),
    Zk = Symbol(""), Vp = Symbol(""), P6 = Symbol(""), O6 = Symbol(""), fv = Symbol(""), F6 = Symbol(""),
    R6 = Symbol(""), gv = Symbol(""), $E = Symbol(""), zu = {
        [jh]: "Fragment",
        [Th]: "Teleport",
        [tv]: "Suspense",
        [Rp]: "KeepAlive",
        [jE]: "BaseTransition",
        [gc]: "openBlock",
        [VE]: "createBlock",
        [HE]: "createElementBlock",
        [nv]: "createVNode",
        [rv]: "createElementVNode",
        [ef]: "createCommentVNode",
        [iv]: "createTextVNode",
        [UE]: "createStaticVNode",
        [ov]: "resolveComponent",
        [zp]: "resolveDynamicComponent",
        [sv]: "resolveDirective",
        [av]: "resolveFilter",
        [lv]: "withDirectives",
        [cv]: "renderList",
        [qE]: "renderSlot",
        [WE]: "createSlots",
        [wm]: "toDisplayString",
        [jp]: "mergeProps",
        [uv]: "normalizeClass",
        [dv]: "normalizeStyle",
        [Vh]: "normalizeProps",
        [tf]: "guardReactiveProps",
        [hv]: "toHandlers",
        [Kk]: "camelize",
        [L6]: "capitalize",
        [Zk]: "toHandlerKey",
        [Vp]: "setBlockTracking",
        [P6]: "pushScopeId",
        [O6]: "popScopeId",
        [fv]: "withCtx",
        [F6]: "unref",
        [R6]: "isRef",
        [gv]: "withMemo",
        [$E]: "isMemoSame"
    };

function z6(a) {
    Object.getOwnPropertySymbols(a).forEach(c => {
        zu[c] = a[c]
    })
}

const Fi = {source: "", start: {line: 1, column: 1, offset: 0}, end: {line: 1, column: 1, offset: 0}};

function j6(a, c = Fi) {
    return {
        type: 0,
        children: a,
        helpers: new Set,
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc: c
    }
}

function Hh(a, c, h, b, C, k, A, y = !1, w = !1, S = !1, I = Fi) {
    return a && (y ? (a.helper(gc), a.helper(Hu(a.inSSR, S))) : a.helper(Vu(a.inSSR, S)), A && a.helper(lv)), {
        type: 13,
        tag: c,
        props: h,
        children: b,
        patchFlag: C,
        dynamicProps: k,
        directives: A,
        isBlock: y,
        disableTracking: w,
        isComponent: S,
        loc: I
    }
}

function nf(a, c = Fi) {
    return {type: 17, loc: c, elements: a}
}

function ro(a, c = Fi) {
    return {type: 15, loc: c, properties: a}
}

function er(a, c) {
    return {type: 16, loc: Fi, key: Pt(a) ? jt(a, !0) : a, value: c}
}

function jt(a, c = !1, h = Fi, b = 0) {
    return {type: 4, loc: h, content: a, isStatic: c, constType: c ? 3 : b}
}

function xo(a, c = Fi) {
    return {type: 8, loc: c, children: a}
}

function fr(a, c = [], h = Fi) {
    return {type: 14, loc: h, callee: a, arguments: c}
}

function ju(a, c = void 0, h = !1, b = !1, C = Fi) {
    return {type: 18, params: a, returns: c, newline: h, isSlot: b, loc: C}
}

function Yk(a, c, h, b = !0) {
    return {type: 19, test: a, consequent: c, alternate: h, newline: b, loc: Fi}
}

function V6(a, c, h = !1) {
    return {type: 20, index: a, value: c, isVNode: h, loc: Fi}
}

function H6(a) {
    return {type: 21, body: a, loc: Fi}
}

function Vu(a, c) {
    return a || c ? nv : rv
}

function Hu(a, c) {
    return a || c ? VE : HE
}

function pv(a, {helper: c, removeHelper: h, inSSR: b}) {
    a.isBlock || (a.isBlock = !0, h(Vu(b, a.isComponent)), c(gc), c(Hu(b, a.isComponent)))
}

const pi = a => a.type === 4 && a.isStatic, Tu = (a, c) => a === c || a === Li(c);

function GE(a) {
    if (Tu(a, "Teleport")) return Th;
    if (Tu(a, "Suspense")) return tv;
    if (Tu(a, "KeepAlive")) return Rp;
    if (Tu(a, "BaseTransition")) return jE
}

const U6 = /^\d|[^\$\w]/, mv = a => !U6.test(a), q6 = /[A-Za-z_$\xA0-\uFFFF]/, W6 = /[\.\?\w$\xA0-\uFFFF]/,
    $6 = /\s+[.[]\s*|\s*[.[]\s+/g, G6 = a => {
        a = a.trim().replace($6, A => A.trim());
        let c = 0, h = [], b = 0, C = 0, k = null;
        for (let A = 0; A < a.length; A++) {
            const y = a.charAt(A);
            switch (c) {
                case 0:
                    if (y === "[") h.push(c), c = 1, b++; else if (y === "(") h.push(c), c = 2, C++; else if (!(A === 0 ? q6 : W6).test(y)) return !1;
                    break;
                case 1:
                    y === "'" || y === '"' || y === "`" ? (h.push(c), c = 3, k = y) : y === "[" ? b++ : y === "]" && (--b || (c = h.pop()));
                    break;
                case 2:
                    if (y === "'" || y === '"' || y === "`") h.push(c), c = 3, k = y; else if (y === "(") C++; else if (y === ")") {
                        if (A === a.length - 1) return !1;
                        --C || (c = h.pop())
                    }
                    break;
                case 3:
                    y === k && (c = h.pop(), k = null);
                    break
            }
        }
        return !b && !C
    }, KE = G6;

function ZE(a, c, h) {
    const C = {source: a.source.slice(c, c + h), start: Hp(a.start, a.source, c), end: a.end};
    return h != null && (C.end = Hp(a.start, a.source, c + h)), C
}

function Hp(a, c, h = c.length) {
    return Up(nn({}, a), c, h)
}

function Up(a, c, h = c.length) {
    let b = 0, C = -1;
    for (let k = 0; k < h; k++) c.charCodeAt(k) === 10 && (b++, C = k);
    return a.offset += h, a.line += b, a.column = C === -1 ? a.column + h : h - C, a
}

function no(a, c, h = !1) {
    for (let b = 0; b < a.props.length; b++) {
        const C = a.props[b];
        if (C.type === 7 && (h || C.exp) && (Pt(c) ? C.name === c : c.test(C.name))) return C
    }
}

function Am(a, c, h = !1, b = !1) {
    for (let C = 0; C < a.props.length; C++) {
        const k = a.props[C];
        if (k.type === 6) {
            if (h) continue;
            if (k.name === c && (k.value || b)) return k
        } else if (k.name === "bind" && (k.exp || b) && rc(k.arg, c)) return k
    }
}

function rc(a, c) {
    return !!(a && pi(a) && a.content === c)
}

function K6(a) {
    return a.props.some(c => c.type === 7 && c.name === "bind" && (!c.arg || c.arg.type !== 4 || !c.arg.isStatic))
}

function Ek(a) {
    return a.type === 5 || a.type === 2
}

function Z6(a) {
    return a.type === 7 && a.name === "slot"
}

function qp(a) {
    return a.type === 1 && a.tagType === 3
}

function Wp(a) {
    return a.type === 1 && a.tagType === 2
}

const Y6 = new Set([Vh, tf]);

function YE(a, c = []) {
    if (a && !Pt(a) && a.type === 14) {
        const h = a.callee;
        if (!Pt(h) && Y6.has(h)) return YE(a.arguments[0], c.concat(a))
    }
    return [a, c]
}

function $p(a, c, h) {
    let b, C = a.type === 13 ? a.props : a.arguments[2], k = [], A;
    if (C && !Pt(C) && C.type === 14) {
        const y = YE(C);
        C = y[0], k = y[1], A = k[k.length - 1]
    }
    if (C == null || Pt(C)) b = ro([c]); else if (C.type === 14) {
        const y = C.arguments[0];
        !Pt(y) && y.type === 15 ? oD(c, y) || y.properties.unshift(c) : C.callee === hv ? b = fr(h.helper(jp), [ro([c]), C]) : C.arguments.unshift(ro([c])), !b && (b = C)
    } else C.type === 15 ? (oD(c, C) || C.properties.unshift(c), b = C) : (b = fr(h.helper(jp), [ro([c]), C]), A && A.callee === tf && (A = k[k.length - 2]));
    a.type === 13 ? A ? A.arguments[0] = b : a.props = b : A ? A.arguments[0] = b : a.arguments[2] = b
}

function oD(a, c) {
    let h = !1;
    if (a.key.type === 4) {
        const b = a.key.content;
        h = c.properties.some(C => C.key.type === 4 && C.key.content === b)
    }
    return h
}

function Uh(a, c) {
    return `_${c}_${a.replace(/[^\w]/g, (h, b) => h === "-" ? "_" : a.charCodeAt(b).toString())}`
}

function Q6(a) {
    return a.type === 14 && a.callee === gv ? a.arguments[1].returns : a
}

const J6 = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;

function sD(a, c) {
    const h = c.options ? c.options.compatConfig : c.compatConfig, b = h && h[a];
    return a === "MODE" ? b || 3 : b
}

function lc(a, c) {
    const h = sD("MODE", c), b = sD(a, c);
    return h === 3 ? b === !0 : b !== !1
}

function qh(a, c, h, ...b) {
    return lc(a, c)
}

const X6 = /&(gt|lt|amp|apos|quot);/g, eO = {gt: ">", lt: "<", amp: "&", apos: "'", quot: '"'}, aD = {
    delimiters: ["{{", "}}"],
    getNamespace: () => 0,
    getTextMode: () => 0,
    isVoidTag: Ap,
    isPreTag: Ap,
    isCustomElement: Ap,
    decodeEntities: a => a.replace(X6, (c, h) => eO[h]),
    onError: ev,
    onWarn: zE,
    comments: !1
};

function tO(a, c = {}) {
    const h = nO(a, c), b = Pi(h);
    return j6(bv(h, 0, []), lo(h, b))
}

function nO(a, c) {
    const h = nn({}, aD);
    let b;
    for (b in c) h[b] = c[b] === void 0 ? aD[b] : c[b];
    return {
        options: h,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: a,
        source: a,
        inPre: !1,
        inVPre: !1,
        onWarn: h.onWarn
    }
}

function bv(a, c, h) {
    const b = Cm(h), C = b ? b.ns : 0, k = [];
    for (; !dO(a, c, h);) {
        const y = a.source;
        let w;
        if (c === 0 || c === 1) {
            if (!a.inVPre && $r(y, a.options.delimiters[0])) w = cO(a, c); else if (c === 0 && y[0] === "<") if (y.length === 1) kn(a, 5, 1); else if (y[1] === "!") $r(y, "<!--") ? w = iO(a) : $r(y, "<!DOCTYPE") ? w = Ah(a) : $r(y, "<![CDATA[") ? C !== 0 ? w = rO(a, h) : (kn(a, 1), w = Ah(a)) : (kn(a, 11), w = Ah(a)); else if (y[1] === "/") if (y.length === 2) kn(a, 5, 2); else if (y[2] === ">") {
                kn(a, 14, 2), Ar(a, 3);
                continue
            } else if (/[a-z]/i.test(y[2])) {
                kn(a, 23), Qk(a, 1, b);
                continue
            } else kn(a, 12, 2), w = Ah(a); else /[a-z]/i.test(y[1]) ? (w = oO(a, h), lc("COMPILER_NATIVE_TEMPLATE", a) && w && w.tag === "template" && !w.props.some(S => S.type === 7 && QE(S.name)) && (w = w.children)) : y[1] === "?" ? (kn(a, 21, 1), w = Ah(a)) : kn(a, 12, 1)
        }
        if (w || (w = uO(a, c)), ut(w)) for (let S = 0; S < w.length; S++) lD(k, w[S]); else lD(k, w)
    }
    let A = !1;
    if (c !== 2 && c !== 1) {
        const y = a.options.whitespace !== "preserve";
        for (let w = 0; w < k.length; w++) {
            const S = k[w];
            if (S.type === 2) if (a.inPre) S.content = S.content.replace(/\r\n/g, `
`); else if (/[^\t\r\n\f ]/.test(S.content)) y && (S.content = S.content.replace(/[\t\r\n\f ]+/g, " ")); else {
                const I = k[w - 1], T = k[w + 1];
                !I || !T || y && (I.type === 3 && T.type === 3 || I.type === 3 && T.type === 1 || I.type === 1 && T.type === 3 || I.type === 1 && T.type === 1 && /[\r\n]/.test(S.content)) ? (A = !0, k[w] = null) : S.content = " "
            } else S.type === 3 && !a.options.comments && (A = !0, k[w] = null)
        }
        if (a.inPre && b && a.options.isPreTag(b.tag)) {
            const w = k[0];
            w && w.type === 2 && (w.content = w.content.replace(/^\r?\n/, ""))
        }
    }
    return A ? k.filter(Boolean) : k
}

function lD(a, c) {
    if (c.type === 2) {
        const h = Cm(a);
        if (h && h.type === 2 && h.loc.end.offset === c.loc.start.offset) {
            h.content += c.content, h.loc.end = c.loc.end, h.loc.source += c.loc.source;
            return
        }
    }
    a.push(c)
}

function rO(a, c) {
    Ar(a, 9);
    const h = bv(a, 3, c);
    return a.source.length === 0 ? kn(a, 6) : Ar(a, 3), h
}

function iO(a) {
    const c = Pi(a);
    let h;
    const b = /--(\!)?>/.exec(a.source);
    if (!b) h = a.source.slice(4), Ar(a, a.source.length), kn(a, 7); else {
        b.index <= 3 && kn(a, 0), b[1] && kn(a, 10), h = a.source.slice(4, b.index);
        const C = a.source.slice(0, b.index);
        let k = 1, A = 0;
        for (; (A = C.indexOf("<!--", k)) !== -1;) Ar(a, A - k + 1), A + 4 < C.length && kn(a, 16), k = A + 1;
        Ar(a, b.index + b[0].length - k + 1)
    }
    return {type: 3, content: h, loc: lo(a, c)}
}

function Ah(a) {
    const c = Pi(a), h = a.source[1] === "?" ? 1 : 2;
    let b;
    const C = a.source.indexOf(">");
    return C === -1 ? (b = a.source.slice(h), Ar(a, a.source.length)) : (b = a.source.slice(h, C), Ar(a, C + 1)), {
        type: 3,
        content: b,
        loc: lo(a, c)
    }
}

function oO(a, c) {
    const h = a.inPre, b = a.inVPre, C = Cm(c), k = Qk(a, 0, C), A = a.inPre && !h, y = a.inVPre && !b;
    if (k.isSelfClosing || a.options.isVoidTag(k.tag)) return A && (a.inPre = !1), y && (a.inVPre = !1), k;
    c.push(k);
    const w = a.options.getTextMode(k, C), S = bv(a, w, c);
    c.pop();
    {
        const I = k.props.find(T => T.type === 6 && T.name === "inline-template");
        if (I && qh("COMPILER_INLINE_TEMPLATE", a, I.loc)) {
            const T = lo(a, k.loc.end);
            I.value = {type: 2, content: T.source, loc: T}
        }
    }
    if (k.children = S, Jk(a.source, k.tag)) Qk(a, 1, C); else if (kn(a, 24, 0, k.loc.start), a.source.length === 0 && k.tag.toLowerCase() === "script") {
        const I = S[0];
        I && $r(I.loc.source, "<!--") && kn(a, 8)
    }
    return k.loc = lo(a, k.loc.start), A && (a.inPre = !1), y && (a.inVPre = !1), k
}

const QE = vi("if,else,else-if,for,slot");

function Qk(a, c, h) {
    const b = Pi(a), C = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(a.source), k = C[1], A = a.options.getNamespace(k, h);
    Ar(a, C[0].length), Wh(a);
    const y = Pi(a), w = a.source;
    a.options.isPreTag(k) && (a.inPre = !0);
    let S = cD(a, c);
    c === 0 && !a.inVPre && S.some(D => D.type === 7 && D.name === "pre") && (a.inVPre = !0, nn(a, y), a.source = w, S = cD(a, c).filter(D => D.name !== "v-pre"));
    let I = !1;
    if (a.source.length === 0 ? kn(a, 9) : (I = $r(a.source, "/>"), c === 1 && I && kn(a, 4), Ar(a, I ? 2 : 1)), c === 1) return;
    let T = 0;
    return a.inVPre || (k === "slot" ? T = 2 : k === "template" ? S.some(D => D.type === 7 && QE(D.name)) && (T = 3) : sO(k, S, a) && (T = 1)), {
        type: 1,
        ns: A,
        tag: k,
        tagType: T,
        props: S,
        isSelfClosing: I,
        children: [],
        loc: lo(a, b),
        codegenNode: void 0
    }
}

function sO(a, c, h) {
    const b = h.options;
    if (b.isCustomElement(a)) return !1;
    if (a === "component" || /^[A-Z]/.test(a) || GE(a) || b.isBuiltInComponent && b.isBuiltInComponent(a) || b.isNativeTag && !b.isNativeTag(a)) return !0;
    for (let C = 0; C < c.length; C++) {
        const k = c[C];
        if (k.type === 6) {
            if (k.name === "is" && k.value) {
                if (k.value.content.startsWith("vue:")) return !0;
                if (qh("COMPILER_IS_ON_ELEMENT", h, k.loc)) return !0
            }
        } else {
            if (k.name === "is") return !0;
            if (k.name === "bind" && rc(k.arg, "is") && qh("COMPILER_IS_ON_ELEMENT", h, k.loc)) return !0
        }
    }
}

function cD(a, c) {
    const h = [], b = new Set;
    for (; a.source.length > 0 && !$r(a.source, ">") && !$r(a.source, "/>");) {
        if ($r(a.source, "/")) {
            kn(a, 22), Ar(a, 1), Wh(a);
            continue
        }
        c === 1 && kn(a, 3);
        const C = aO(a, b);
        C.type === 6 && C.value && C.name === "class" && (C.value.content = C.value.content.replace(/\s+/g, " ").trim()), c === 0 && h.push(C), /^[^\t\r\n\f />]/.test(a.source) && kn(a, 15), Wh(a)
    }
    return h
}

function aO(a, c) {
    var h;
    const b = Pi(a), k = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(a.source)[0];
    c.has(k) && kn(a, 2), c.add(k), k[0] === "=" && kn(a, 19);
    {
        const w = /["'<]/g;
        let S;
        for (; S = w.exec(k);) kn(a, 17, S.index)
    }
    Ar(a, k.length);
    let A;
    /^[\t\r\n\f ]*=/.test(a.source) && (Wh(a), Ar(a, 1), Wh(a), A = lO(a), A || kn(a, 13));
    const y = lo(a, b);
    if (!a.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(k)) {
        const w = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(k);
        let S = $r(k, "."), I = w[1] || (S || $r(k, ":") ? "bind" : $r(k, "@") ? "on" : "slot"), T;
        if (w[2]) {
            const B = I === "slot", L = k.lastIndexOf(w[2], k.length - (((h = w[3]) == null ? void 0 : h.length) || 0)),
                z = lo(a, uD(a, b, L), uD(a, b, L + w[2].length + (B && w[3] || "").length));
            let q = w[2], Q = !0;
            q.startsWith("[") ? (Q = !1, q.endsWith("]") ? q = q.slice(1, q.length - 1) : (kn(a, 27), q = q.slice(1))) : B && (q += w[3] || ""), T = {
                type: 4,
                content: q,
                isStatic: Q,
                constType: Q ? 3 : 0,
                loc: z
            }
        }
        if (A && A.isQuoted) {
            const B = A.loc;
            B.start.offset++, B.start.column++, B.end = Hp(B.start, A.content), B.source = B.source.slice(1, -1)
        }
        const D = w[3] ? w[3].slice(1).split(".") : [];
        return S && D.push("prop"), I === "bind" && T && D.includes("sync") && qh("COMPILER_V_BIND_SYNC", a, y, T.loc.source) && (I = "model", D.splice(D.indexOf("sync"), 1)), {
            type: 7,
            name: I,
            exp: A && {type: 4, content: A.content, isStatic: !1, constType: 0, loc: A.loc},
            arg: T,
            modifiers: D,
            loc: y
        }
    }
    return !a.inVPre && $r(k, "v-") && kn(a, 26), {
        type: 6,
        name: k,
        value: A && {type: 2, content: A.content, loc: A.loc},
        loc: y
    }
}

function lO(a) {
    const c = Pi(a);
    let h;
    const b = a.source[0], C = b === '"' || b === "'";
    if (C) {
        Ar(a, 1);
        const k = a.source.indexOf(b);
        k === -1 ? h = Ih(a, a.source.length, 4) : (h = Ih(a, k, 4), Ar(a, 1))
    } else {
        const k = /^[^\t\r\n\f >]+/.exec(a.source);
        if (!k) return;
        const A = /["'<=`]/g;
        let y;
        for (; y = A.exec(k[0]);) kn(a, 18, y.index);
        h = Ih(a, k[0].length, 4)
    }
    return {content: h, isQuoted: C, loc: lo(a, c)}
}

function cO(a, c) {
    const [h, b] = a.options.delimiters, C = a.source.indexOf(b, h.length);
    if (C === -1) {
        kn(a, 25);
        return
    }
    const k = Pi(a);
    Ar(a, h.length);
    const A = Pi(a), y = Pi(a), w = C - h.length, S = a.source.slice(0, w), I = Ih(a, w, c), T = I.trim(),
        D = I.indexOf(T);
    D > 0 && Up(A, S, D);
    const B = w - (I.length - T.length - D);
    return Up(y, S, B), Ar(a, b.length), {
        type: 5,
        content: {type: 4, isStatic: !1, constType: 0, content: T, loc: lo(a, A, y)},
        loc: lo(a, k)
    }
}

function uO(a, c) {
    const h = c === 3 ? ["]]>"] : ["<", a.options.delimiters[0]];
    let b = a.source.length;
    for (let A = 0; A < h.length; A++) {
        const y = a.source.indexOf(h[A], 1);
        y !== -1 && b > y && (b = y)
    }
    const C = Pi(a);
    return {type: 2, content: Ih(a, b, c), loc: lo(a, C)}
}

function Ih(a, c, h) {
    const b = a.source.slice(0, c);
    return Ar(a, c), h === 2 || h === 3 || !b.includes("&") ? b : a.options.decodeEntities(b, h === 4)
}

function Pi(a) {
    const {column: c, line: h, offset: b} = a;
    return {column: c, line: h, offset: b}
}

function lo(a, c, h) {
    return h = h || Pi(a), {start: c, end: h, source: a.originalSource.slice(c.offset, h.offset)}
}

function Cm(a) {
    return a[a.length - 1]
}

function $r(a, c) {
    return a.startsWith(c)
}

function Ar(a, c) {
    const {source: h} = a;
    Up(a, h, c), a.source = h.slice(c)
}

function Wh(a) {
    const c = /^[\t\r\n\f ]+/.exec(a.source);
    c && Ar(a, c[0].length)
}

function uD(a, c, h) {
    return Hp(c, a.originalSource.slice(c.offset, h), h)
}

function kn(a, c, h, b = Pi(a)) {
    h && (b.offset += h, b.column += h), a.options.onError(Pn(c, {start: b, end: b, source: ""}))
}

function dO(a, c, h) {
    const b = a.source;
    switch (c) {
        case 0:
            if ($r(b, "</")) {
                for (let C = h.length - 1; C >= 0; --C) if (Jk(b, h[C].tag)) return !0
            }
            break;
        case 1:
        case 2: {
            const C = Cm(h);
            if (C && Jk(b, C.tag)) return !0;
            break
        }
        case 3:
            if ($r(b, "]]>")) return !0;
            break
    }
    return !b
}

function Jk(a, c) {
    return $r(a, "</") && a.slice(2, 2 + c.length).toLowerCase() === c.toLowerCase() && /[\t\r\n\f />]/.test(a[2 + c.length] || ">")
}

function hO(a, c) {
    yp(a, c, JE(a, a.children[0]))
}

function JE(a, c) {
    const {children: h} = a;
    return h.length === 1 && c.type === 1 && !Wp(c)
}

function yp(a, c, h = !1) {
    const {children: b} = a, C = b.length;
    let k = 0;
    for (let A = 0; A < b.length; A++) {
        const y = b[A];
        if (y.type === 1 && y.tagType === 0) {
            const w = h ? 0 : io(y, c);
            if (w > 0) {
                if (w >= 2) {
                    y.codegenNode.patchFlag = "-1", y.codegenNode = c.hoist(y.codegenNode), k++;
                    continue
                }
            } else {
                const S = y.codegenNode;
                if (S.type === 13) {
                    const I = n5(S);
                    if ((!I || I === 512 || I === 1) && e5(y, c) >= 2) {
                        const T = t5(y);
                        T && (S.props = c.hoist(T))
                    }
                    S.dynamicProps && (S.dynamicProps = c.hoist(S.dynamicProps))
                }
            }
        }
        if (y.type === 1) {
            const w = y.tagType === 1;
            w && c.scopes.vSlot++, yp(y, c), w && c.scopes.vSlot--
        } else if (y.type === 11) yp(y, c, y.children.length === 1); else if (y.type === 9) for (let w = 0; w < y.branches.length; w++) yp(y.branches[w], c, y.branches[w].children.length === 1)
    }
    if (k && c.transformHoist && c.transformHoist(b, c, a), k && k === C && a.type === 1 && a.tagType === 0 && a.codegenNode && a.codegenNode.type === 13 && ut(a.codegenNode.children)) {
        const A = c.hoist(nf(a.codegenNode.children));
        c.hmr && (A.content = `[...${A.content}]`), a.codegenNode.children = A
    }
}

function io(a, c) {
    const {constantCache: h} = c;
    switch (a.type) {
        case 1:
            if (a.tagType !== 0) return 0;
            const b = h.get(a);
            if (b !== void 0) return b;
            const C = a.codegenNode;
            if (C.type !== 13 || C.isBlock && a.tag !== "svg" && a.tag !== "foreignObject") return 0;
            if (n5(C)) return h.set(a, 0), 0;
        {
            let y = 3;
            const w = e5(a, c);
            if (w === 0) return h.set(a, 0), 0;
            w < y && (y = w);
            for (let S = 0; S < a.children.length; S++) {
                const I = io(a.children[S], c);
                if (I === 0) return h.set(a, 0), 0;
                I < y && (y = I)
            }
            if (y > 1) for (let S = 0; S < a.props.length; S++) {
                const I = a.props[S];
                if (I.type === 7 && I.name === "bind" && I.exp) {
                    const T = io(I.exp, c);
                    if (T === 0) return h.set(a, 0), 0;
                    T < y && (y = T)
                }
            }
            if (C.isBlock) {
                for (let S = 0; S < a.props.length; S++) if (a.props[S].type === 7) return h.set(a, 0), 0;
                c.removeHelper(gc), c.removeHelper(Hu(c.inSSR, C.isComponent)), C.isBlock = !1, c.helper(Vu(c.inSSR, C.isComponent))
            }
            return h.set(a, y), y
        }
        case 2:
        case 3:
            return 3;
        case 9:
        case 11:
        case 10:
            return 0;
        case 5:
        case 12:
            return io(a.content, c);
        case 4:
            return a.constType;
        case 8:
            let A = 3;
            for (let y = 0; y < a.children.length; y++) {
                const w = a.children[y];
                if (Pt(w) || Eo(w)) continue;
                const S = io(w, c);
                if (S === 0) return 0;
                S < A && (A = S)
            }
            return A;
        default:
            return 0
    }
}

const fO = new Set([uv, dv, Vh, tf]);

function XE(a, c) {
    if (a.type === 14 && !Pt(a.callee) && fO.has(a.callee)) {
        const h = a.arguments[0];
        if (h.type === 4) return io(h, c);
        if (h.type === 14) return XE(h, c)
    }
    return 0
}

function e5(a, c) {
    let h = 3;
    const b = t5(a);
    if (b && b.type === 15) {
        const {properties: C} = b;
        for (let k = 0; k < C.length; k++) {
            const {key: A, value: y} = C[k], w = io(A, c);
            if (w === 0) return w;
            w < h && (h = w);
            let S;
            if (y.type === 4 ? S = io(y, c) : y.type === 14 ? S = XE(y, c) : S = 0, S === 0) return S;
            S < h && (h = S)
        }
    }
    return h
}

function t5(a) {
    const c = a.codegenNode;
    if (c.type === 13) return c.props
}

function n5(a) {
    const c = a.patchFlag;
    return c ? parseInt(c, 10) : void 0
}

function gO(a, {
    filename: c = "",
    prefixIdentifiers: h = !1,
    hoistStatic: b = !1,
    hmr: C = !1,
    cacheHandlers: k = !1,
    nodeTransforms: A = [],
    directiveTransforms: y = {},
    transformHoist: w = null,
    isBuiltInComponent: S = mi,
    isCustomElement: I = mi,
    expressionPlugins: T = [],
    scopeId: D = null,
    slotted: B = !0,
    ssr: L = !1,
    inSSR: z = !1,
    ssrCssVars: q = "",
    bindingMetadata: Q = an,
    inline: G = !1,
    isTS: Z = !1,
    onError: Y = ev,
    onWarn: ce = zE,
    compatConfig: Ce
}) {
    const me = c.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), R = {
        selfName: me && Xa(sr(me[1])),
        prefixIdentifiers: h,
        hoistStatic: b,
        hmr: C,
        cacheHandlers: k,
        nodeTransforms: A,
        directiveTransforms: y,
        transformHoist: w,
        isBuiltInComponent: S,
        isCustomElement: I,
        expressionPlugins: T,
        scopeId: D,
        slotted: B,
        ssr: L,
        inSSR: z,
        ssrCssVars: q,
        bindingMetadata: Q,
        inline: G,
        isTS: Z,
        onError: Y,
        onWarn: ce,
        compatConfig: Ce,
        root: a,
        helpers: new Map,
        components: new Set,
        directives: new Set,
        hoists: [],
        imports: [],
        constantCache: new WeakMap,
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {vFor: 0, vSlot: 0, vPre: 0, vOnce: 0},
        parent: null,
        currentNode: a,
        childIndex: 0,
        inVOnce: !1,
        helper(ae) {
            const ue = R.helpers.get(ae) || 0;
            return R.helpers.set(ae, ue + 1), ae
        },
        removeHelper(ae) {
            const ue = R.helpers.get(ae);
            if (ue) {
                const ve = ue - 1;
                ve ? R.helpers.set(ae, ve) : R.helpers.delete(ae)
            }
        },
        helperString(ae) {
            return `_${zu[R.helper(ae)]}`
        },
        replaceNode(ae) {
            R.parent.children[R.childIndex] = R.currentNode = ae
        },
        removeNode(ae) {
            const ue = R.parent.children, ve = ae ? ue.indexOf(ae) : R.currentNode ? R.childIndex : -1;
            !ae || ae === R.currentNode ? (R.currentNode = null, R.onNodeRemoved()) : R.childIndex > ve && (R.childIndex--, R.onNodeRemoved()), R.parent.children.splice(ve, 1)
        },
        onNodeRemoved: () => {
        },
        addIdentifiers(ae) {
        },
        removeIdentifiers(ae) {
        },
        hoist(ae) {
            Pt(ae) && (ae = jt(ae)), R.hoists.push(ae);
            const ue = jt(`_hoisted_${R.hoists.length}`, !1, ae.loc, 2);
            return ue.hoisted = ae, ue
        },
        cache(ae, ue = !1) {
            return V6(R.cached++, ae, ue)
        }
    };
    return R.filters = new Set, R
}

function pO(a, c) {
    const h = gO(a, c);
    _m(a, h), c.hoistStatic && hO(a, h), c.ssr || mO(a, h), a.helpers = new Set([...h.helpers.keys()]), a.components = [...h.components], a.directives = [...h.directives], a.imports = h.imports, a.hoists = h.hoists, a.temps = h.temps, a.cached = h.cached, a.filters = [...h.filters]
}

function mO(a, c) {
    const {helper: h} = c, {children: b} = a;
    if (b.length === 1) {
        const C = b[0];
        if (JE(a, C) && C.codegenNode) {
            const k = C.codegenNode;
            k.type === 13 && pv(k, c), a.codegenNode = k
        } else a.codegenNode = C
    } else if (b.length > 1) {
        let C = 64;
        a.codegenNode = Hh(c, h(jh), void 0, a.children, C + "", void 0, void 0, !0, void 0, !1)
    }
}

function bO(a, c) {
    let h = 0;
    const b = () => {
        h--
    };
    for (; h < a.children.length; h++) {
        const C = a.children[h];
        Pt(C) || (c.parent = a, c.childIndex = h, c.onNodeRemoved = b, _m(C, c))
    }
}

function _m(a, c) {
    c.currentNode = a;
    const {nodeTransforms: h} = c, b = [];
    for (let k = 0; k < h.length; k++) {
        const A = h[k](a, c);
        if (A && (ut(A) ? b.push(...A) : b.push(A)), c.currentNode) a = c.currentNode; else return
    }
    switch (a.type) {
        case 3:
            c.ssr || c.helper(ef);
            break;
        case 5:
            c.ssr || c.helper(wm);
            break;
        case 9:
            for (let k = 0; k < a.branches.length; k++) _m(a.branches[k], c);
            break;
        case 10:
        case 11:
        case 1:
        case 0:
            bO(a, c);
            break
    }
    c.currentNode = a;
    let C = b.length;
    for (; C--;) b[C]()
}

function r5(a, c) {
    const h = Pt(a) ? b => b === a : b => a.test(b);
    return (b, C) => {
        if (b.type === 1) {
            const {props: k} = b;
            if (b.tagType === 3 && k.some(Z6)) return;
            const A = [];
            for (let y = 0; y < k.length; y++) {
                const w = k[y];
                if (w.type === 7 && h(w.name)) {
                    k.splice(y, 1), y--;
                    const S = c(b, w, C);
                    S && A.push(S)
                }
            }
            return A
        }
    }
}

const ym = "/*#__PURE__*/", i5 = a => `${zu[a]}: _${zu[a]}`;

function dD(a, {
    mode: c = "function",
    prefixIdentifiers: h = c === "module",
    sourceMap: b = !1,
    filename: C = "template.vue.html",
    scopeId: k = null,
    optimizeImports: A = !1,
    runtimeGlobalName: y = "Vue",
    runtimeModuleName: w = "vue",
    ssrRuntimeModuleName: S = "vue/server-renderer",
    ssr: I = !1,
    isTS: T = !1,
    inSSR: D = !1
}) {
    const B = {
        mode: c,
        prefixIdentifiers: h,
        sourceMap: b,
        filename: C,
        scopeId: k,
        optimizeImports: A,
        runtimeGlobalName: y,
        runtimeModuleName: w,
        ssrRuntimeModuleName: S,
        ssr: I,
        isTS: T,
        inSSR: D,
        source: a.loc.source,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: !1,
        map: void 0,
        helper(z) {
            return `_${zu[z]}`
        },
        push(z, q) {
            B.code += z
        },
        indent() {
            L(++B.indentLevel)
        },
        deindent(z = !1) {
            z ? --B.indentLevel : L(--B.indentLevel)
        },
        newline() {
            L(B.indentLevel)
        }
    };

    function L(z) {
        B.push(`
` + "  ".repeat(z))
    }

    return B
}

function kO(a, c = {}) {
    const h = dD(a, c);
    c.onContextCreated && c.onContextCreated(h);
    const {mode: b, push: C, prefixIdentifiers: k, indent: A, deindent: y, newline: w, scopeId: S, ssr: I} = h,
        T = Array.from(a.helpers), D = T.length > 0, B = !k && b !== "module", L = !1, z = L ? dD(a, c) : h;
    vO(a, z);
    const q = I ? "ssrRender" : "render",
        G = (I ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ");
    if (C(`function ${q}(${G}) {`), A(), B && (C("with (_ctx) {"), A(), D && (C(`const { ${T.map(i5).join(", ")} } = _Vue`), C(`
`), w())), a.components.length && (Sk(a.components, "component", h), (a.directives.length || a.temps > 0) && w()), a.directives.length && (Sk(a.directives, "directive", h), a.temps > 0 && w()), a.filters && a.filters.length && (w(), Sk(a.filters, "filter", h), w()), a.temps > 0) {
        C("let ");
        for (let Z = 0; Z < a.temps; Z++) C(`${Z > 0 ? ", " : ""}_temp${Z}`)
    }
    return (a.components.length || a.directives.length || a.temps) && (C(`
`), w()), I || C("return "), a.codegenNode ? Gr(a.codegenNode, h) : C("null"), B && (y(), C("}")), y(), C("}"), {
        ast: a,
        code: h.code,
        preamble: L ? z.code : "",
        map: h.map ? h.map.toJSON() : void 0
    }
}

function vO(a, c) {
    const {
        ssr: h,
        prefixIdentifiers: b,
        push: C,
        newline: k,
        runtimeModuleName: A,
        runtimeGlobalName: y,
        ssrRuntimeModuleName: w
    } = c, S = y, I = Array.from(a.helpers);
    if (I.length > 0 && (C(`const _Vue = ${S}
`), a.hoists.length)) {
        const T = [nv, rv, ef, iv, UE].filter(D => I.includes(D)).map(i5).join(", ");
        C(`const { ${T} } = _Vue
`)
    }
    wO(a.hoists, c), k(), C("return ")
}

function Sk(a, c, {helper: h, push: b, newline: C, isTS: k}) {
    const A = h(c === "filter" ? av : c === "component" ? ov : sv);
    for (let y = 0; y < a.length; y++) {
        let w = a[y];
        const S = w.endsWith("__self");
        S && (w = w.slice(0, -6)), b(`const ${Uh(w, c)} = ${A}(${JSON.stringify(w)}${S ? ", true" : ""})${k ? "!" : ""}`), y < a.length - 1 && C()
    }
}

function wO(a, c) {
    if (!a.length) return;
    c.pure = !0;
    const {push: h, newline: b, helper: C, scopeId: k, mode: A} = c;
    b();
    for (let y = 0; y < a.length; y++) {
        const w = a[y];
        w && (h(`const _hoisted_${y + 1} = `), Gr(w, c), b())
    }
    c.pure = !1
}

function kv(a, c) {
    const h = a.length > 3 || !1;
    c.push("["), h && c.indent(), rf(a, c, h), h && c.deindent(), c.push("]")
}

function rf(a, c, h = !1, b = !0) {
    const {push: C, newline: k} = c;
    for (let A = 0; A < a.length; A++) {
        const y = a[A];
        Pt(y) ? C(y) : ut(y) ? kv(y, c) : Gr(y, c), A < a.length - 1 && (h ? (b && C(","), k()) : b && C(", "))
    }
}

function Gr(a, c) {
    if (Pt(a)) {
        c.push(a);
        return
    }
    if (Eo(a)) {
        c.push(c.helper(a));
        return
    }
    switch (a.type) {
        case 1:
        case 9:
        case 11:
            Gr(a.codegenNode, c);
            break;
        case 2:
            AO(a, c);
            break;
        case 4:
            o5(a, c);
            break;
        case 5:
            CO(a, c);
            break;
        case 12:
            Gr(a.codegenNode, c);
            break;
        case 8:
            s5(a, c);
            break;
        case 3:
            yO(a, c);
            break;
        case 13:
            DO(a, c);
            break;
        case 14:
            EO(a, c);
            break;
        case 15:
            SO(a, c);
            break;
        case 17:
            TO(a, c);
            break;
        case 18:
            IO(a, c);
            break;
        case 19:
            MO(a, c);
            break;
        case 20:
            BO(a, c);
            break;
        case 21:
            rf(a.body, c, !0, !1);
            break
    }
}

function AO(a, c) {
    c.push(JSON.stringify(a.content), a)
}

function o5(a, c) {
    const {content: h, isStatic: b} = a;
    c.push(b ? JSON.stringify(h) : h, a)
}

function CO(a, c) {
    const {push: h, helper: b, pure: C} = c;
    C && h(ym), h(`${b(wm)}(`), Gr(a.content, c), h(")")
}

function s5(a, c) {
    for (let h = 0; h < a.children.length; h++) {
        const b = a.children[h];
        Pt(b) ? c.push(b) : Gr(b, c)
    }
}

function _O(a, c) {
    const {push: h} = c;
    if (a.type === 8) h("["), s5(a, c), h("]"); else if (a.isStatic) {
        const b = mv(a.content) ? a.content : JSON.stringify(a.content);
        h(b, a)
    } else h(`[${a.content}]`, a)
}

function yO(a, c) {
    const {push: h, helper: b, pure: C} = c;
    C && h(ym), h(`${b(ef)}(${JSON.stringify(a.content)})`, a)
}

function DO(a, c) {
    const {push: h, helper: b, pure: C} = c, {
        tag: k,
        props: A,
        children: y,
        patchFlag: w,
        dynamicProps: S,
        directives: I,
        isBlock: T,
        disableTracking: D,
        isComponent: B
    } = a;
    I && h(b(lv) + "("), T && h(`(${b(gc)}(${D ? "true" : ""}), `), C && h(ym);
    const L = T ? Hu(c.inSSR, B) : Vu(c.inSSR, B);
    h(b(L) + "(", a), rf(xO([k, A, y, w, S]), c), h(")"), T && h(")"), I && (h(", "), Gr(I, c), h(")"))
}

function xO(a) {
    let c = a.length;
    for (; c-- && a[c] == null;) ;
    return a.slice(0, c + 1).map(h => h || "null")
}

function EO(a, c) {
    const {push: h, helper: b, pure: C} = c, k = Pt(a.callee) ? a.callee : b(a.callee);
    C && h(ym), h(k + "(", a), rf(a.arguments, c), h(")")
}

function SO(a, c) {
    const {push: h, indent: b, deindent: C, newline: k} = c, {properties: A} = a;
    if (!A.length) {
        h("{}", a);
        return
    }
    const y = A.length > 1 || !1;
    h(y ? "{" : "{ "), y && b();
    for (let w = 0; w < A.length; w++) {
        const {key: S, value: I} = A[w];
        _O(S, c), h(": "), Gr(I, c), w < A.length - 1 && (h(","), k())
    }
    y && C(), h(y ? "}" : " }")
}

function TO(a, c) {
    kv(a.elements, c)
}

function IO(a, c) {
    const {push: h, indent: b, deindent: C} = c, {params: k, returns: A, body: y, newline: w, isSlot: S} = a;
    S && h(`_${zu[fv]}(`), h("(", a), ut(k) ? rf(k, c) : k && Gr(k, c), h(") => "), (w || y) && (h("{"), b()), A ? (w && h("return "), ut(A) ? kv(A, c) : Gr(A, c)) : y && Gr(y, c), (w || y) && (C(), h("}")), S && (a.isNonScopedSlot && h(", undefined, true"), h(")"))
}

function MO(a, c) {
    const {test: h, consequent: b, alternate: C, newline: k} = a, {push: A, indent: y, deindent: w, newline: S} = c;
    if (h.type === 4) {
        const T = !mv(h.content);
        T && A("("), o5(h, c), T && A(")")
    } else A("("), Gr(h, c), A(")");
    k && y(), c.indentLevel++, k || A(" "), A("? "), Gr(b, c), c.indentLevel--, k && S(), k || A(" "), A(": ");
    const I = C.type === 19;
    I || c.indentLevel++, Gr(C, c), I || c.indentLevel--, k && w(!0)
}

function BO(a, c) {
    const {push: h, helper: b, indent: C, deindent: k, newline: A} = c;
    h(`_cache[${a.index}] || (`), a.isVNode && (C(), h(`${b(Vp)}(-1),`), A()), h(`_cache[${a.index}] = `), Gr(a.value, c), a.isVNode && (h(","), A(), h(`${b(Vp)}(1),`), A(), h(`_cache[${a.index}]`), k()), h(")")
}

new RegExp("\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b");
const NO = r5(/^(if|else|else-if)$/, (a, c, h) => LO(a, c, h, (b, C, k) => {
    const A = h.parent.children;
    let y = A.indexOf(b), w = 0;
    for (; y-- >= 0;) {
        const S = A[y];
        S && S.type === 9 && (w += S.branches.length)
    }
    return () => {
        if (k) b.codegenNode = fD(C, w, h); else {
            const S = PO(b.codegenNode);
            S.alternate = fD(C, w + b.branches.length - 1, h)
        }
    }
}));

function LO(a, c, h, b) {
    if (c.name !== "else" && (!c.exp || !c.exp.content.trim())) {
        const C = c.exp ? c.exp.loc : a.loc;
        h.onError(Pn(28, c.loc)), c.exp = jt("true", !1, C)
    }
    if (c.name === "if") {
        const C = hD(a, c), k = {type: 9, loc: a.loc, branches: [C]};
        if (h.replaceNode(k), b) return b(k, C, !0)
    } else {
        const C = h.parent.children;
        let k = C.indexOf(a);
        for (; k-- >= -1;) {
            const A = C[k];
            if (A && A.type === 3) {
                h.removeNode(A);
                continue
            }
            if (A && A.type === 2 && !A.content.trim().length) {
                h.removeNode(A);
                continue
            }
            if (A && A.type === 9) {
                c.name === "else-if" && A.branches[A.branches.length - 1].condition === void 0 && h.onError(Pn(30, a.loc)), h.removeNode();
                const y = hD(a, c);
                A.branches.push(y);
                const w = b && b(A, y, !1);
                _m(y, h), w && w(), h.currentNode = null
            } else h.onError(Pn(30, a.loc));
            break
        }
    }
}

function hD(a, c) {
    const h = a.tagType === 3;
    return {
        type: 10,
        loc: a.loc,
        condition: c.name === "else" ? void 0 : c.exp,
        children: h && !no(a, "for") ? a.children : [a],
        userKey: Am(a, "key"),
        isTemplateIf: h
    }
}

function fD(a, c, h) {
    return a.condition ? Yk(a.condition, gD(a, c, h), fr(h.helper(ef), ['""', "true"])) : gD(a, c, h)
}

function gD(a, c, h) {
    const {helper: b} = h, C = er("key", jt(`${c}`, !1, Fi, 2)), {children: k} = a, A = k[0];
    if (k.length !== 1 || A.type !== 1) if (k.length === 1 && A.type === 11) {
        const w = A.codegenNode;
        return $p(w, C, h), w
    } else {
        let w = 64;
        return Hh(h, b(jh), ro([C]), k, w + "", void 0, void 0, !0, !1, !1, a.loc)
    } else {
        const w = A.codegenNode, S = Q6(w);
        return S.type === 13 && pv(S, h), $p(S, C, h), w
    }
}

function PO(a) {
    for (; ;) if (a.type === 19) if (a.alternate.type === 19) a = a.alternate; else return a; else a.type === 20 && (a = a.value)
}

const OO = r5("for", (a, c, h) => {
    const {helper: b, removeHelper: C} = h;
    return FO(a, c, h, k => {
        const A = fr(b(cv), [k.source]), y = qp(a), w = no(a, "memo"), S = Am(a, "key"),
            I = S && (S.type === 6 ? jt(S.value.content, !0) : S.exp), T = S ? er("key", I) : null,
            D = k.source.type === 4 && k.source.constType > 0, B = D ? 64 : S ? 128 : 256;
        return k.codegenNode = Hh(h, b(jh), void 0, A, B + "", void 0, void 0, !0, !D, !1, a.loc), () => {
            let L;
            const {children: z} = k, q = z.length !== 1 || z[0].type !== 1,
                Q = Wp(a) ? a : y && a.children.length === 1 && Wp(a.children[0]) ? a.children[0] : null;
            if (Q ? (L = Q.codegenNode, y && T && $p(L, T, h)) : q ? L = Hh(h, b(jh), T ? ro([T]) : void 0, a.children, "64", void 0, void 0, !0, void 0, !1) : (L = z[0].codegenNode, y && T && $p(L, T, h), L.isBlock !== !D && (L.isBlock ? (C(gc), C(Hu(h.inSSR, L.isComponent))) : C(Vu(h.inSSR, L.isComponent))), L.isBlock = !D, L.isBlock ? (b(gc), b(Hu(h.inSSR, L.isComponent))) : b(Vu(h.inSSR, L.isComponent))), w) {
                const G = ju(Xk(k.parseResult, [jt("_cached")]));
                G.body = H6([xo(["const _memo = (", w.exp, ")"]), xo(["if (_cached", ...I ? [" && _cached.key === ", I] : [], ` && ${h.helperString($E)}(_cached, _memo)) return _cached`]), xo(["const _item = ", L]), jt("_item.memo = _memo"), jt("return _item")]), A.arguments.push(G, jt("_cache"), jt(String(h.cached++)))
            } else A.arguments.push(ju(Xk(k.parseResult), L, !0))
        }
    })
});

function FO(a, c, h, b) {
    if (!c.exp) {
        h.onError(Pn(31, c.loc));
        return
    }
    const C = a5(c.exp);
    if (!C) {
        h.onError(Pn(32, c.loc));
        return
    }
    const {addIdentifiers: k, removeIdentifiers: A, scopes: y} = h, {source: w, value: S, key: I, index: T} = C, D = {
        type: 11,
        loc: c.loc,
        source: w,
        valueAlias: S,
        keyAlias: I,
        objectIndexAlias: T,
        parseResult: C,
        children: qp(a) ? a.children : [a]
    };
    h.replaceNode(D), y.vFor++;
    const B = b && b(D);
    return () => {
        y.vFor--, B && B()
    }
}

const pD = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, RO = /^\(|\)$/g;

function a5(a, c) {
    const h = a.loc, b = a.content, C = b.match(J6);
    if (!C) return;
    const [, k, A] = C,
        y = {source: bp(h, A.trim(), b.indexOf(A, k.length)), value: void 0, key: void 0, index: void 0};
    let w = k.trim().replace(RO, "").trim();
    const S = k.indexOf(w), I = w.match(pD);
    if (I) {
        w = w.replace(pD, "").trim();
        const T = I[1].trim();
        let D;
        if (T && (D = b.indexOf(T, S + w.length), y.key = bp(h, T, D)), I[2]) {
            const B = I[2].trim();
            B && (y.index = bp(h, B, b.indexOf(B, y.key ? D + T.length : S + w.length)))
        }
    }
    return w && (y.value = bp(h, w, S)), y
}

function bp(a, c, h) {
    return jt(c, !1, ZE(a, h, c.length))
}

function Xk({value: a, key: c, index: h}, b = []) {
    return zO([a, c, h, ...b])
}

function zO(a) {
    let c = a.length;
    for (; c-- && !a[c];) ;
    return a.slice(0, c + 1).map((h, b) => h || jt("_".repeat(b + 1), !1))
}

const mD = jt("undefined", !1), jO = (a, c) => {
    if (a.type === 1 && (a.tagType === 1 || a.tagType === 3)) {
        const h = no(a, "slot");
        if (h) return h.exp, c.scopes.vSlot++, () => {
            c.scopes.vSlot--
        }
    }
}, VO = (a, c, h, b) => ju(a, h, !1, !0, h.length ? h[0].loc : b);

function HO(a, c, h = VO) {
    c.helper(fv);
    const {children: b, loc: C} = a, k = [], A = [];
    let y = c.scopes.vSlot > 0 || c.scopes.vFor > 0;
    const w = no(a, "slot", !0);
    if (w) {
        const {arg: q, exp: Q} = w;
        q && !pi(q) && (y = !0), k.push(er(q || jt("default", !0), h(Q, void 0, b, C)))
    }
    let S = !1, I = !1;
    const T = [], D = new Set;
    let B = 0;
    for (let q = 0; q < b.length; q++) {
        const Q = b[q];
        let G;
        if (!qp(Q) || !(G = no(Q, "slot", !0))) {
            Q.type !== 3 && T.push(Q);
            continue
        }
        if (w) {
            c.onError(Pn(37, G.loc));
            break
        }
        S = !0;
        const {children: Z, loc: Y} = Q, {arg: ce = jt("default", !0), exp: Ce, loc: me} = G;
        let R;
        pi(ce) ? R = ce ? ce.content : "default" : y = !0;
        const ae = no(Q, "for"), ue = h(Ce, ae == null ? void 0 : ae.exp, Z, Y);
        let ve, ke;
        if (ve = no(Q, "if")) y = !0, A.push(Yk(ve.exp, kp(ce, ue, B++), mD)); else if (ke = no(Q, /^else(-if)?$/, !0)) {
            let le = q, ye;
            for (; le-- && (ye = b[le], ye.type === 3);) ;
            if (ye && qp(ye) && no(ye, "if")) {
                b.splice(q, 1), q--;
                let ee = A[A.length - 1];
                for (; ee.alternate.type === 19;) ee = ee.alternate;
                ee.alternate = ke.exp ? Yk(ke.exp, kp(ce, ue, B++), mD) : kp(ce, ue, B++)
            } else c.onError(Pn(30, ke.loc))
        } else if (ae) {
            y = !0;
            const le = ae.parseResult || a5(ae.exp);
            le ? A.push(fr(c.helper(cv), [le.source, ju(Xk(le), kp(ce, ue), !0)])) : c.onError(Pn(32, ae.loc))
        } else {
            if (R) {
                if (D.has(R)) {
                    c.onError(Pn(38, me));
                    continue
                }
                D.add(R), R === "default" && (I = !0)
            }
            k.push(er(ce, ue))
        }
    }
    if (!w) {
        const q = (Q, G) => {
            const Z = h(Q, void 0, G, C);
            return c.compatConfig && (Z.isNonScopedSlot = !0), er("default", Z)
        };
        S ? T.length && T.some(Q => l5(Q)) && (I ? c.onError(Pn(39, T[0].loc)) : k.push(q(void 0, T))) : k.push(q(void 0, b))
    }
    const L = y ? 2 : Dp(a.children) ? 3 : 1;
    let z = ro(k.concat(er("_", jt(L + "", !1))), C);
    return A.length && (z = fr(c.helper(WE), [z, nf(A)])), {slots: z, hasDynamicSlots: y}
}

function kp(a, c, h) {
    const b = [er("name", a), er("fn", c)];
    return h != null && b.push(er("key", jt(String(h), !0))), ro(b)
}

function Dp(a) {
    for (let c = 0; c < a.length; c++) {
        const h = a[c];
        switch (h.type) {
            case 1:
                if (h.tagType === 2 || Dp(h.children)) return !0;
                break;
            case 9:
                if (Dp(h.branches)) return !0;
                break;
            case 10:
            case 11:
                if (Dp(h.children)) return !0;
                break
        }
    }
    return !1
}

function l5(a) {
    return a.type !== 2 && a.type !== 12 ? !0 : a.type === 2 ? !!a.content.trim() : l5(a.content)
}

const c5 = new WeakMap, UO = (a, c) => function () {
    if (a = c.currentNode, !(a.type === 1 && (a.tagType === 0 || a.tagType === 1))) return;
    const {tag: b, props: C} = a, k = a.tagType === 1;
    let A = k ? qO(a, c) : `"${b}"`;
    const y = vn(A) && A.callee === zp;
    let w, S, I, T = 0, D, B, L, z = y || A === Th || A === tv || !k && (b === "svg" || b === "foreignObject");
    if (C.length > 0) {
        const q = u5(a, c, void 0, k, y);
        w = q.props, T = q.patchFlag, B = q.dynamicPropNames;
        const Q = q.directives;
        L = Q && Q.length ? nf(Q.map(G => $O(G, c))) : void 0, q.shouldUseBlock && (z = !0)
    }
    if (a.children.length > 0) if (A === Rp && (z = !0, T |= 1024), k && A !== Th && A !== Rp) {
        const {slots: Q, hasDynamicSlots: G} = HO(a, c);
        S = Q, G && (T |= 1024)
    } else if (a.children.length === 1 && A !== Th) {
        const Q = a.children[0], G = Q.type, Z = G === 5 || G === 8;
        Z && io(Q, c) === 0 && (T |= 1), Z || G === 2 ? S = Q : S = a.children
    } else S = a.children;
    T !== 0 && (I = String(T), B && B.length && (D = GO(B))), a.codegenNode = Hh(c, A, w, S, I, D, L, !!z, !1, k, a.loc)
};

function qO(a, c, h = !1) {
    let {tag: b} = a;
    const C = e0(b), k = Am(a, "is");
    if (k) if (C || lc("COMPILER_IS_ON_ELEMENT", c)) {
        const w = k.type === 6 ? k.value && jt(k.value.content, !0) : k.exp;
        if (w) return fr(c.helper(zp), [w])
    } else k.type === 6 && k.value.content.startsWith("vue:") && (b = k.value.content.slice(4));
    const A = !C && no(a, "is");
    if (A && A.exp) return fr(c.helper(zp), [A.exp]);
    const y = GE(b) || c.isBuiltInComponent(b);
    return y ? (h || c.helper(y), y) : (c.helper(ov), c.components.add(b), Uh(b, "component"))
}

function u5(a, c, h = a.props, b, C, k = !1) {
    const {tag: A, loc: y, children: w} = a;
    let S = [];
    const I = [], T = [], D = w.length > 0;
    let B = !1, L = 0, z = !1, q = !1, Q = !1, G = !1, Z = !1, Y = !1;
    const ce = [], Ce = ae => {
        S.length && (I.push(ro(bD(S), y)), S = []), ae && I.push(ae)
    }, me = ({key: ae, value: ue}) => {
        if (pi(ae)) {
            const ve = ae.content, ke = pc(ve);
            if (ke && (!b || C) && ve.toLowerCase() !== "onclick" && ve !== "onUpdate:modelValue" && !ic(ve) && (G = !0), ke && ic(ve) && (Y = !0), ke && ue.type === 14 && (ue = ue.arguments[0]), ue.type === 20 || (ue.type === 4 || ue.type === 8) && io(ue, c) > 0) return;
            ve === "ref" ? z = !0 : ve === "class" ? q = !0 : ve === "style" ? Q = !0 : ve !== "key" && !ce.includes(ve) && ce.push(ve), b && (ve === "class" || ve === "style") && !ce.includes(ve) && ce.push(ve)
        } else Z = !0
    };
    for (let ae = 0; ae < h.length; ae++) {
        const ue = h[ae];
        if (ue.type === 6) {
            const {loc: ve, name: ke, value: le} = ue;
            let ye = !0;
            if (ke === "ref" && (z = !0, c.scopes.vFor > 0 && S.push(er(jt("ref_for", !0), jt("true")))), ke === "is" && (e0(A) || le && le.content.startsWith("vue:") || lc("COMPILER_IS_ON_ELEMENT", c))) continue;
            S.push(er(jt(ke, !0, ZE(ve, 0, ke.length)), jt(le ? le.content : "", ye, le ? le.loc : ve)))
        } else {
            const {name: ve, arg: ke, exp: le, loc: ye, modifiers: ee} = ue, qe = ve === "bind", Ze = ve === "on";
            if (ve === "slot") {
                b || c.onError(Pn(40, ye));
                continue
            }
            if (ve === "once" || ve === "memo" || ve === "is" || qe && rc(ke, "is") && (e0(A) || lc("COMPILER_IS_ON_ELEMENT", c)) || Ze && k) continue;
            if ((qe && rc(ke, "key") || Ze && D && rc(ke, "vue:before-update")) && (B = !0), qe && rc(ke, "ref") && c.scopes.vFor > 0 && S.push(er(jt("ref_for", !0), jt("true"))), !ke && (qe || Ze)) {
                if (Z = !0, le) if (qe) {
                    if (Ce(), lc("COMPILER_V_BIND_OBJECT_ORDER", c)) {
                        I.unshift(le);
                        continue
                    }
                    I.push(le)
                } else Ce({
                    type: 14,
                    loc: ye,
                    callee: c.helper(hv),
                    arguments: b ? [le] : [le, "true"]
                }); else c.onError(Pn(qe ? 34 : 35, ye));
                continue
            }
            qe && ee.includes("prop") && (L |= 32);
            const Xe = c.directiveTransforms[ve];
            if (Xe) {
                const {props: Le, needRuntime: it} = Xe(ue, a, c);
                !k && Le.forEach(me), Ze && ke && !pi(ke) ? Ce(ro(Le, y)) : S.push(...Le), it && (T.push(ue), Eo(it) && c5.set(ue, it))
            } else wL(ve) || (T.push(ue), D && (B = !0))
        }
    }
    let R;
    if (I.length ? (Ce(), I.length > 1 ? R = fr(c.helper(jp), I, y) : R = I[0]) : S.length && (R = ro(bD(S), y)), Z ? L |= 16 : (q && !b && (L |= 2), Q && !b && (L |= 4), ce.length && (L |= 8), G && (L |= 32)), !B && (L === 0 || L === 32) && (z || Y || T.length > 0) && (L |= 512), !c.inSSR && R) switch (R.type) {
        case 15:
            let ae = -1, ue = -1, ve = !1;
            for (let ye = 0; ye < R.properties.length; ye++) {
                const ee = R.properties[ye].key;
                pi(ee) ? ee.content === "class" ? ae = ye : ee.content === "style" && (ue = ye) : ee.isHandlerKey || (ve = !0)
            }
            const ke = R.properties[ae], le = R.properties[ue];
            ve ? R = fr(c.helper(Vh), [R]) : (ke && !pi(ke.value) && (ke.value = fr(c.helper(uv), [ke.value])), le && (Q || le.value.type === 4 && le.value.content.trim()[0] === "[" || le.value.type === 17) && (le.value = fr(c.helper(dv), [le.value])));
            break;
        case 14:
            break;
        default:
            R = fr(c.helper(Vh), [fr(c.helper(tf), [R])]);
            break
    }
    return {props: R, directives: T, patchFlag: L, dynamicPropNames: ce, shouldUseBlock: B}
}

function bD(a) {
    const c = new Map, h = [];
    for (let b = 0; b < a.length; b++) {
        const C = a[b];
        if (C.key.type === 8 || !C.key.isStatic) {
            h.push(C);
            continue
        }
        const k = C.key.content, A = c.get(k);
        A ? (k === "style" || k === "class" || pc(k)) && WO(A, C) : (c.set(k, C), h.push(C))
    }
    return h
}

function WO(a, c) {
    a.value.type === 17 ? a.value.elements.push(c.value) : a.value = nf([a.value, c.value], a.loc)
}

function $O(a, c) {
    const h = [], b = c5.get(a);
    b ? h.push(c.helperString(b)) : (c.helper(sv), c.directives.add(a.name), h.push(Uh(a.name, "directive")));
    const {loc: C} = a;
    if (a.exp && h.push(a.exp), a.arg && (a.exp || h.push("void 0"), h.push(a.arg)), Object.keys(a.modifiers).length) {
        a.arg || (a.exp || h.push("void 0"), h.push("void 0"));
        const k = jt("true", !1, C);
        h.push(ro(a.modifiers.map(A => er(A, k)), C))
    }
    return nf(h, a.loc)
}

function GO(a) {
    let c = "[";
    for (let h = 0, b = a.length; h < b; h++) c += JSON.stringify(a[h]), h < b - 1 && (c += ", ");
    return c + "]"
}

function e0(a) {
    return a === "component" || a === "Component"
}

const KO = (a, c) => {
    if (Wp(a)) {
        const {children: h, loc: b} = a, {slotName: C, slotProps: k} = ZO(a, c),
            A = [c.prefixIdentifiers ? "_ctx.$slots" : "$slots", C, "{}", "undefined", "true"];
        let y = 2;
        k && (A[2] = k, y = 3), h.length && (A[3] = ju([], h, !1, !1, b), y = 4), c.scopeId && !c.slotted && (y = 5), A.splice(y), a.codegenNode = fr(c.helper(qE), A, b)
    }
};

function ZO(a, c) {
    let h = '"default"', b;
    const C = [];
    for (let k = 0; k < a.props.length; k++) {
        const A = a.props[k];
        A.type === 6 ? A.value && (A.name === "name" ? h = JSON.stringify(A.value.content) : (A.name = sr(A.name), C.push(A))) : A.name === "bind" && rc(A.arg, "name") ? A.exp && (h = A.exp) : (A.name === "bind" && A.arg && pi(A.arg) && (A.arg.content = sr(A.arg.content)), C.push(A))
    }
    if (C.length > 0) {
        const {props: k, directives: A} = u5(a, c, C, !1, !1);
        b = k, A.length && c.onError(Pn(36, A[0].loc))
    }
    return {slotName: h, slotProps: b}
}

const YO = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,
    d5 = (a, c, h, b) => {
        const {loc: C, modifiers: k, arg: A} = a;
        !a.exp && !k.length && h.onError(Pn(35, C));
        let y;
        if (A.type === 4) if (A.isStatic) {
            let T = A.content;
            T.startsWith("vue:") && (T = `vnode-${T.slice(4)}`);
            const D = c.tagType !== 0 || T.startsWith("vnode") || !/[A-Z]/.test(T) ? oc(sr(T)) : `on:${T}`;
            y = jt(D, !0, A.loc)
        } else y = xo([`${h.helperString(Zk)}(`, A, ")"]); else y = A, y.children.unshift(`${h.helperString(Zk)}(`), y.children.push(")");
        let w = a.exp;
        w && !w.content.trim() && (w = void 0);
        let S = h.cacheHandlers && !w && !h.inVOnce;
        if (w) {
            const T = KE(w.content), D = !(T || YO.test(w.content)), B = w.content.includes(";");
            (D || S && T) && (w = xo([`${D ? "$event" : "(...args)"} => ${B ? "{" : "("}`, w, B ? "}" : ")"]))
        }
        let I = {props: [er(y, w || jt("() => {}", !1, C))]};
        return b && (I = b(I)), S && (I.props[0].value = h.cache(I.props[0].value)), I.props.forEach(T => T.key.isHandlerKey = !0), I
    }, QO = (a, c, h) => {
        const {exp: b, modifiers: C, loc: k} = a, A = a.arg;
        return A.type !== 4 ? (A.children.unshift("("), A.children.push(') || ""')) : A.isStatic || (A.content = `${A.content} || ""`), C.includes("camel") && (A.type === 4 ? A.isStatic ? A.content = sr(A.content) : A.content = `${h.helperString(Kk)}(${A.content})` : (A.children.unshift(`${h.helperString(Kk)}(`), A.children.push(")"))), h.inSSR || (C.includes("prop") && kD(A, "."), C.includes("attr") && kD(A, "^")), !b || b.type === 4 && !b.content.trim() ? (h.onError(Pn(34, k)), {props: [er(A, jt("", !0, k))]}) : {props: [er(A, b)]}
    }, kD = (a, c) => {
        a.type === 4 ? a.isStatic ? a.content = c + a.content : a.content = `\`${c}\${${a.content}}\`` : (a.children.unshift(`'${c}' + (`), a.children.push(")"))
    }, JO = (a, c) => {
        if (a.type === 0 || a.type === 1 || a.type === 11 || a.type === 10) return () => {
            const h = a.children;
            let b, C = !1;
            for (let k = 0; k < h.length; k++) {
                const A = h[k];
                if (Ek(A)) {
                    C = !0;
                    for (let y = k + 1; y < h.length; y++) {
                        const w = h[y];
                        if (Ek(w)) b || (b = h[k] = xo([A], A.loc)), b.children.push(" + ", w), h.splice(y, 1), y--; else {
                            b = void 0;
                            break
                        }
                    }
                }
            }
            if (!(!C || h.length === 1 && (a.type === 0 || a.type === 1 && a.tagType === 0 && !a.props.find(k => k.type === 7 && !c.directiveTransforms[k.name]) && a.tag !== "template"))) for (let k = 0; k < h.length; k++) {
                const A = h[k];
                if (Ek(A) || A.type === 8) {
                    const y = [];
                    (A.type !== 2 || A.content !== " ") && y.push(A), !c.ssr && io(A, c) === 0 && y.push("1"), h[k] = {
                        type: 12,
                        content: A,
                        loc: A.loc,
                        codegenNode: fr(c.helper(iv), y)
                    }
                }
            }
        }
    }, vD = new WeakSet, XO = (a, c) => {
        if (a.type === 1 && no(a, "once", !0)) return vD.has(a) || c.inVOnce || c.inSSR ? void 0 : (vD.add(a), c.inVOnce = !0, c.helper(Vp), () => {
            c.inVOnce = !1;
            const h = c.currentNode;
            h.codegenNode && (h.codegenNode = c.cache(h.codegenNode, !0))
        })
    }, h5 = (a, c, h) => {
        const {exp: b, arg: C} = a;
        if (!b) return h.onError(Pn(41, a.loc)), vp();
        const k = b.loc.source, A = b.type === 4 ? b.content : k, y = h.bindingMetadata[k];
        if (y === "props" || y === "props-aliased") return h.onError(Pn(44, b.loc)), vp();
        const w = !1;
        if (!A.trim() || !KE(A) && !w) return h.onError(Pn(42, b.loc)), vp();
        const S = C || jt("modelValue", !0),
            I = C ? pi(C) ? `onUpdate:${sr(C.content)}` : xo(['"onUpdate:" + ', C]) : "onUpdate:modelValue";
        let T;
        const D = h.isTS ? "($event: any)" : "$event";
        T = xo([`${D} => ((`, b, ") = $event)"]);
        const B = [er(S, a.exp), er(I, T)];
        if (a.modifiers.length && c.tagType === 1) {
            const L = a.modifiers.map(q => (mv(q) ? q : JSON.stringify(q)) + ": true").join(", "),
                z = C ? pi(C) ? `${C.content}Modifiers` : xo([C, ' + "Modifiers"']) : "modelModifiers";
            B.push(er(z, jt(`{ ${L} }`, !1, a.loc, 2)))
        }
        return vp(B)
    };

function vp(a = []) {
    return {props: a}
}

const e9 = /[\w).+\-_$\]]/, t9 = (a, c) => {
    lc("COMPILER_FILTER", c) && (a.type === 5 && Gp(a.content, c), a.type === 1 && a.props.forEach(h => {
        h.type === 7 && h.name !== "for" && h.exp && Gp(h.exp, c)
    }))
};

function Gp(a, c) {
    if (a.type === 4) wD(a, c); else for (let h = 0; h < a.children.length; h++) {
        const b = a.children[h];
        typeof b == "object" && (b.type === 4 ? wD(b, c) : b.type === 8 ? Gp(a, c) : b.type === 5 && Gp(b.content, c))
    }
}

function wD(a, c) {
    const h = a.content;
    let b = !1, C = !1, k = !1, A = !1, y = 0, w = 0, S = 0, I = 0, T, D, B, L, z = [];
    for (B = 0; B < h.length; B++) if (D = T, T = h.charCodeAt(B), b) T === 39 && D !== 92 && (b = !1); else if (C) T === 34 && D !== 92 && (C = !1); else if (k) T === 96 && D !== 92 && (k = !1); else if (A) T === 47 && D !== 92 && (A = !1); else if (T === 124 && h.charCodeAt(B + 1) !== 124 && h.charCodeAt(B - 1) !== 124 && !y && !w && !S) L === void 0 ? (I = B + 1, L = h.slice(0, B).trim()) : q(); else {
        switch (T) {
            case 34:
                C = !0;
                break;
            case 39:
                b = !0;
                break;
            case 96:
                k = !0;
                break;
            case 40:
                S++;
                break;
            case 41:
                S--;
                break;
            case 91:
                w++;
                break;
            case 93:
                w--;
                break;
            case 123:
                y++;
                break;
            case 125:
                y--;
                break
        }
        if (T === 47) {
            let Q = B - 1, G;
            for (; Q >= 0 && (G = h.charAt(Q), G === " "); Q--) ;
            (!G || !e9.test(G)) && (A = !0)
        }
    }
    L === void 0 ? L = h.slice(0, B).trim() : I !== 0 && q();

    function q() {
        z.push(h.slice(I, B).trim()), I = B + 1
    }

    if (z.length) {
        for (B = 0; B < z.length; B++) L = n9(L, z[B], c);
        a.content = L
    }
}

function n9(a, c, h) {
    h.helper(av);
    const b = c.indexOf("(");
    if (b < 0) return h.filters.add(c), `${Uh(c, "filter")}(${a})`;
    {
        const C = c.slice(0, b), k = c.slice(b + 1);
        return h.filters.add(C), `${Uh(C, "filter")}(${a}${k !== ")" ? "," + k : k}`
    }
}

const AD = new WeakSet, r9 = (a, c) => {
    if (a.type === 1) {
        const h = no(a, "memo");
        return !h || AD.has(a) ? void 0 : (AD.add(a), () => {
            const b = a.codegenNode || c.currentNode.codegenNode;
            b && b.type === 13 && (a.tagType !== 1 && pv(b, c), a.codegenNode = fr(c.helper(gv), [h.exp, ju(void 0, b), "_cache", String(c.cached++)]))
        })
    }
};

function i9(a) {
    return [[XO, NO, r9, OO, t9, KO, UO, jO, JO], {on: d5, bind: QO, model: h5}]
}

function o9(a, c = {}) {
    const h = c.onError || ev, b = c.mode === "module";
    c.prefixIdentifiers === !0 ? h(Pn(47)) : b && h(Pn(48));
    const C = !1;
    c.cacheHandlers && h(Pn(49)), c.scopeId && !b && h(Pn(50));
    const k = Pt(a) ? tO(a, c) : a, [A, y] = i9();
    return pO(k, nn({}, c, {
        prefixIdentifiers: C,
        nodeTransforms: [...A, ...c.nodeTransforms || []],
        directiveTransforms: nn({}, y, c.directiveTransforms || {})
    })), kO(k, nn({}, c, {prefixIdentifiers: C}))
}

const s9 = () => ({props: []}), f5 = Symbol(""), g5 = Symbol(""), p5 = Symbol(""), m5 = Symbol(""), t0 = Symbol(""),
    b5 = Symbol(""), k5 = Symbol(""), v5 = Symbol(""), w5 = Symbol(""), A5 = Symbol("");
z6({
    [f5]: "vModelRadio",
    [g5]: "vModelCheckbox",
    [p5]: "vModelText",
    [m5]: "vModelSelect",
    [t0]: "vModelDynamic",
    [b5]: "withModifiers",
    [k5]: "withKeys",
    [v5]: "vShow",
    [w5]: "Transition",
    [A5]: "TransitionGroup"
});
let Su;

function a9(a, c = !1) {
    return Su || (Su = document.createElement("div")), c ? (Su.innerHTML = `<div foo="${a.replace(/"/g, "&quot;")}">`, Su.children[0].getAttribute("foo")) : (Su.innerHTML = a, Su.textContent)
}

const l9 = vi("style,iframe,script,noscript", !0), c9 = {
    isVoidTag: NL,
    isNativeTag: a => ML(a) || BL(a),
    isPreTag: a => a === "pre",
    decodeEntities: a9,
    isBuiltInComponent: a => {
        if (Tu(a, "Transition")) return w5;
        if (Tu(a, "TransitionGroup")) return A5
    },
    getNamespace(a, c) {
        let h = c ? c.ns : 0;
        if (c && h === 2) if (c.tag === "annotation-xml") {
            if (a === "svg") return 1;
            c.props.some(b => b.type === 6 && b.name === "encoding" && b.value != null && (b.value.content === "text/html" || b.value.content === "application/xhtml+xml")) && (h = 0)
        } else /^m(?:[ions]|text)$/.test(c.tag) && a !== "mglyph" && a !== "malignmark" && (h = 0); else c && h === 1 && (c.tag === "foreignObject" || c.tag === "desc" || c.tag === "title") && (h = 0);
        if (h === 0) {
            if (a === "svg") return 1;
            if (a === "math") return 2
        }
        return h
    },
    getTextMode({tag: a, ns: c}) {
        if (c === 0) {
            if (a === "textarea" || a === "title") return 1;
            if (l9(a)) return 2
        }
        return 0
    }
}, u9 = a => {
    a.type === 1 && a.props.forEach((c, h) => {
        c.type === 6 && c.name === "style" && c.value && (a.props[h] = {
            type: 7,
            name: "bind",
            arg: jt("style", !0, c.loc),
            exp: d9(c.value.content, c.loc),
            modifiers: [],
            loc: c.loc
        })
    })
}, d9 = (a, c) => {
    const h = ND(a);
    return jt(JSON.stringify(h), !1, c, 3)
};

function Wa(a, c) {
    return Pn(a, c)
}

const h9 = (a, c, h) => {
        const {exp: b, loc: C} = a;
        return b || h.onError(Wa(53, C)), c.children.length && (h.onError(Wa(54, C)), c.children.length = 0), {props: [er(jt("innerHTML", !0, C), b || jt("", !0))]}
    }, f9 = (a, c, h) => {
        const {exp: b, loc: C} = a;
        return b || h.onError(Wa(55, C)), c.children.length && (h.onError(Wa(56, C)), c.children.length = 0), {props: [er(jt("textContent", !0), b ? io(b, h) > 0 ? b : fr(h.helperString(wm), [b], C) : jt("", !0))]}
    }, g9 = (a, c, h) => {
        const b = h5(a, c, h);
        if (!b.props.length || c.tagType === 1) return b;
        a.arg && h.onError(Wa(58, a.arg.loc));
        const {tag: C} = c, k = h.isCustomElement(C);
        if (C === "input" || C === "textarea" || C === "select" || k) {
            let A = p5, y = !1;
            if (C === "input" || k) {
                const w = Am(c, "type");
                if (w) {
                    if (w.type === 7) A = t0; else if (w.value) switch (w.value.content) {
                        case"radio":
                            A = f5;
                            break;
                        case"checkbox":
                            A = g5;
                            break;
                        case"file":
                            y = !0, h.onError(Wa(59, a.loc));
                            break
                    }
                } else K6(c) && (A = t0)
            } else C === "select" && (A = m5);
            y || (b.needRuntime = h.helper(A))
        } else h.onError(Wa(57, a.loc));
        return b.props = b.props.filter(A => !(A.key.type === 4 && A.key.content === "modelValue")), b
    }, p9 = vi("passive,once,capture"), m9 = vi("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"),
    b9 = vi("left,right"), C5 = vi("onkeyup,onkeydown,onkeypress", !0), k9 = (a, c, h, b) => {
        const C = [], k = [], A = [];
        for (let y = 0; y < c.length; y++) {
            const w = c[y];
            w === "native" && qh("COMPILER_V_ON_NATIVE", h) || p9(w) ? A.push(w) : b9(w) ? pi(a) ? C5(a.content) ? C.push(w) : k.push(w) : (C.push(w), k.push(w)) : m9(w) ? k.push(w) : C.push(w)
        }
        return {keyModifiers: C, nonKeyModifiers: k, eventOptionModifiers: A}
    },
    CD = (a, c) => pi(a) && a.content.toLowerCase() === "onclick" ? jt(c, !0) : a.type !== 4 ? xo(["(", a, `) === "onClick" ? "${c}" : (`, a, ")"]) : a,
    v9 = (a, c, h) => d5(a, c, h, b => {
        const {modifiers: C} = a;
        if (!C.length) return b;
        let {key: k, value: A} = b.props[0];
        const {keyModifiers: y, nonKeyModifiers: w, eventOptionModifiers: S} = k9(k, C, h, a.loc);
        if (w.includes("right") && (k = CD(k, "onContextmenu")), w.includes("middle") && (k = CD(k, "onMouseup")), w.length && (A = fr(h.helper(b5), [A, JSON.stringify(w)])), y.length && (!pi(k) || C5(k.content)) && (A = fr(h.helper(k5), [A, JSON.stringify(y)])), S.length) {
            const I = S.map(Xa).join("");
            k = pi(k) ? jt(`${k.content}${I}`, !0) : xo(["(", k, `) + "${I}"`])
        }
        return {props: [er(k, A)]}
    }), w9 = (a, c, h) => {
        const {exp: b, loc: C} = a;
        return b || h.onError(Wa(61, C)), {props: [], needRuntime: h.helper(v5)}
    }, A9 = (a, c) => {
        a.type === 1 && a.tagType === 0 && (a.tag === "script" || a.tag === "style") && c.removeNode()
    }, C9 = [u9], _9 = {cloak: s9, html: h9, text: f9, model: g9, on: v9, show: w9};

function y9(a, c = {}) {
    return o9(a, nn({}, c9, c, {
        nodeTransforms: [A9, ...C9, ...c.nodeTransforms || []],
        directiveTransforms: nn({}, _9, c.directiveTransforms || {}),
        transformHoist: null
    }))
}

const _D = new WeakMap;

function D9(a) {
    let c = _D.get(a ?? an);
    return c || (c = Object.create(null), _D.set(a ?? an, c)), c
}

function _5(a, c) {
    if (!Pt(a)) if (a.nodeType) a = a.innerHTML; else return mi;
    const h = a, b = D9(c), C = b[h];
    if (C) return C;
    if (a[0] === "#") {
        const w = document.querySelector(a);
        a = w ? w.innerHTML : ""
    }
    const k = nn({hoistStatic: !0, onError: void 0, onWarn: mi}, c);
    !k.isCustomElement && typeof customElements < "u" && (k.isCustomElement = w => !!customElements.get(w));
    const {code: A} = y9(a, k), y = new Function("Vue", A)(N6);
    return y._rc = !0, b[h] = y
}

U0(_5);
const x9 = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseTransition: D0,
    BaseTransitionPropsValidators: dm,
    Comment: Vr,
    EffectScope: Xp,
    Fragment: ln,
    KeepAlive: Dx,
    ReactiveEffect: cc,
    Static: Ua,
    Suspense: kx,
    Teleport: tE,
    Text: Ya,
    Transition: bm,
    TransitionGroup: TE,
    VueElement: Xh,
    assertNumber: cx,
    callWithAsyncErrorHandling: bi,
    callWithErrorHandling: os,
    camelize: sr,
    capitalize: Xa,
    cloneVNode: So,
    compatUtils: bE,
    compile: _5,
    computed: tn,
    createApp: X0,
    createBlock: gr,
    createCommentVNode: Rt,
    createElementBlock: tt,
    createElementVNode: J,
    createHydrationRenderer: F0,
    createPropsRestProxy: Ux,
    createRenderer: O0,
    createSSRApp: OE,
    createSlots: Ex,
    createStaticVNode: j0,
    createTextVNode: Yt,
    createVNode: lt,
    customRef: ix,
    defineAsyncComponent: yx,
    defineComponent: tl,
    defineCustomElement: Y0,
    defineEmits: Mx,
    defineExpose: Bx,
    defineModel: Px,
    defineOptions: Nx,
    defineProps: Ix,
    defineSSRCustomElement: yE,
    defineSlots: Lx,
    get devtools() {
        return ec
    },
    effect: HD,
    effectScope: FD,
    getCurrentInstance: co,
    getCurrentScope: d0,
    getTransitionRawChildren: Zh,
    guardReactiveProps: z0,
    h: q0,
    handleError: el,
    hasInjectionContext: Gx,
    hydrate: J0,
    initCustomFormatter: fE,
    initDirectivesForSSR: RE,
    inject: Ha,
    isMemoSame: G0,
    isProxy: im,
    isReactive: qs,
    isReadonly: $s,
    isRef: ar,
    isRuntimeOnly: uE,
    isShallow: Pu,
    isVNode: Ks,
    markRaw: Gs,
    mergeDefaults: Vx,
    mergeModels: Hx,
    mergeProps: pm,
    nextTick: uc,
    normalizeClass: On,
    normalizeProps: LD,
    normalizeStyle: bc,
    onActivated: x0,
    onBeforeMount: fm,
    onBeforeUnmount: kc,
    onBeforeUpdate: S0,
    onDeactivated: E0,
    onErrorCaptured: B0,
    onMounted: Oi,
    onRenderTracked: M0,
    onRenderTriggered: I0,
    onScopeDispose: zD,
    onServerPrefetch: T0,
    onUnmounted: Jh,
    onUpdated: Qh,
    openBlock: He,
    popScopeId: Gu,
    provide: hc,
    proxyRefs: sm,
    pushScopeId: $u,
    queuePostFlushCb: Nh,
    reactive: jr,
    readonly: nm,
    ref: yt,
    registerRuntimeCompiler: U0,
    render: Fp,
    renderList: so,
    renderSlot: N0,
    resolveComponent: Nn,
    resolveDirective: mx,
    resolveDynamicComponent: Oh,
    resolveFilter: mE,
    resolveTransitionHooks: dc,
    setBlockTracking: Lp,
    setDevtoolsHook: v0,
    setTransitionHooks: Za,
    shallowReactive: g0,
    shallowReadonly: ex,
    shallowRef: b0,
    ssrContextKey: W0,
    ssrUtils: pE,
    stop: UD,
    toDisplayString: Fn,
    toHandlerKey: oc,
    toHandlers: Tx,
    toRaw: Wt,
    toRef: sx,
    toRefs: ox,
    toValue: rx,
    transformVNodeArgs: oE,
    triggerRef: nx,
    unref: xt,
    useAttrs: Rx,
    useCssModule: DE,
    useCssVars: _E,
    useModel: zx,
    useSSRContext: $0,
    useSlots: Fx,
    useTransitionState: um,
    vModelCheckbox: vc,
    vModelDynamic: Q0,
    vModelRadio: km,
    vModelSelect: xr,
    vModelText: Vn,
    vShow: Hs,
    version: K0,
    warn: lx,
    watch: or,
    watchEffect: wx,
    watchPostEffect: y0,
    watchSyncEffect: Ax,
    withAsyncContext: qx,
    withCtx: Sr,
    withDefaults: Ox,
    withDirectives: Bt,
    withKeys: BE,
    withMemo: gE,
    withModifiers: vm,
    withScopeId: gx
}, Symbol.toStringTag, {value: "Module"})), $h = jr(new Set), E9 = (a, c) => {
    for (let h = 0; h < c.config.languages.en.settings_modal.blocks.length; h++) if (Gh(c.config.languages.en.settings_modal.blocks[h]) && a.category === c.config.languages.en.settings_modal.blocks[h].category) return !0;
    return !1
}, Gh = a => {
    const c = [...a.opt_in_code ? [...a.opt_in_code.matchAll(/\[##(.*?)##\]/g)] : [], ...a.opt_out_code ? [...a.opt_out_code.matchAll(/\[##(.*?)##\]/g)] : []];
    for (const h of c) {
        const b = h[1];
        if (a.variables === void 0 || a.variables[b] === void 0 || a.variables[b] === "") return !0
    }
    return !1
}, y5 = a => typeof a.category > "u" || !Gh(a), D5 = a => {
    let c = !0;
    for (let h of a.languages.en.settings_modal.blocks) typeof h.category > "u" || (y5(h) === !1 ? ($h.add(h), c = !1) : $h.delete(h));
    return c
}, x5 = a => {
    if (a = xt(a), Array.isArray(a)) return !!a.length;
    if (a == null) return !1;
    if (a === !1) return !0;
    if (a instanceof Date) return !isNaN(a.getTime());
    if (typeof a == "object") {
        for (let c in a) return !0;
        return !1
    }
    return !!String(a).length
};

function wc() {
    for (var a = arguments.length, c = new Array(a), h = 0; h < a; h++) c[h] = arguments[h];
    return b => (b = xt(b), !x5(b) || c.every(C => (C.lastIndex = 0, C.test(b))))
}

wc(/^[a-zA-Z]*$/);
wc(/^[a-zA-Z0-9]*$/);
wc(/^\d*(\.\d+)?$/);
const S9 = /^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
wc(S9);

function T9(a) {
    return typeof a == "string" && (a = a.trim()), x5(a)
}

var to = {$validator: T9, $message: "Value is required", $params: {type: "required"}};
const I9 = /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i;
wc(I9);
wc(/(^[0-9]*$)|(^-[0-9]+$)/);
wc(/^[-]?\d*(\.\d+)?$/);

function yD(a, c) {
    var h = Object.keys(a);
    if (Object.getOwnPropertySymbols) {
        var b = Object.getOwnPropertySymbols(a);
        c && (b = b.filter(function (C) {
            return Object.getOwnPropertyDescriptor(a, C).enumerable
        })), h.push.apply(h, b)
    }
    return h
}

function ja(a) {
    for (var c = 1; c < arguments.length; c++) {
        var h = arguments[c] != null ? arguments[c] : {};
        c % 2 ? yD(Object(h), !0).forEach(function (b) {
            M9(a, b, h[b])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(h)) : yD(Object(h)).forEach(function (b) {
            Object.defineProperty(a, b, Object.getOwnPropertyDescriptor(h, b))
        })
    }
    return a
}

function M9(a, c, h) {
    return c in a ? Object.defineProperty(a, c, {
        value: h,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : a[c] = h, a
}

function DD(a) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return Object.keys(a).reduce((h, b) => (c.includes(b) || (h[b] = xt(a[b])), h), {})
}

function Kp(a) {
    return typeof a == "function"
}

function B9(a) {
    return qs(a) || $s(a)
}

function E5(a, c, h) {
    let b = a;
    const C = c.split(".");
    for (let k = 0; k < C.length; k++) {
        if (!b[C[k]]) return h;
        b = b[C[k]]
    }
    return b
}

function Tk(a, c, h) {
    return tn(() => a.some(b => E5(c, b, {[h]: !1})[h]))
}

function xD(a, c, h) {
    return tn(() => a.reduce((b, C) => {
        const k = E5(c, C, {[h]: !1})[h] || [];
        return b.concat(k)
    }, []))
}

function S5(a, c, h, b) {
    return a.call(b, xt(c), xt(h), b)
}

function T5(a) {
    return a.$valid !== void 0 ? !a.$valid : !a
}

function N9(a, c, h, b, C, k, A) {
    let {$lazy: y, $rewardEarly: w} = C, S = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : [],
        I = arguments.length > 8 ? arguments[8] : void 0, T = arguments.length > 9 ? arguments[9] : void 0,
        D = arguments.length > 10 ? arguments[10] : void 0;
    const B = yt(!!b.value), L = yt(0);
    h.value = !1;
    const z = or([c, b].concat(S, D), () => {
        if (y && !b.value || w && !T.value && !h.value) return;
        let q;
        try {
            q = S5(a, c, I, A)
        } catch (Q) {
            q = Promise.reject(Q)
        }
        L.value++, h.value = !!L.value, B.value = !1, Promise.resolve(q).then(Q => {
            L.value--, h.value = !!L.value, k.value = Q, B.value = T5(Q)
        }).catch(Q => {
            L.value--, h.value = !!L.value, k.value = Q, B.value = !0
        })
    }, {immediate: !0, deep: typeof c == "object"});
    return {$invalid: B, $unwatch: z}
}

function L9(a, c, h, b, C, k, A, y) {
    let {$lazy: w, $rewardEarly: S} = b;
    const I = () => ({}), T = tn(() => {
        if (w && !h.value || S && !y.value) return !1;
        let D = !0;
        try {
            const B = S5(a, c, A, k);
            C.value = B, D = T5(B)
        } catch (B) {
            C.value = B
        }
        return D
    });
    return {$unwatch: I, $invalid: T}
}

function P9(a, c, h, b, C, k, A, y, w, S, I) {
    const T = yt(!1), D = a.$params || {}, B = yt(null);
    let L, z;
    a.$async ? {$invalid: L, $unwatch: z} = N9(a.$validator, c, T, h, b, B, C, a.$watchTargets, w, S, I) : {
        $invalid: L,
        $unwatch: z
    } = L9(a.$validator, c, h, b, B, C, w, S);
    const q = a.$message;
    return {
        $message: Kp(q) ? tn(() => q(DD({
            $pending: T,
            $invalid: L,
            $params: DD(D),
            $model: c,
            $response: B,
            $validator: k,
            $propertyPath: y,
            $property: A
        }))) : q || "", $params: D, $pending: T, $invalid: L, $response: B, $unwatch: z
    }
}

function O9() {
    let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const c = xt(a), h = Object.keys(c), b = {}, C = {}, k = {};
    let A = null;
    return h.forEach(y => {
        const w = c[y];
        switch (!0) {
            case Kp(w.$validator):
                b[y] = w;
                break;
            case Kp(w):
                b[y] = {$validator: w};
                break;
            case y === "$validationGroups":
                A = w;
                break;
            case y.startsWith("$"):
                k[y] = w;
                break;
            default:
                C[y] = w
        }
    }), {rules: b, nestedValidators: C, config: k, validationGroups: A}
}

const F9 = "__root";

function R9(a, c, h, b, C, k, A, y, w) {
    const S = Object.keys(a), I = b.get(C, a), T = yt(!1), D = yt(!1), B = yt(0);
    if (I) {
        if (!I.$partial) return I;
        I.$unwatch(), T.value = I.$dirty.value
    }
    const L = {
        $dirty: T, $path: C, $touch: () => {
            T.value || (T.value = !0)
        }, $reset: () => {
            T.value && (T.value = !1)
        }, $commit: () => {
        }
    };
    return S.length ? (S.forEach(z => {
        L[z] = P9(a[z], c, L.$dirty, k, A, z, h, C, w, D, B)
    }), L.$externalResults = tn(() => y.value ? [].concat(y.value).map((z, q) => ({
        $propertyPath: C,
        $property: h,
        $validator: "$externalResults",
        $uid: `${C}-externalResult-${q}`,
        $message: z,
        $params: {},
        $response: null,
        $pending: !1
    })) : []), L.$invalid = tn(() => {
        const z = S.some(q => xt(L[q].$invalid));
        return D.value = z, !!L.$externalResults.value.length || z
    }), L.$pending = tn(() => S.some(z => xt(L[z].$pending))), L.$error = tn(() => L.$dirty.value ? L.$pending.value || L.$invalid.value : !1), L.$silentErrors = tn(() => S.filter(z => xt(L[z].$invalid)).map(z => {
        const q = L[z];
        return jr({
            $propertyPath: C,
            $property: h,
            $validator: z,
            $uid: `${C}-${z}`,
            $message: q.$message,
            $params: q.$params,
            $response: q.$response,
            $pending: q.$pending
        })
    }).concat(L.$externalResults.value)), L.$errors = tn(() => L.$dirty.value ? L.$silentErrors.value : []), L.$unwatch = () => S.forEach(z => {
        L[z].$unwatch()
    }), L.$commit = () => {
        D.value = !0, B.value = Date.now()
    }, b.set(C, a, L), L) : (I && b.set(C, a, L), L)
}

function z9(a, c, h, b, C, k, A) {
    const y = Object.keys(a);
    return y.length ? y.reduce((w, S) => (w[S] = n0({
        validations: a[S],
        state: c,
        key: S,
        parentKey: h,
        resultsCache: b,
        globalConfig: C,
        instance: k,
        externalResults: A
    }), w), {}) : {}
}

function j9(a, c, h) {
    const b = tn(() => [c, h].filter(L => L).reduce((L, z) => L.concat(Object.values(xt(z))), [])), C = tn({
            get() {
                return a.$dirty.value || (b.value.length ? b.value.every(L => L.$dirty) : !1)
            }, set(L) {
                a.$dirty.value = L
            }
        }), k = tn(() => {
            const L = xt(a.$silentErrors) || [],
                z = b.value.filter(q => (xt(q).$silentErrors || []).length).reduce((q, Q) => q.concat(...Q.$silentErrors), []);
            return L.concat(z)
        }), A = tn(() => {
            const L = xt(a.$errors) || [],
                z = b.value.filter(q => (xt(q).$errors || []).length).reduce((q, Q) => q.concat(...Q.$errors), []);
            return L.concat(z)
        }), y = tn(() => b.value.some(L => L.$invalid) || xt(a.$invalid) || !1),
        w = tn(() => b.value.some(L => xt(L.$pending)) || xt(a.$pending) || !1),
        S = tn(() => b.value.some(L => L.$dirty) || b.value.some(L => L.$anyDirty) || C.value),
        I = tn(() => C.value ? w.value || y.value : !1), T = () => {
            a.$touch(), b.value.forEach(L => {
                L.$touch()
            })
        }, D = () => {
            a.$commit(), b.value.forEach(L => {
                L.$commit()
            })
        }, B = () => {
            a.$reset(), b.value.forEach(L => {
                L.$reset()
            })
        };
    return b.value.length && b.value.every(L => L.$dirty) && T(), {
        $dirty: C,
        $errors: A,
        $invalid: y,
        $anyDirty: S,
        $error: I,
        $pending: w,
        $touch: T,
        $reset: B,
        $silentErrors: k,
        $commit: D
    }
}

function n0(a) {
    let {
        validations: c,
        state: h,
        key: b,
        parentKey: C,
        childResults: k,
        resultsCache: A,
        globalConfig: y = {},
        instance: w,
        externalResults: S
    } = a;
    const I = C ? `${C}.${b}` : b, {rules: T, nestedValidators: D, config: B, validationGroups: L} = O9(c),
        z = ja(ja({}, y), B), q = b ? tn(() => {
            const it = xt(h);
            return it ? xt(it[b]) : void 0
        }) : h, Q = ja({}, xt(S) || {}), G = tn(() => {
            const it = xt(S);
            return b ? it ? xt(it[b]) : void 0 : it
        }), Z = R9(T, q, b, A, I, z, w, G, h), Y = z9(D, q, I, A, z, w, G), ce = {};
    L && Object.entries(L).forEach(it => {
        let [_t, Tt] = it;
        ce[_t] = {
            $invalid: Tk(Tt, Y, "$invalid"),
            $error: Tk(Tt, Y, "$error"),
            $pending: Tk(Tt, Y, "$pending"),
            $errors: xD(Tt, Y, "$errors"),
            $silentErrors: xD(Tt, Y, "$silentErrors")
        }
    });
    const {
        $dirty: Ce,
        $errors: me,
        $invalid: R,
        $anyDirty: ae,
        $error: ue,
        $pending: ve,
        $touch: ke,
        $reset: le,
        $silentErrors: ye,
        $commit: ee
    } = j9(Z, Y, k), qe = b ? tn({
        get: () => xt(q), set: it => {
            Ce.value = !0;
            const _t = xt(h), Tt = xt(S);
            Tt && (Tt[b] = Q[b]), ar(_t[b]) ? _t[b].value = it : _t[b] = it
        }
    }) : null;
    b && z.$autoDirty && or(q, () => {
        Ce.value || ke();
        const it = xt(S);
        it && (it[b] = Q[b])
    }, {flush: "sync"});

    async function Ze() {
        return ke(), z.$rewardEarly && (ee(), await uc()), await uc(), new Promise(it => {
            if (!ve.value) return it(!R.value);
            const _t = or(ve, () => {
                it(!R.value), _t()
            })
        })
    }

    function Xe(it) {
        return (k.value || {})[it]
    }

    function Le() {
        ar(S) ? S.value = Q : Object.keys(Q).length === 0 ? Object.keys(S).forEach(it => {
            delete S[it]
        }) : Object.assign(S, Q)
    }

    return jr(ja(ja(ja({}, Z), {}, {
        $model: qe,
        $dirty: Ce,
        $error: ue,
        $errors: me,
        $invalid: R,
        $anyDirty: ae,
        $pending: ve,
        $touch: ke,
        $reset: le,
        $path: I || F9,
        $silentErrors: ye,
        $validate: Ze,
        $commit: ee
    }, k && {$getResultsForChild: Xe, $clearExternalResults: Le, $validationGroups: ce}), Y))
}

class V9 {
    constructor() {
        this.storage = new Map
    }

    set(c, h, b) {
        this.storage.set(c, {rules: h, result: b})
    }

    checkRulesValidity(c, h, b) {
        const C = Object.keys(b), k = Object.keys(h);
        return k.length !== C.length || !k.every(y => C.includes(y)) ? !1 : k.every(y => h[y].$params ? Object.keys(h[y].$params).every(w => xt(b[y].$params[w]) === xt(h[y].$params[w])) : !0)
    }

    get(c, h) {
        const b = this.storage.get(c);
        if (!b) return;
        const {rules: C, result: k} = b, A = this.checkRulesValidity(c, h, C), y = k.$unwatch ? k.$unwatch : () => ({});
        return A ? k : {$dirty: k.$dirty, $partial: !0, $unwatch: y}
    }
}

const xp = {COLLECT_ALL: !0, COLLECT_NONE: !1}, ED = Symbol("vuelidate#injectChildResults"),
    SD = Symbol("vuelidate#removeChildResults");

function H9(a) {
    let {$scope: c, instance: h} = a;
    const b = {}, C = yt([]), k = tn(() => C.value.reduce((I, T) => (I[T] = xt(b[T]), I), {}));

    function A(I, T) {
        let {$registerAs: D, $scope: B, $stopPropagation: L} = T;
        L || c === xp.COLLECT_NONE || B === xp.COLLECT_NONE || c !== xp.COLLECT_ALL && c !== B || (b[D] = I, C.value.push(D))
    }

    h.__vuelidateInjectInstances = [].concat(h.__vuelidateInjectInstances || [], A);

    function y(I) {
        C.value = C.value.filter(T => T !== I), delete b[I]
    }

    h.__vuelidateRemoveInstances = [].concat(h.__vuelidateRemoveInstances || [], y);
    const w = Ha(ED, []);
    hc(ED, h.__vuelidateInjectInstances);
    const S = Ha(SD, []);
    return hc(SD, h.__vuelidateRemoveInstances), {
        childResults: k,
        sendValidationResultsToParent: w,
        removeValidationResultsFromParent: S
    }
}

function I5(a) {
    return new Proxy(a, {
        get(c, h) {
            return typeof c[h] == "object" ? I5(c[h]) : tn(() => c[h])
        }
    })
}

let TD = 0;

function M5(a, c) {
    var h;
    let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    arguments.length === 1 && (b = a, a = void 0, c = void 0);
    let {
        $registerAs: C,
        $scope: k = xp.COLLECT_ALL,
        $stopPropagation: A,
        $externalResults: y,
        currentVueInstance: w
    } = b;
    const S = w || ((h = co()) === null || h === void 0 ? void 0 : h.proxy), I = S ? S.$options : {};
    C || (TD += 1, C = `_vuelidate_${TD}`);
    const T = yt({}), D = new V9, {
        childResults: B,
        sendValidationResultsToParent: L,
        removeValidationResultsFromParent: z
    } = S ? H9({$scope: k, instance: S}) : {childResults: yt({})};
    if (!a && I.validations) {
        const q = I.validations;
        c = yt({}), fm(() => {
            c.value = S, or(() => Kp(q) ? q.call(c.value, new I5(c.value)) : q, Q => {
                T.value = n0({
                    validations: Q,
                    state: c,
                    childResults: B,
                    resultsCache: D,
                    globalConfig: b,
                    instance: S,
                    externalResults: y || S.vuelidateExternalResults
                })
            }, {immediate: !0})
        }), b = I.validationsConfig || b
    } else {
        const q = ar(a) || B9(a) ? a : jr(a || {});
        or(q, Q => {
            T.value = n0({
                validations: Q,
                state: c,
                childResults: B,
                resultsCache: D,
                globalConfig: b,
                instance: S ?? {},
                externalResults: y
            })
        }, {immediate: !0})
    }
    return S && (L.forEach(q => q(T, {
        $registerAs: C,
        $scope: k,
        $stopPropagation: A
    })), kc(() => z.forEach(q => q(C)))), tn(() => ja(ja({}, xt(T.value)), B.value))
}

const Tr = (a, c) => {
        const h = a.__vccOpts || a;
        for (const [b, C] of c) h[b] = C;
        return h
    }, U9 = {name: "IconArrow"},
    q9 = {xmlns: "http://www.w3.org/2000/svg", height: "25", viewBox: "0 -960 960 960", width: "25"},
    W9 = J("path", {d: "m560-240-56-58 142-142H160v-80h486L504-662l56-58 240 240-240 240Z"}, null, -1), $9 = [W9];

function G9(a, c, h, b, C, k) {
    return He(), tt("svg", q9, $9)
}

const K9 = Tr(U9, [["render", G9]]), Z9 = {name: "IconPlus"},
    Y9 = {xmlns: "http://www.w3.org/2000/svg", height: "25", viewBox: "0 -960 960 960", width: "25"},
    Q9 = J("path", {d: "M440-440H200v-80h240v-240h80v240h240v80H520v240h-80v-240Z"}, null, -1), J9 = [Q9];

function X9(a, c, h, b, C, k) {
    return He(), tt("svg", Y9, J9)
}

const e8 = Tr(Z9, [["render", X9]]), t8 = {key: 0, class: "cf-btn-icon"}, n8 = {class: "cf-btn-text"},
    r8 = {key: 1, class: "cf-btn-icon"}, Ws = {
        __name: "Buttonwithicon",
        props: {icon: String, btnClass: String, position: {type: String, default: "right"}},
        setup(a) {
            const c = jr({IconArrow: Gs(K9), IconPlus: Gs(e8)});
            return (h, b) => (He(), tt("div", {class: On([a.btnClass, "cf-btn", "btn-rounded"])}, [a.position === "left" ? (He(), tt("div", t8, [(He(), gr(Oh(c[a.icon]), {class: "cf-rotate-180"}))])) : Rt("", !0), J("div", n8, [N0(h.$slots, "default")]), a.position === "right" ? (He(), tt("div", r8, [(He(), gr(Oh(c[a.icon])))])) : Rt("", !0)], 2))
        }
    }, i8 = {}, o8 = {xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24"},
    s8 = J("path", {d: "M160-400v-80h280v80H160Zm0-160v-80h440v80H160Zm0-160v-80h440v80H160Zm360 560v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q8 9 12.5 20t4.5 22q0 11-4 22.5T863-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z"}, null, -1),
    a8 = [s8];

function l8(a, c) {
    return He(), tt("svg", o8, a8)
}

const r0 = Tr(i8, [["render", l8]]), c8 = {},
    u8 = {xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24"},
    d8 = J("path", {d: "M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z"}, null, -1),
    h8 = [d8];

function f8(a, c) {
    return He(), tt("svg", u8, h8)
}

const B5 = Tr(c8, [["render", f8]]);
var oo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function of(a) {
    return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a
}

function g8(a) {
    if (a.__esModule) return a;
    var c = a.default;
    if (typeof c == "function") {
        var h = function b() {
            return this instanceof b ? Reflect.construct(c, arguments, this.constructor) : c.apply(this, arguments)
        };
        h.prototype = c.prototype
    } else h = {};
    return Object.defineProperty(h, "__esModule", {value: !0}), Object.keys(a).forEach(function (b) {
        var C = Object.getOwnPropertyDescriptor(a, b);
        Object.defineProperty(h, b, C.get ? C : {
            enumerable: !0, get: function () {
                return a[b]
            }
        })
    }), h
}

var N5 = {exports: {}};
(function (a, c) {
    (function (h, b) {
        a.exports = b()
    })(oo, function () {
        var h = navigator.userAgent, b = navigator.platform, C = /gecko\/\d/i.test(h), k = /MSIE \d/.test(h),
            A = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(h), y = /Edge\/(\d+)/.exec(h), w = k || A || y,
            S = w && (k ? document.documentMode || 6 : +(y || A)[1]), I = !y && /WebKit\//.test(h),
            T = I && /Qt\/\d+\.\d+/.test(h), D = !y && /Chrome\/(\d+)/.exec(h), B = D && +D[1], L = /Opera\//.test(h),
            z = /Apple Computer/.test(navigator.vendor), q = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(h),
            Q = /PhantomJS/.test(h), G = z && (/Mobile\/\w+/.test(h) || navigator.maxTouchPoints > 2),
            Z = /Android/.test(h), Y = G || Z || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(h),
            ce = G || /Mac/.test(b), Ce = /\bCrOS\b/.test(h), me = /win/i.test(b),
            R = L && h.match(/Version\/(\d*\.\d*)/);
        R && (R = Number(R[1])), R && R >= 15 && (L = !1, I = !0);
        var ae = ce && (T || L && (R == null || R < 12.11)), ue = C || w && S >= 9;

        function ve(o) {
            return new RegExp("(^|\\s)" + o + "(?:$|\\s)\\s*")
        }

        var ke = function (o, u) {
            var p = o.className, f = ve(u).exec(p);
            if (f) {
                var m = p.slice(f.index + f[0].length);
                o.className = p.slice(0, f.index) + (m ? f[1] + m : "")
            }
        };

        function le(o) {
            for (var u = o.childNodes.length; u > 0; --u) o.removeChild(o.firstChild);
            return o
        }

        function ye(o, u) {
            return le(o).appendChild(u)
        }

        function ee(o, u, p, f) {
            var m = document.createElement(o);
            if (p && (m.className = p), f && (m.style.cssText = f), typeof u == "string") m.appendChild(document.createTextNode(u)); else if (u) for (var E = 0; E < u.length; ++E) m.appendChild(u[E]);
            return m
        }

        function qe(o, u, p, f) {
            var m = ee(o, u, p, f);
            return m.setAttribute("role", "presentation"), m
        }

        var Ze;
        document.createRange ? Ze = function (o, u, p, f) {
            var m = document.createRange();
            return m.setEnd(f || o, p), m.setStart(o, u), m
        } : Ze = function (o, u, p) {
            var f = document.body.createTextRange();
            try {
                f.moveToElementText(o.parentNode)
            } catch {
                return f
            }
            return f.collapse(!0), f.moveEnd("character", p), f.moveStart("character", u), f
        };

        function Xe(o, u) {
            if (u.nodeType == 3 && (u = u.parentNode), o.contains) return o.contains(u);
            do if (u.nodeType == 11 && (u = u.host), u == o) return !0; while (u = u.parentNode)
        }

        function Le(o) {
            var u = o.ownerDocument || o, p;
            try {
                p = o.activeElement
            } catch {
                p = u.body || null
            }
            for (; p && p.shadowRoot && p.shadowRoot.activeElement;) p = p.shadowRoot.activeElement;
            return p
        }

        function it(o, u) {
            var p = o.className;
            ve(u).test(p) || (o.className += (p ? " " : "") + u)
        }

        function _t(o, u) {
            for (var p = o.split(" "), f = 0; f < p.length; f++) p[f] && !ve(p[f]).test(u) && (u += " " + p[f]);
            return u
        }

        var Tt = function (o) {
            o.select()
        };
        G ? Tt = function (o) {
            o.selectionStart = 0, o.selectionEnd = o.value.length
        } : w && (Tt = function (o) {
            try {
                o.select()
            } catch {
            }
        });

        function Pe(o) {
            return o.display.wrapper.ownerDocument
        }

        function At(o) {
            return mt(o.display.wrapper)
        }

        function mt(o) {
            return o.getRootNode ? o.getRootNode() : o.ownerDocument
        }

        function Ye(o) {
            return Pe(o).defaultView
        }

        function Oe(o) {
            var u = Array.prototype.slice.call(arguments, 1);
            return function () {
                return o.apply(null, u)
            }
        }

        function ht(o, u, p) {
            u || (u = {});
            for (var f in o) o.hasOwnProperty(f) && (p !== !1 || !u.hasOwnProperty(f)) && (u[f] = o[f]);
            return u
        }

        function vt(o, u, p, f, m) {
            u == null && (u = o.search(/[^\s\u00a0]/), u == -1 && (u = o.length));
            for (var E = f || 0, N = m || 0; ;) {
                var P = o.indexOf("	", E);
                if (P < 0 || P >= u) return N + (u - E);
                N += P - E, N += p - N % p, E = P + 1
            }
        }

        var Vt = function () {
            this.id = null, this.f = null, this.time = 0, this.handler = Oe(this.onTimeout, this)
        };
        Vt.prototype.onTimeout = function (o) {
            o.id = 0, o.time <= +new Date ? o.f() : setTimeout(o.handler, o.time - +new Date)
        }, Vt.prototype.set = function (o, u) {
            this.f = u;
            var p = +new Date + o;
            (!this.id || p < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, o), this.time = p)
        };

        function ct(o, u) {
            for (var p = 0; p < o.length; ++p) if (o[p] == u) return p;
            return -1
        }

        var se = 50, ge = {
            toString: function () {
                return "CodeMirror.Pass"
            }
        }, we = {scroll: !1}, Me = {origin: "*mouse"}, Be = {origin: "+move"};

        function Ue(o, u, p) {
            for (var f = 0, m = 0; ;) {
                var E = o.indexOf("	", f);
                E == -1 && (E = o.length);
                var N = E - f;
                if (E == o.length || m + N >= u) return f + Math.min(N, u - m);
                if (m += E - f, m += p - m % p, f = E + 1, m >= u) return f
            }
        }

        var Ge = [""];

        function ze(o) {
            for (; Ge.length <= o;) Ge.push(V(Ge) + " ");
            return Ge[o]
        }

        function V(o) {
            return o[o.length - 1]
        }

        function $(o, u) {
            for (var p = [], f = 0; f < o.length; f++) p[f] = u(o[f], f);
            return p
        }

        function te(o, u, p) {
            for (var f = 0, m = p(u); f < o.length && p(o[f]) <= m;) f++;
            o.splice(f, 0, u)
        }

        function oe() {
        }

        function de(o, u) {
            var p;
            return Object.create ? p = Object.create(o) : (oe.prototype = o, p = new oe), u && ht(u, p), p
        }

        var he = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

        function Ae(o) {
            return /\w/.test(o) || o > "" && (o.toUpperCase() != o.toLowerCase() || he.test(o))
        }

        function De(o, u) {
            return u ? u.source.indexOf("\\w") > -1 && Ae(o) ? !0 : u.test(o) : Ae(o)
        }

        function Ie(o) {
            for (var u in o) if (o.hasOwnProperty(u) && o[u]) return !1;
            return !0
        }

        var nt = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

        function st(o) {
            return o.charCodeAt(0) >= 768 && nt.test(o)
        }

        function Dt(o, u, p) {
            for (; (p < 0 ? u > 0 : u < o.length) && st(o.charAt(u));) u += p;
            return u
        }

        function zt(o, u, p) {
            for (var f = u > p ? -1 : 1; ;) {
                if (u == p) return u;
                var m = (u + p) / 2, E = f < 0 ? Math.ceil(m) : Math.floor(m);
                if (E == u) return o(E) ? u : p;
                o(E) ? p = E : u = E + f
            }
        }

        function Nt(o, u, p, f) {
            if (!o) return f(u, p, "ltr", 0);
            for (var m = !1, E = 0; E < o.length; ++E) {
                var N = o[E];
                (N.from < p && N.to > u || u == p && N.to == u) && (f(Math.max(N.from, u), Math.min(N.to, p), N.level == 1 ? "rtl" : "ltr", E), m = !0)
            }
            m || f(u, p, "ltr")
        }

        var $t = null;

        function Ot(o, u, p) {
            var f;
            $t = null;
            for (var m = 0; m < o.length; ++m) {
                var E = o[m];
                if (E.from < u && E.to > u) return m;
                E.to == u && (E.from != E.to && p == "before" ? f = m : $t = m), E.from == u && (E.from != E.to && p != "before" ? f = m : $t = m)
            }
            return f ?? $t
        }

        var Gt = function () {
            var o = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",
                u = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

            function p(H) {
                return H <= 247 ? o.charAt(H) : 1424 <= H && H <= 1524 ? "R" : 1536 <= H && H <= 1785 ? u.charAt(H - 1536) : 1774 <= H && H <= 2220 ? "r" : 8192 <= H && H <= 8203 ? "w" : H == 8204 ? "b" : "L"
            }

            var f = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, m = /[stwN]/, E = /[LRr]/, N = /[Lb1n]/, P = /[1n]/;

            function F(H, X, ie) {
                this.level = H, this.from = X, this.to = ie
            }

            return function (H, X) {
                var ie = X == "ltr" ? "L" : "R";
                if (H.length == 0 || X == "ltr" && !f.test(H)) return !1;
                for (var be = H.length, fe = [], xe = 0; xe < be; ++xe) fe.push(p(H.charCodeAt(xe)));
                for (var Ne = 0, Ve = ie; Ne < be; ++Ne) {
                    var $e = fe[Ne];
                    $e == "m" ? fe[Ne] = Ve : Ve = $e
                }
                for (var et = 0, Ke = ie; et < be; ++et) {
                    var at = fe[et];
                    at == "1" && Ke == "r" ? fe[et] = "n" : E.test(at) && (Ke = at, at == "r" && (fe[et] = "R"))
                }
                for (var pt = 1, gt = fe[0]; pt < be - 1; ++pt) {
                    var Mt = fe[pt];
                    Mt == "+" && gt == "1" && fe[pt + 1] == "1" ? fe[pt] = "1" : Mt == "," && gt == fe[pt + 1] && (gt == "1" || gt == "n") && (fe[pt] = gt), gt = Mt
                }
                for (var hn = 0; hn < be; ++hn) {
                    var $n = fe[hn];
                    if ($n == ",") fe[hn] = "N"; else if ($n == "%") {
                        var Dn = void 0;
                        for (Dn = hn + 1; Dn < be && fe[Dn] == "%"; ++Dn) ;
                        for (var Pr = hn && fe[hn - 1] == "!" || Dn < be && fe[Dn] == "1" ? "1" : "N", En = hn; En < Dn; ++En) fe[En] = Pr;
                        hn = Dn - 1
                    }
                }
                for (var Ln = 0, Gn = ie; Ln < be; ++Ln) {
                    var xn = fe[Ln];
                    Gn == "L" && xn == "1" ? fe[Ln] = "L" : E.test(xn) && (Gn = xn)
                }
                for (var Kn = 0; Kn < be; ++Kn) if (m.test(fe[Kn])) {
                    var Mn = void 0;
                    for (Mn = Kn + 1; Mn < be && m.test(fe[Mn]); ++Mn) ;
                    for (var Bn = (Kn ? fe[Kn - 1] : ie) == "L", Or = (Mn < be ? fe[Mn] : ie) == "L", xa = Bn == Or ? Bn ? "L" : "R" : ie, Jo = Kn; Jo < Mn; ++Jo) fe[Jo] = xa;
                    Kn = Mn - 1
                }
                for (var vr = [], Ki, rr = 0; rr < be;) if (N.test(fe[rr])) {
                    var Xd = rr;
                    for (++rr; rr < be && N.test(fe[rr]); ++rr) ;
                    vr.push(new F(0, Xd, rr))
                } else {
                    var Zi = rr, Ts = vr.length, Is = X == "rtl" ? 1 : 0;
                    for (++rr; rr < be && fe[rr] != "L"; ++rr) ;
                    for (var Zn = Zi; Zn < rr;) if (P.test(fe[Zn])) {
                        Zi < Zn && (vr.splice(Ts, 0, new F(1, Zi, Zn)), Ts += Is);
                        var Ea = Zn;
                        for (++Zn; Zn < rr && P.test(fe[Zn]); ++Zn) ;
                        vr.splice(Ts, 0, new F(2, Ea, Zn)), Ts += Is, Zi = Zn
                    } else ++Zn;
                    Zi < rr && vr.splice(Ts, 0, new F(1, Zi, rr))
                }
                return X == "ltr" && (vr[0].level == 1 && (Ki = H.match(/^\s+/)) && (vr[0].from = Ki[0].length, vr.unshift(new F(0, 0, Ki[0].length))), V(vr).level == 1 && (Ki = H.match(/\s+$/)) && (V(vr).to -= Ki[0].length, vr.push(new F(0, be - Ki[0].length, be)))), X == "rtl" ? vr.reverse() : vr
            }
        }();

        function ot(o, u) {
            var p = o.order;
            return p == null && (p = o.order = Gt(o.text, u)), p
        }

        var lr = [], ft = function (o, u, p) {
            if (o.addEventListener) o.addEventListener(u, p, !1); else if (o.attachEvent) o.attachEvent("on" + u, p); else {
                var f = o._handlers || (o._handlers = {});
                f[u] = (f[u] || lr).concat(p)
            }
        };

        function Ir(o, u) {
            return o._handlers && o._handlers[u] || lr
        }

        function Rn(o, u, p) {
            if (o.removeEventListener) o.removeEventListener(u, p, !1); else if (o.detachEvent) o.detachEvent("on" + u, p); else {
                var f = o._handlers, m = f && f[u];
                if (m) {
                    var E = ct(m, p);
                    E > -1 && (f[u] = m.slice(0, E).concat(m.slice(E + 1)))
                }
            }
        }

        function cn(o, u) {
            var p = Ir(o, u);
            if (p.length) for (var f = Array.prototype.slice.call(arguments, 2), m = 0; m < p.length; ++m) p[m].apply(null, f)
        }

        function fn(o, u, p) {
            return typeof u == "string" && (u = {
                type: u, preventDefault: function () {
                    this.defaultPrevented = !0
                }
            }), cn(o, p || u.type, o, u), Mr(u) || u.codemirrorIgnore
        }

        function cr(o) {
            var u = o._handlers && o._handlers.cursorActivity;
            if (u) for (var p = o.curOp.cursorActivityHandlers || (o.curOp.cursorActivityHandlers = []), f = 0; f < u.length; ++f) ct(p, u[f]) == -1 && p.push(u[f])
        }

        function zn(o, u) {
            return Ir(o, u).length > 0
        }

        function Hr(o) {
            o.prototype.on = function (u, p) {
                ft(this, u, p)
            }, o.prototype.off = function (u, p) {
                Rn(this, u, p)
            }
        }

        function Sn(o) {
            o.preventDefault ? o.preventDefault() : o.returnValue = !1
        }

        function ur(o) {
            o.stopPropagation ? o.stopPropagation() : o.cancelBubble = !0
        }

        function Mr(o) {
            return o.defaultPrevented != null ? o.defaultPrevented : o.returnValue == !1
        }

        function ti(o) {
            Sn(o), ur(o)
        }

        function To(o) {
            return o.target || o.srcElement
        }

        function wi(o) {
            var u = o.which;
            return u == null && (o.button & 1 ? u = 1 : o.button & 2 ? u = 3 : o.button & 4 && (u = 2)), ce && o.ctrlKey && u == 1 && (u = 3), u
        }

        var Ku = function () {
            if (w && S < 9) return !1;
            var o = ee("div");
            return "draggable" in o || "dragDrop" in o
        }(), Ys;

        function Ac(o) {
            if (Ys == null) {
                var u = ee("span", "​");
                ye(o, ee("span", [u, document.createTextNode("x")])), o.firstChild.offsetHeight != 0 && (Ys = u.offsetWidth <= 1 && u.offsetHeight > 2 && !(w && S < 8))
            }
            var p = Ys ? ee("span", "​") : ee("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
            return p.setAttribute("cm-text", ""), p
        }

        var nl;

        function Zr(o) {
            if (nl != null) return nl;
            var u = ye(o, document.createTextNode("AخA")), p = Ze(u, 0, 1).getBoundingClientRect(),
                f = Ze(u, 1, 2).getBoundingClientRect();
            return le(o), !p || p.left == p.right ? !1 : nl = f.right - p.right < 3
        }

        var Br = `

b`.split(/\n/).length != 3 ? function (o) {
            for (var u = 0, p = [], f = o.length; u <= f;) {
                var m = o.indexOf(`
`, u);
                m == -1 && (m = o.length);
                var E = o.slice(u, o.charAt(m - 1) == "\r" ? m - 1 : m), N = E.indexOf("\r");
                N != -1 ? (p.push(E.slice(0, N)), u += N + 1) : (p.push(E), u = m + 1)
            }
            return p
        } : function (o) {
            return o.split(/\r\n?|\n/)
        }, Io = window.getSelection ? function (o) {
            try {
                return o.selectionStart != o.selectionEnd
            } catch {
                return !1
            }
        } : function (o) {
            var u;
            try {
                u = o.ownerDocument.selection.createRange()
            } catch {
            }
            return !u || u.parentElement() != o ? !1 : u.compareEndPoints("StartToEnd", u) != 0
        }, Cc = function () {
            var o = ee("div");
            return "oncopy" in o ? !0 : (o.setAttribute("oncopy", "return;"), typeof o.oncopy == "function")
        }(), Ai = null;

        function Zu(o) {
            if (Ai != null) return Ai;
            var u = ye(o, ee("span", "x")), p = u.getBoundingClientRect(), f = Ze(u, 0, 1).getBoundingClientRect();
            return Ai = Math.abs(p.left - f.left) > 1
        }

        var ni = {}, Yr = {};

        function ri(o, u) {
            arguments.length > 2 && (u.dependencies = Array.prototype.slice.call(arguments, 2)), ni[o] = u
        }

        function ss(o, u) {
            Yr[o] = u
        }

        function Qs(o) {
            if (typeof o == "string" && Yr.hasOwnProperty(o)) o = Yr[o]; else if (o && typeof o.name == "string" && Yr.hasOwnProperty(o.name)) {
                var u = Yr[o.name];
                typeof u == "string" && (u = {name: u}), o = de(u, o), o.name = u.name
            } else {
                if (typeof o == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(o)) return Qs("application/xml");
                if (typeof o == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(o)) return Qs("application/json")
            }
            return typeof o == "string" ? {name: o} : o || {name: "null"}
        }

        function ii(o, u) {
            u = Qs(u);
            var p = ni[u.name];
            if (!p) return ii(o, "text/plain");
            var f = p(o, u);
            if (Mo.hasOwnProperty(u.name)) {
                var m = Mo[u.name];
                for (var E in m) m.hasOwnProperty(E) && (f.hasOwnProperty(E) && (f["_" + E] = f[E]), f[E] = m[E])
            }
            if (f.name = u.name, u.helperType && (f.helperType = u.helperType), u.modeProps) for (var N in u.modeProps) f[N] = u.modeProps[N];
            return f
        }

        var Mo = {};

        function Js(o, u) {
            var p = Mo.hasOwnProperty(o) ? Mo[o] : Mo[o] = {};
            ht(u, p)
        }

        function Ri(o, u) {
            if (u === !0) return u;
            if (o.copyState) return o.copyState(u);
            var p = {};
            for (var f in u) {
                var m = u[f];
                m instanceof Array && (m = m.concat([])), p[f] = m
            }
            return p
        }

        function rl(o, u) {
            for (var p; o.innerMode && (p = o.innerMode(u), !(!p || p.mode == o));) u = p.state, o = p.mode;
            return p || {mode: o, state: u}
        }

        function Xs(o, u, p) {
            return o.startState ? o.startState(u, p) : !0
        }

        var Tn = function (o, u, p) {
            this.pos = this.start = 0, this.string = o, this.tabSize = u || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = p
        };
        Tn.prototype.eol = function () {
            return this.pos >= this.string.length
        }, Tn.prototype.sol = function () {
            return this.pos == this.lineStart
        }, Tn.prototype.peek = function () {
            return this.string.charAt(this.pos) || void 0
        }, Tn.prototype.next = function () {
            if (this.pos < this.string.length) return this.string.charAt(this.pos++)
        }, Tn.prototype.eat = function (o) {
            var u = this.string.charAt(this.pos), p;
            if (typeof o == "string" ? p = u == o : p = u && (o.test ? o.test(u) : o(u)), p) return ++this.pos, u
        }, Tn.prototype.eatWhile = function (o) {
            for (var u = this.pos; this.eat(o);) ;
            return this.pos > u
        }, Tn.prototype.eatSpace = function () {
            for (var o = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos));) ++this.pos;
            return this.pos > o
        }, Tn.prototype.skipToEnd = function () {
            this.pos = this.string.length
        }, Tn.prototype.skipTo = function (o) {
            var u = this.string.indexOf(o, this.pos);
            if (u > -1) return this.pos = u, !0
        }, Tn.prototype.backUp = function (o) {
            this.pos -= o
        }, Tn.prototype.column = function () {
            return this.lastColumnPos < this.start && (this.lastColumnValue = vt(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? vt(this.string, this.lineStart, this.tabSize) : 0)
        }, Tn.prototype.indentation = function () {
            return vt(this.string, null, this.tabSize) - (this.lineStart ? vt(this.string, this.lineStart, this.tabSize) : 0)
        }, Tn.prototype.match = function (o, u, p) {
            if (typeof o == "string") {
                var f = function (N) {
                    return p ? N.toLowerCase() : N
                }, m = this.string.substr(this.pos, o.length);
                if (f(m) == f(o)) return u !== !1 && (this.pos += o.length), !0
            } else {
                var E = this.string.slice(this.pos).match(o);
                return E && E.index > 0 ? null : (E && u !== !1 && (this.pos += E[0].length), E)
            }
        }, Tn.prototype.current = function () {
            return this.string.slice(this.start, this.pos)
        }, Tn.prototype.hideFirstChars = function (o, u) {
            this.lineStart += o;
            try {
                return u()
            } finally {
                this.lineStart -= o
            }
        }, Tn.prototype.lookAhead = function (o) {
            var u = this.lineOracle;
            return u && u.lookAhead(o)
        }, Tn.prototype.baseToken = function () {
            var o = this.lineOracle;
            return o && o.baseToken(this.pos)
        };

        function dt(o, u) {
            if (u -= o.first, u < 0 || u >= o.size) throw new Error("There is no line " + (u + o.first) + " in the document.");
            for (var p = o; !p.lines;) for (var f = 0; ; ++f) {
                var m = p.children[f], E = m.chunkSize();
                if (u < E) {
                    p = m;
                    break
                }
                u -= E
            }
            return p.lines[u]
        }

        function uo(o, u, p) {
            var f = [], m = u.line;
            return o.iter(u.line, p.line + 1, function (E) {
                var N = E.text;
                m == p.line && (N = N.slice(0, p.ch)), m == u.line && (N = N.slice(u.ch)), f.push(N), ++m
            }), f
        }

        function Ci(o, u, p) {
            var f = [];
            return o.iter(u, p, function (m) {
                f.push(m.text)
            }), f
        }

        function mr(o, u) {
            var p = u - o.height;
            if (p) for (var f = o; f; f = f.parent) f.height += p
        }

        function W(o) {
            if (o.parent == null) return null;
            for (var u = o.parent, p = ct(u.lines, o), f = u.parent; f; u = f, f = f.parent) for (var m = 0; f.children[m] != u; ++m) p += f.children[m].chunkSize();
            return p + u.first
        }

        function re(o, u) {
            var p = o.first;
            e:do {
                for (var f = 0; f < o.children.length; ++f) {
                    var m = o.children[f], E = m.height;
                    if (u < E) {
                        o = m;
                        continue e
                    }
                    u -= E, p += m.chunkSize()
                }
                return p
            } while (!o.lines);
            for (var N = 0; N < o.lines.length; ++N) {
                var P = o.lines[N], F = P.height;
                if (u < F) break;
                u -= F
            }
            return p + N
        }

        function Te(o, u) {
            return u >= o.first && u < o.first + o.size
        }

        function je(o, u) {
            return String(o.lineNumberFormatter(u + o.firstLineNumber))
        }

        function _e(o, u, p) {
            if (p === void 0 && (p = null), !(this instanceof _e)) return new _e(o, u, p);
            this.line = o, this.ch = u, this.sticky = p
        }

        function Qe(o, u) {
            return o.line - u.line || o.ch - u.ch
        }

        function Qt(o, u) {
            return o.sticky == u.sticky && Qe(o, u) == 0
        }

        function tr(o) {
            return _e(o.line, o.ch)
        }

        function Hn(o, u) {
            return Qe(o, u) < 0 ? u : o
        }

        function as(o, u) {
            return Qe(o, u) < 0 ? o : u
        }

        function lf(o, u) {
            return Math.max(o.first, Math.min(u, o.first + o.size - 1))
        }

        function Et(o, u) {
            if (u.line < o.first) return _e(o.first, 0);
            var p = o.first + o.size - 1;
            return u.line > p ? _e(p, dt(o, p).text.length) : _c(u, dt(o, u.line).text.length)
        }

        function _c(o, u) {
            var p = o.ch;
            return p == null || p > u ? _e(o.line, u) : p < 0 ? _e(o.line, 0) : o
        }

        function cf(o, u) {
            for (var p = [], f = 0; f < u.length; f++) p[f] = Et(o, u[f]);
            return p
        }

        var yc = function (o, u) {
            this.state = o, this.lookAhead = u
        }, zi = function (o, u, p, f) {
            this.state = u, this.doc = o, this.line = p, this.maxLookAhead = f || 0, this.baseTokens = null, this.baseTokenPos = 1
        };
        zi.prototype.lookAhead = function (o) {
            var u = this.doc.getLine(this.line + o);
            return u != null && o > this.maxLookAhead && (this.maxLookAhead = o), u
        }, zi.prototype.baseToken = function (o) {
            if (!this.baseTokens) return null;
            for (; this.baseTokens[this.baseTokenPos] <= o;) this.baseTokenPos += 2;
            var u = this.baseTokens[this.baseTokenPos + 1];
            return {type: u && u.replace(/( |^)overlay .*/, ""), size: this.baseTokens[this.baseTokenPos] - o}
        }, zi.prototype.nextLine = function () {
            this.line++, this.maxLookAhead > 0 && this.maxLookAhead--
        }, zi.fromSaved = function (o, u, p) {
            return u instanceof yc ? new zi(o, Ri(o.mode, u.state), p, u.lookAhead) : new zi(o, Ri(o.mode, u), p)
        }, zi.prototype.save = function (o) {
            var u = o !== !1 ? Ri(this.doc.mode, this.state) : this.state;
            return this.maxLookAhead > 0 ? new yc(u, this.maxLookAhead) : u
        };

        function uf(o, u, p, f) {
            var m = [o.state.modeGen], E = {};
            hf(o, u.text, o.doc.mode, p, function (H, X) {
                return m.push(H, X)
            }, E, f);
            for (var N = p.state, P = function (H) {
                p.baseTokens = m;
                var X = o.state.overlays[H], ie = 1, be = 0;
                p.state = !0, hf(o, u.text, X.mode, p, function (fe, xe) {
                    for (var Ne = ie; be < fe;) {
                        var Ve = m[ie];
                        Ve > fe && m.splice(ie, 1, fe, m[ie + 1], Ve), ie += 2, be = Math.min(fe, Ve)
                    }
                    if (xe) if (X.opaque) m.splice(Ne, ie - Ne, fe, "overlay " + xe), ie = Ne + 2; else for (; Ne < ie; Ne += 2) {
                        var $e = m[Ne + 1];
                        m[Ne + 1] = ($e ? $e + " " : "") + "overlay " + xe
                    }
                }, E), p.state = N, p.baseTokens = null, p.baseTokenPos = 1
            }, F = 0; F < o.state.overlays.length; ++F) P(F);
            return {styles: m, classes: E.bgClass || E.textClass ? E : null}
        }

        function ls(o, u, p) {
            if (!u.styles || u.styles[0] != o.state.modeGen) {
                var f = Bo(o, W(u)), m = u.text.length > o.options.maxHighlightLength && Ri(o.doc.mode, f.state),
                    E = uf(o, u, f);
                m && (f.state = m), u.stateAfter = f.save(!m), u.styles = E.styles, E.classes ? u.styleClasses = E.classes : u.styleClasses && (u.styleClasses = null), p === o.doc.highlightFrontier && (o.doc.modeFrontier = Math.max(o.doc.modeFrontier, ++o.doc.highlightFrontier))
            }
            return u.styles
        }

        function Bo(o, u, p) {
            var f = o.doc, m = o.display;
            if (!f.mode.startState) return new zi(f, !0, u);
            var E = Qu(o, u, p), N = E > f.first && dt(f, E - 1).stateAfter,
                P = N ? zi.fromSaved(f, N, E) : new zi(f, Xs(f.mode), E);
            return f.iter(E, u, function (F) {
                Yu(o, F.text, P);
                var H = P.line;
                F.stateAfter = H == u - 1 || H % 5 == 0 || H >= m.viewFrom && H < m.viewTo ? P.save() : null, P.nextLine()
            }), p && (f.modeFrontier = P.line), P
        }

        function Yu(o, u, p, f) {
            var m = o.doc.mode, E = new Tn(u, o.options.tabSize, p);
            for (E.start = E.pos = f || 0, u == "" && cs(m, p.state); !E.eol();) us(m, E, p.state), E.start = E.pos
        }

        function cs(o, u) {
            if (o.blankLine) return o.blankLine(u);
            if (o.innerMode) {
                var p = rl(o, u);
                if (p.mode.blankLine) return p.mode.blankLine(p.state)
            }
        }

        function us(o, u, p, f) {
            for (var m = 0; m < 10; m++) {
                f && (f[0] = rl(o, p).mode);
                var E = o.token(u, p);
                if (u.pos > u.start) return E
            }
            throw new Error("Mode " + o.name + " failed to advance stream.")
        }

        var df = function (o, u, p) {
            this.start = o.start, this.end = o.pos, this.string = o.current(), this.type = u || null, this.state = p
        };

        function il(o, u, p, f) {
            var m = o.doc, E = m.mode, N;
            u = Et(m, u);
            var P = dt(m, u.line), F = Bo(o, u.line, p), H = new Tn(P.text, o.options.tabSize, F), X;
            for (f && (X = []); (f || H.pos < u.ch) && !H.eol();) H.start = H.pos, N = us(E, H, F.state), f && X.push(new df(H, N, Ri(m.mode, F.state)));
            return f ? X : new df(H, N, F.state)
        }

        function Dc(o, u) {
            if (o) for (; ;) {
                var p = o.match(/(?:^|\s+)line-(background-)?(\S+)/);
                if (!p) break;
                o = o.slice(0, p.index) + o.slice(p.index + p[0].length);
                var f = p[1] ? "bgClass" : "textClass";
                u[f] == null ? u[f] = p[2] : new RegExp("(?:^|\\s)" + p[2] + "(?:$|\\s)").test(u[f]) || (u[f] += " " + p[2])
            }
            return o
        }

        function hf(o, u, p, f, m, E, N) {
            var P = p.flattenSpans;
            P == null && (P = o.options.flattenSpans);
            var F = 0, H = null, X = new Tn(u, o.options.tabSize, f), ie, be = o.options.addModeClass && [null];
            for (u == "" && Dc(cs(p, f.state), E); !X.eol();) {
                if (X.pos > o.options.maxHighlightLength ? (P = !1, N && Yu(o, u, f, X.pos), X.pos = u.length, ie = null) : ie = Dc(us(p, X, f.state, be), E), be) {
                    var fe = be[0].name;
                    fe && (ie = "m-" + (ie ? fe + " " + ie : fe))
                }
                if (!P || H != ie) {
                    for (; F < X.start;) F = Math.min(X.start, F + 5e3), m(F, H);
                    H = ie
                }
                X.start = X.pos
            }
            for (; F < X.pos;) {
                var xe = Math.min(X.pos, F + 5e3);
                m(xe, H), F = xe
            }
        }

        function Qu(o, u, p) {
            for (var f, m, E = o.doc, N = p ? -1 : u - (o.doc.mode.innerMode ? 1e3 : 100), P = u; P > N; --P) {
                if (P <= E.first) return E.first;
                var F = dt(E, P - 1), H = F.stateAfter;
                if (H && (!p || P + (H instanceof yc ? H.lookAhead : 0) <= E.modeFrontier)) return P;
                var X = vt(F.text, null, o.options.tabSize);
                (m == null || f > X) && (m = P - 1, f = X)
            }
            return m
        }

        function ea(o, u) {
            if (o.modeFrontier = Math.min(o.modeFrontier, u), !(o.highlightFrontier < u - 10)) {
                for (var p = o.first, f = u - 1; f > p; f--) {
                    var m = dt(o, f).stateAfter;
                    if (m && (!(m instanceof yc) || f + m.lookAhead < u)) {
                        p = f + 1;
                        break
                    }
                }
                o.highlightFrontier = Math.min(o.highlightFrontier, p)
            }
        }

        var ff = !1, ji = !1;

        function gf() {
            ff = !0
        }

        function Dm() {
            ji = !0
        }

        function xc(o, u, p) {
            this.marker = o, this.from = u, this.to = p
        }

        function ds(o, u) {
            if (o) for (var p = 0; p < o.length; ++p) {
                var f = o[p];
                if (f.marker == u) return f
            }
        }

        function xm(o, u) {
            for (var p, f = 0; f < o.length; ++f) o[f] != u && (p || (p = [])).push(o[f]);
            return p
        }

        function pf(o, u, p) {
            var f = p && window.WeakSet && (p.markedSpans || (p.markedSpans = new WeakSet));
            f && o.markedSpans && f.has(o.markedSpans) ? o.markedSpans.push(u) : (o.markedSpans = o.markedSpans ? o.markedSpans.concat([u]) : [u], f && f.add(o.markedSpans)), u.marker.attachLine(o)
        }

        function mf(o, u, p) {
            var f;
            if (o) for (var m = 0; m < o.length; ++m) {
                var E = o[m], N = E.marker, P = E.from == null || (N.inclusiveLeft ? E.from <= u : E.from < u);
                if (P || E.from == u && N.type == "bookmark" && (!p || !E.marker.insertLeft)) {
                    var F = E.to == null || (N.inclusiveRight ? E.to >= u : E.to > u);
                    (f || (f = [])).push(new xc(N, E.from, F ? null : E.to))
                }
            }
            return f
        }

        function bf(o, u, p) {
            var f;
            if (o) for (var m = 0; m < o.length; ++m) {
                var E = o[m], N = E.marker, P = E.to == null || (N.inclusiveRight ? E.to >= u : E.to > u);
                if (P || E.from == u && N.type == "bookmark" && (!p || E.marker.insertLeft)) {
                    var F = E.from == null || (N.inclusiveLeft ? E.from <= u : E.from < u);
                    (f || (f = [])).push(new xc(N, F ? null : E.from - u, E.to == null ? null : E.to - u))
                }
            }
            return f
        }

        function hs(o, u) {
            if (u.full) return null;
            var p = Te(o, u.from.line) && dt(o, u.from.line).markedSpans,
                f = Te(o, u.to.line) && dt(o, u.to.line).markedSpans;
            if (!p && !f) return null;
            var m = u.from.ch, E = u.to.ch, N = Qe(u.from, u.to) == 0, P = mf(p, m, N), F = bf(f, E, N),
                H = u.text.length == 1, X = V(u.text).length + (H ? m : 0);
            if (P) for (var ie = 0; ie < P.length; ++ie) {
                var be = P[ie];
                if (be.to == null) {
                    var fe = ds(F, be.marker);
                    fe ? H && (be.to = fe.to == null ? null : fe.to + X) : be.to = m
                }
            }
            if (F) for (var xe = 0; xe < F.length; ++xe) {
                var Ne = F[xe];
                if (Ne.to != null && (Ne.to += X), Ne.from == null) {
                    var Ve = ds(P, Ne.marker);
                    Ve || (Ne.from = X, H && (P || (P = [])).push(Ne))
                } else Ne.from += X, H && (P || (P = [])).push(Ne)
            }
            P && (P = kf(P)), F && F != P && (F = kf(F));
            var $e = [P];
            if (!H) {
                var et = u.text.length - 2, Ke;
                if (et > 0 && P) for (var at = 0; at < P.length; ++at) P[at].to == null && (Ke || (Ke = [])).push(new xc(P[at].marker, null, null));
                for (var pt = 0; pt < et; ++pt) $e.push(Ke);
                $e.push(F)
            }
            return $e
        }

        function kf(o) {
            for (var u = 0; u < o.length; ++u) {
                var p = o[u];
                p.from != null && p.from == p.to && p.marker.clearWhenEmpty !== !1 && o.splice(u--, 1)
            }
            return o.length ? o : null
        }

        function Ju(o, u, p) {
            var f = null;
            if (o.iter(u.line, p.line + 1, function (fe) {
                if (fe.markedSpans) for (var xe = 0; xe < fe.markedSpans.length; ++xe) {
                    var Ne = fe.markedSpans[xe].marker;
                    Ne.readOnly && (!f || ct(f, Ne) == -1) && (f || (f = [])).push(Ne)
                }
            }), !f) return null;
            for (var m = [{
                from: u,
                to: p
            }], E = 0; E < f.length; ++E) for (var N = f[E], P = N.find(0), F = 0; F < m.length; ++F) {
                var H = m[F];
                if (!(Qe(H.to, P.from) < 0 || Qe(H.from, P.to) > 0)) {
                    var X = [F, 1], ie = Qe(H.from, P.from), be = Qe(H.to, P.to);
                    (ie < 0 || !N.inclusiveLeft && !ie) && X.push({
                        from: H.from,
                        to: P.from
                    }), (be > 0 || !N.inclusiveRight && !be) && X.push({
                        from: P.to,
                        to: H.to
                    }), m.splice.apply(m, X), F += X.length - 3
                }
            }
            return m
        }

        function Xu(o) {
            var u = o.markedSpans;
            if (u) {
                for (var p = 0; p < u.length; ++p) u[p].marker.detachLine(o);
                o.markedSpans = null
            }
        }

        function wn(o, u) {
            if (u) {
                for (var p = 0; p < u.length; ++p) u[p].marker.attachLine(o);
                o.markedSpans = u
            }
        }

        function Ec(o) {
            return o.inclusiveLeft ? -1 : 0
        }

        function ta(o) {
            return o.inclusiveRight ? 1 : 0
        }

        function Sc(o, u) {
            var p = o.lines.length - u.lines.length;
            if (p != 0) return p;
            var f = o.find(), m = u.find(), E = Qe(f.from, m.from) || Ec(o) - Ec(u);
            if (E) return -E;
            var N = Qe(f.to, m.to) || ta(o) - ta(u);
            return N || u.id - o.id
        }

        function na(o, u) {
            var p = ji && o.markedSpans, f;
            if (p) for (var m = void 0, E = 0; E < p.length; ++E) m = p[E], m.marker.collapsed && (u ? m.from : m.to) == null && (!f || Sc(f, m.marker) < 0) && (f = m.marker);
            return f
        }

        function Tc(o) {
            return na(o, !0)
        }

        function ho(o) {
            return na(o, !1)
        }

        function vf(o, u) {
            var p = ji && o.markedSpans, f;
            if (p) for (var m = 0; m < p.length; ++m) {
                var E = p[m];
                E.marker.collapsed && (E.from == null || E.from < u) && (E.to == null || E.to > u) && (!f || Sc(f, E.marker) < 0) && (f = E.marker)
            }
            return f
        }

        function Ic(o, u, p, f, m) {
            var E = dt(o, u), N = ji && E.markedSpans;
            if (N) for (var P = 0; P < N.length; ++P) {
                var F = N[P];
                if (F.marker.collapsed) {
                    var H = F.marker.find(0), X = Qe(H.from, p) || Ec(F.marker) - Ec(m),
                        ie = Qe(H.to, f) || ta(F.marker) - ta(m);
                    if (!(X >= 0 && ie <= 0 || X <= 0 && ie >= 0) && (X <= 0 && (F.marker.inclusiveRight && m.inclusiveLeft ? Qe(H.to, p) >= 0 : Qe(H.to, p) > 0) || X >= 0 && (F.marker.inclusiveRight && m.inclusiveLeft ? Qe(H.from, f) <= 0 : Qe(H.from, f) < 0))) return !0
                }
            }
        }

        function _i(o) {
            for (var u; u = Tc(o);) o = u.find(-1, !0).line;
            return o
        }

        function wf(o) {
            for (var u; u = ho(o);) o = u.find(1, !0).line;
            return o
        }

        function Em(o) {
            for (var u, p; u = ho(o);) o = u.find(1, !0).line, (p || (p = [])).push(o);
            return p
        }

        function ol(o, u) {
            var p = dt(o, u), f = _i(p);
            return p == f ? u : W(f)
        }

        function Af(o, u) {
            if (u > o.lastLine()) return u;
            var p = dt(o, u), f;
            if (!No(o, p)) return u;
            for (; f = ho(p);) p = f.find(1, !0).line;
            return W(p) + 1
        }

        function No(o, u) {
            var p = ji && u.markedSpans;
            if (p) {
                for (var f = void 0, m = 0; m < p.length; ++m) if (f = p[m], !!f.marker.collapsed) {
                    if (f.from == null) return !0;
                    if (!f.marker.widgetNode && f.from == 0 && f.marker.inclusiveLeft && ed(o, u, f)) return !0
                }
            }
        }

        function ed(o, u, p) {
            if (p.to == null) {
                var f = p.marker.find(1, !0);
                return ed(o, f.line, ds(f.line.markedSpans, p.marker))
            }
            if (p.marker.inclusiveRight && p.to == u.text.length) return !0;
            for (var m = void 0, E = 0; E < u.markedSpans.length; ++E) if (m = u.markedSpans[E], m.marker.collapsed && !m.marker.widgetNode && m.from == p.to && (m.to == null || m.to != p.from) && (m.marker.inclusiveLeft || p.marker.inclusiveRight) && ed(o, u, m)) return !0
        }

        function oi(o) {
            o = _i(o);
            for (var u = 0, p = o.parent, f = 0; f < p.lines.length; ++f) {
                var m = p.lines[f];
                if (m == o) break;
                u += m.height
            }
            for (var E = p.parent; E; p = E, E = p.parent) for (var N = 0; N < E.children.length; ++N) {
                var P = E.children[N];
                if (P == p) break;
                u += P.height
            }
            return u
        }

        function ra(o) {
            if (o.height == 0) return 0;
            for (var u = o.text.length, p, f = o; p = Tc(f);) {
                var m = p.find(0, !0);
                f = m.from.line, u += m.from.ch - m.to.ch
            }
            for (f = o; p = ho(f);) {
                var E = p.find(0, !0);
                u -= f.text.length - E.from.ch, f = E.to.line, u += f.text.length - E.to.ch
            }
            return u
        }

        function td(o) {
            var u = o.display, p = o.doc;
            u.maxLine = dt(p, p.first), u.maxLineLength = ra(u.maxLine), u.maxLineChanged = !0, p.iter(function (f) {
                var m = ra(f);
                m > u.maxLineLength && (u.maxLineLength = m, u.maxLine = f)
            })
        }

        var ia = function (o, u, p) {
            this.text = o, wn(this, u), this.height = p ? p(this) : 1
        };
        ia.prototype.lineNo = function () {
            return W(this)
        }, Hr(ia);

        function Sm(o, u, p, f) {
            o.text = u, o.stateAfter && (o.stateAfter = null), o.styles && (o.styles = null), o.order != null && (o.order = null), Xu(o), wn(o, p);
            var m = f ? f(o) : 1;
            m != o.height && mr(o, m)
        }

        function Tm(o) {
            o.parent = null, Xu(o)
        }

        var oa = {}, Im = {};

        function nd(o, u) {
            if (!o || /^\s*$/.test(o)) return null;
            var p = u.addModeClass ? Im : oa;
            return p[o] || (p[o] = o.replace(/\S+/g, "cm-$&"))
        }

        function rd(o, u) {
            var p = qe("span", null, null, I ? "padding-right: .1px" : null), f = {
                pre: qe("pre", [p], "CodeMirror-line"),
                content: p,
                col: 0,
                pos: 0,
                cm: o,
                trailingSpace: !1,
                splitSpaces: o.getOption("lineWrapping")
            };
            u.measure = {};
            for (var m = 0; m <= (u.rest ? u.rest.length : 0); m++) {
                var E = m ? u.rest[m - 1] : u.line, N = void 0;
                f.pos = 0, f.addToken = _f, Zr(o.display.measure) && (N = ot(E, o.doc.direction)) && (f.addToken = Df(f.addToken, N)), f.map = [];
                var P = u != o.display.externalMeasured && W(E);
                Ef(E, f, ls(o, E, P)), E.styleClasses && (E.styleClasses.bgClass && (f.bgClass = _t(E.styleClasses.bgClass, f.bgClass || "")), E.styleClasses.textClass && (f.textClass = _t(E.styleClasses.textClass, f.textClass || ""))), f.map.length == 0 && f.map.push(0, 0, f.content.appendChild(Ac(o.display.measure))), m == 0 ? (u.measure.map = f.map, u.measure.cache = {}) : ((u.measure.maps || (u.measure.maps = [])).push(f.map), (u.measure.caches || (u.measure.caches = [])).push({}))
            }
            if (I) {
                var F = f.content.lastChild;
                (/\bcm-tab\b/.test(F.className) || F.querySelector && F.querySelector(".cm-tab")) && (f.content.className = "cm-tab-wrap-hack")
            }
            return cn(o, "renderLine", o, u.line, f.pre), f.pre.className && (f.textClass = _t(f.pre.className, f.textClass || "")), f
        }

        function Cf(o) {
            var u = ee("span", "•", "cm-invalidchar");
            return u.title = "\\u" + o.charCodeAt(0).toString(16), u.setAttribute("aria-label", u.title), u
        }

        function _f(o, u, p, f, m, E, N) {
            if (u) {
                var P = o.splitSpaces ? yf(u, o.trailingSpace) : u, F = o.cm.state.specialChars, H = !1, X;
                if (!F.test(u)) o.col += u.length, X = document.createTextNode(P), o.map.push(o.pos, o.pos + u.length, X), w && S < 9 && (H = !0), o.pos += u.length; else {
                    X = document.createDocumentFragment();
                    for (var ie = 0; ;) {
                        F.lastIndex = ie;
                        var be = F.exec(u), fe = be ? be.index - ie : u.length - ie;
                        if (fe) {
                            var xe = document.createTextNode(P.slice(ie, ie + fe));
                            w && S < 9 ? X.appendChild(ee("span", [xe])) : X.appendChild(xe), o.map.push(o.pos, o.pos + fe, xe), o.col += fe, o.pos += fe
                        }
                        if (!be) break;
                        ie += fe + 1;
                        var Ne = void 0;
                        if (be[0] == "	") {
                            var Ve = o.cm.options.tabSize, $e = Ve - o.col % Ve;
                            Ne = X.appendChild(ee("span", ze($e), "cm-tab")), Ne.setAttribute("role", "presentation"), Ne.setAttribute("cm-text", "	"), o.col += $e
                        } else be[0] == "\r" || be[0] == `
` ? (Ne = X.appendChild(ee("span", be[0] == "\r" ? "␍" : "␤", "cm-invalidchar")), Ne.setAttribute("cm-text", be[0]), o.col += 1) : (Ne = o.cm.options.specialCharPlaceholder(be[0]), Ne.setAttribute("cm-text", be[0]), w && S < 9 ? X.appendChild(ee("span", [Ne])) : X.appendChild(Ne), o.col += 1);
                        o.map.push(o.pos, o.pos + 1, Ne), o.pos++
                    }
                }
                if (o.trailingSpace = P.charCodeAt(u.length - 1) == 32, p || f || m || H || E || N) {
                    var et = p || "";
                    f && (et += f), m && (et += m);
                    var Ke = ee("span", [X], et, E);
                    if (N) for (var at in N) N.hasOwnProperty(at) && at != "style" && at != "class" && Ke.setAttribute(at, N[at]);
                    return o.content.appendChild(Ke)
                }
                o.content.appendChild(X)
            }
        }

        function yf(o, u) {
            if (o.length > 1 && !/  /.test(o)) return o;
            for (var p = u, f = "", m = 0; m < o.length; m++) {
                var E = o.charAt(m);
                E == " " && p && (m == o.length - 1 || o.charCodeAt(m + 1) == 32) && (E = " "), f += E, p = E == " "
            }
            return f
        }

        function Df(o, u) {
            return function (p, f, m, E, N, P, F) {
                m = m ? m + " cm-force-border" : "cm-force-border";
                for (var H = p.pos, X = H + f.length; ;) {
                    for (var ie = void 0, be = 0; be < u.length && (ie = u[be], !(ie.to > H && ie.from <= H)); be++) ;
                    if (ie.to >= X) return o(p, f, m, E, N, P, F);
                    o(p, f.slice(0, ie.to - H), m, E, null, P, F), E = null, f = f.slice(ie.to - H), H = ie.to
                }
            }
        }

        function xf(o, u, p, f) {
            var m = !f && p.widgetNode;
            m && o.map.push(o.pos, o.pos + u, m), !f && o.cm.display.input.needsContentAttribute && (m || (m = o.content.appendChild(document.createElement("span"))), m.setAttribute("cm-marker", p.id)), m && (o.cm.display.input.setUneditable(m), o.content.appendChild(m)), o.pos += u, o.trailingSpace = !1
        }

        function Ef(o, u, p) {
            var f = o.markedSpans, m = o.text, E = 0;
            if (!f) {
                for (var N = 1; N < p.length; N += 2) u.addToken(u, m.slice(E, E = p[N]), nd(p[N + 1], u.cm.options));
                return
            }
            for (var P = m.length, F = 0, H = 1, X = "", ie, be, fe = 0, xe, Ne, Ve, $e, et; ;) {
                if (fe == F) {
                    xe = Ne = Ve = be = "", et = null, $e = null, fe = 1 / 0;
                    for (var Ke = [], at = void 0, pt = 0; pt < f.length; ++pt) {
                        var gt = f[pt], Mt = gt.marker;
                        if (Mt.type == "bookmark" && gt.from == F && Mt.widgetNode) Ke.push(Mt); else if (gt.from <= F && (gt.to == null || gt.to > F || Mt.collapsed && gt.to == F && gt.from == F)) {
                            if (gt.to != null && gt.to != F && fe > gt.to && (fe = gt.to, Ne = ""), Mt.className && (xe += " " + Mt.className), Mt.css && (be = (be ? be + ";" : "") + Mt.css), Mt.startStyle && gt.from == F && (Ve += " " + Mt.startStyle), Mt.endStyle && gt.to == fe && (at || (at = [])).push(Mt.endStyle, gt.to), Mt.title && ((et || (et = {})).title = Mt.title), Mt.attributes) for (var hn in Mt.attributes) (et || (et = {}))[hn] = Mt.attributes[hn];
                            Mt.collapsed && (!$e || Sc($e.marker, Mt) < 0) && ($e = gt)
                        } else gt.from > F && fe > gt.from && (fe = gt.from)
                    }
                    if (at) for (var $n = 0; $n < at.length; $n += 2) at[$n + 1] == fe && (Ne += " " + at[$n]);
                    if (!$e || $e.from == F) for (var Dn = 0; Dn < Ke.length; ++Dn) xf(u, 0, Ke[Dn]);
                    if ($e && ($e.from || 0) == F) {
                        if (xf(u, ($e.to == null ? P + 1 : $e.to) - F, $e.marker, $e.from == null), $e.to == null) return;
                        $e.to == F && ($e = !1)
                    }
                }
                if (F >= P) break;
                for (var Pr = Math.min(P, fe); ;) {
                    if (X) {
                        var En = F + X.length;
                        if (!$e) {
                            var Ln = En > Pr ? X.slice(0, Pr - F) : X;
                            u.addToken(u, Ln, ie ? ie + xe : xe, Ve, F + Ln.length == fe ? Ne : "", be, et)
                        }
                        if (En >= Pr) {
                            X = X.slice(Pr - F), F = Pr;
                            break
                        }
                        F = En, Ve = ""
                    }
                    X = m.slice(E, E = p[H++]), ie = nd(p[H++], u.cm.options)
                }
            }
        }

        function Sf(o, u, p) {
            this.line = u, this.rest = Em(u), this.size = this.rest ? W(V(this.rest)) - p + 1 : 1, this.node = this.text = null, this.hidden = No(o, u)
        }

        function sl(o, u, p) {
            for (var f = [], m, E = u; E < p; E = m) {
                var N = new Sf(o.doc, dt(o.doc, E), E);
                m = E + N.size, f.push(N)
            }
            return f
        }

        var Lo = null;

        function Mm(o) {
            Lo ? Lo.ops.push(o) : o.ownsGroup = Lo = {ops: [o], delayedCallbacks: []}
        }

        function Tf(o) {
            var u = o.delayedCallbacks, p = 0;
            do {
                for (; p < u.length; p++) u[p].call(null);
                for (var f = 0; f < o.ops.length; f++) {
                    var m = o.ops[f];
                    if (m.cursorActivityHandlers) for (; m.cursorActivityCalled < m.cursorActivityHandlers.length;) m.cursorActivityHandlers[m.cursorActivityCalled++].call(null, m.cm)
                }
            } while (p < u.length)
        }

        function If(o, u) {
            var p = o.ownsGroup;
            if (p) try {
                Tf(p)
            } finally {
                Lo = null, u(p)
            }
        }

        var al = null;

        function Un(o, u) {
            var p = Ir(o, u);
            if (p.length) {
                var f = Array.prototype.slice.call(arguments, 2), m;
                Lo ? m = Lo.delayedCallbacks : al ? m = al : (m = al = [], setTimeout(id, 0));
                for (var E = function (P) {
                    m.push(function () {
                        return p[P].apply(null, f)
                    })
                }, N = 0; N < p.length; ++N) E(N)
            }
        }

        function id() {
            var o = al;
            al = null;
            for (var u = 0; u < o.length; ++u) o[u]()
        }

        function Mf(o, u, p, f) {
            for (var m = 0; m < u.changes.length; m++) {
                var E = u.changes[m];
                E == "text" ? sd(o, u) : E == "gutter" ? ad(o, u, p, f) : E == "class" ? Bc(o, u) : E == "widget" && Bf(o, u, f)
            }
            u.changes = null
        }

        function fs(o) {
            return o.node == o.text && (o.node = ee("div", null, null, "position: relative"), o.text.parentNode && o.text.parentNode.replaceChild(o.node, o.text), o.node.appendChild(o.text), w && S < 8 && (o.node.style.zIndex = 2)), o.node
        }

        function od(o, u) {
            var p = u.bgClass ? u.bgClass + " " + (u.line.bgClass || "") : u.line.bgClass;
            if (p && (p += " CodeMirror-linebackground"), u.background) p ? u.background.className = p : (u.background.parentNode.removeChild(u.background), u.background = null); else if (p) {
                var f = fs(u);
                u.background = f.insertBefore(ee("div", null, p), f.firstChild), o.display.input.setUneditable(u.background)
            }
        }

        function Mc(o, u) {
            var p = o.display.externalMeasured;
            return p && p.line == u.line ? (o.display.externalMeasured = null, u.measure = p.measure, p.built) : rd(o, u)
        }

        function sd(o, u) {
            var p = u.text.className, f = Mc(o, u);
            u.text == u.node && (u.node = f.pre), u.text.parentNode.replaceChild(f.pre, u.text), u.text = f.pre, f.bgClass != u.bgClass || f.textClass != u.textClass ? (u.bgClass = f.bgClass, u.textClass = f.textClass, Bc(o, u)) : p && (u.text.className = p)
        }

        function Bc(o, u) {
            od(o, u), u.line.wrapClass ? fs(u).className = u.line.wrapClass : u.node != u.text && (u.node.className = "");
            var p = u.textClass ? u.textClass + " " + (u.line.textClass || "") : u.line.textClass;
            u.text.className = p || ""
        }

        function ad(o, u, p, f) {
            if (u.gutter && (u.node.removeChild(u.gutter), u.gutter = null), u.gutterBackground && (u.node.removeChild(u.gutterBackground), u.gutterBackground = null), u.line.gutterClass) {
                var m = fs(u);
                u.gutterBackground = ee("div", null, "CodeMirror-gutter-background " + u.line.gutterClass, "left: " + (o.options.fixedGutter ? f.fixedPos : -f.gutterTotalWidth) + "px; width: " + f.gutterTotalWidth + "px"), o.display.input.setUneditable(u.gutterBackground), m.insertBefore(u.gutterBackground, u.text)
            }
            var E = u.line.gutterMarkers;
            if (o.options.lineNumbers || E) {
                var N = fs(u),
                    P = u.gutter = ee("div", null, "CodeMirror-gutter-wrapper", "left: " + (o.options.fixedGutter ? f.fixedPos : -f.gutterTotalWidth) + "px");
                if (P.setAttribute("aria-hidden", "true"), o.display.input.setUneditable(P), N.insertBefore(P, u.text), u.line.gutterClass && (P.className += " " + u.line.gutterClass), o.options.lineNumbers && (!E || !E["CodeMirror-linenumbers"]) && (u.lineNumber = P.appendChild(ee("div", je(o.options, p), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + f.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + o.display.lineNumInnerWidth + "px"))), E) for (var F = 0; F < o.display.gutterSpecs.length; ++F) {
                    var H = o.display.gutterSpecs[F].className, X = E.hasOwnProperty(H) && E[H];
                    X && P.appendChild(ee("div", [X], "CodeMirror-gutter-elt", "left: " + f.gutterLeft[H] + "px; width: " + f.gutterWidth[H] + "px"))
                }
            }
        }

        function Bf(o, u, p) {
            u.alignable && (u.alignable = null);
            for (var f = ve("CodeMirror-linewidget"), m = u.node.firstChild, E = void 0; m; m = E) E = m.nextSibling, f.test(m.className) && u.node.removeChild(m);
            ld(o, u, p)
        }

        function Nf(o, u, p, f) {
            var m = Mc(o, u);
            return u.text = u.node = m.pre, m.bgClass && (u.bgClass = m.bgClass), m.textClass && (u.textClass = m.textClass), Bc(o, u), ad(o, u, p, f), ld(o, u, f), u.node
        }

        function ld(o, u, p) {
            if (Lf(o, u.line, u, p, !0), u.rest) for (var f = 0; f < u.rest.length; f++) Lf(o, u.rest[f], u, p, !1)
        }

        function Lf(o, u, p, f, m) {
            if (u.widgets) for (var E = fs(p), N = 0, P = u.widgets; N < P.length; ++N) {
                var F = P[N], H = ee("div", [F.node], "CodeMirror-linewidget" + (F.className ? " " + F.className : ""));
                F.handleMouseEvents || H.setAttribute("cm-ignore-events", "true"), Bm(F, H, p, f), o.display.input.setUneditable(H), m && F.above ? E.insertBefore(H, p.gutter || p.text) : E.appendChild(H), Un(F, "redraw")
            }
        }

        function Bm(o, u, p, f) {
            if (o.noHScroll) {
                (p.alignable || (p.alignable = [])).push(u);
                var m = f.wrapperWidth;
                u.style.left = f.fixedPos + "px", o.coverGutter || (m -= f.gutterTotalWidth, u.style.paddingLeft = f.gutterTotalWidth + "px"), u.style.width = m + "px"
            }
            o.coverGutter && (u.style.zIndex = 5, u.style.position = "relative", o.noHScroll || (u.style.marginLeft = -f.gutterTotalWidth + "px"))
        }

        function ll(o) {
            if (o.height != null) return o.height;
            var u = o.doc.cm;
            if (!u) return 0;
            if (!Xe(document.body, o.node)) {
                var p = "position: relative;";
                o.coverGutter && (p += "margin-left: -" + u.display.gutters.offsetWidth + "px;"), o.noHScroll && (p += "width: " + u.display.wrapper.clientWidth + "px;"), ye(u.display.measure, ee("div", [o.node], null, p))
            }
            return o.height = o.node.parentNode.offsetHeight
        }

        function fo(o, u) {
            for (var p = To(u); p != o.wrapper; p = p.parentNode) if (!p || p.nodeType == 1 && p.getAttribute("cm-ignore-events") == "true" || p.parentNode == o.sizer && p != o.mover) return !0
        }

        function Nc(o) {
            return o.lineSpace.offsetTop
        }

        function go(o) {
            return o.mover.offsetHeight - o.lineSpace.offsetHeight
        }

        function sa(o) {
            if (o.cachedPaddingH) return o.cachedPaddingH;
            var u = ye(o.measure, ee("pre", "x", "CodeMirror-line-like")),
                p = window.getComputedStyle ? window.getComputedStyle(u) : u.currentStyle,
                f = {left: parseInt(p.paddingLeft), right: parseInt(p.paddingRight)};
            return !isNaN(f.left) && !isNaN(f.right) && (o.cachedPaddingH = f), f
        }

        function Vi(o) {
            return se - o.display.nativeBarWidth
        }

        function gs(o) {
            return o.display.scroller.clientWidth - Vi(o) - o.display.barWidth
        }

        function aa(o) {
            return o.display.scroller.clientHeight - Vi(o) - o.display.barHeight
        }

        function cd(o, u, p) {
            var f = o.options.lineWrapping, m = f && gs(o);
            if (!u.measure.heights || f && u.measure.width != m) {
                var E = u.measure.heights = [];
                if (f) {
                    u.measure.width = m;
                    for (var N = u.text.firstChild.getClientRects(), P = 0; P < N.length - 1; P++) {
                        var F = N[P], H = N[P + 1];
                        Math.abs(F.bottom - H.bottom) > 2 && E.push((F.bottom + H.top) / 2 - p.top)
                    }
                }
                E.push(p.bottom - p.top)
            }
        }

        function Pf(o, u, p) {
            if (o.line == u) return {map: o.measure.map, cache: o.measure.cache};
            if (o.rest) {
                for (var f = 0; f < o.rest.length; f++) if (o.rest[f] == u) return {
                    map: o.measure.maps[f],
                    cache: o.measure.caches[f]
                };
                for (var m = 0; m < o.rest.length; m++) if (W(o.rest[m]) > p) return {
                    map: o.measure.maps[m],
                    cache: o.measure.caches[m],
                    before: !0
                }
            }
        }

        function Nm(o, u) {
            u = _i(u);
            var p = W(u), f = o.display.externalMeasured = new Sf(o.doc, u, p);
            f.lineN = p;
            var m = f.built = rd(o, f);
            return f.text = m.pre, ye(o.display.lineMeasure, m.pre), f
        }

        function Of(o, u, p, f) {
            return Hi(o, ps(o, u), p, f)
        }

        function Lc(o, u) {
            if (u >= o.display.viewFrom && u < o.display.viewTo) return o.display.view[Fo(o, u)];
            var p = o.display.externalMeasured;
            if (p && u >= p.lineN && u < p.lineN + p.size) return p
        }

        function ps(o, u) {
            var p = W(u), f = Lc(o, p);
            f && !f.text ? f = null : f && f.changes && (Mf(o, f, p, fl(o)), o.curOp.forceUpdate = !0), f || (f = Nm(o, u));
            var m = Pf(f, u, p);
            return {line: u, view: f, rect: null, map: m.map, cache: m.cache, before: m.before, hasHeights: !1}
        }

        function Hi(o, u, p, f, m) {
            u.before && (p = -1);
            var E = p + (f || ""), N;
            return u.cache.hasOwnProperty(E) ? N = u.cache[E] : (u.rect || (u.rect = u.view.text.getBoundingClientRect()), u.hasHeights || (cd(o, u.view, u.rect), u.hasHeights = !0), N = Lm(o, u, p, f), N.bogus || (u.cache[E] = N)), {
                left: N.left,
                right: N.right,
                top: m ? N.rtop : N.top,
                bottom: m ? N.rbottom : N.bottom
            }
        }

        var ud = {left: 0, right: 0, top: 0, bottom: 0};

        function Ff(o, u, p) {
            for (var f, m, E, N, P, F, H = 0; H < o.length; H += 3) if (P = o[H], F = o[H + 1], u < P ? (m = 0, E = 1, N = "left") : u < F ? (m = u - P, E = m + 1) : (H == o.length - 3 || u == F && o[H + 3] > u) && (E = F - P, m = E - 1, u >= F && (N = "right")), m != null) {
                if (f = o[H + 2], P == F && p == (f.insertLeft ? "left" : "right") && (N = p), p == "left" && m == 0) for (; H && o[H - 2] == o[H - 3] && o[H - 1].insertLeft;) f = o[(H -= 3) + 2], N = "left";
                if (p == "right" && m == F - P) for (; H < o.length - 3 && o[H + 3] == o[H + 4] && !o[H + 5].insertLeft;) f = o[(H += 3) + 2], N = "right";
                break
            }
            return {node: f, start: m, end: E, collapse: N, coverStart: P, coverEnd: F}
        }

        function Rf(o, u) {
            var p = ud;
            if (u == "left") for (var f = 0; f < o.length && (p = o[f]).left == p.right; f++) ; else for (var m = o.length - 1; m >= 0 && (p = o[m]).left == p.right; m--) ;
            return p
        }

        function Lm(o, u, p, f) {
            var m = Ff(u.map, p, f), E = m.node, N = m.start, P = m.end, F = m.collapse, H;
            if (E.nodeType == 3) {
                for (var X = 0; X < 4; X++) {
                    for (; N && st(u.line.text.charAt(m.coverStart + N));) --N;
                    for (; m.coverStart + P < m.coverEnd && st(u.line.text.charAt(m.coverStart + P));) ++P;
                    if (w && S < 9 && N == 0 && P == m.coverEnd - m.coverStart ? H = E.parentNode.getBoundingClientRect() : H = Rf(Ze(E, N, P).getClientRects(), f), H.left || H.right || N == 0) break;
                    P = N, N = N - 1, F = "right"
                }
                w && S < 11 && (H = zf(o.display.measure, H))
            } else {
                N > 0 && (F = f = "right");
                var ie;
                o.options.lineWrapping && (ie = E.getClientRects()).length > 1 ? H = ie[f == "right" ? ie.length - 1 : 0] : H = E.getBoundingClientRect()
            }
            if (w && S < 9 && !N && (!H || !H.left && !H.right)) {
                var be = E.parentNode.getClientRects()[0];
                be ? H = {left: be.left, right: be.left + ms(o.display), top: be.top, bottom: be.bottom} : H = ud
            }
            for (var fe = H.top - u.rect.top, xe = H.bottom - u.rect.top, Ne = (fe + xe) / 2, Ve = u.view.measure.heights, $e = 0; $e < Ve.length - 1 && !(Ne < Ve[$e]); $e++) ;
            var et = $e ? Ve[$e - 1] : 0, Ke = Ve[$e], at = {
                left: (F == "right" ? H.right : H.left) - u.rect.left,
                right: (F == "left" ? H.left : H.right) - u.rect.left,
                top: et,
                bottom: Ke
            };
            return !H.left && !H.right && (at.bogus = !0), o.options.singleCursorHeightPerLine || (at.rtop = fe, at.rbottom = xe), at
        }

        function zf(o, u) {
            if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !Zu(o)) return u;
            var p = screen.logicalXDPI / screen.deviceXDPI, f = screen.logicalYDPI / screen.deviceYDPI;
            return {left: u.left * p, right: u.right * p, top: u.top * f, bottom: u.bottom * f}
        }

        function jf(o) {
            if (o.measure && (o.measure.cache = {}, o.measure.heights = null, o.rest)) for (var u = 0; u < o.rest.length; u++) o.measure.caches[u] = {}
        }

        function dd(o) {
            o.display.externalMeasure = null, le(o.display.lineMeasure);
            for (var u = 0; u < o.display.view.length; u++) jf(o.display.view[u])
        }

        function cl(o) {
            dd(o), o.display.cachedCharWidth = o.display.cachedTextHeight = o.display.cachedPaddingH = null, o.options.lineWrapping || (o.display.maxLineChanged = !0), o.display.lineNumChars = null
        }

        function Vf(o) {
            return D && Z ? -(o.body.getBoundingClientRect().left - parseInt(getComputedStyle(o.body).marginLeft)) : o.defaultView.pageXOffset || (o.documentElement || o.body).scrollLeft
        }

        function hd(o) {
            return D && Z ? -(o.body.getBoundingClientRect().top - parseInt(getComputedStyle(o.body).marginTop)) : o.defaultView.pageYOffset || (o.documentElement || o.body).scrollTop
        }

        function fd(o) {
            var u = _i(o), p = u.widgets, f = 0;
            if (p) for (var m = 0; m < p.length; ++m) p[m].above && (f += ll(p[m]));
            return f
        }

        function ul(o, u, p, f, m) {
            if (!m) {
                var E = fd(u);
                p.top += E, p.bottom += E
            }
            if (f == "line") return p;
            f || (f = "local");
            var N = oi(u);
            if (f == "local" ? N += Nc(o.display) : N -= o.display.viewOffset, f == "page" || f == "window") {
                var P = o.display.lineSpace.getBoundingClientRect();
                N += P.top + (f == "window" ? 0 : hd(Pe(o)));
                var F = P.left + (f == "window" ? 0 : Vf(Pe(o)));
                p.left += F, p.right += F
            }
            return p.top += N, p.bottom += N, p
        }

        function gd(o, u, p) {
            if (p == "div") return u;
            var f = u.left, m = u.top;
            if (p == "page") f -= Vf(Pe(o)), m -= hd(Pe(o)); else if (p == "local" || !p) {
                var E = o.display.sizer.getBoundingClientRect();
                f += E.left, m += E.top
            }
            var N = o.display.lineSpace.getBoundingClientRect();
            return {left: f - N.left, top: m - N.top}
        }

        function dl(o, u, p, f, m) {
            return f || (f = dt(o.doc, u.line)), ul(o, f, Of(o, f, u.ch, m), p)
        }

        function Ht(o, u, p, f, m, E) {
            f = f || dt(o.doc, u.line), m || (m = ps(o, f));

            function N(xe, Ne) {
                var Ve = Hi(o, m, xe, Ne ? "right" : "left", E);
                return Ne ? Ve.left = Ve.right : Ve.right = Ve.left, ul(o, f, Ve, p)
            }

            var P = ot(f, o.doc.direction), F = u.ch, H = u.sticky;
            if (F >= f.text.length ? (F = f.text.length, H = "before") : F <= 0 && (F = 0, H = "after"), !P) return N(H == "before" ? F - 1 : F, H == "before");

            function X(xe, Ne, Ve) {
                var $e = P[Ne], et = $e.level == 1;
                return N(Ve ? xe - 1 : xe, et != Ve)
            }

            var ie = Ot(P, F, H), be = $t, fe = X(F, ie, H == "before");
            return be != null && (fe.other = X(F, be, H != "before")), fe
        }

        function Pc(o, u) {
            var p = 0;
            u = Et(o.doc, u), o.options.lineWrapping || (p = ms(o.display) * u.ch);
            var f = dt(o.doc, u.line), m = oi(f) + Nc(o.display);
            return {left: p, right: p, top: m, bottom: m + f.height}
        }

        function hl(o, u, p, f, m) {
            var E = _e(o, u, p);
            return E.xRel = m, f && (E.outside = f), E
        }

        function po(o, u, p) {
            var f = o.doc;
            if (p += o.display.viewOffset, p < 0) return hl(f.first, 0, null, -1, -1);
            var m = re(f, p), E = f.first + f.size - 1;
            if (m > E) return hl(f.first + f.size - 1, dt(f, E).text.length, null, 1, 1);
            u < 0 && (u = 0);
            for (var N = dt(f, m); ;) {
                var P = Po(o, N, m, u, p), F = vf(N, P.ch + (P.xRel > 0 || P.outside > 0 ? 1 : 0));
                if (!F) return P;
                var H = F.find(1);
                if (H.line == m) return H;
                N = dt(f, m = H.line)
            }
        }

        function pd(o, u, p, f) {
            f -= fd(u);
            var m = u.text.length, E = zt(function (N) {
                return Hi(o, p, N - 1).bottom <= f
            }, m, 0);
            return m = zt(function (N) {
                return Hi(o, p, N).top > f
            }, E, m), {begin: E, end: m}
        }

        function md(o, u, p, f) {
            p || (p = ps(o, u));
            var m = ul(o, u, Hi(o, p, f), "line").top;
            return pd(o, u, p, m)
        }

        function bd(o, u, p, f) {
            return o.bottom <= p ? !1 : o.top > p ? !0 : (f ? o.left : o.right) > u
        }

        function Po(o, u, p, f, m) {
            m -= oi(u);
            var E = ps(o, u), N = fd(u), P = 0, F = u.text.length, H = !0, X = ot(u, o.doc.direction);
            if (X) {
                var ie = (o.options.lineWrapping ? Hf : Oc)(o, u, p, E, X, f, m);
                H = ie.level != 1, P = H ? ie.from : ie.to - 1, F = H ? ie.to : ie.from - 1
            }
            var be = null, fe = null, xe = zt(function (pt) {
                var gt = Hi(o, E, pt);
                return gt.top += N, gt.bottom += N, bd(gt, f, m, !1) ? (gt.top <= m && gt.left <= f && (be = pt, fe = gt), !0) : !1
            }, P, F), Ne, Ve, $e = !1;
            if (fe) {
                var et = f - fe.left < fe.right - f, Ke = et == H;
                xe = be + (Ke ? 0 : 1), Ve = Ke ? "after" : "before", Ne = et ? fe.left : fe.right
            } else {
                !H && (xe == F || xe == P) && xe++, Ve = xe == 0 ? "after" : xe == u.text.length ? "before" : Hi(o, E, xe - (H ? 1 : 0)).bottom + N <= m == H ? "after" : "before";
                var at = Ht(o, _e(p, xe, Ve), "line", u, E);
                Ne = at.left, $e = m < at.top ? -1 : m >= at.bottom ? 1 : 0
            }
            return xe = Dt(u.text, xe, 1), hl(p, xe, Ve, $e, f - Ne)
        }

        function Oc(o, u, p, f, m, E, N) {
            var P = zt(function (ie) {
                var be = m[ie], fe = be.level != 1;
                return bd(Ht(o, _e(p, fe ? be.to : be.from, fe ? "before" : "after"), "line", u, f), E, N, !0)
            }, 0, m.length - 1), F = m[P];
            if (P > 0) {
                var H = F.level != 1, X = Ht(o, _e(p, H ? F.from : F.to, H ? "after" : "before"), "line", u, f);
                bd(X, E, N, !0) && X.top > N && (F = m[P - 1])
            }
            return F
        }

        function Hf(o, u, p, f, m, E, N) {
            var P = pd(o, u, f, N), F = P.begin, H = P.end;
            /\s/.test(u.text.charAt(H - 1)) && H--;
            for (var X = null, ie = null, be = 0; be < m.length; be++) {
                var fe = m[be];
                if (!(fe.from >= H || fe.to <= F)) {
                    var xe = fe.level != 1, Ne = Hi(o, f, xe ? Math.min(H, fe.to) - 1 : Math.max(F, fe.from)).right,
                        Ve = Ne < E ? E - Ne + 1e9 : Ne - E;
                    (!X || ie > Ve) && (X = fe, ie = Ve)
                }
            }
            return X || (X = m[m.length - 1]), X.from < F && (X = {
                from: F,
                to: X.to,
                level: X.level
            }), X.to > H && (X = {from: X.from, to: H, level: X.level}), X
        }

        var dr;

        function la(o) {
            if (o.cachedTextHeight != null) return o.cachedTextHeight;
            if (dr == null) {
                dr = ee("pre", null, "CodeMirror-line-like");
                for (var u = 0; u < 49; ++u) dr.appendChild(document.createTextNode("x")), dr.appendChild(ee("br"));
                dr.appendChild(document.createTextNode("x"))
            }
            ye(o.measure, dr);
            var p = dr.offsetHeight / 50;
            return p > 3 && (o.cachedTextHeight = p), le(o.measure), p || 1
        }

        function ms(o) {
            if (o.cachedCharWidth != null) return o.cachedCharWidth;
            var u = ee("span", "xxxxxxxxxx"), p = ee("pre", [u], "CodeMirror-line-like");
            ye(o.measure, p);
            var f = u.getBoundingClientRect(), m = (f.right - f.left) / 10;
            return m > 2 && (o.cachedCharWidth = m), m || 10
        }

        function fl(o) {
            for (var u = o.display, p = {}, f = {}, m = u.gutters.clientLeft, E = u.gutters.firstChild, N = 0; E; E = E.nextSibling, ++N) {
                var P = o.display.gutterSpecs[N].className;
                p[P] = E.offsetLeft + E.clientLeft + m, f[P] = E.clientWidth
            }
            return {
                fixedPos: bt(u),
                gutterTotalWidth: u.gutters.offsetWidth,
                gutterLeft: p,
                gutterWidth: f,
                wrapperWidth: u.wrapper.clientWidth
            }
        }

        function bt(o) {
            return o.scroller.getBoundingClientRect().left - o.sizer.getBoundingClientRect().left
        }

        function jn(o) {
            var u = la(o.display), p = o.options.lineWrapping,
                f = p && Math.max(5, o.display.scroller.clientWidth / ms(o.display) - 3);
            return function (m) {
                if (No(o.doc, m)) return 0;
                var E = 0;
                if (m.widgets) for (var N = 0; N < m.widgets.length; N++) m.widgets[N].height && (E += m.widgets[N].height);
                return p ? E + (Math.ceil(m.text.length / f) || 1) * u : E + u
            }
        }

        function ca(o) {
            var u = o.doc, p = jn(o);
            u.iter(function (f) {
                var m = p(f);
                m != f.height && mr(f, m)
            })
        }

        function Oo(o, u, p, f) {
            var m = o.display;
            if (!p && To(u).getAttribute("cm-not-content") == "true") return null;
            var E, N, P = m.lineSpace.getBoundingClientRect();
            try {
                E = u.clientX - P.left, N = u.clientY - P.top
            } catch {
                return null
            }
            var F = po(o, E, N), H;
            if (f && F.xRel > 0 && (H = dt(o.doc, F.line).text).length == F.ch) {
                var X = vt(H, H.length, o.options.tabSize) - H.length;
                F = _e(F.line, Math.max(0, Math.round((E - sa(o.display).left) / ms(o.display)) - X))
            }
            return F
        }

        function Fo(o, u) {
            if (u >= o.display.viewTo || (u -= o.display.viewFrom, u < 0)) return null;
            for (var p = o.display.view, f = 0; f < p.length; f++) if (u -= p[f].size, u < 0) return f
        }

        function Cr(o, u, p, f) {
            u == null && (u = o.doc.first), p == null && (p = o.doc.first + o.doc.size), f || (f = 0);
            var m = o.display;
            if (f && p < m.viewTo && (m.updateLineNumbers == null || m.updateLineNumbers > u) && (m.updateLineNumbers = u), o.curOp.viewChanged = !0, u >= m.viewTo) ji && ol(o.doc, u) < m.viewTo && yi(o); else if (p <= m.viewFrom) ji && Af(o.doc, p + f) > m.viewFrom ? yi(o) : (m.viewFrom += f, m.viewTo += f); else if (u <= m.viewFrom && p >= m.viewTo) yi(o); else if (u <= m.viewFrom) {
                var E = gl(o, p, p + f, 1);
                E ? (m.view = m.view.slice(E.index), m.viewFrom = E.lineN, m.viewTo += f) : yi(o)
            } else if (p >= m.viewTo) {
                var N = gl(o, u, u, -1);
                N ? (m.view = m.view.slice(0, N.index), m.viewTo = N.lineN) : yi(o)
            } else {
                var P = gl(o, u, u, -1), F = gl(o, p, p + f, 1);
                P && F ? (m.view = m.view.slice(0, P.index).concat(sl(o, P.lineN, F.lineN)).concat(m.view.slice(F.index)), m.viewTo += f) : yi(o)
            }
            var H = m.externalMeasured;
            H && (p < H.lineN ? H.lineN += f : u < H.lineN + H.size && (m.externalMeasured = null))
        }

        function Lt(o, u, p) {
            o.curOp.viewChanged = !0;
            var f = o.display, m = o.display.externalMeasured;
            if (m && u >= m.lineN && u < m.lineN + m.size && (f.externalMeasured = null), !(u < f.viewFrom || u >= f.viewTo)) {
                var E = f.view[Fo(o, u)];
                if (E.node != null) {
                    var N = E.changes || (E.changes = []);
                    ct(N, p) == -1 && N.push(p)
                }
            }
        }

        function yi(o) {
            o.display.viewFrom = o.display.viewTo = o.doc.first, o.display.view = [], o.display.viewOffset = 0
        }

        function gl(o, u, p, f) {
            var m = Fo(o, u), E, N = o.display.view;
            if (!ji || p == o.doc.first + o.doc.size) return {index: m, lineN: p};
            for (var P = o.display.viewFrom, F = 0; F < m; F++) P += N[F].size;
            if (P != u) {
                if (f > 0) {
                    if (m == N.length - 1) return null;
                    E = P + N[m].size - u, m++
                } else E = P - u;
                u += E, p += E
            }
            for (; ol(o.doc, p) != p;) {
                if (m == (f < 0 ? 0 : N.length - 1)) return null;
                p += f * N[m - (f < 0 ? 1 : 0)].size, m += f
            }
            return {index: m, lineN: p}
        }

        function kd(o, u, p) {
            var f = o.display, m = f.view;
            m.length == 0 || u >= f.viewTo || p <= f.viewFrom ? (f.view = sl(o, u, p), f.viewFrom = u) : (f.viewFrom > u ? f.view = sl(o, u, f.viewFrom).concat(f.view) : f.viewFrom < u && (f.view = f.view.slice(Fo(o, u))), f.viewFrom = u, f.viewTo < p ? f.view = f.view.concat(sl(o, f.viewTo, p)) : f.viewTo > p && (f.view = f.view.slice(0, Fo(o, p)))), f.viewTo = p
        }

        function vd(o) {
            for (var u = o.display.view, p = 0, f = 0; f < u.length; f++) {
                var m = u[f];
                !m.hidden && (!m.node || m.changes) && ++p
            }
            return p
        }

        function _n(o) {
            o.display.input.showSelection(o.display.input.prepareSelection())
        }

        function ua(o, u) {
            u === void 0 && (u = !0);
            var p = o.doc, f = {}, m = f.cursors = document.createDocumentFragment(),
                E = f.selection = document.createDocumentFragment(), N = o.options.$customCursor;
            N && (u = !0);
            for (var P = 0; P < p.sel.ranges.length; P++) if (!(!u && P == p.sel.primIndex)) {
                var F = p.sel.ranges[P];
                if (!(F.from().line >= o.display.viewTo || F.to().line < o.display.viewFrom)) {
                    var H = F.empty();
                    if (N) {
                        var X = N(o, F);
                        X && Fc(o, X, m)
                    } else (H || o.options.showCursorWhenSelecting) && Fc(o, F.head, m);
                    H || Rc(o, F, E)
                }
            }
            return f
        }

        function Fc(o, u, p) {
            var f = Ht(o, u, "div", null, null, !o.options.singleCursorHeightPerLine),
                m = p.appendChild(ee("div", " ", "CodeMirror-cursor"));
            if (m.style.left = f.left + "px", m.style.top = f.top + "px", m.style.height = Math.max(0, f.bottom - f.top) * o.options.cursorHeight + "px", /\bcm-fat-cursor\b/.test(o.getWrapperElement().className)) {
                var E = dl(o, u, "div", null, null), N = E.right - E.left;
                m.style.width = (N > 0 ? N : o.defaultCharWidth()) + "px"
            }
            if (f.other) {
                var P = p.appendChild(ee("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
                P.style.display = "", P.style.left = f.other.left + "px", P.style.top = f.other.top + "px", P.style.height = (f.other.bottom - f.other.top) * .85 + "px"
            }
        }

        function Ro(o, u) {
            return o.top - u.top || o.left - u.left
        }

        function Rc(o, u, p) {
            var f = o.display, m = o.doc, E = document.createDocumentFragment(), N = sa(o.display), P = N.left,
                F = Math.max(f.sizerWidth, gs(o) - f.sizer.offsetLeft) - N.right, H = m.direction == "ltr";

            function X(Ke, at, pt, gt) {
                at < 0 && (at = 0), at = Math.round(at), gt = Math.round(gt), E.appendChild(ee("div", null, "CodeMirror-selected", "position: absolute; left: " + Ke + `px;
                             top: ` + at + "px; width: " + (pt ?? F - Ke) + `px;
                             height: ` + (gt - at) + "px"))
            }

            function ie(Ke, at, pt) {
                var gt = dt(m, Ke), Mt = gt.text.length, hn, $n;

                function Dn(Ln, Gn) {
                    return dl(o, _e(Ke, Ln), "div", gt, Gn)
                }

                function Pr(Ln, Gn, xn) {
                    var Kn = md(o, gt, null, Ln), Mn = Gn == "ltr" == (xn == "after") ? "left" : "right",
                        Bn = xn == "after" ? Kn.begin : Kn.end - (/\s/.test(gt.text.charAt(Kn.end - 1)) ? 2 : 1);
                    return Dn(Bn, Mn)[Mn]
                }

                var En = ot(gt, m.direction);
                return Nt(En, at || 0, pt ?? Mt, function (Ln, Gn, xn, Kn) {
                    var Mn = xn == "ltr", Bn = Dn(Ln, Mn ? "left" : "right"), Or = Dn(Gn - 1, Mn ? "right" : "left"),
                        xa = at == null && Ln == 0, Jo = pt == null && Gn == Mt, vr = Kn == 0,
                        Ki = !En || Kn == En.length - 1;
                    if (Or.top - Bn.top <= 3) {
                        var rr = (H ? xa : Jo) && vr, Xd = (H ? Jo : xa) && Ki, Zi = rr ? P : (Mn ? Bn : Or).left,
                            Ts = Xd ? F : (Mn ? Or : Bn).right;
                        X(Zi, Bn.top, Ts - Zi, Bn.bottom)
                    } else {
                        var Is, Zn, Ea, eh;
                        Mn ? (Is = H && xa && vr ? P : Bn.left, Zn = H ? F : Pr(Ln, xn, "before"), Ea = H ? P : Pr(Gn, xn, "after"), eh = H && Jo && Ki ? F : Or.right) : (Is = H ? Pr(Ln, xn, "before") : P, Zn = !H && xa && vr ? F : Bn.right, Ea = !H && Jo && Ki ? P : Or.left, eh = H ? Pr(Gn, xn, "after") : F), X(Is, Bn.top, Zn - Is, Bn.bottom), Bn.bottom < Or.top && X(P, Bn.bottom, null, Or.top), X(Ea, Or.top, eh - Ea, Or.bottom)
                    }
                    (!hn || Ro(Bn, hn) < 0) && (hn = Bn), Ro(Or, hn) < 0 && (hn = Or), (!$n || Ro(Bn, $n) < 0) && ($n = Bn), Ro(Or, $n) < 0 && ($n = Or)
                }), {start: hn, end: $n}
            }

            var be = u.from(), fe = u.to();
            if (be.line == fe.line) ie(be.line, be.ch, fe.ch); else {
                var xe = dt(m, be.line), Ne = dt(m, fe.line), Ve = _i(xe) == _i(Ne),
                    $e = ie(be.line, be.ch, Ve ? xe.text.length + 1 : null).end,
                    et = ie(fe.line, Ve ? 0 : null, fe.ch).start;
                Ve && ($e.top < et.top - 2 ? (X($e.right, $e.top, null, $e.bottom), X(P, et.top, et.left, et.bottom)) : X($e.right, $e.top, et.left - $e.right, $e.bottom)), $e.bottom < et.top && X(P, $e.bottom, null, et.top)
            }
            p.appendChild(E)
        }

        function zc(o) {
            if (o.state.focused) {
                var u = o.display;
                clearInterval(u.blinker);
                var p = !0;
                u.cursorDiv.style.visibility = "", o.options.cursorBlinkRate > 0 ? u.blinker = setInterval(function () {
                    o.hasFocus() || zo(o), u.cursorDiv.style.visibility = (p = !p) ? "" : "hidden"
                }, o.options.cursorBlinkRate) : o.options.cursorBlinkRate < 0 && (u.cursorDiv.style.visibility = "hidden")
            }
        }

        function da(o) {
            o.hasFocus() || (o.display.input.focus(), o.state.focused || jc(o))
        }

        function mo(o) {
            o.state.delayingBlurEvent = !0, setTimeout(function () {
                o.state.delayingBlurEvent && (o.state.delayingBlurEvent = !1, o.state.focused && zo(o))
            }, 100)
        }

        function jc(o, u) {
            o.state.delayingBlurEvent && !o.state.draggingText && (o.state.delayingBlurEvent = !1), o.options.readOnly != "nocursor" && (o.state.focused || (cn(o, "focus", o, u), o.state.focused = !0, it(o.display.wrapper, "CodeMirror-focused"), !o.curOp && o.display.selForContextMenu != o.doc.sel && (o.display.input.reset(), I && setTimeout(function () {
                return o.display.input.reset(!0)
            }, 20)), o.display.input.receivedFocus()), zc(o))
        }

        function zo(o, u) {
            o.state.delayingBlurEvent || (o.state.focused && (cn(o, "blur", o, u), o.state.focused = !1, ke(o.display.wrapper, "CodeMirror-focused")), clearInterval(o.display.blinker), setTimeout(function () {
                o.state.focused || (o.display.shift = !1)
            }, 150))
        }

        function pl(o) {
            for (var u = o.display, p = u.lineDiv.offsetTop, f = Math.max(0, u.scroller.getBoundingClientRect().top), m = u.lineDiv.getBoundingClientRect().top, E = 0, N = 0; N < u.view.length; N++) {
                var P = u.view[N], F = o.options.lineWrapping, H = void 0, X = 0;
                if (!P.hidden) {
                    if (m += P.line.height, w && S < 8) {
                        var ie = P.node.offsetTop + P.node.offsetHeight;
                        H = ie - p, p = ie
                    } else {
                        var be = P.node.getBoundingClientRect();
                        H = be.bottom - be.top, !F && P.text.firstChild && (X = P.text.firstChild.getBoundingClientRect().right - be.left - 1)
                    }
                    var fe = P.line.height - H;
                    if ((fe > .005 || fe < -.005) && (m < f && (E -= fe), mr(P.line, H), wd(P.line), P.rest)) for (var xe = 0; xe < P.rest.length; xe++) wd(P.rest[xe]);
                    if (X > o.display.sizerWidth) {
                        var Ne = Math.ceil(X / ms(o.display));
                        Ne > o.display.maxLineLength && (o.display.maxLineLength = Ne, o.display.maxLine = P.line, o.display.maxLineChanged = !0)
                    }
                }
            }
            Math.abs(E) > 2 && (u.scroller.scrollTop += E)
        }

        function wd(o) {
            if (o.widgets) for (var u = 0; u < o.widgets.length; ++u) {
                var p = o.widgets[u], f = p.node.parentNode;
                f && (p.height = f.offsetHeight)
            }
        }

        function ml(o, u, p) {
            var f = p && p.top != null ? Math.max(0, p.top) : o.scroller.scrollTop;
            f = Math.floor(f - Nc(o));
            var m = p && p.bottom != null ? p.bottom : f + o.wrapper.clientHeight, E = re(u, f), N = re(u, m);
            if (p && p.ensure) {
                var P = p.ensure.from.line, F = p.ensure.to.line;
                P < E ? (E = P, N = re(u, oi(dt(u, P)) + o.wrapper.clientHeight)) : Math.min(F, u.lastLine()) >= N && (E = re(u, oi(dt(u, F)) - o.wrapper.clientHeight), N = F)
            }
            return {from: E, to: Math.max(N, E + 1)}
        }

        function Pm(o, u) {
            if (!fn(o, "scrollCursorIntoView")) {
                var p = o.display, f = p.sizer.getBoundingClientRect(), m = null, E = p.wrapper.ownerDocument;
                if (u.top + f.top < 0 ? m = !0 : u.bottom + f.top > (E.defaultView.innerHeight || E.documentElement.clientHeight) && (m = !1), m != null && !Q) {
                    var N = ee("div", "​", null, `position: absolute;
                         top: ` + (u.top - p.viewOffset - Nc(o.display)) + `px;
                         height: ` + (u.bottom - u.top + Vi(o) + p.barHeight) + `px;
                         left: ` + u.left + "px; width: " + Math.max(2, u.right - u.left) + "px;");
                    o.display.lineSpace.appendChild(N), N.scrollIntoView(m), o.display.lineSpace.removeChild(N)
                }
            }
        }

        function Om(o, u, p, f) {
            f == null && (f = 0);
            var m;
            !o.options.lineWrapping && u == p && (p = u.sticky == "before" ? _e(u.line, u.ch + 1, "before") : u, u = u.ch ? _e(u.line, u.sticky == "before" ? u.ch - 1 : u.ch, "after") : u);
            for (var E = 0; E < 5; E++) {
                var N = !1, P = Ht(o, u), F = !p || p == u ? P : Ht(o, p);
                m = {
                    left: Math.min(P.left, F.left),
                    top: Math.min(P.top, F.top) - f,
                    right: Math.max(P.left, F.left),
                    bottom: Math.max(P.bottom, F.bottom) + f
                };
                var H = Vc(o, m), X = o.doc.scrollTop, ie = o.doc.scrollLeft;
                if (H.scrollTop != null && (kl(o, H.scrollTop), Math.abs(o.doc.scrollTop - X) > 1 && (N = !0)), H.scrollLeft != null && (vs(o, H.scrollLeft), Math.abs(o.doc.scrollLeft - ie) > 1 && (N = !0)), !N) break
            }
            return m
        }

        function Uf(o, u) {
            var p = Vc(o, u);
            p.scrollTop != null && kl(o, p.scrollTop), p.scrollLeft != null && vs(o, p.scrollLeft)
        }

        function Vc(o, u) {
            var p = o.display, f = la(o.display);
            u.top < 0 && (u.top = 0);
            var m = o.curOp && o.curOp.scrollTop != null ? o.curOp.scrollTop : p.scroller.scrollTop, E = aa(o), N = {};
            u.bottom - u.top > E && (u.bottom = u.top + E);
            var P = o.doc.height + go(p), F = u.top < f, H = u.bottom > P - f;
            if (u.top < m) N.scrollTop = F ? 0 : u.top; else if (u.bottom > m + E) {
                var X = Math.min(u.top, (H ? P : u.bottom) - E);
                X != m && (N.scrollTop = X)
            }
            var ie = o.options.fixedGutter ? 0 : p.gutters.offsetWidth,
                be = o.curOp && o.curOp.scrollLeft != null ? o.curOp.scrollLeft : p.scroller.scrollLeft - ie,
                fe = gs(o) - p.gutters.offsetWidth, xe = u.right - u.left > fe;
            return xe && (u.right = u.left + fe), u.left < 10 ? N.scrollLeft = 0 : u.left < be ? N.scrollLeft = Math.max(0, u.left + ie - (xe ? 0 : 10)) : u.right > fe + be - 3 && (N.scrollLeft = u.right + (xe ? 0 : 10) - fe), N
        }

        function Hc(o, u) {
            u != null && (bl(o), o.curOp.scrollTop = (o.curOp.scrollTop == null ? o.doc.scrollTop : o.curOp.scrollTop) + u)
        }

        function bs(o) {
            bl(o);
            var u = o.getCursor();
            o.curOp.scrollToPos = {from: u, to: u, margin: o.options.cursorScrollMargin}
        }

        function ks(o, u, p) {
            (u != null || p != null) && bl(o), u != null && (o.curOp.scrollLeft = u), p != null && (o.curOp.scrollTop = p)
        }

        function Fm(o, u) {
            bl(o), o.curOp.scrollToPos = u
        }

        function bl(o) {
            var u = o.curOp.scrollToPos;
            if (u) {
                o.curOp.scrollToPos = null;
                var p = Pc(o, u.from), f = Pc(o, u.to);
                qf(o, p, f, u.margin)
            }
        }

        function qf(o, u, p, f) {
            var m = Vc(o, {
                left: Math.min(u.left, p.left),
                top: Math.min(u.top, p.top) - f,
                right: Math.max(u.right, p.right),
                bottom: Math.max(u.bottom, p.bottom) + f
            });
            ks(o, m.scrollLeft, m.scrollTop)
        }

        function kl(o, u) {
            Math.abs(o.doc.scrollTop - u) < 2 || (C || Uc(o, {top: u}), Ut(o, u, !0), C && Uc(o), vl(o, 100))
        }

        function Ut(o, u, p) {
            u = Math.max(0, Math.min(o.display.scroller.scrollHeight - o.display.scroller.clientHeight, u)), !(o.display.scroller.scrollTop == u && !p) && (o.doc.scrollTop = u, o.display.scrollbars.setScrollTop(u), o.display.scroller.scrollTop != u && (o.display.scroller.scrollTop = u))
        }

        function vs(o, u, p, f) {
            u = Math.max(0, Math.min(u, o.display.scroller.scrollWidth - o.display.scroller.clientWidth)), !((p ? u == o.doc.scrollLeft : Math.abs(o.doc.scrollLeft - u) < 2) && !f) && (o.doc.scrollLeft = u, Zf(o), o.display.scroller.scrollLeft != u && (o.display.scroller.scrollLeft = u), o.display.scrollbars.setScrollLeft(u))
        }

        function Ui(o) {
            var u = o.display, p = u.gutters.offsetWidth, f = Math.round(o.doc.height + go(o.display));
            return {
                clientHeight: u.scroller.clientHeight,
                viewHeight: u.wrapper.clientHeight,
                scrollWidth: u.scroller.scrollWidth,
                clientWidth: u.scroller.clientWidth,
                viewWidth: u.wrapper.clientWidth,
                barLeft: o.options.fixedGutter ? p : 0,
                docHeight: f,
                scrollHeight: f + Vi(o) + u.barHeight,
                nativeBarWidth: u.nativeBarWidth,
                gutterWidth: p
            }
        }

        var Di = function (o, u, p) {
            this.cm = p;
            var f = this.vert = ee("div", [ee("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"),
                m = this.horiz = ee("div", [ee("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
            f.tabIndex = m.tabIndex = -1, o(f), o(m), ft(f, "scroll", function () {
                f.clientHeight && u(f.scrollTop, "vertical")
            }), ft(m, "scroll", function () {
                m.clientWidth && u(m.scrollLeft, "horizontal")
            }), this.checkedZeroWidth = !1, w && S < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
        };
        Di.prototype.update = function (o) {
            var u = o.scrollWidth > o.clientWidth + 1, p = o.scrollHeight > o.clientHeight + 1, f = o.nativeBarWidth;
            if (p) {
                this.vert.style.display = "block", this.vert.style.bottom = u ? f + "px" : "0";
                var m = o.viewHeight - (u ? f : 0);
                this.vert.firstChild.style.height = Math.max(0, o.scrollHeight - o.clientHeight + m) + "px"
            } else this.vert.scrollTop = 0, this.vert.style.display = "", this.vert.firstChild.style.height = "0";
            if (u) {
                this.horiz.style.display = "block", this.horiz.style.right = p ? f + "px" : "0", this.horiz.style.left = o.barLeft + "px";
                var E = o.viewWidth - o.barLeft - (p ? f : 0);
                this.horiz.firstChild.style.width = Math.max(0, o.scrollWidth - o.clientWidth + E) + "px"
            } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
            return !this.checkedZeroWidth && o.clientHeight > 0 && (f == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), {
                right: p ? f : 0,
                bottom: u ? f : 0
            }
        }, Di.prototype.setScrollLeft = function (o) {
            this.horiz.scrollLeft != o && (this.horiz.scrollLeft = o), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz")
        }, Di.prototype.setScrollTop = function (o) {
            this.vert.scrollTop != o && (this.vert.scrollTop = o), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert")
        }, Di.prototype.zeroWidthHack = function () {
            var o = ce && !q ? "12px" : "18px";
            this.horiz.style.height = this.vert.style.width = o, this.horiz.style.visibility = this.vert.style.visibility = "hidden", this.disableHoriz = new Vt, this.disableVert = new Vt
        }, Di.prototype.enableZeroWidthBar = function (o, u, p) {
            o.style.visibility = "";

            function f() {
                var m = o.getBoundingClientRect(),
                    E = p == "vert" ? document.elementFromPoint(m.right - 1, (m.top + m.bottom) / 2) : document.elementFromPoint((m.right + m.left) / 2, m.bottom - 1);
                E != o ? o.style.visibility = "hidden" : u.set(1e3, f)
            }

            u.set(1e3, f)
        }, Di.prototype.clear = function () {
            var o = this.horiz.parentNode;
            o.removeChild(this.horiz), o.removeChild(this.vert)
        };
        var ha = function () {
        };
        ha.prototype.update = function () {
            return {bottom: 0, right: 0}
        }, ha.prototype.setScrollLeft = function () {
        }, ha.prototype.setScrollTop = function () {
        }, ha.prototype.clear = function () {
        };

        function jo(o, u) {
            u || (u = Ui(o));
            var p = o.display.barWidth, f = o.display.barHeight;
            qn(o, u);
            for (var m = 0; m < 4 && p != o.display.barWidth || f != o.display.barHeight; m++) p != o.display.barWidth && o.options.lineWrapping && pl(o), qn(o, Ui(o)), p = o.display.barWidth, f = o.display.barHeight
        }

        function qn(o, u) {
            var p = o.display, f = p.scrollbars.update(u);
            p.sizer.style.paddingRight = (p.barWidth = f.right) + "px", p.sizer.style.paddingBottom = (p.barHeight = f.bottom) + "px", p.heightForcer.style.borderBottom = f.bottom + "px solid transparent", f.right && f.bottom ? (p.scrollbarFiller.style.display = "block", p.scrollbarFiller.style.height = f.bottom + "px", p.scrollbarFiller.style.width = f.right + "px") : p.scrollbarFiller.style.display = "", f.bottom && o.options.coverGutterNextToScrollbar && o.options.fixedGutter ? (p.gutterFiller.style.display = "block", p.gutterFiller.style.height = f.bottom + "px", p.gutterFiller.style.width = u.gutterWidth + "px") : p.gutterFiller.style.display = ""
        }

        var Wf = {native: Di, null: ha};

        function $f(o) {
            o.display.scrollbars && (o.display.scrollbars.clear(), o.display.scrollbars.addClass && ke(o.display.wrapper, o.display.scrollbars.addClass)), o.display.scrollbars = new Wf[o.options.scrollbarStyle](function (u) {
                o.display.wrapper.insertBefore(u, o.display.scrollbarFiller), ft(u, "mousedown", function () {
                    o.state.focused && setTimeout(function () {
                        return o.display.input.focus()
                    }, 0)
                }), u.setAttribute("cm-not-content", "true")
            }, function (u, p) {
                p == "horizontal" ? vs(o, u) : kl(o, u)
            }, o), o.display.scrollbars.addClass && it(o.display.wrapper, o.display.scrollbars.addClass)
        }

        var Gf = 0;

        function ws(o) {
            o.curOp = {
                cm: o,
                viewChanged: !1,
                startHeight: o.doc.height,
                forceUpdate: !1,
                updateInput: 0,
                typing: !1,
                changeObjs: null,
                cursorActivityHandlers: null,
                cursorActivityCalled: 0,
                selectionChanged: !1,
                updateMaxLine: !1,
                scrollLeft: null,
                scrollTop: null,
                scrollToPos: null,
                focus: !1,
                id: ++Gf,
                markArrays: null
            }, Mm(o.curOp)
        }

        function br(o) {
            var u = o.curOp;
            u && If(u, function (p) {
                for (var f = 0; f < p.ops.length; f++) p.ops[f].cm.curOp = null;
                Wn(p)
            })
        }

        function Wn(o) {
            for (var u = o.ops, p = 0; p < u.length; p++) Nr(u[p]);
            for (var f = 0; f < u.length; f++) si(u[f]);
            for (var m = 0; m < u.length; m++) qi(u[m]);
            for (var E = 0; E < u.length; E++) Ad(u[E]);
            for (var N = 0; N < u.length; N++) Cd(u[N])
        }

        function Nr(o) {
            var u = o.cm, p = u.display;
            Rm(u), o.updateMaxLine && td(u), o.mustUpdate = o.viewChanged || o.forceUpdate || o.scrollTop != null || o.scrollToPos && (o.scrollToPos.from.line < p.viewFrom || o.scrollToPos.to.line >= p.viewTo) || p.maxLineChanged && u.options.lineWrapping, o.update = o.mustUpdate && new wl(u, o.mustUpdate && {
                top: o.scrollTop,
                ensure: o.scrollToPos
            }, o.forceUpdate)
        }

        function si(o) {
            o.updatedDisplay = o.mustUpdate && As(o.cm, o.update)
        }

        function qi(o) {
            var u = o.cm, p = u.display;
            o.updatedDisplay && pl(u), o.barMeasure = Ui(u), p.maxLineChanged && !u.options.lineWrapping && (o.adjustWidthTo = Of(u, p.maxLine, p.maxLine.text.length).left + 3, u.display.sizerWidth = o.adjustWidthTo, o.barMeasure.scrollWidth = Math.max(p.scroller.clientWidth, p.sizer.offsetLeft + o.adjustWidthTo + Vi(u) + u.display.barWidth), o.maxScrollLeft = Math.max(0, p.sizer.offsetLeft + o.adjustWidthTo - gs(u))), (o.updatedDisplay || o.selectionChanged) && (o.preparedSelection = p.input.prepareSelection())
        }

        function Ad(o) {
            var u = o.cm;
            o.adjustWidthTo != null && (u.display.sizer.style.minWidth = o.adjustWidthTo + "px", o.maxScrollLeft < u.doc.scrollLeft && vs(u, Math.min(u.display.scroller.scrollLeft, o.maxScrollLeft), !0), u.display.maxLineChanged = !1);
            var p = o.focus && o.focus == Le(At(u));
            o.preparedSelection && u.display.input.showSelection(o.preparedSelection, p), (o.updatedDisplay || o.startHeight != u.doc.height) && jo(u, o.barMeasure), o.updatedDisplay && _d(u, o.barMeasure), o.selectionChanged && zc(u), u.state.focused && o.updateInput && u.display.input.reset(o.typing), p && da(o.cm)
        }

        function Cd(o) {
            var u = o.cm, p = u.display, f = u.doc;
            if (o.updatedDisplay && Kf(u, o.update), p.wheelStartX != null && (o.scrollTop != null || o.scrollLeft != null || o.scrollToPos) && (p.wheelStartX = p.wheelStartY = null), o.scrollTop != null && Ut(u, o.scrollTop, o.forceScroll), o.scrollLeft != null && vs(u, o.scrollLeft, !0, !0), o.scrollToPos) {
                var m = Om(u, Et(f, o.scrollToPos.from), Et(f, o.scrollToPos.to), o.scrollToPos.margin);
                Pm(u, m)
            }
            var E = o.maybeHiddenMarkers, N = o.maybeUnhiddenMarkers;
            if (E) for (var P = 0; P < E.length; ++P) E[P].lines.length || cn(E[P], "hide");
            if (N) for (var F = 0; F < N.length; ++F) N[F].lines.length && cn(N[F], "unhide");
            p.wrapper.offsetHeight && (f.scrollTop = u.display.scroller.scrollTop), o.changeObjs && cn(u, "changes", u, o.changeObjs), o.update && o.update.finish()
        }

        function _r(o, u) {
            if (o.curOp) return u();
            ws(o);
            try {
                return u()
            } finally {
                br(o)
            }
        }

        function nr(o, u) {
            return function () {
                if (o.curOp) return u.apply(o, arguments);
                ws(o);
                try {
                    return u.apply(o, arguments)
                } finally {
                    br(o)
                }
            }
        }

        function kr(o) {
            return function () {
                if (this.curOp) return o.apply(this, arguments);
                ws(this);
                try {
                    return o.apply(this, arguments)
                } finally {
                    br(this)
                }
            }
        }

        function un(o) {
            return function () {
                var u = this.cm;
                if (!u || u.curOp) return o.apply(this, arguments);
                ws(u);
                try {
                    return o.apply(this, arguments)
                } finally {
                    br(u)
                }
            }
        }

        function vl(o, u) {
            o.doc.highlightFrontier < o.display.viewTo && o.state.highlight.set(u, Oe(rt, o))
        }

        function rt(o) {
            var u = o.doc;
            if (!(u.highlightFrontier >= o.display.viewTo)) {
                var p = +new Date + o.options.workTime, f = Bo(o, u.highlightFrontier), m = [];
                u.iter(f.line, Math.min(u.first + u.size, o.display.viewTo + 500), function (E) {
                    if (f.line >= o.display.viewFrom) {
                        var N = E.styles, P = E.text.length > o.options.maxHighlightLength ? Ri(u.mode, f.state) : null,
                            F = uf(o, E, f, !0);
                        P && (f.state = P), E.styles = F.styles;
                        var H = E.styleClasses, X = F.classes;
                        X ? E.styleClasses = X : H && (E.styleClasses = null);
                        for (var ie = !N || N.length != E.styles.length || H != X && (!H || !X || H.bgClass != X.bgClass || H.textClass != X.textClass), be = 0; !ie && be < N.length; ++be) ie = N[be] != E.styles[be];
                        ie && m.push(f.line), E.stateAfter = f.save(), f.nextLine()
                    } else E.text.length <= o.options.maxHighlightLength && Yu(o, E.text, f), E.stateAfter = f.line % 5 == 0 ? f.save() : null, f.nextLine();
                    if (+new Date > p) return vl(o, o.options.workDelay), !0
                }), u.highlightFrontier = f.line, u.modeFrontier = Math.max(u.modeFrontier, f.line), m.length && _r(o, function () {
                    for (var E = 0; E < m.length; E++) Lt(o, m[E], "text")
                })
            }
        }

        var wl = function (o, u, p) {
            var f = o.display;
            this.viewport = u, this.visible = ml(f, o.doc, u), this.editorIsHidden = !f.wrapper.offsetWidth, this.wrapperHeight = f.wrapper.clientHeight, this.wrapperWidth = f.wrapper.clientWidth, this.oldDisplayWidth = gs(o), this.force = p, this.dims = fl(o), this.events = []
        };
        wl.prototype.signal = function (o, u) {
            zn(o, u) && this.events.push(arguments)
        }, wl.prototype.finish = function () {
            for (var o = 0; o < this.events.length; o++) cn.apply(null, this.events[o])
        };

        function Rm(o) {
            var u = o.display;
            !u.scrollbarsClipped && u.scroller.offsetWidth && (u.nativeBarWidth = u.scroller.offsetWidth - u.scroller.clientWidth, u.heightForcer.style.height = Vi(o) + "px", u.sizer.style.marginBottom = -u.nativeBarWidth + "px", u.sizer.style.borderRightWidth = Vi(o) + "px", u.scrollbarsClipped = !0)
        }

        function It(o) {
            if (o.hasFocus()) return null;
            var u = Le(At(o));
            if (!u || !Xe(o.display.lineDiv, u)) return null;
            var p = {activeElt: u};
            if (window.getSelection) {
                var f = Ye(o).getSelection();
                f.anchorNode && f.extend && Xe(o.display.lineDiv, f.anchorNode) && (p.anchorNode = f.anchorNode, p.anchorOffset = f.anchorOffset, p.focusNode = f.focusNode, p.focusOffset = f.focusOffset)
            }
            return p
        }

        function xi(o) {
            if (!(!o || !o.activeElt || o.activeElt == Le(mt(o.activeElt))) && (o.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(o.activeElt.nodeName) && o.anchorNode && Xe(document.body, o.anchorNode) && Xe(document.body, o.focusNode))) {
                var u = o.activeElt.ownerDocument, p = u.defaultView.getSelection(), f = u.createRange();
                f.setEnd(o.anchorNode, o.anchorOffset), f.collapse(!1), p.removeAllRanges(), p.addRange(f), p.extend(o.focusNode, o.focusOffset)
            }
        }

        function As(o, u) {
            var p = o.display, f = o.doc;
            if (u.editorIsHidden) return yi(o), !1;
            if (!u.force && u.visible.from >= p.viewFrom && u.visible.to <= p.viewTo && (p.updateLineNumbers == null || p.updateLineNumbers >= p.viewTo) && p.renderedView == p.view && vd(o) == 0) return !1;
            Yf(o) && (yi(o), u.dims = fl(o));
            var m = f.first + f.size, E = Math.max(u.visible.from - o.options.viewportMargin, f.first),
                N = Math.min(m, u.visible.to + o.options.viewportMargin);
            p.viewFrom < E && E - p.viewFrom < 20 && (E = Math.max(f.first, p.viewFrom)), p.viewTo > N && p.viewTo - N < 20 && (N = Math.min(m, p.viewTo)), ji && (E = ol(o.doc, E), N = Af(o.doc, N));
            var P = E != p.viewFrom || N != p.viewTo || p.lastWrapHeight != u.wrapperHeight || p.lastWrapWidth != u.wrapperWidth;
            kd(o, E, N), p.viewOffset = oi(dt(o.doc, p.viewFrom)), o.display.mover.style.top = p.viewOffset + "px";
            var F = vd(o);
            if (!P && F == 0 && !u.force && p.renderedView == p.view && (p.updateLineNumbers == null || p.updateLineNumbers >= p.viewTo)) return !1;
            var H = It(o);
            return F > 4 && (p.lineDiv.style.display = "none"), qc(o, p.updateLineNumbers, u.dims), F > 4 && (p.lineDiv.style.display = ""), p.renderedView = p.view, xi(H), le(p.cursorDiv), le(p.selectionDiv), p.gutters.style.height = p.sizer.style.minHeight = 0, P && (p.lastWrapHeight = u.wrapperHeight, p.lastWrapWidth = u.wrapperWidth, vl(o, 400)), p.updateLineNumbers = null, !0
        }

        function Kf(o, u) {
            for (var p = u.viewport, f = !0; ; f = !1) {
                if (!f || !o.options.lineWrapping || u.oldDisplayWidth == gs(o)) {
                    if (p && p.top != null && (p = {top: Math.min(o.doc.height + go(o.display) - aa(o), p.top)}), u.visible = ml(o.display, o.doc, p), u.visible.from >= o.display.viewFrom && u.visible.to <= o.display.viewTo) break
                } else f && (u.visible = ml(o.display, o.doc, p));
                if (!As(o, u)) break;
                pl(o);
                var m = Ui(o);
                _n(o), jo(o, m), _d(o, m), u.force = !1
            }
            u.signal(o, "update", o), (o.display.viewFrom != o.display.reportedViewFrom || o.display.viewTo != o.display.reportedViewTo) && (u.signal(o, "viewportChange", o, o.display.viewFrom, o.display.viewTo), o.display.reportedViewFrom = o.display.viewFrom, o.display.reportedViewTo = o.display.viewTo)
        }

        function Uc(o, u) {
            var p = new wl(o, u);
            if (As(o, p)) {
                pl(o), Kf(o, p);
                var f = Ui(o);
                _n(o), jo(o, f), _d(o, f), p.finish()
            }
        }

        function qc(o, u, p) {
            var f = o.display, m = o.options.lineNumbers, E = f.lineDiv, N = E.firstChild;

            function P(xe) {
                var Ne = xe.nextSibling;
                return I && ce && o.display.currentWheelTarget == xe ? xe.style.display = "none" : xe.parentNode.removeChild(xe), Ne
            }

            for (var F = f.view, H = f.viewFrom, X = 0; X < F.length; X++) {
                var ie = F[X];
                if (!ie.hidden) if (!ie.node || ie.node.parentNode != E) {
                    var be = Nf(o, ie, H, p);
                    E.insertBefore(be, N)
                } else {
                    for (; N != ie.node;) N = P(N);
                    var fe = m && u != null && u <= H && ie.lineNumber;
                    ie.changes && (ct(ie.changes, "gutter") > -1 && (fe = !1), Mf(o, ie, H, p)), fe && (le(ie.lineNumber), ie.lineNumber.appendChild(document.createTextNode(je(o.options, H)))), N = ie.node.nextSibling
                }
                H += ie.size
            }
            for (; N;) N = P(N)
        }

        function Wc(o) {
            var u = o.gutters.offsetWidth;
            o.sizer.style.marginLeft = u + "px", Un(o, "gutterChanged", o)
        }

        function _d(o, u) {
            o.display.sizer.style.minHeight = u.docHeight + "px", o.display.heightForcer.style.top = u.docHeight + "px", o.display.gutters.style.height = u.docHeight + o.display.barHeight + Vi(o) + "px"
        }

        function Zf(o) {
            var u = o.display, p = u.view;
            if (!(!u.alignWidgets && (!u.gutters.firstChild || !o.options.fixedGutter))) {
                for (var f = bt(u) - u.scroller.scrollLeft + o.doc.scrollLeft, m = u.gutters.offsetWidth, E = f + "px", N = 0; N < p.length; N++) if (!p[N].hidden) {
                    o.options.fixedGutter && (p[N].gutter && (p[N].gutter.style.left = E), p[N].gutterBackground && (p[N].gutterBackground.style.left = E));
                    var P = p[N].alignable;
                    if (P) for (var F = 0; F < P.length; F++) P[F].style.left = E
                }
                o.options.fixedGutter && (u.gutters.style.left = f + m + "px")
            }
        }

        function Yf(o) {
            if (!o.options.lineNumbers) return !1;
            var u = o.doc, p = je(o.options, u.first + u.size - 1), f = o.display;
            if (p.length != f.lineNumChars) {
                var m = f.measure.appendChild(ee("div", [ee("div", p)], "CodeMirror-linenumber CodeMirror-gutter-elt")),
                    E = m.firstChild.offsetWidth, N = m.offsetWidth - E;
                return f.lineGutter.style.width = "", f.lineNumInnerWidth = Math.max(E, f.lineGutter.offsetWidth - N) + 1, f.lineNumWidth = f.lineNumInnerWidth + N, f.lineNumChars = f.lineNumInnerWidth ? p.length : -1, f.lineGutter.style.width = f.lineNumWidth + "px", Wc(o.display), !0
            }
            return !1
        }

        function $c(o, u) {
            for (var p = [], f = !1, m = 0; m < o.length; m++) {
                var E = o[m], N = null;
                if (typeof E != "string" && (N = E.style, E = E.className), E == "CodeMirror-linenumbers") if (u) f = !0; else continue;
                p.push({className: E, style: N})
            }
            return u && !f && p.push({className: "CodeMirror-linenumbers", style: null}), p
        }

        function yd(o) {
            var u = o.gutters, p = o.gutterSpecs;
            le(u), o.lineGutter = null;
            for (var f = 0; f < p.length; ++f) {
                var m = p[f], E = m.className, N = m.style,
                    P = u.appendChild(ee("div", null, "CodeMirror-gutter " + E));
                N && (P.style.cssText = N), E == "CodeMirror-linenumbers" && (o.lineGutter = P, P.style.width = (o.lineNumWidth || 1) + "px")
            }
            u.style.display = p.length ? "" : "none", Wc(o)
        }

        function fa(o) {
            yd(o.display), Cr(o), Zf(o)
        }

        function Qf(o, u, p, f) {
            var m = this;
            this.input = p, m.scrollbarFiller = ee("div", null, "CodeMirror-scrollbar-filler"), m.scrollbarFiller.setAttribute("cm-not-content", "true"), m.gutterFiller = ee("div", null, "CodeMirror-gutter-filler"), m.gutterFiller.setAttribute("cm-not-content", "true"), m.lineDiv = qe("div", null, "CodeMirror-code"), m.selectionDiv = ee("div", null, null, "position: relative; z-index: 1"), m.cursorDiv = ee("div", null, "CodeMirror-cursors"), m.measure = ee("div", null, "CodeMirror-measure"), m.lineMeasure = ee("div", null, "CodeMirror-measure"), m.lineSpace = qe("div", [m.measure, m.lineMeasure, m.selectionDiv, m.cursorDiv, m.lineDiv], null, "position: relative; outline: none");
            var E = qe("div", [m.lineSpace], "CodeMirror-lines");
            m.mover = ee("div", [E], null, "position: relative"), m.sizer = ee("div", [m.mover], "CodeMirror-sizer"), m.sizerWidth = null, m.heightForcer = ee("div", null, null, "position: absolute; height: " + se + "px; width: 1px;"), m.gutters = ee("div", null, "CodeMirror-gutters"), m.lineGutter = null, m.scroller = ee("div", [m.sizer, m.heightForcer, m.gutters], "CodeMirror-scroll"), m.scroller.setAttribute("tabIndex", "-1"), m.wrapper = ee("div", [m.scrollbarFiller, m.gutterFiller, m.scroller], "CodeMirror"), D && B >= 105 && (m.wrapper.style.clipPath = "inset(0px)"), m.wrapper.setAttribute("translate", "no"), w && S < 8 && (m.gutters.style.zIndex = -1, m.scroller.style.paddingRight = 0), !I && !(C && Y) && (m.scroller.draggable = !0), o && (o.appendChild ? o.appendChild(m.wrapper) : o(m.wrapper)), m.viewFrom = m.viewTo = u.first, m.reportedViewFrom = m.reportedViewTo = u.first, m.view = [], m.renderedView = null, m.externalMeasured = null, m.viewOffset = 0, m.lastWrapHeight = m.lastWrapWidth = 0, m.updateLineNumbers = null, m.nativeBarWidth = m.barHeight = m.barWidth = 0, m.scrollbarsClipped = !1, m.lineNumWidth = m.lineNumInnerWidth = m.lineNumChars = null, m.alignWidgets = !1, m.cachedCharWidth = m.cachedTextHeight = m.cachedPaddingH = null, m.maxLine = null, m.maxLineLength = 0, m.maxLineChanged = !1, m.wheelDX = m.wheelDY = m.wheelStartX = m.wheelStartY = null, m.shift = !1, m.selForContextMenu = null, m.activeTouch = null, m.gutterSpecs = $c(f.gutters, f.lineNumbers), yd(m), p.init(m)
        }

        var Al = 0, Wi = null;
        w ? Wi = -.53 : C ? Wi = 15 : D ? Wi = -.7 : z && (Wi = -1 / 3);

        function Cs(o) {
            var u = o.wheelDeltaX, p = o.wheelDeltaY;
            return u == null && o.detail && o.axis == o.HORIZONTAL_AXIS && (u = o.detail), p == null && o.detail && o.axis == o.VERTICAL_AXIS ? p = o.detail : p == null && (p = o.wheelDelta), {
                x: u,
                y: p
            }
        }

        function Gc(o) {
            var u = Cs(o);
            return u.x *= Wi, u.y *= Wi, u
        }

        function Kc(o, u) {
            D && B == 102 && (o.display.chromeScrollHack == null ? o.display.sizer.style.pointerEvents = "none" : clearTimeout(o.display.chromeScrollHack), o.display.chromeScrollHack = setTimeout(function () {
                o.display.chromeScrollHack = null, o.display.sizer.style.pointerEvents = ""
            }, 100));
            var p = Cs(u), f = p.x, m = p.y, E = Wi;
            u.deltaMode === 0 && (f = u.deltaX, m = u.deltaY, E = 1);
            var N = o.display, P = N.scroller, F = P.scrollWidth > P.clientWidth, H = P.scrollHeight > P.clientHeight;
            if (f && F || m && H) {
                if (m && ce && I) {
                    e:for (var X = u.target, ie = N.view; X != P; X = X.parentNode) for (var be = 0; be < ie.length; be++) if (ie[be].node == X) {
                        o.display.currentWheelTarget = X;
                        break e
                    }
                }
                if (f && !C && !L && E != null) {
                    m && H && kl(o, Math.max(0, P.scrollTop + m * E)), vs(o, Math.max(0, P.scrollLeft + f * E)), (!m || m && H) && Sn(u), N.wheelStartX = null;
                    return
                }
                if (m && E != null) {
                    var fe = m * E, xe = o.doc.scrollTop, Ne = xe + N.wrapper.clientHeight;
                    fe < 0 ? xe = Math.max(0, xe + fe - 50) : Ne = Math.min(o.doc.height, Ne + fe + 50), Uc(o, {
                        top: xe,
                        bottom: Ne
                    })
                }
                Al < 20 && u.deltaMode !== 0 && (N.wheelStartX == null ? (N.wheelStartX = P.scrollLeft, N.wheelStartY = P.scrollTop, N.wheelDX = f, N.wheelDY = m, setTimeout(function () {
                    if (N.wheelStartX != null) {
                        var Ve = P.scrollLeft - N.wheelStartX, $e = P.scrollTop - N.wheelStartY,
                            et = $e && N.wheelDY && $e / N.wheelDY || Ve && N.wheelDX && Ve / N.wheelDX;
                        N.wheelStartX = N.wheelStartY = null, et && (Wi = (Wi * Al + et) / (Al + 1), ++Al)
                    }
                }, 200)) : (N.wheelDX += f, N.wheelDY += m))
            }
        }

        var Lr = function (o, u) {
            this.ranges = o, this.primIndex = u
        };
        Lr.prototype.primary = function () {
            return this.ranges[this.primIndex]
        }, Lr.prototype.equals = function (o) {
            if (o == this) return !0;
            if (o.primIndex != this.primIndex || o.ranges.length != this.ranges.length) return !1;
            for (var u = 0; u < this.ranges.length; u++) {
                var p = this.ranges[u], f = o.ranges[u];
                if (!Qt(p.anchor, f.anchor) || !Qt(p.head, f.head)) return !1
            }
            return !0
        }, Lr.prototype.deepCopy = function () {
            for (var o = [], u = 0; u < this.ranges.length; u++) o[u] = new Kt(tr(this.ranges[u].anchor), tr(this.ranges[u].head));
            return new Lr(o, this.primIndex)
        }, Lr.prototype.somethingSelected = function () {
            for (var o = 0; o < this.ranges.length; o++) if (!this.ranges[o].empty()) return !0;
            return !1
        }, Lr.prototype.contains = function (o, u) {
            u || (u = o);
            for (var p = 0; p < this.ranges.length; p++) {
                var f = this.ranges[p];
                if (Qe(u, f.from()) >= 0 && Qe(o, f.to()) <= 0) return p
            }
            return -1
        };
        var Kt = function (o, u) {
            this.anchor = o, this.head = u
        };
        Kt.prototype.from = function () {
            return as(this.anchor, this.head)
        }, Kt.prototype.to = function () {
            return Hn(this.anchor, this.head)
        }, Kt.prototype.empty = function () {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
        };

        function ai(o, u, p) {
            var f = o && o.options.selectionsMayTouch, m = u[p];
            u.sort(function (be, fe) {
                return Qe(be.from(), fe.from())
            }), p = ct(u, m);
            for (var E = 1; E < u.length; E++) {
                var N = u[E], P = u[E - 1], F = Qe(P.to(), N.from());
                if (f && !N.empty() ? F > 0 : F >= 0) {
                    var H = as(P.from(), N.from()), X = Hn(P.to(), N.to()),
                        ie = P.empty() ? N.from() == N.head : P.from() == P.head;
                    E <= p && --p, u.splice(--E, 2, new Kt(ie ? X : H, ie ? H : X))
                }
            }
            return new Lr(u, p)
        }

        function Vo(o, u) {
            return new Lr([new Kt(o, u || o)], 0)
        }

        function bo(o) {
            return o.text ? _e(o.from.line + o.text.length - 1, V(o.text).length + (o.text.length == 1 ? o.from.ch : 0)) : o.to
        }

        function Jf(o, u) {
            if (Qe(o, u.from) < 0) return o;
            if (Qe(o, u.to) <= 0) return bo(u);
            var p = o.line + u.text.length - (u.to.line - u.from.line) - 1, f = o.ch;
            return o.line == u.to.line && (f += bo(u).ch - u.to.ch), _e(p, f)
        }

        function Zc(o, u) {
            for (var p = [], f = 0; f < o.sel.ranges.length; f++) {
                var m = o.sel.ranges[f];
                p.push(new Kt(Jf(m.anchor, u), Jf(m.head, u)))
            }
            return ai(o.cm, p, o.sel.primIndex)
        }

        function Ho(o, u, p) {
            return o.line == u.line ? _e(p.line, o.ch - u.ch + p.ch) : _e(p.line + (o.line - u.line), o.ch)
        }

        function zm(o, u, p) {
            for (var f = [], m = _e(o.first, 0), E = m, N = 0; N < u.length; N++) {
                var P = u[N], F = Ho(P.from, m, E), H = Ho(bo(P), m, E);
                if (m = P.to, E = H, p == "around") {
                    var X = o.sel.ranges[N], ie = Qe(X.head, X.anchor) < 0;
                    f[N] = new Kt(ie ? H : F, ie ? F : H)
                } else f[N] = new Kt(F, F)
            }
            return new Lr(f, o.sel.primIndex)
        }

        function Yc(o) {
            o.doc.mode = ii(o.options, o.doc.modeOption), Cl(o)
        }

        function Cl(o) {
            o.doc.iter(function (u) {
                u.stateAfter && (u.stateAfter = null), u.styles && (u.styles = null)
            }), o.doc.modeFrontier = o.doc.highlightFrontier = o.doc.first, vl(o, 100), o.state.modeGen++, o.curOp && Cr(o)
        }

        function sn(o, u) {
            return u.from.ch == 0 && u.to.ch == 0 && V(u.text) == "" && (!o.cm || o.cm.options.wholeLineUpdateBefore)
        }

        function Qc(o, u, p, f) {
            function m(et) {
                return p ? p[et] : null
            }

            function E(et, Ke, at) {
                Sm(et, Ke, at, f), Un(et, "change", et, u)
            }

            function N(et, Ke) {
                for (var at = [], pt = et; pt < Ke; ++pt) at.push(new ia(H[pt], m(pt), f));
                return at
            }

            var P = u.from, F = u.to, H = u.text, X = dt(o, P.line), ie = dt(o, F.line), be = V(H),
                fe = m(H.length - 1), xe = F.line - P.line;
            if (u.full) o.insert(0, N(0, H.length)), o.remove(H.length, o.size - H.length); else if (sn(o, u)) {
                var Ne = N(0, H.length - 1);
                E(ie, ie.text, fe), xe && o.remove(P.line, xe), Ne.length && o.insert(P.line, Ne)
            } else if (X == ie) if (H.length == 1) E(X, X.text.slice(0, P.ch) + be + X.text.slice(F.ch), fe); else {
                var Ve = N(1, H.length - 1);
                Ve.push(new ia(be + X.text.slice(F.ch), fe, f)), E(X, X.text.slice(0, P.ch) + H[0], m(0)), o.insert(P.line + 1, Ve)
            } else if (H.length == 1) E(X, X.text.slice(0, P.ch) + H[0] + ie.text.slice(F.ch), m(0)), o.remove(P.line + 1, xe); else {
                E(X, X.text.slice(0, P.ch) + H[0], m(0)), E(ie, be + ie.text.slice(F.ch), fe);
                var $e = N(1, H.length - 1);
                xe > 1 && o.remove(P.line + 1, xe - 1), o.insert(P.line + 1, $e)
            }
            Un(o, "change", o, u)
        }

        function Uo(o, u, p) {
            function f(m, E, N) {
                if (m.linked) for (var P = 0; P < m.linked.length; ++P) {
                    var F = m.linked[P];
                    if (F.doc != E) {
                        var H = N && F.sharedHist;
                        p && !H || (u(F.doc, H), f(F.doc, m, H))
                    }
                }
            }

            f(o, null, !0)
        }

        function _l(o, u) {
            if (u.cm) throw new Error("This document is already in use.");
            o.doc = u, u.cm = o, ca(o), Yc(o), Dd(o), o.options.direction = u.direction, o.options.lineWrapping || td(o), o.options.mode = u.modeOption, Cr(o)
        }

        function Dd(o) {
            (o.doc.direction == "rtl" ? it : ke)(o.display.lineDiv, "CodeMirror-rtl")
        }

        function jm(o) {
            _r(o, function () {
                Dd(o), Cr(o)
            })
        }

        function yl(o) {
            this.done = [], this.undone = [], this.undoDepth = o ? o.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = o ? o.maxGeneration : 1
        }

        function xd(o, u) {
            var p = {from: tr(u.from), to: bo(u), text: uo(o, u.from, u.to)};
            return tg(o, p, u.from.line, u.to.line + 1), Uo(o, function (f) {
                return tg(f, p, u.from.line, u.to.line + 1)
            }, !0), p
        }

        function Jc(o) {
            for (; o.length;) {
                var u = V(o);
                if (u.ranges) o.pop(); else break
            }
        }

        function Xf(o, u) {
            if (u) return Jc(o.done), V(o.done);
            if (o.done.length && !V(o.done).ranges) return V(o.done);
            if (o.done.length > 1 && !o.done[o.done.length - 2].ranges) return o.done.pop(), V(o.done)
        }

        function eg(o, u, p, f) {
            var m = o.history;
            m.undone.length = 0;
            var E = +new Date, N, P;
            if ((m.lastOp == f || m.lastOrigin == u.origin && u.origin && (u.origin.charAt(0) == "+" && m.lastModTime > E - (o.cm ? o.cm.options.historyEventDelay : 500) || u.origin.charAt(0) == "*")) && (N = Xf(m, m.lastOp == f))) P = V(N.changes), Qe(u.from, u.to) == 0 && Qe(u.from, P.to) == 0 ? P.to = bo(u) : N.changes.push(xd(o, u)); else {
                var F = V(m.done);
                for ((!F || !F.ranges) && Dl(o.sel, m.done), N = {
                    changes: [xd(o, u)],
                    generation: m.generation
                }, m.done.push(N); m.done.length > m.undoDepth;) m.done.shift(), m.done[0].ranges || m.done.shift()
            }
            m.done.push(p), m.generation = ++m.maxGeneration, m.lastModTime = m.lastSelTime = E, m.lastOp = m.lastSelOp = f, m.lastOrigin = m.lastSelOrigin = u.origin, P || cn(o, "historyAdded")
        }

        function Xc(o, u, p, f) {
            var m = u.charAt(0);
            return m == "*" || m == "+" && p.ranges.length == f.ranges.length && p.somethingSelected() == f.somethingSelected() && new Date - o.history.lastSelTime <= (o.cm ? o.cm.options.historyEventDelay : 500)
        }

        function Vm(o, u, p, f) {
            var m = o.history, E = f && f.origin;
            p == m.lastSelOp || E && m.lastSelOrigin == E && (m.lastModTime == m.lastSelTime && m.lastOrigin == E || Xc(o, E, V(m.done), u)) ? m.done[m.done.length - 1] = u : Dl(u, m.done), m.lastSelTime = +new Date, m.lastSelOrigin = E, m.lastSelOp = p, f && f.clearRedo !== !1 && Jc(m.undone)
        }

        function Dl(o, u) {
            var p = V(u);
            p && p.ranges && p.equals(o) || u.push(o)
        }

        function tg(o, u, p, f) {
            var m = u["spans_" + o.id], E = 0;
            o.iter(Math.max(o.first, p), Math.min(o.first + o.size, f), function (N) {
                N.markedSpans && ((m || (m = u["spans_" + o.id] = {}))[E] = N.markedSpans), ++E
            })
        }

        function Hm(o) {
            if (!o) return null;
            for (var u, p = 0; p < o.length; ++p) o[p].marker.explicitlyCleared ? u || (u = o.slice(0, p)) : u && u.push(o[p]);
            return u ? u.length ? u : null : o
        }

        function Um(o, u) {
            var p = u["spans_" + o.id];
            if (!p) return null;
            for (var f = [], m = 0; m < u.text.length; ++m) f.push(Hm(p[m]));
            return f
        }

        function Ed(o, u) {
            var p = Um(o, u), f = hs(o, u);
            if (!p) return f;
            if (!f) return p;
            for (var m = 0; m < p.length; ++m) {
                var E = p[m], N = f[m];
                if (E && N) e:for (var P = 0; P < N.length; ++P) {
                    for (var F = N[P], H = 0; H < E.length; ++H) if (E[H].marker == F.marker) continue e;
                    E.push(F)
                } else N && (p[m] = N)
            }
            return p
        }

        function ga(o, u, p) {
            for (var f = [], m = 0; m < o.length; ++m) {
                var E = o[m];
                if (E.ranges) {
                    f.push(p ? Lr.prototype.deepCopy.call(E) : E);
                    continue
                }
                var N = E.changes, P = [];
                f.push({changes: P});
                for (var F = 0; F < N.length; ++F) {
                    var H = N[F], X = void 0;
                    if (P.push({
                        from: H.from,
                        to: H.to,
                        text: H.text
                    }), u) for (var ie in H) (X = ie.match(/^spans_(\d+)$/)) && ct(u, Number(X[1])) > -1 && (V(P)[ie] = H[ie], delete H[ie])
                }
            }
            return f
        }

        function Sd(o, u, p, f) {
            if (f) {
                var m = o.anchor;
                if (p) {
                    var E = Qe(u, m) < 0;
                    E != Qe(p, m) < 0 ? (m = u, u = p) : E != Qe(u, p) < 0 && (u = p)
                }
                return new Kt(m, u)
            } else return new Kt(p || u, u)
        }

        function xl(o, u, p, f, m) {
            m == null && (m = o.cm && (o.cm.display.shift || o.extend)), yn(o, new Lr([Sd(o.sel.primary(), u, p, m)], 0), f)
        }

        function ng(o, u, p) {
            for (var f = [], m = o.cm && (o.cm.display.shift || o.extend), E = 0; E < o.sel.ranges.length; E++) f[E] = Sd(o.sel.ranges[E], u[E], null, m);
            var N = ai(o.cm, f, o.sel.primIndex);
            yn(o, N, p)
        }

        function El(o, u, p, f) {
            var m = o.sel.ranges.slice(0);
            m[u] = p, yn(o, ai(o.cm, m, o.sel.primIndex), f)
        }

        function eu(o, u, p, f) {
            yn(o, Vo(u, p), f)
        }

        function Td(o, u, p) {
            var f = {
                ranges: u.ranges, update: function (m) {
                    this.ranges = [];
                    for (var E = 0; E < m.length; E++) this.ranges[E] = new Kt(Et(o, m[E].anchor), Et(o, m[E].head))
                }, origin: p && p.origin
            };
            return cn(o, "beforeSelectionChange", o, f), o.cm && cn(o.cm, "beforeSelectionChange", o.cm, f), f.ranges != u.ranges ? ai(o.cm, f.ranges, f.ranges.length - 1) : u
        }

        function rg(o, u, p) {
            var f = o.history.done, m = V(f);
            m && m.ranges ? (f[f.length - 1] = u, pa(o, u, p)) : yn(o, u, p)
        }

        function yn(o, u, p) {
            pa(o, u, p), Vm(o, o.sel, o.cm ? o.cm.curOp.id : NaN, p)
        }

        function pa(o, u, p) {
            (zn(o, "beforeSelectionChange") || o.cm && zn(o.cm, "beforeSelectionChange")) && (u = Td(o, u, p));
            var f = p && p.bias || (Qe(u.primary().head, o.sel.primary().head) < 0 ? -1 : 1);
            Id(o, og(o, u, f, !0)), !(p && p.scroll === !1) && o.cm && o.cm.getOption("readOnly") != "nocursor" && bs(o.cm)
        }

        function Id(o, u) {
            u.equals(o.sel) || (o.sel = u, o.cm && (o.cm.curOp.updateInput = 1, o.cm.curOp.selectionChanged = !0, cr(o.cm)), Un(o, "cursorActivity", o))
        }

        function ig(o) {
            Id(o, og(o, o.sel, null, !1))
        }

        function og(o, u, p, f) {
            for (var m, E = 0; E < u.ranges.length; E++) {
                var N = u.ranges[E], P = u.ranges.length == o.sel.ranges.length && o.sel.ranges[E],
                    F = tu(o, N.anchor, P && P.anchor, p, f),
                    H = N.head == N.anchor ? F : tu(o, N.head, P && P.head, p, f);
                (m || F != N.anchor || H != N.head) && (m || (m = u.ranges.slice(0, E)), m[E] = new Kt(F, H))
            }
            return m ? ai(o.cm, m, u.primIndex) : u
        }

        function _s(o, u, p, f, m) {
            var E = dt(o, u.line);
            if (E.markedSpans) for (var N = 0; N < E.markedSpans.length; ++N) {
                var P = E.markedSpans[N], F = P.marker, H = "selectLeft" in F ? !F.selectLeft : F.inclusiveLeft,
                    X = "selectRight" in F ? !F.selectRight : F.inclusiveRight;
                if ((P.from == null || (H ? P.from <= u.ch : P.from < u.ch)) && (P.to == null || (X ? P.to >= u.ch : P.to > u.ch))) {
                    if (m && (cn(F, "beforeCursorEnter"), F.explicitlyCleared)) if (E.markedSpans) {
                        --N;
                        continue
                    } else break;
                    if (!F.atomic) continue;
                    if (p) {
                        var ie = F.find(f < 0 ? 1 : -1), be = void 0;
                        if ((f < 0 ? X : H) && (ie = sg(o, ie, -f, ie && ie.line == u.line ? E : null)), ie && ie.line == u.line && (be = Qe(ie, p)) && (f < 0 ? be < 0 : be > 0)) return _s(o, ie, u, f, m)
                    }
                    var fe = F.find(f < 0 ? -1 : 1);
                    return (f < 0 ? H : X) && (fe = sg(o, fe, f, fe.line == u.line ? E : null)), fe ? _s(o, fe, u, f, m) : null
                }
            }
            return u
        }

        function tu(o, u, p, f, m) {
            var E = f || 1,
                N = _s(o, u, p, E, m) || !m && _s(o, u, p, E, !0) || _s(o, u, p, -E, m) || !m && _s(o, u, p, -E, !0);
            return N || (o.cantEdit = !0, _e(o.first, 0))
        }

        function sg(o, u, p, f) {
            return p < 0 && u.ch == 0 ? u.line > o.first ? Et(o, _e(u.line - 1)) : null : p > 0 && u.ch == (f || dt(o, u.line)).text.length ? u.line < o.first + o.size - 1 ? _e(u.line + 1, 0) : null : new _e(u.line, u.ch + p)
        }

        function Md(o) {
            o.setSelection(_e(o.firstLine(), 0), _e(o.lastLine()), we)
        }

        function Bd(o, u, p) {
            var f = {
                canceled: !1, from: u.from, to: u.to, text: u.text, origin: u.origin, cancel: function () {
                    return f.canceled = !0
                }
            };
            return p && (f.update = function (m, E, N, P) {
                m && (f.from = Et(o, m)), E && (f.to = Et(o, E)), N && (f.text = N), P !== void 0 && (f.origin = P)
            }), cn(o, "beforeChange", o, f), o.cm && cn(o.cm, "beforeChange", o.cm, f), f.canceled ? (o.cm && (o.cm.curOp.updateInput = 2), null) : {
                from: f.from,
                to: f.to,
                text: f.text,
                origin: f.origin
            }
        }

        function ys(o, u, p) {
            if (o.cm) {
                if (!o.cm.curOp) return nr(o.cm, ys)(o, u, p);
                if (o.cm.state.suppressEdits) return
            }
            if (!((zn(o, "beforeChange") || o.cm && zn(o.cm, "beforeChange")) && (u = Bd(o, u, !0), !u))) {
                var f = ff && !p && Ju(o, u.from, u.to);
                if (f) for (var m = f.length - 1; m >= 0; --m) Re(o, {
                    from: f[m].from,
                    to: f[m].to,
                    text: m ? [""] : u.text,
                    origin: u.origin
                }); else Re(o, u)
            }
        }

        function Re(o, u) {
            if (!(u.text.length == 1 && u.text[0] == "" && Qe(u.from, u.to) == 0)) {
                var p = Zc(o, u);
                eg(o, u, p, o.cm ? o.cm.curOp.id : NaN), ma(o, u, p, hs(o, u));
                var f = [];
                Uo(o, function (m, E) {
                    !E && ct(f, m.history) == -1 && (lg(m.history, u), f.push(m.history)), ma(m, u, null, hs(m, u))
                })
            }
        }

        function Sl(o, u, p) {
            var f = o.cm && o.cm.state.suppressEdits;
            if (!(f && !p)) {
                for (var m = o.history, E, N = o.sel, P = u == "undo" ? m.done : m.undone, F = u == "undo" ? m.undone : m.done, H = 0; H < P.length && (E = P[H], !(p ? E.ranges && !E.equals(o.sel) : !E.ranges)); H++) ;
                if (H != P.length) {
                    for (m.lastOrigin = m.lastSelOrigin = null; ;) if (E = P.pop(), E.ranges) {
                        if (Dl(E, F), p && !E.equals(o.sel)) {
                            yn(o, E, {clearRedo: !1});
                            return
                        }
                        N = E
                    } else if (f) {
                        P.push(E);
                        return
                    } else break;
                    var X = [];
                    Dl(N, F), F.push({
                        changes: X,
                        generation: m.generation
                    }), m.generation = E.generation || ++m.maxGeneration;
                    for (var ie = zn(o, "beforeChange") || o.cm && zn(o.cm, "beforeChange"), be = function (Ne) {
                        var Ve = E.changes[Ne];
                        if (Ve.origin = u, ie && !Bd(o, Ve, !1)) return P.length = 0, {};
                        X.push(xd(o, Ve));
                        var $e = Ne ? Zc(o, Ve) : V(P);
                        ma(o, Ve, $e, Ed(o, Ve)), !Ne && o.cm && o.cm.scrollIntoView({from: Ve.from, to: bo(Ve)});
                        var et = [];
                        Uo(o, function (Ke, at) {
                            !at && ct(et, Ke.history) == -1 && (lg(Ke.history, Ve), et.push(Ke.history)), ma(Ke, Ve, null, Ed(Ke, Ve))
                        })
                    }, fe = E.changes.length - 1; fe >= 0; --fe) {
                        var xe = be(fe);
                        if (xe) return xe.v
                    }
                }
            }
        }

        function Ft(o, u) {
            if (u != 0 && (o.first += u, o.sel = new Lr($(o.sel.ranges, function (m) {
                return new Kt(_e(m.anchor.line + u, m.anchor.ch), _e(m.head.line + u, m.head.ch))
            }), o.sel.primIndex), o.cm)) {
                Cr(o.cm, o.first, o.first - u, u);
                for (var p = o.cm.display, f = p.viewFrom; f < p.viewTo; f++) Lt(o.cm, f, "gutter")
            }
        }

        function ma(o, u, p, f) {
            if (o.cm && !o.cm.curOp) return nr(o.cm, ma)(o, u, p, f);
            if (u.to.line < o.first) {
                Ft(o, u.text.length - 1 - (u.to.line - u.from.line));
                return
            }
            if (!(u.from.line > o.lastLine())) {
                if (u.from.line < o.first) {
                    var m = u.text.length - 1 - (o.first - u.from.line);
                    Ft(o, m), u = {
                        from: _e(o.first, 0),
                        to: _e(u.to.line + m, u.to.ch),
                        text: [V(u.text)],
                        origin: u.origin
                    }
                }
                var E = o.lastLine();
                u.to.line > E && (u = {
                    from: u.from,
                    to: _e(E, dt(o, E).text.length),
                    text: [u.text[0]],
                    origin: u.origin
                }), u.removed = uo(o, u.from, u.to), p || (p = Zc(o, u)), o.cm ? ag(o.cm, u, f) : Qc(o, u, f), pa(o, p, we), o.cantEdit && tu(o, _e(o.firstLine(), 0)) && (o.cantEdit = !1)
            }
        }

        function ag(o, u, p) {
            var f = o.doc, m = o.display, E = u.from, N = u.to, P = !1, F = E.line;
            o.options.lineWrapping || (F = W(_i(dt(f, E.line))), f.iter(F, N.line + 1, function (fe) {
                if (fe == m.maxLine) return P = !0, !0
            })), f.sel.contains(u.from, u.to) > -1 && cr(o), Qc(f, u, p, jn(o)), o.options.lineWrapping || (f.iter(F, E.line + u.text.length, function (fe) {
                var xe = ra(fe);
                xe > m.maxLineLength && (m.maxLine = fe, m.maxLineLength = xe, m.maxLineChanged = !0, P = !1)
            }), P && (o.curOp.updateMaxLine = !0)), ea(f, E.line), vl(o, 400);
            var H = u.text.length - (N.line - E.line) - 1;
            u.full ? Cr(o) : E.line == N.line && u.text.length == 1 && !sn(o.doc, u) ? Lt(o, E.line, "text") : Cr(o, E.line, N.line + 1, H);
            var X = zn(o, "changes"), ie = zn(o, "change");
            if (ie || X) {
                var be = {from: E, to: N, text: u.text, removed: u.removed, origin: u.origin};
                ie && Un(o, "change", o, be), X && (o.curOp.changeObjs || (o.curOp.changeObjs = [])).push(be)
            }
            o.display.selForContextMenu = null
        }

        function Ds(o, u, p, f, m) {
            var E;
            f || (f = p), Qe(f, p) < 0 && (E = [f, p], p = E[0], f = E[1]), typeof u == "string" && (u = o.splitLines(u)), ys(o, {
                from: p,
                to: f,
                text: u,
                origin: m
            })
        }

        function Nd(o, u, p, f) {
            p < o.line ? o.line += f : u < o.line && (o.line = u, o.ch = 0)
        }

        function Tl(o, u, p, f) {
            for (var m = 0; m < o.length; ++m) {
                var E = o[m], N = !0;
                if (E.ranges) {
                    E.copied || (E = o[m] = E.deepCopy(), E.copied = !0);
                    for (var P = 0; P < E.ranges.length; P++) Nd(E.ranges[P].anchor, u, p, f), Nd(E.ranges[P].head, u, p, f);
                    continue
                }
                for (var F = 0; F < E.changes.length; ++F) {
                    var H = E.changes[F];
                    if (p < H.from.line) H.from = _e(H.from.line + f, H.from.ch), H.to = _e(H.to.line + f, H.to.ch); else if (u <= H.to.line) {
                        N = !1;
                        break
                    }
                }
                N || (o.splice(0, m + 1), m = 0)
            }
        }

        function lg(o, u) {
            var p = u.from.line, f = u.to.line, m = u.text.length - (f - p) - 1;
            Tl(o.done, p, f, m), Tl(o.undone, p, f, m)
        }

        function ba(o, u, p, f) {
            var m = u, E = u;
            return typeof u == "number" ? E = dt(o, lf(o, u)) : m = W(u), m == null ? null : (f(E, m) && o.cm && Lt(o.cm, m, p), E)
        }

        function Il(o) {
            this.lines = o, this.parent = null;
            for (var u = 0, p = 0; p < o.length; ++p) o[p].parent = this, u += o[p].height;
            this.height = u
        }

        Il.prototype = {
            chunkSize: function () {
                return this.lines.length
            }, removeInner: function (o, u) {
                for (var p = o, f = o + u; p < f; ++p) {
                    var m = this.lines[p];
                    this.height -= m.height, Tm(m), Un(m, "delete")
                }
                this.lines.splice(o, u)
            }, collapse: function (o) {
                o.push.apply(o, this.lines)
            }, insertInner: function (o, u, p) {
                this.height += p, this.lines = this.lines.slice(0, o).concat(u).concat(this.lines.slice(o));
                for (var f = 0; f < u.length; ++f) u[f].parent = this
            }, iterN: function (o, u, p) {
                for (var f = o + u; o < f; ++o) if (p(this.lines[o])) return !0
            }
        };

        function qo(o) {
            this.children = o;
            for (var u = 0, p = 0, f = 0; f < o.length; ++f) {
                var m = o[f];
                u += m.chunkSize(), p += m.height, m.parent = this
            }
            this.size = u, this.height = p, this.parent = null
        }

        qo.prototype = {
            chunkSize: function () {
                return this.size
            }, removeInner: function (o, u) {
                this.size -= u;
                for (var p = 0; p < this.children.length; ++p) {
                    var f = this.children[p], m = f.chunkSize();
                    if (o < m) {
                        var E = Math.min(u, m - o), N = f.height;
                        if (f.removeInner(o, E), this.height -= N - f.height, m == E && (this.children.splice(p--, 1), f.parent = null), (u -= E) == 0) break;
                        o = 0
                    } else o -= m
                }
                if (this.size - u < 25 && (this.children.length > 1 || !(this.children[0] instanceof Il))) {
                    var P = [];
                    this.collapse(P), this.children = [new Il(P)], this.children[0].parent = this
                }
            }, collapse: function (o) {
                for (var u = 0; u < this.children.length; ++u) this.children[u].collapse(o)
            }, insertInner: function (o, u, p) {
                this.size += u.length, this.height += p;
                for (var f = 0; f < this.children.length; ++f) {
                    var m = this.children[f], E = m.chunkSize();
                    if (o <= E) {
                        if (m.insertInner(o, u, p), m.lines && m.lines.length > 50) {
                            for (var N = m.lines.length % 25 + 25, P = N; P < m.lines.length;) {
                                var F = new Il(m.lines.slice(P, P += 25));
                                m.height -= F.height, this.children.splice(++f, 0, F), F.parent = this
                            }
                            m.lines = m.lines.slice(0, N), this.maybeSpill()
                        }
                        break
                    }
                    o -= E
                }
            }, maybeSpill: function () {
                if (!(this.children.length <= 10)) {
                    var o = this;
                    do {
                        var u = o.children.splice(o.children.length - 5, 5), p = new qo(u);
                        if (o.parent) {
                            o.size -= p.size, o.height -= p.height;
                            var m = ct(o.parent.children, o);
                            o.parent.children.splice(m + 1, 0, p)
                        } else {
                            var f = new qo(o.children);
                            f.parent = o, o.children = [f, p], o = f
                        }
                        p.parent = o.parent
                    } while (o.children.length > 10);
                    o.parent.maybeSpill()
                }
            }, iterN: function (o, u, p) {
                for (var f = 0; f < this.children.length; ++f) {
                    var m = this.children[f], E = m.chunkSize();
                    if (o < E) {
                        var N = Math.min(u, E - o);
                        if (m.iterN(o, N, p)) return !0;
                        if ((u -= N) == 0) break;
                        o = 0
                    } else o -= E
                }
            }
        };
        var ka = function (o, u, p) {
            if (p) for (var f in p) p.hasOwnProperty(f) && (this[f] = p[f]);
            this.doc = o, this.node = u
        };
        ka.prototype.clear = function () {
            var o = this.doc.cm, u = this.line.widgets, p = this.line, f = W(p);
            if (!(f == null || !u)) {
                for (var m = 0; m < u.length; ++m) u[m] == this && u.splice(m--, 1);
                u.length || (p.widgets = null);
                var E = ll(this);
                mr(p, Math.max(0, p.height - E)), o && (_r(o, function () {
                    Ld(o, p, -E), Lt(o, f, "widget")
                }), Un(o, "lineWidgetCleared", o, this, f))
            }
        }, ka.prototype.changed = function () {
            var o = this, u = this.height, p = this.doc.cm, f = this.line;
            this.height = null;
            var m = ll(this) - u;
            m && (No(this.doc, f) || mr(f, f.height + m), p && _r(p, function () {
                p.curOp.forceUpdate = !0, Ld(p, f, m), Un(p, "lineWidgetChanged", p, o, W(f))
            }))
        }, Hr(ka);

        function Ld(o, u, p) {
            oi(u) < (o.curOp && o.curOp.scrollTop || o.doc.scrollTop) && Hc(o, p)
        }

        function qm(o, u, p, f) {
            var m = new ka(o, p, f), E = o.cm;
            return E && m.noHScroll && (E.display.alignWidgets = !0), ba(o, u, "widget", function (N) {
                var P = N.widgets || (N.widgets = []);
                if (m.insertAt == null ? P.push(m) : P.splice(Math.min(P.length, Math.max(0, m.insertAt)), 0, m), m.line = N, E && !No(o, N)) {
                    var F = oi(N) < o.scrollTop;
                    mr(N, N.height + ll(m)), F && Hc(E, m.height), E.curOp.forceUpdate = !0
                }
                return !0
            }), E && Un(E, "lineWidgetAdded", E, m, typeof u == "number" ? u : W(u)), m
        }

        var nu = 0, ko = function (o, u) {
            this.lines = [], this.type = u, this.doc = o, this.id = ++nu
        };
        ko.prototype.clear = function () {
            if (!this.explicitlyCleared) {
                var o = this.doc.cm, u = o && !o.curOp;
                if (u && ws(o), zn(this, "clear")) {
                    var p = this.find();
                    p && Un(this, "clear", p.from, p.to)
                }
                for (var f = null, m = null, E = 0; E < this.lines.length; ++E) {
                    var N = this.lines[E], P = ds(N.markedSpans, this);
                    o && !this.collapsed ? Lt(o, W(N), "text") : o && (P.to != null && (m = W(N)), P.from != null && (f = W(N))), N.markedSpans = xm(N.markedSpans, P), P.from == null && this.collapsed && !No(this.doc, N) && o && mr(N, la(o.display))
                }
                if (o && this.collapsed && !o.options.lineWrapping) for (var F = 0; F < this.lines.length; ++F) {
                    var H = _i(this.lines[F]), X = ra(H);
                    X > o.display.maxLineLength && (o.display.maxLine = H, o.display.maxLineLength = X, o.display.maxLineChanged = !0)
                }
                f != null && o && this.collapsed && Cr(o, f, m + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, o && ig(o.doc)), o && Un(o, "markerCleared", o, this, f, m), u && br(o), this.parent && this.parent.clear()
            }
        }, ko.prototype.find = function (o, u) {
            o == null && this.type == "bookmark" && (o = 1);
            for (var p, f, m = 0; m < this.lines.length; ++m) {
                var E = this.lines[m], N = ds(E.markedSpans, this);
                if (N.from != null && (p = _e(u ? E : W(E), N.from), o == -1)) return p;
                if (N.to != null && (f = _e(u ? E : W(E), N.to), o == 1)) return f
            }
            return p && {from: p, to: f}
        }, ko.prototype.changed = function () {
            var o = this, u = this.find(-1, !0), p = this, f = this.doc.cm;
            !u || !f || _r(f, function () {
                var m = u.line, E = W(u.line), N = Lc(f, E);
                if (N && (jf(N), f.curOp.selectionChanged = f.curOp.forceUpdate = !0), f.curOp.updateMaxLine = !0, !No(p.doc, m) && p.height != null) {
                    var P = p.height;
                    p.height = null;
                    var F = ll(p) - P;
                    F && mr(m, m.height + F)
                }
                Un(f, "markerChanged", f, o)
            })
        }, ko.prototype.attachLine = function (o) {
            if (!this.lines.length && this.doc.cm) {
                var u = this.doc.cm.curOp;
                (!u.maybeHiddenMarkers || ct(u.maybeHiddenMarkers, this) == -1) && (u.maybeUnhiddenMarkers || (u.maybeUnhiddenMarkers = [])).push(this)
            }
            this.lines.push(o)
        }, ko.prototype.detachLine = function (o) {
            if (this.lines.splice(ct(this.lines, o), 1), !this.lines.length && this.doc.cm) {
                var u = this.doc.cm.curOp;
                (u.maybeHiddenMarkers || (u.maybeHiddenMarkers = [])).push(this)
            }
        }, Hr(ko);

        function va(o, u, p, f, m) {
            if (f && f.shared) return cg(o, u, p, f, m);
            if (o.cm && !o.cm.curOp) return nr(o.cm, va)(o, u, p, f, m);
            var E = new ko(o, m), N = Qe(u, p);
            if (f && ht(f, E, !1), N > 0 || N == 0 && E.clearWhenEmpty !== !1) return E;
            if (E.replacedWith && (E.collapsed = !0, E.widgetNode = qe("span", [E.replacedWith], "CodeMirror-widget"), f.handleMouseEvents || E.widgetNode.setAttribute("cm-ignore-events", "true"), f.insertLeft && (E.widgetNode.insertLeft = !0)), E.collapsed) {
                if (Ic(o, u.line, u, p, E) || u.line != p.line && Ic(o, p.line, u, p, E)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
                Dm()
            }
            E.addToHistory && eg(o, {from: u, to: p, origin: "markText"}, o.sel, NaN);
            var P = u.line, F = o.cm, H;
            if (o.iter(P, p.line + 1, function (ie) {
                F && E.collapsed && !F.options.lineWrapping && _i(ie) == F.display.maxLine && (H = !0), E.collapsed && P != u.line && mr(ie, 0), pf(ie, new xc(E, P == u.line ? u.ch : null, P == p.line ? p.ch : null), o.cm && o.cm.curOp), ++P
            }), E.collapsed && o.iter(u.line, p.line + 1, function (ie) {
                No(o, ie) && mr(ie, 0)
            }), E.clearOnEnter && ft(E, "beforeCursorEnter", function () {
                return E.clear()
            }), E.readOnly && (gf(), (o.history.done.length || o.history.undone.length) && o.clearHistory()), E.collapsed && (E.id = ++nu, E.atomic = !0), F) {
                if (H && (F.curOp.updateMaxLine = !0), E.collapsed) Cr(F, u.line, p.line + 1); else if (E.className || E.startStyle || E.endStyle || E.css || E.attributes || E.title) for (var X = u.line; X <= p.line; X++) Lt(F, X, "text");
                E.atomic && ig(F.doc), Un(F, "markerAdded", F, E)
            }
            return E
        }

        var Ei = function (o, u) {
            this.markers = o, this.primary = u;
            for (var p = 0; p < o.length; ++p) o[p].parent = this
        };
        Ei.prototype.clear = function () {
            if (!this.explicitlyCleared) {
                this.explicitlyCleared = !0;
                for (var o = 0; o < this.markers.length; ++o) this.markers[o].clear();
                Un(this, "clear")
            }
        }, Ei.prototype.find = function (o, u) {
            return this.primary.find(o, u)
        }, Hr(Ei);

        function cg(o, u, p, f, m) {
            f = ht(f), f.shared = !1;
            var E = [va(o, u, p, f, m)], N = E[0], P = f.widgetNode;
            return Uo(o, function (F) {
                P && (f.widgetNode = P.cloneNode(!0)), E.push(va(F, Et(F, u), Et(F, p), f, m));
                for (var H = 0; H < F.linked.length; ++H) if (F.linked[H].isParent) return;
                N = V(E)
            }), new Ei(E, N)
        }

        function Wo(o) {
            return o.findMarks(_e(o.first, 0), o.clipPos(_e(o.lastLine())), function (u) {
                return u.parent
            })
        }

        function dn(o, u) {
            for (var p = 0; p < u.length; p++) {
                var f = u[p], m = f.find(), E = o.clipPos(m.from), N = o.clipPos(m.to);
                if (Qe(E, N)) {
                    var P = va(o, E, N, f.primary, f.primary.type);
                    f.markers.push(P), P.parent = f
                }
            }
        }

        function $i(o) {
            for (var u = function (f) {
                var m = o[f], E = [m.primary.doc];
                Uo(m.primary.doc, function (F) {
                    return E.push(F)
                });
                for (var N = 0; N < m.markers.length; N++) {
                    var P = m.markers[N];
                    ct(E, P.doc) == -1 && (P.parent = null, m.markers.splice(N--, 1))
                }
            }, p = 0; p < o.length; p++) u(p)
        }

        var Si = 0, yr = function (o, u, p, f, m) {
            if (!(this instanceof yr)) return new yr(o, u, p, f, m);
            p == null && (p = 0), qo.call(this, [new Il([new ia("", null)])]), this.first = p, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = p;
            var E = _e(p, 0);
            this.sel = Vo(E), this.history = new yl(null), this.id = ++Si, this.modeOption = u, this.lineSep = f, this.direction = m == "rtl" ? "rtl" : "ltr", this.extend = !1, typeof o == "string" && (o = this.splitLines(o)), Qc(this, {
                from: E,
                to: E,
                text: o
            }), yn(this, Vo(E), we)
        };
        yr.prototype = de(qo.prototype, {
            constructor: yr, iter: function (o, u, p) {
                p ? this.iterN(o - this.first, u - o, p) : this.iterN(this.first, this.first + this.size, o)
            }, insert: function (o, u) {
                for (var p = 0, f = 0; f < u.length; ++f) p += u[f].height;
                this.insertInner(o - this.first, u, p)
            }, remove: function (o, u) {
                this.removeInner(o - this.first, u)
            }, getValue: function (o) {
                var u = Ci(this, this.first, this.first + this.size);
                return o === !1 ? u : u.join(o || this.lineSeparator())
            }, setValue: un(function (o) {
                var u = _e(this.first, 0), p = this.first + this.size - 1;
                ys(this, {
                    from: u,
                    to: _e(p, dt(this, p).text.length),
                    text: this.splitLines(o),
                    origin: "setValue",
                    full: !0
                }, !0), this.cm && ks(this.cm, 0, 0), yn(this, Vo(u), we)
            }), replaceRange: function (o, u, p, f) {
                u = Et(this, u), p = p ? Et(this, p) : u, Ds(this, o, u, p, f)
            }, getRange: function (o, u, p) {
                var f = uo(this, Et(this, o), Et(this, u));
                return p === !1 ? f : p === "" ? f.join("") : f.join(p || this.lineSeparator())
            }, getLine: function (o) {
                var u = this.getLineHandle(o);
                return u && u.text
            }, getLineHandle: function (o) {
                if (Te(this, o)) return dt(this, o)
            }, getLineNumber: function (o) {
                return W(o)
            }, getLineHandleVisualStart: function (o) {
                return typeof o == "number" && (o = dt(this, o)), _i(o)
            }, lineCount: function () {
                return this.size
            }, firstLine: function () {
                return this.first
            }, lastLine: function () {
                return this.first + this.size - 1
            }, clipPos: function (o) {
                return Et(this, o)
            }, getCursor: function (o) {
                var u = this.sel.primary(), p;
                return o == null || o == "head" ? p = u.head : o == "anchor" ? p = u.anchor : o == "end" || o == "to" || o === !1 ? p = u.to() : p = u.from(), p
            }, listSelections: function () {
                return this.sel.ranges
            }, somethingSelected: function () {
                return this.sel.somethingSelected()
            }, setCursor: un(function (o, u, p) {
                eu(this, Et(this, typeof o == "number" ? _e(o, u || 0) : o), null, p)
            }), setSelection: un(function (o, u, p) {
                eu(this, Et(this, o), Et(this, u || o), p)
            }), extendSelection: un(function (o, u, p) {
                xl(this, Et(this, o), u && Et(this, u), p)
            }), extendSelections: un(function (o, u) {
                ng(this, cf(this, o), u)
            }), extendSelectionsBy: un(function (o, u) {
                var p = $(this.sel.ranges, o);
                ng(this, cf(this, p), u)
            }), setSelections: un(function (o, u, p) {
                if (o.length) {
                    for (var f = [], m = 0; m < o.length; m++) f[m] = new Kt(Et(this, o[m].anchor), Et(this, o[m].head || o[m].anchor));
                    u == null && (u = Math.min(o.length - 1, this.sel.primIndex)), yn(this, ai(this.cm, f, u), p)
                }
            }), addSelection: un(function (o, u, p) {
                var f = this.sel.ranges.slice(0);
                f.push(new Kt(Et(this, o), Et(this, u || o))), yn(this, ai(this.cm, f, f.length - 1), p)
            }), getSelection: function (o) {
                for (var u = this.sel.ranges, p, f = 0; f < u.length; f++) {
                    var m = uo(this, u[f].from(), u[f].to());
                    p = p ? p.concat(m) : m
                }
                return o === !1 ? p : p.join(o || this.lineSeparator())
            }, getSelections: function (o) {
                for (var u = [], p = this.sel.ranges, f = 0; f < p.length; f++) {
                    var m = uo(this, p[f].from(), p[f].to());
                    o !== !1 && (m = m.join(o || this.lineSeparator())), u[f] = m
                }
                return u
            }, replaceSelection: function (o, u, p) {
                for (var f = [], m = 0; m < this.sel.ranges.length; m++) f[m] = o;
                this.replaceSelections(f, u, p || "+input")
            }, replaceSelections: un(function (o, u, p) {
                for (var f = [], m = this.sel, E = 0; E < m.ranges.length; E++) {
                    var N = m.ranges[E];
                    f[E] = {from: N.from(), to: N.to(), text: this.splitLines(o[E]), origin: p}
                }
                for (var P = u && u != "end" && zm(this, f, u), F = f.length - 1; F >= 0; F--) ys(this, f[F]);
                P ? rg(this, P) : this.cm && bs(this.cm)
            }), undo: un(function () {
                Sl(this, "undo")
            }), redo: un(function () {
                Sl(this, "redo")
            }), undoSelection: un(function () {
                Sl(this, "undo", !0)
            }), redoSelection: un(function () {
                Sl(this, "redo", !0)
            }), setExtending: function (o) {
                this.extend = o
            }, getExtending: function () {
                return this.extend
            }, historySize: function () {
                for (var o = this.history, u = 0, p = 0, f = 0; f < o.done.length; f++) o.done[f].ranges || ++u;
                for (var m = 0; m < o.undone.length; m++) o.undone[m].ranges || ++p;
                return {undo: u, redo: p}
            }, clearHistory: function () {
                var o = this;
                this.history = new yl(this.history), Uo(this, function (u) {
                    return u.history = o.history
                }, !0)
            }, markClean: function () {
                this.cleanGeneration = this.changeGeneration(!0)
            }, changeGeneration: function (o) {
                return o && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation
            }, isClean: function (o) {
                return this.history.generation == (o || this.cleanGeneration)
            }, getHistory: function () {
                return {done: ga(this.history.done), undone: ga(this.history.undone)}
            }, setHistory: function (o) {
                var u = this.history = new yl(this.history);
                u.done = ga(o.done.slice(0), null, !0), u.undone = ga(o.undone.slice(0), null, !0)
            }, setGutterMarker: un(function (o, u, p) {
                return ba(this, o, "gutter", function (f) {
                    var m = f.gutterMarkers || (f.gutterMarkers = {});
                    return m[u] = p, !p && Ie(m) && (f.gutterMarkers = null), !0
                })
            }), clearGutter: un(function (o) {
                var u = this;
                this.iter(function (p) {
                    p.gutterMarkers && p.gutterMarkers[o] && ba(u, p, "gutter", function () {
                        return p.gutterMarkers[o] = null, Ie(p.gutterMarkers) && (p.gutterMarkers = null), !0
                    })
                })
            }), lineInfo: function (o) {
                var u;
                if (typeof o == "number") {
                    if (!Te(this, o) || (u = o, o = dt(this, o), !o)) return null
                } else if (u = W(o), u == null) return null;
                return {
                    line: u,
                    handle: o,
                    text: o.text,
                    gutterMarkers: o.gutterMarkers,
                    textClass: o.textClass,
                    bgClass: o.bgClass,
                    wrapClass: o.wrapClass,
                    widgets: o.widgets
                }
            }, addLineClass: un(function (o, u, p) {
                return ba(this, o, u == "gutter" ? "gutter" : "class", function (f) {
                    var m = u == "text" ? "textClass" : u == "background" ? "bgClass" : u == "gutter" ? "gutterClass" : "wrapClass";
                    if (!f[m]) f[m] = p; else {
                        if (ve(p).test(f[m])) return !1;
                        f[m] += " " + p
                    }
                    return !0
                })
            }), removeLineClass: un(function (o, u, p) {
                return ba(this, o, u == "gutter" ? "gutter" : "class", function (f) {
                    var m = u == "text" ? "textClass" : u == "background" ? "bgClass" : u == "gutter" ? "gutterClass" : "wrapClass",
                        E = f[m];
                    if (E) if (p == null) f[m] = null; else {
                        var N = E.match(ve(p));
                        if (!N) return !1;
                        var P = N.index + N[0].length;
                        f[m] = E.slice(0, N.index) + (!N.index || P == E.length ? "" : " ") + E.slice(P) || null
                    } else return !1;
                    return !0
                })
            }), addLineWidget: un(function (o, u, p) {
                return qm(this, o, u, p)
            }), removeLineWidget: function (o) {
                o.clear()
            }, markText: function (o, u, p) {
                return va(this, Et(this, o), Et(this, u), p, p && p.type || "range")
            }, setBookmark: function (o, u) {
                var p = {
                    replacedWith: u && (u.nodeType == null ? u.widget : u),
                    insertLeft: u && u.insertLeft,
                    clearWhenEmpty: !1,
                    shared: u && u.shared,
                    handleMouseEvents: u && u.handleMouseEvents
                };
                return o = Et(this, o), va(this, o, o, p, "bookmark")
            }, findMarksAt: function (o) {
                o = Et(this, o);
                var u = [], p = dt(this, o.line).markedSpans;
                if (p) for (var f = 0; f < p.length; ++f) {
                    var m = p[f];
                    (m.from == null || m.from <= o.ch) && (m.to == null || m.to >= o.ch) && u.push(m.marker.parent || m.marker)
                }
                return u
            }, findMarks: function (o, u, p) {
                o = Et(this, o), u = Et(this, u);
                var f = [], m = o.line;
                return this.iter(o.line, u.line + 1, function (E) {
                    var N = E.markedSpans;
                    if (N) for (var P = 0; P < N.length; P++) {
                        var F = N[P];
                        !(F.to != null && m == o.line && o.ch >= F.to || F.from == null && m != o.line || F.from != null && m == u.line && F.from >= u.ch) && (!p || p(F.marker)) && f.push(F.marker.parent || F.marker)
                    }
                    ++m
                }), f
            }, getAllMarks: function () {
                var o = [];
                return this.iter(function (u) {
                    var p = u.markedSpans;
                    if (p) for (var f = 0; f < p.length; ++f) p[f].from != null && o.push(p[f].marker)
                }), o
            }, posFromIndex: function (o) {
                var u, p = this.first, f = this.lineSeparator().length;
                return this.iter(function (m) {
                    var E = m.text.length + f;
                    if (E > o) return u = o, !0;
                    o -= E, ++p
                }), Et(this, _e(p, u))
            }, indexFromPos: function (o) {
                o = Et(this, o);
                var u = o.ch;
                if (o.line < this.first || o.ch < 0) return 0;
                var p = this.lineSeparator().length;
                return this.iter(this.first, o.line, function (f) {
                    u += f.text.length + p
                }), u
            }, copy: function (o) {
                var u = new yr(Ci(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
                return u.scrollTop = this.scrollTop, u.scrollLeft = this.scrollLeft, u.sel = this.sel, u.extend = !1, o && (u.history.undoDepth = this.history.undoDepth, u.setHistory(this.getHistory())), u
            }, linkedDoc: function (o) {
                o || (o = {});
                var u = this.first, p = this.first + this.size;
                o.from != null && o.from > u && (u = o.from), o.to != null && o.to < p && (p = o.to);
                var f = new yr(Ci(this, u, p), o.mode || this.modeOption, u, this.lineSep, this.direction);
                return o.sharedHist && (f.history = this.history), (this.linked || (this.linked = [])).push({
                    doc: f,
                    sharedHist: o.sharedHist
                }), f.linked = [{doc: this, isParent: !0, sharedHist: o.sharedHist}], dn(f, Wo(this)), f
            }, unlinkDoc: function (o) {
                if (o instanceof gn && (o = o.doc), this.linked) for (var u = 0; u < this.linked.length; ++u) {
                    var p = this.linked[u];
                    if (p.doc == o) {
                        this.linked.splice(u, 1), o.unlinkDoc(this), $i(Wo(this));
                        break
                    }
                }
                if (o.history == this.history) {
                    var f = [o.id];
                    Uo(o, function (m) {
                        return f.push(m.id)
                    }, !0), o.history = new yl(null), o.history.done = ga(this.history.done, f), o.history.undone = ga(this.history.undone, f)
                }
            }, iterLinkedDocs: function (o) {
                Uo(this, o)
            }, getMode: function () {
                return this.mode
            }, getEditor: function () {
                return this.cm
            }, splitLines: function (o) {
                return this.lineSep ? o.split(this.lineSep) : Br(o)
            }, lineSeparator: function () {
                return this.lineSep || `
`
            }, setDirection: un(function (o) {
                o != "rtl" && (o = "ltr"), o != this.direction && (this.direction = o, this.iter(function (u) {
                    return u.order = null
                }), this.cm && jm(this.cm))
            })
        }), yr.prototype.eachLine = yr.prototype.iter;
        var ru = 0;

        function iu(o) {
            var u = this;
            if (ug(u), !(fn(u, o) || fo(u.display, o))) {
                Sn(o), w && (ru = +new Date);
                var p = Oo(u, o, !0), f = o.dataTransfer.files;
                if (!(!p || u.isReadOnly())) if (f && f.length && window.FileReader && window.File) for (var m = f.length, E = Array(m), N = 0, P = function () {
                    ++N == m && nr(u, function () {
                        p = Et(u.doc, p);
                        var fe = {
                            from: p, to: p, text: u.doc.splitLines(E.filter(function (xe) {
                                return xe != null
                            }).join(u.doc.lineSeparator())), origin: "paste"
                        };
                        ys(u.doc, fe), rg(u.doc, Vo(Et(u.doc, p), Et(u.doc, bo(fe))))
                    })()
                }, F = function (fe, xe) {
                    if (u.options.allowDropFileTypes && ct(u.options.allowDropFileTypes, fe.type) == -1) {
                        P();
                        return
                    }
                    var Ne = new FileReader;
                    Ne.onerror = function () {
                        return P()
                    }, Ne.onload = function () {
                        var Ve = Ne.result;
                        if (/[\x00-\x08\x0e-\x1f]{2}/.test(Ve)) {
                            P();
                            return
                        }
                        E[xe] = Ve, P()
                    }, Ne.readAsText(fe)
                }, H = 0; H < f.length; H++) F(f[H], H); else {
                    if (u.state.draggingText && u.doc.sel.contains(p) > -1) {
                        u.state.draggingText(o), setTimeout(function () {
                            return u.display.input.focus()
                        }, 20);
                        return
                    }
                    try {
                        var X = o.dataTransfer.getData("Text");
                        if (X) {
                            var ie;
                            if (u.state.draggingText && !u.state.draggingText.copy && (ie = u.listSelections()), pa(u.doc, Vo(p, p)), ie) for (var be = 0; be < ie.length; ++be) Ds(u.doc, "", ie[be].anchor, ie[be].head, "drag");
                            u.replaceSelection(X, "around", "paste"), u.display.input.focus()
                        }
                    } catch {
                    }
                }
            }
        }

        function Wm(o, u) {
            if (w && (!o.state.draggingText || +new Date - ru < 100)) {
                ti(u);
                return
            }
            if (!(fn(o, u) || fo(o.display, u)) && (u.dataTransfer.setData("Text", o.getSelection()), u.dataTransfer.effectAllowed = "copyMove", u.dataTransfer.setDragImage && !z)) {
                var p = ee("img", null, null, "position: fixed; left: 0; top: 0;");
                p.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", L && (p.width = p.height = 1, o.display.wrapper.appendChild(p), p._top = p.offsetTop), u.dataTransfer.setDragImage(p, 0, 0), L && p.parentNode.removeChild(p)
            }
        }

        function $m(o, u) {
            var p = Oo(o, u);
            if (p) {
                var f = document.createDocumentFragment();
                Fc(o, p, f), o.display.dragCursor || (o.display.dragCursor = ee("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), o.display.lineSpace.insertBefore(o.display.dragCursor, o.display.cursorDiv)), ye(o.display.dragCursor, f)
            }
        }

        function ug(o) {
            o.display.dragCursor && (o.display.lineSpace.removeChild(o.display.dragCursor), o.display.dragCursor = null)
        }

        function ou(o) {
            if (document.getElementsByClassName) {
                for (var u = document.getElementsByClassName("CodeMirror"), p = [], f = 0; f < u.length; f++) {
                    var m = u[f].CodeMirror;
                    m && p.push(m)
                }
                p.length && p[0].operation(function () {
                    for (var E = 0; E < p.length; E++) o(p[E])
                })
            }
        }

        var dg = !1;

        function Gm() {
            dg || (Km(), dg = !0)
        }

        function Km() {
            var o;
            ft(window, "resize", function () {
                o == null && (o = setTimeout(function () {
                    o = null, ou(Zm)
                }, 100))
            }), ft(window, "blur", function () {
                return ou(zo)
            })
        }

        function Zm(o) {
            var u = o.display;
            u.cachedCharWidth = u.cachedTextHeight = u.cachedPaddingH = null, u.scrollbarsClipped = !1, o.setSize()
        }

        for (var $o = {
            3: "Pause",
            8: "Backspace",
            9: "Tab",
            13: "Enter",
            16: "Shift",
            17: "Ctrl",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "PrintScrn",
            45: "Insert",
            46: "Delete",
            59: ";",
            61: "=",
            91: "Mod",
            92: "Mod",
            93: "Mod",
            106: "*",
            107: "=",
            109: "-",
            110: ".",
            111: "/",
            145: "ScrollLock",
            173: "-",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'",
            224: "Mod",
            63232: "Up",
            63233: "Down",
            63234: "Left",
            63235: "Right",
            63272: "Delete",
            63273: "Home",
            63275: "End",
            63276: "PageUp",
            63277: "PageDown",
            63302: "Insert"
        }, Ml = 0; Ml < 10; Ml++) $o[Ml + 48] = $o[Ml + 96] = String(Ml);
        for (var su = 65; su <= 90; su++) $o[su] = String.fromCharCode(su);
        for (var wa = 1; wa <= 12; wa++) $o[wa + 111] = $o[wa + 63235] = "F" + wa;
        var Gi = {};
        Gi.basic = {
            Left: "goCharLeft",
            Right: "goCharRight",
            Up: "goLineUp",
            Down: "goLineDown",
            End: "goLineEnd",
            Home: "goLineStartSmart",
            PageUp: "goPageUp",
            PageDown: "goPageDown",
            Delete: "delCharAfter",
            Backspace: "delCharBefore",
            "Shift-Backspace": "delCharBefore",
            Tab: "defaultTab",
            "Shift-Tab": "indentAuto",
            Enter: "newlineAndIndent",
            Insert: "toggleOverwrite",
            Esc: "singleSelection"
        }, Gi.pcDefault = {
            "Ctrl-A": "selectAll",
            "Ctrl-D": "deleteLine",
            "Ctrl-Z": "undo",
            "Shift-Ctrl-Z": "redo",
            "Ctrl-Y": "redo",
            "Ctrl-Home": "goDocStart",
            "Ctrl-End": "goDocEnd",
            "Ctrl-Up": "goLineUp",
            "Ctrl-Down": "goLineDown",
            "Ctrl-Left": "goGroupLeft",
            "Ctrl-Right": "goGroupRight",
            "Alt-Left": "goLineStart",
            "Alt-Right": "goLineEnd",
            "Ctrl-Backspace": "delGroupBefore",
            "Ctrl-Delete": "delGroupAfter",
            "Ctrl-S": "save",
            "Ctrl-F": "find",
            "Ctrl-G": "findNext",
            "Shift-Ctrl-G": "findPrev",
            "Shift-Ctrl-F": "replace",
            "Shift-Ctrl-R": "replaceAll",
            "Ctrl-[": "indentLess",
            "Ctrl-]": "indentMore",
            "Ctrl-U": "undoSelection",
            "Shift-Ctrl-U": "redoSelection",
            "Alt-U": "redoSelection",
            fallthrough: "basic"
        }, Gi.emacsy = {
            "Ctrl-F": "goCharRight",
            "Ctrl-B": "goCharLeft",
            "Ctrl-P": "goLineUp",
            "Ctrl-N": "goLineDown",
            "Ctrl-A": "goLineStart",
            "Ctrl-E": "goLineEnd",
            "Ctrl-V": "goPageDown",
            "Shift-Ctrl-V": "goPageUp",
            "Ctrl-D": "delCharAfter",
            "Ctrl-H": "delCharBefore",
            "Alt-Backspace": "delWordBefore",
            "Ctrl-K": "killLine",
            "Ctrl-T": "transposeChars",
            "Ctrl-O": "openLine"
        }, Gi.macDefault = {
            "Cmd-A": "selectAll",
            "Cmd-D": "deleteLine",
            "Cmd-Z": "undo",
            "Shift-Cmd-Z": "redo",
            "Cmd-Y": "redo",
            "Cmd-Home": "goDocStart",
            "Cmd-Up": "goDocStart",
            "Cmd-End": "goDocEnd",
            "Cmd-Down": "goDocEnd",
            "Alt-Left": "goGroupLeft",
            "Alt-Right": "goGroupRight",
            "Cmd-Left": "goLineLeft",
            "Cmd-Right": "goLineRight",
            "Alt-Backspace": "delGroupBefore",
            "Ctrl-Alt-Backspace": "delGroupAfter",
            "Alt-Delete": "delGroupAfter",
            "Cmd-S": "save",
            "Cmd-F": "find",
            "Cmd-G": "findNext",
            "Shift-Cmd-G": "findPrev",
            "Cmd-Alt-F": "replace",
            "Shift-Cmd-Alt-F": "replaceAll",
            "Cmd-[": "indentLess",
            "Cmd-]": "indentMore",
            "Cmd-Backspace": "delWrappedLineLeft",
            "Cmd-Delete": "delWrappedLineRight",
            "Cmd-U": "undoSelection",
            "Shift-Cmd-U": "redoSelection",
            "Ctrl-Up": "goDocStart",
            "Ctrl-Down": "goDocEnd",
            fallthrough: ["basic", "emacsy"]
        }, Gi.default = ce ? Gi.macDefault : Gi.pcDefault;

        function Ym(o) {
            var u = o.split(/-(?!$)/);
            o = u[u.length - 1];
            for (var p, f, m, E, N = 0; N < u.length - 1; N++) {
                var P = u[N];
                if (/^(cmd|meta|m)$/i.test(P)) E = !0; else if (/^a(lt)?$/i.test(P)) p = !0; else if (/^(c|ctrl|control)$/i.test(P)) f = !0; else if (/^s(hift)?$/i.test(P)) m = !0; else throw new Error("Unrecognized modifier name: " + P)
            }
            return p && (o = "Alt-" + o), f && (o = "Ctrl-" + o), E && (o = "Cmd-" + o), m && (o = "Shift-" + o), o
        }

        function Pd(o) {
            var u = {};
            for (var p in o) if (o.hasOwnProperty(p)) {
                var f = o[p];
                if (/^(name|fallthrough|(de|at)tach)$/.test(p)) continue;
                if (f == "...") {
                    delete o[p];
                    continue
                }
                for (var m = $(p.split(" "), Ym), E = 0; E < m.length; E++) {
                    var N = void 0, P = void 0;
                    E == m.length - 1 ? (P = m.join(" "), N = f) : (P = m.slice(0, E + 1).join(" "), N = "...");
                    var F = u[P];
                    if (!F) u[P] = N; else if (F != N) throw new Error("Inconsistent bindings for " + P)
                }
                delete o[p]
            }
            for (var H in u) o[H] = u[H];
            return o
        }

        function Go(o, u, p, f) {
            u = Bl(u);
            var m = u.call ? u.call(o, f) : u[o];
            if (m === !1) return "nothing";
            if (m === "...") return "multi";
            if (m != null && p(m)) return "handled";
            if (u.fallthrough) {
                if (Object.prototype.toString.call(u.fallthrough) != "[object Array]") return Go(o, u.fallthrough, p, f);
                for (var E = 0; E < u.fallthrough.length; E++) {
                    var N = Go(o, u.fallthrough[E], p, f);
                    if (N) return N
                }
            }
        }

        function hg(o) {
            var u = typeof o == "string" ? o : $o[o.keyCode];
            return u == "Ctrl" || u == "Alt" || u == "Shift" || u == "Mod"
        }

        function au(o, u, p) {
            var f = o;
            return u.altKey && f != "Alt" && (o = "Alt-" + o), (ae ? u.metaKey : u.ctrlKey) && f != "Ctrl" && (o = "Ctrl-" + o), (ae ? u.ctrlKey : u.metaKey) && f != "Mod" && (o = "Cmd-" + o), !p && u.shiftKey && f != "Shift" && (o = "Shift-" + o), o
        }

        function Od(o, u) {
            if (L && o.keyCode == 34 && o.char) return !1;
            var p = $o[o.keyCode];
            return p == null || o.altGraphKey ? !1 : (o.keyCode == 3 && o.code && (p = o.code), au(p, o, u))
        }

        function Bl(o) {
            return typeof o == "string" ? Gi[o] : o
        }

        function Aa(o, u) {
            for (var p = o.doc.sel.ranges, f = [], m = 0; m < p.length; m++) {
                for (var E = u(p[m]); f.length && Qe(E.from, V(f).to) <= 0;) {
                    var N = f.pop();
                    if (Qe(N.from, E.from) < 0) {
                        E.from = N.from;
                        break
                    }
                }
                f.push(E)
            }
            _r(o, function () {
                for (var P = f.length - 1; P >= 0; P--) Ds(o.doc, "", f[P].from, f[P].to, "+delete");
                bs(o)
            })
        }

        function Fd(o, u, p) {
            var f = Dt(o.text, u + p, p);
            return f < 0 || f > o.text.length ? null : f
        }

        function Rd(o, u, p) {
            var f = Fd(o, u.ch, p);
            return f == null ? null : new _e(u.line, f, p < 0 ? "after" : "before")
        }

        function Ca(o, u, p, f, m) {
            if (o) {
                u.doc.direction == "rtl" && (m = -m);
                var E = ot(p, u.doc.direction);
                if (E) {
                    var N = m < 0 ? V(E) : E[0], P = m < 0 == (N.level == 1), F = P ? "after" : "before", H;
                    if (N.level > 0 || u.doc.direction == "rtl") {
                        var X = ps(u, p);
                        H = m < 0 ? p.text.length - 1 : 0;
                        var ie = Hi(u, X, H).top;
                        H = zt(function (be) {
                            return Hi(u, X, be).top == ie
                        }, m < 0 == (N.level == 1) ? N.from : N.to - 1, H), F == "before" && (H = Fd(p, H, 1))
                    } else H = m < 0 ? N.to : N.from;
                    return new _e(f, H, F)
                }
            }
            return new _e(f, m < 0 ? p.text.length : 0, m < 0 ? "before" : "after")
        }

        function zd(o, u, p, f) {
            var m = ot(u, o.doc.direction);
            if (!m) return Rd(u, p, f);
            p.ch >= u.text.length ? (p.ch = u.text.length, p.sticky = "before") : p.ch <= 0 && (p.ch = 0, p.sticky = "after");
            var E = Ot(m, p.ch, p.sticky), N = m[E];
            if (o.doc.direction == "ltr" && N.level % 2 == 0 && (f > 0 ? N.to > p.ch : N.from < p.ch)) return Rd(u, p, f);
            var P = function ($e, et) {
                return Fd(u, $e instanceof _e ? $e.ch : $e, et)
            }, F, H = function ($e) {
                return o.options.lineWrapping ? (F = F || ps(o, u), md(o, u, F, $e)) : {begin: 0, end: u.text.length}
            }, X = H(p.sticky == "before" ? P(p, -1) : p.ch);
            if (o.doc.direction == "rtl" || N.level == 1) {
                var ie = N.level == 1 == f < 0, be = P(p, ie ? 1 : -1);
                if (be != null && (ie ? be <= N.to && be <= X.end : be >= N.from && be >= X.begin)) {
                    var fe = ie ? "before" : "after";
                    return new _e(p.line, be, fe)
                }
            }
            var xe = function ($e, et, Ke) {
                for (var at = function (hn, $n) {
                    return $n ? new _e(p.line, P(hn, 1), "before") : new _e(p.line, hn, "after")
                }; $e >= 0 && $e < m.length; $e += et) {
                    var pt = m[$e], gt = et > 0 == (pt.level != 1), Mt = gt ? Ke.begin : P(Ke.end, -1);
                    if (pt.from <= Mt && Mt < pt.to || (Mt = gt ? pt.from : P(pt.to, -1), Ke.begin <= Mt && Mt < Ke.end)) return at(Mt, gt)
                }
            }, Ne = xe(E + f, f, X);
            if (Ne) return Ne;
            var Ve = f > 0 ? X.end : P(X.begin, -1);
            return Ve != null && !(f > 0 && Ve == u.text.length) && (Ne = xe(f > 0 ? 0 : m.length - 1, f, H(Ve)), Ne) ? Ne : null
        }

        var Nl = {
            selectAll: Md, singleSelection: function (o) {
                return o.setSelection(o.getCursor("anchor"), o.getCursor("head"), we)
            }, killLine: function (o) {
                return Aa(o, function (u) {
                    if (u.empty()) {
                        var p = dt(o.doc, u.head.line).text.length;
                        return u.head.ch == p && u.head.line < o.lastLine() ? {
                            from: u.head,
                            to: _e(u.head.line + 1, 0)
                        } : {from: u.head, to: _e(u.head.line, p)}
                    } else return {from: u.from(), to: u.to()}
                })
            }, deleteLine: function (o) {
                return Aa(o, function (u) {
                    return {from: _e(u.from().line, 0), to: Et(o.doc, _e(u.to().line + 1, 0))}
                })
            }, delLineLeft: function (o) {
                return Aa(o, function (u) {
                    return {from: _e(u.from().line, 0), to: u.from()}
                })
            }, delWrappedLineLeft: function (o) {
                return Aa(o, function (u) {
                    var p = o.charCoords(u.head, "div").top + 5, f = o.coordsChar({left: 0, top: p}, "div");
                    return {from: f, to: u.from()}
                })
            }, delWrappedLineRight: function (o) {
                return Aa(o, function (u) {
                    var p = o.charCoords(u.head, "div").top + 5,
                        f = o.coordsChar({left: o.display.lineDiv.offsetWidth + 100, top: p}, "div");
                    return {from: u.from(), to: f}
                })
            }, undo: function (o) {
                return o.undo()
            }, redo: function (o) {
                return o.redo()
            }, undoSelection: function (o) {
                return o.undoSelection()
            }, redoSelection: function (o) {
                return o.redoSelection()
            }, goDocStart: function (o) {
                return o.extendSelection(_e(o.firstLine(), 0))
            }, goDocEnd: function (o) {
                return o.extendSelection(_e(o.lastLine()))
            }, goLineStart: function (o) {
                return o.extendSelectionsBy(function (u) {
                    return fg(o, u.head.line)
                }, {origin: "+move", bias: 1})
            }, goLineStartSmart: function (o) {
                return o.extendSelectionsBy(function (u) {
                    return gg(o, u.head)
                }, {origin: "+move", bias: 1})
            }, goLineEnd: function (o) {
                return o.extendSelectionsBy(function (u) {
                    return jd(o, u.head.line)
                }, {origin: "+move", bias: -1})
            }, goLineRight: function (o) {
                return o.extendSelectionsBy(function (u) {
                    var p = o.cursorCoords(u.head, "div").top + 5;
                    return o.coordsChar({left: o.display.lineDiv.offsetWidth + 100, top: p}, "div")
                }, Be)
            }, goLineLeft: function (o) {
                return o.extendSelectionsBy(function (u) {
                    var p = o.cursorCoords(u.head, "div").top + 5;
                    return o.coordsChar({left: 0, top: p}, "div")
                }, Be)
            }, goLineLeftSmart: function (o) {
                return o.extendSelectionsBy(function (u) {
                    var p = o.cursorCoords(u.head, "div").top + 5, f = o.coordsChar({left: 0, top: p}, "div");
                    return f.ch < o.getLine(f.line).search(/\S/) ? gg(o, u.head) : f
                }, Be)
            }, goLineUp: function (o) {
                return o.moveV(-1, "line")
            }, goLineDown: function (o) {
                return o.moveV(1, "line")
            }, goPageUp: function (o) {
                return o.moveV(-1, "page")
            }, goPageDown: function (o) {
                return o.moveV(1, "page")
            }, goCharLeft: function (o) {
                return o.moveH(-1, "char")
            }, goCharRight: function (o) {
                return o.moveH(1, "char")
            }, goColumnLeft: function (o) {
                return o.moveH(-1, "column")
            }, goColumnRight: function (o) {
                return o.moveH(1, "column")
            }, goWordLeft: function (o) {
                return o.moveH(-1, "word")
            }, goGroupRight: function (o) {
                return o.moveH(1, "group")
            }, goGroupLeft: function (o) {
                return o.moveH(-1, "group")
            }, goWordRight: function (o) {
                return o.moveH(1, "word")
            }, delCharBefore: function (o) {
                return o.deleteH(-1, "codepoint")
            }, delCharAfter: function (o) {
                return o.deleteH(1, "char")
            }, delWordBefore: function (o) {
                return o.deleteH(-1, "word")
            }, delWordAfter: function (o) {
                return o.deleteH(1, "word")
            }, delGroupBefore: function (o) {
                return o.deleteH(-1, "group")
            }, delGroupAfter: function (o) {
                return o.deleteH(1, "group")
            }, indentAuto: function (o) {
                return o.indentSelection("smart")
            }, indentMore: function (o) {
                return o.indentSelection("add")
            }, indentLess: function (o) {
                return o.indentSelection("subtract")
            }, insertTab: function (o) {
                return o.replaceSelection("	")
            }, insertSoftTab: function (o) {
                for (var u = [], p = o.listSelections(), f = o.options.tabSize, m = 0; m < p.length; m++) {
                    var E = p[m].from(), N = vt(o.getLine(E.line), E.ch, f);
                    u.push(ze(f - N % f))
                }
                o.replaceSelections(u)
            }, defaultTab: function (o) {
                o.somethingSelected() ? o.indentSelection("add") : o.execCommand("insertTab")
            }, transposeChars: function (o) {
                return _r(o, function () {
                    for (var u = o.listSelections(), p = [], f = 0; f < u.length; f++) if (u[f].empty()) {
                        var m = u[f].head, E = dt(o.doc, m.line).text;
                        if (E) {
                            if (m.ch == E.length && (m = new _e(m.line, m.ch - 1)), m.ch > 0) m = new _e(m.line, m.ch + 1), o.replaceRange(E.charAt(m.ch - 1) + E.charAt(m.ch - 2), _e(m.line, m.ch - 2), m, "+transpose"); else if (m.line > o.doc.first) {
                                var N = dt(o.doc, m.line - 1).text;
                                N && (m = new _e(m.line, 1), o.replaceRange(E.charAt(0) + o.doc.lineSeparator() + N.charAt(N.length - 1), _e(m.line - 1, N.length - 1), m, "+transpose"))
                            }
                        }
                        p.push(new Kt(m, m))
                    }
                    o.setSelections(p)
                })
            }, newlineAndIndent: function (o) {
                return _r(o, function () {
                    for (var u = o.listSelections(), p = u.length - 1; p >= 0; p--) o.replaceRange(o.doc.lineSeparator(), u[p].anchor, u[p].head, "+input");
                    u = o.listSelections();
                    for (var f = 0; f < u.length; f++) o.indentLine(u[f].from().line, null, !0);
                    bs(o)
                })
            }, openLine: function (o) {
                return o.replaceSelection(`
`, "start")
            }, toggleOverwrite: function (o) {
                return o.toggleOverwrite()
            }
        };

        function fg(o, u) {
            var p = dt(o.doc, u), f = _i(p);
            return f != p && (u = W(f)), Ca(!0, o, f, u, 1)
        }

        function jd(o, u) {
            var p = dt(o.doc, u), f = wf(p);
            return f != p && (u = W(f)), Ca(!0, o, p, u, -1)
        }

        function gg(o, u) {
            var p = fg(o, u.line), f = dt(o.doc, p.line), m = ot(f, o.doc.direction);
            if (!m || m[0].level == 0) {
                var E = Math.max(p.ch, f.text.search(/\S/)), N = u.line == p.line && u.ch <= E && u.ch;
                return _e(p.line, N ? 0 : E, p.sticky)
            }
            return p
        }

        function lu(o, u, p) {
            if (typeof u == "string" && (u = Nl[u], !u)) return !1;
            o.display.input.ensurePolled();
            var f = o.display.shift, m = !1;
            try {
                o.isReadOnly() && (o.state.suppressEdits = !0), p && (o.display.shift = !1), m = u(o) != ge
            } finally {
                o.display.shift = f, o.state.suppressEdits = !1
            }
            return m
        }

        function Qm(o, u, p) {
            for (var f = 0; f < o.state.keyMaps.length; f++) {
                var m = Go(u, o.state.keyMaps[f], p, o);
                if (m) return m
            }
            return o.options.extraKeys && Go(u, o.options.extraKeys, p, o) || Go(u, o.options.keyMap, p, o)
        }

        var xs = new Vt;

        function Ll(o, u, p, f) {
            var m = o.state.keySeq;
            if (m) {
                if (hg(u)) return "handled";
                if (/\'$/.test(u) ? o.state.keySeq = null : xs.set(50, function () {
                    o.state.keySeq == m && (o.state.keySeq = null, o.display.input.reset())
                }), Vd(o, m + " " + u, p, f)) return !0
            }
            return Vd(o, u, p, f)
        }

        function Vd(o, u, p, f) {
            var m = Qm(o, u, f);
            return m == "multi" && (o.state.keySeq = u), m == "handled" && Un(o, "keyHandled", o, u, p), (m == "handled" || m == "multi") && (Sn(p), zc(o)), !!m
        }

        function pg(o, u) {
            var p = Od(u, !0);
            return p ? u.shiftKey && !o.state.keySeq ? Ll(o, "Shift-" + p, u, function (f) {
                return lu(o, f, !0)
            }) || Ll(o, p, u, function (f) {
                if (typeof f == "string" ? /^go[A-Z]/.test(f) : f.motion) return lu(o, f)
            }) : Ll(o, p, u, function (f) {
                return lu(o, f)
            }) : !1
        }

        function Jm(o, u, p) {
            return Ll(o, "'" + p + "'", u, function (f) {
                return lu(o, f, !0)
            })
        }

        var Hd = null;

        function mg(o) {
            var u = this;
            if (!(o.target && o.target != u.display.input.getField()) && (u.curOp.focus = Le(At(u)), !fn(u, o))) {
                w && S < 11 && o.keyCode == 27 && (o.returnValue = !1);
                var p = o.keyCode;
                u.display.shift = p == 16 || o.shiftKey;
                var f = pg(u, o);
                L && (Hd = f ? p : null, !f && p == 88 && !Cc && (ce ? o.metaKey : o.ctrlKey) && u.replaceSelection("", null, "cut")), C && !ce && !f && p == 46 && o.shiftKey && !o.ctrlKey && document.execCommand && document.execCommand("cut"), p == 18 && !/\bCodeMirror-crosshair\b/.test(u.display.lineDiv.className) && yv(u)
            }
        }

        function yv(o) {
            var u = o.display.lineDiv;
            it(u, "CodeMirror-crosshair");

            function p(f) {
                (f.keyCode == 18 || !f.altKey) && (ke(u, "CodeMirror-crosshair"), Rn(document, "keyup", p), Rn(document, "mouseover", p))
            }

            ft(document, "keyup", p), ft(document, "mouseover", p)
        }

        function bg(o) {
            o.keyCode == 16 && (this.doc.sel.shift = !1), fn(this, o)
        }

        function kg(o) {
            var u = this;
            if (!(o.target && o.target != u.display.input.getField()) && !(fo(u.display, o) || fn(u, o) || o.ctrlKey && !o.altKey || ce && o.metaKey)) {
                var p = o.keyCode, f = o.charCode;
                if (L && p == Hd) {
                    Hd = null, Sn(o);
                    return
                }
                if (!(L && (!o.which || o.which < 10) && pg(u, o))) {
                    var m = String.fromCharCode(f ?? p);
                    m != "\b" && (Jm(u, o, m) || u.display.input.onKeyPress(o))
                }
            }
        }

        var Xm = 400, cu = function (o, u, p) {
            this.time = o, this.pos = u, this.button = p
        };
        cu.prototype.compare = function (o, u, p) {
            return this.time + Xm > o && Qe(u, this.pos) == 0 && p == this.button
        };
        var _a, Pl;

        function eb(o, u) {
            var p = +new Date;
            return Pl && Pl.compare(p, o, u) ? (_a = Pl = null, "triple") : _a && _a.compare(p, o, u) ? (Pl = new cu(p, o, u), _a = null, "double") : (_a = new cu(p, o, u), Pl = null, "single")
        }

        function vg(o) {
            var u = this, p = u.display;
            if (!(fn(u, o) || p.activeTouch && p.input.supportsTouch())) {
                if (p.input.ensurePolled(), p.shift = o.shiftKey, fo(p, o)) {
                    I || (p.scroller.draggable = !1, setTimeout(function () {
                        return p.scroller.draggable = !0
                    }, 100));
                    return
                }
                if (!uu(u, o)) {
                    var f = Oo(u, o), m = wi(o), E = f ? eb(f, m) : "single";
                    Ye(u).focus(), m == 1 && u.state.selectingText && u.state.selectingText(o), !(f && tb(u, m, f, E, o)) && (m == 1 ? f ? qd(u, f, E, o) : To(o) == p.scroller && Sn(o) : m == 2 ? (f && xl(u.doc, f), setTimeout(function () {
                        return p.input.focus()
                    }, 20)) : m == 3 && (ue ? u.display.input.onContextMenu(o) : mo(u)))
                }
            }
        }

        function tb(o, u, p, f, m) {
            var E = "Click";
            return f == "double" ? E = "Double" + E : f == "triple" && (E = "Triple" + E), E = (u == 1 ? "Left" : u == 2 ? "Middle" : "Right") + E, Ll(o, au(E, m), m, function (N) {
                if (typeof N == "string" && (N = Nl[N]), !N) return !1;
                var P = !1;
                try {
                    o.isReadOnly() && (o.state.suppressEdits = !0), P = N(o, p) != ge
                } finally {
                    o.state.suppressEdits = !1
                }
                return P
            })
        }

        function Ud(o, u, p) {
            var f = o.getOption("configureMouse"), m = f ? f(o, u, p) : {};
            if (m.unit == null) {
                var E = Ce ? p.shiftKey && p.metaKey : p.altKey;
                m.unit = E ? "rectangle" : u == "single" ? "char" : u == "double" ? "word" : "line"
            }
            return (m.extend == null || o.doc.extend) && (m.extend = o.doc.extend || p.shiftKey), m.addNew == null && (m.addNew = ce ? p.metaKey : p.ctrlKey), m.moveOnDrag == null && (m.moveOnDrag = !(ce ? p.altKey : p.ctrlKey)), m
        }

        function qd(o, u, p, f) {
            w ? setTimeout(Oe(da, o), 0) : o.curOp.focus = Le(At(o));
            var m = Ud(o, p, f), E = o.doc.sel, N;
            o.options.dragDrop && Ku && !o.isReadOnly() && p == "single" && (N = E.contains(u)) > -1 && (Qe((N = E.ranges[N]).from(), u) < 0 || u.xRel > 0) && (Qe(N.to(), u) > 0 || u.xRel < 0) ? Qr(o, f, u, m) : Ol(o, f, u, m)
        }

        function Qr(o, u, p, f) {
            var m = o.display, E = !1, N = nr(o, function (H) {
                I && (m.scroller.draggable = !1), o.state.draggingText = !1, o.state.delayingBlurEvent && (o.hasFocus() ? o.state.delayingBlurEvent = !1 : mo(o)), Rn(m.wrapper.ownerDocument, "mouseup", N), Rn(m.wrapper.ownerDocument, "mousemove", P), Rn(m.scroller, "dragstart", F), Rn(m.scroller, "drop", N), E || (Sn(H), f.addNew || xl(o.doc, p, null, null, f.extend), I && !z || w && S == 9 ? setTimeout(function () {
                    m.wrapper.ownerDocument.body.focus({preventScroll: !0}), m.input.focus()
                }, 20) : m.input.focus())
            }), P = function (H) {
                E = E || Math.abs(u.clientX - H.clientX) + Math.abs(u.clientY - H.clientY) >= 10
            }, F = function () {
                return E = !0
            };
            I && (m.scroller.draggable = !0), o.state.draggingText = N, N.copy = !f.moveOnDrag, ft(m.wrapper.ownerDocument, "mouseup", N), ft(m.wrapper.ownerDocument, "mousemove", P), ft(m.scroller, "dragstart", F), ft(m.scroller, "drop", N), o.state.delayingBlurEvent = !0, setTimeout(function () {
                return m.input.focus()
            }, 20), m.scroller.dragDrop && m.scroller.dragDrop()
        }

        function Wd(o, u, p) {
            if (p == "char") return new Kt(u, u);
            if (p == "word") return o.findWordAt(u);
            if (p == "line") return new Kt(_e(u.line, 0), Et(o.doc, _e(u.line + 1, 0)));
            var f = p(o, u);
            return new Kt(f.from, f.to)
        }

        function Ol(o, u, p, f) {
            w && mo(o);
            var m = o.display, E = o.doc;
            Sn(u);
            var N, P, F = E.sel, H = F.ranges;
            if (f.addNew && !f.extend ? (P = E.sel.contains(p), P > -1 ? N = H[P] : N = new Kt(p, p)) : (N = E.sel.primary(), P = E.sel.primIndex), f.unit == "rectangle") f.addNew || (N = new Kt(p, p)), p = Oo(o, u, !0, !0), P = -1; else {
                var X = Wd(o, p, f.unit);
                f.extend ? N = Sd(N, X.anchor, X.head, f.extend) : N = X
            }
            f.addNew ? P == -1 ? (P = H.length, yn(E, ai(o, H.concat([N]), P), {
                scroll: !1,
                origin: "*mouse"
            })) : H.length > 1 && H[P].empty() && f.unit == "char" && !f.extend ? (yn(E, ai(o, H.slice(0, P).concat(H.slice(P + 1)), 0), {
                scroll: !1,
                origin: "*mouse"
            }), F = E.sel) : El(E, P, N, Me) : (P = 0, yn(E, new Lr([N], 0), Me), F = E.sel);
            var ie = p;

            function be(Ke) {
                if (Qe(ie, Ke) != 0) if (ie = Ke, f.unit == "rectangle") {
                    for (var at = [], pt = o.options.tabSize, gt = vt(dt(E, p.line).text, p.ch, pt), Mt = vt(dt(E, Ke.line).text, Ke.ch, pt), hn = Math.min(gt, Mt), $n = Math.max(gt, Mt), Dn = Math.min(p.line, Ke.line), Pr = Math.min(o.lastLine(), Math.max(p.line, Ke.line)); Dn <= Pr; Dn++) {
                        var En = dt(E, Dn).text, Ln = Ue(En, hn, pt);
                        hn == $n ? at.push(new Kt(_e(Dn, Ln), _e(Dn, Ln))) : En.length > Ln && at.push(new Kt(_e(Dn, Ln), _e(Dn, Ue(En, $n, pt))))
                    }
                    at.length || at.push(new Kt(p, p)), yn(E, ai(o, F.ranges.slice(0, P).concat(at), P), {
                        origin: "*mouse",
                        scroll: !1
                    }), o.scrollIntoView(Ke)
                } else {
                    var Gn = N, xn = Wd(o, Ke, f.unit), Kn = Gn.anchor, Mn;
                    Qe(xn.anchor, Kn) > 0 ? (Mn = xn.head, Kn = as(Gn.from(), xn.anchor)) : (Mn = xn.anchor, Kn = Hn(Gn.to(), xn.head));
                    var Bn = F.ranges.slice(0);
                    Bn[P] = wg(o, new Kt(Et(E, Kn), Mn)), yn(E, ai(o, Bn, P), Me)
                }
            }

            var fe = m.wrapper.getBoundingClientRect(), xe = 0;

            function Ne(Ke) {
                var at = ++xe, pt = Oo(o, Ke, !0, f.unit == "rectangle");
                if (pt) if (Qe(pt, ie) != 0) {
                    o.curOp.focus = Le(At(o)), be(pt);
                    var gt = ml(m, E);
                    (pt.line >= gt.to || pt.line < gt.from) && setTimeout(nr(o, function () {
                        xe == at && Ne(Ke)
                    }), 150)
                } else {
                    var Mt = Ke.clientY < fe.top ? -20 : Ke.clientY > fe.bottom ? 20 : 0;
                    Mt && setTimeout(nr(o, function () {
                        xe == at && (m.scroller.scrollTop += Mt, Ne(Ke))
                    }), 50)
                }
            }

            function Ve(Ke) {
                o.state.selectingText = !1, xe = 1 / 0, Ke && (Sn(Ke), m.input.focus()), Rn(m.wrapper.ownerDocument, "mousemove", $e), Rn(m.wrapper.ownerDocument, "mouseup", et), E.history.lastSelOrigin = null
            }

            var $e = nr(o, function (Ke) {
                Ke.buttons === 0 || !wi(Ke) ? Ve(Ke) : Ne(Ke)
            }), et = nr(o, Ve);
            o.state.selectingText = et, ft(m.wrapper.ownerDocument, "mousemove", $e), ft(m.wrapper.ownerDocument, "mouseup", et)
        }

        function wg(o, u) {
            var p = u.anchor, f = u.head, m = dt(o.doc, p.line);
            if (Qe(p, f) == 0 && p.sticky == f.sticky) return u;
            var E = ot(m);
            if (!E) return u;
            var N = Ot(E, p.ch, p.sticky), P = E[N];
            if (P.from != p.ch && P.to != p.ch) return u;
            var F = N + (P.from == p.ch == (P.level != 1) ? 0 : 1);
            if (F == 0 || F == E.length) return u;
            var H;
            if (f.line != p.line) H = (f.line - p.line) * (o.doc.direction == "ltr" ? 1 : -1) > 0; else {
                var X = Ot(E, f.ch, f.sticky), ie = X - N || (f.ch - p.ch) * (P.level == 1 ? -1 : 1);
                X == F - 1 || X == F ? H = ie < 0 : H = ie > 0
            }
            var be = E[F + (H ? -1 : 0)], fe = H == (be.level == 1), xe = fe ? be.from : be.to,
                Ne = fe ? "after" : "before";
            return p.ch == xe && p.sticky == Ne ? u : new Kt(new _e(p.line, xe, Ne), f)
        }

        function Fl(o, u, p, f) {
            var m, E;
            if (u.touches) m = u.touches[0].clientX, E = u.touches[0].clientY; else try {
                m = u.clientX, E = u.clientY
            } catch {
                return !1
            }
            if (m >= Math.floor(o.display.gutters.getBoundingClientRect().right)) return !1;
            f && Sn(u);
            var N = o.display, P = N.lineDiv.getBoundingClientRect();
            if (E > P.bottom || !zn(o, p)) return Mr(u);
            E -= P.top - N.viewOffset;
            for (var F = 0; F < o.display.gutterSpecs.length; ++F) {
                var H = N.gutters.childNodes[F];
                if (H && H.getBoundingClientRect().right >= m) {
                    var X = re(o.doc, E), ie = o.display.gutterSpecs[F];
                    return cn(o, p, o, X, ie.className, u), Mr(u)
                }
            }
        }

        function uu(o, u) {
            return Fl(o, u, "gutterClick", !0)
        }

        function $d(o, u) {
            fo(o.display, u) || Es(o, u) || fn(o, u, "contextmenu") || ue || o.display.input.onContextMenu(u)
        }

        function Es(o, u) {
            return zn(o, "gutterContextMenu") ? Fl(o, u, "gutterContextMenu", !1) : !1
        }

        function We(o) {
            o.display.wrapper.className = o.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + o.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), cl(o)
        }

        var Ct = {
            toString: function () {
                return "CodeMirror.Init"
            }
        }, Rl = {}, Ur = {};

        function Gd(o) {
            var u = o.optionHandlers;

            function p(f, m, E, N) {
                o.defaults[f] = m, E && (u[f] = N ? function (P, F, H) {
                    H != Ct && E(P, F, H)
                } : E)
            }

            o.defineOption = p, o.Init = Ct, p("value", "", function (f, m) {
                return f.setValue(m)
            }, !0), p("mode", null, function (f, m) {
                f.doc.modeOption = m, Yc(f)
            }, !0), p("indentUnit", 2, Yc, !0), p("indentWithTabs", !1), p("smartIndent", !0), p("tabSize", 4, function (f) {
                Cl(f), cl(f), Cr(f)
            }, !0), p("lineSeparator", null, function (f, m) {
                if (f.doc.lineSep = m, !!m) {
                    var E = [], N = f.doc.first;
                    f.doc.iter(function (F) {
                        for (var H = 0; ;) {
                            var X = F.text.indexOf(m, H);
                            if (X == -1) break;
                            H = X + m.length, E.push(_e(N, X))
                        }
                        N++
                    });
                    for (var P = E.length - 1; P >= 0; P--) Ds(f.doc, m, E[P], _e(E[P].line, E[P].ch + m.length))
                }
            }), p("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function (f, m, E) {
                f.state.specialChars = new RegExp(m.source + (m.test("	") ? "" : "|	"), "g"), E != Ct && f.refresh()
            }), p("specialCharPlaceholder", Cf, function (f) {
                return f.refresh()
            }, !0), p("electricChars", !0), p("inputStyle", Y ? "contenteditable" : "textarea", function () {
                throw new Error("inputStyle can not (yet) be changed in a running editor")
            }, !0), p("spellcheck", !1, function (f, m) {
                return f.getInputField().spellcheck = m
            }, !0), p("autocorrect", !1, function (f, m) {
                return f.getInputField().autocorrect = m
            }, !0), p("autocapitalize", !1, function (f, m) {
                return f.getInputField().autocapitalize = m
            }, !0), p("rtlMoveVisually", !me), p("wholeLineUpdateBefore", !0), p("theme", "default", function (f) {
                We(f), fa(f)
            }, !0), p("keyMap", "default", function (f, m, E) {
                var N = Bl(m), P = E != Ct && Bl(E);
                P && P.detach && P.detach(f, N), N.attach && N.attach(f, P || null)
            }), p("extraKeys", null), p("configureMouse", null), p("lineWrapping", !1, Kd, !0), p("gutters", [], function (f, m) {
                f.display.gutterSpecs = $c(m, f.options.lineNumbers), fa(f)
            }, !0), p("fixedGutter", !0, function (f, m) {
                f.display.gutters.style.left = m ? bt(f.display) + "px" : "0", f.refresh()
            }, !0), p("coverGutterNextToScrollbar", !1, function (f) {
                return jo(f)
            }, !0), p("scrollbarStyle", "native", function (f) {
                $f(f), jo(f), f.display.scrollbars.setScrollTop(f.doc.scrollTop), f.display.scrollbars.setScrollLeft(f.doc.scrollLeft)
            }, !0), p("lineNumbers", !1, function (f, m) {
                f.display.gutterSpecs = $c(f.options.gutters, m), fa(f)
            }, !0), p("firstLineNumber", 1, fa, !0), p("lineNumberFormatter", function (f) {
                return f
            }, fa, !0), p("showCursorWhenSelecting", !1, _n, !0), p("resetSelectionOnContextMenu", !0), p("lineWiseCopyCut", !0), p("pasteLinesPerSelection", !0), p("selectionsMayTouch", !1), p("readOnly", !1, function (f, m) {
                m == "nocursor" && (zo(f), f.display.input.blur()), f.display.input.readOnlyChanged(m)
            }), p("screenReaderLabel", null, function (f, m) {
                m = m === "" ? null : m, f.display.input.screenReaderLabelChanged(m)
            }), p("disableInput", !1, function (f, m) {
                m || f.display.input.reset()
            }, !0), p("dragDrop", !0, ya), p("allowDropFileTypes", null), p("cursorBlinkRate", 530), p("cursorScrollMargin", 0), p("cursorHeight", 1, _n, !0), p("singleCursorHeightPerLine", !0, _n, !0), p("workTime", 100), p("workDelay", 100), p("flattenSpans", !0, Cl, !0), p("addModeClass", !1, Cl, !0), p("pollInterval", 100), p("undoDepth", 200, function (f, m) {
                return f.doc.history.undoDepth = m
            }), p("historyEventDelay", 1250), p("viewportMargin", 10, function (f) {
                return f.refresh()
            }, !0), p("maxHighlightLength", 1e4, Cl, !0), p("moveInputWithCursor", !0, function (f, m) {
                m || f.display.input.resetPosition()
            }), p("tabindex", null, function (f, m) {
                return f.display.input.getField().tabIndex = m || ""
            }), p("autofocus", null), p("direction", "ltr", function (f, m) {
                return f.doc.setDirection(m)
            }, !0), p("phrases", null)
        }

        function ya(o, u, p) {
            var f = p && p != Ct;
            if (!u != !f) {
                var m = o.display.dragFunctions, E = u ? ft : Rn;
                E(o.display.scroller, "dragstart", m.start), E(o.display.scroller, "dragenter", m.enter), E(o.display.scroller, "dragover", m.over), E(o.display.scroller, "dragleave", m.leave), E(o.display.scroller, "drop", m.drop)
            }
        }

        function Kd(o) {
            o.options.lineWrapping ? (it(o.display.wrapper, "CodeMirror-wrap"), o.display.sizer.style.minWidth = "", o.display.sizerWidth = null) : (ke(o.display.wrapper, "CodeMirror-wrap"), td(o)), ca(o), Cr(o), cl(o), setTimeout(function () {
                return jo(o)
            }, 100)
        }

        function gn(o, u) {
            var p = this;
            if (!(this instanceof gn)) return new gn(o, u);
            this.options = u = u ? ht(u) : {}, ht(Rl, u, !1);
            var f = u.value;
            typeof f == "string" ? f = new yr(f, u.mode, null, u.lineSeparator, u.direction) : u.mode && (f.modeOption = u.mode), this.doc = f;
            var m = new gn.inputStyles[u.inputStyle](this), E = this.display = new Qf(o, f, m, u);
            E.wrapper.CodeMirror = this, We(this), u.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), $f(this), this.state = {
                keyMaps: [],
                overlays: [],
                modeGen: 0,
                overwrite: !1,
                delayingBlurEvent: !1,
                focused: !1,
                suppressEdits: !1,
                pasteIncoming: -1,
                cutIncoming: -1,
                selectingText: !1,
                draggingText: !1,
                highlight: new Vt,
                keySeq: null,
                specialChars: null
            }, u.autofocus && !Y && E.input.focus(), w && S < 11 && setTimeout(function () {
                return p.display.input.reset(!0)
            }, 20), zl(this), Gm(), ws(this), this.curOp.forceUpdate = !0, _l(this, f), u.autofocus && !Y || this.hasFocus() ? setTimeout(function () {
                p.hasFocus() && !p.state.focused && jc(p)
            }, 20) : zo(this);
            for (var N in Ur) Ur.hasOwnProperty(N) && Ur[N](this, u[N], Ct);
            Yf(this), u.finishInit && u.finishInit(this);
            for (var P = 0; P < Ko.length; ++P) Ko[P](this);
            br(this), I && u.lineWrapping && getComputedStyle(E.lineDiv).textRendering == "optimizelegibility" && (E.lineDiv.style.textRendering = "auto")
        }

        gn.defaults = Rl, gn.optionHandlers = Ur;

        function zl(o) {
            var u = o.display;
            ft(u.scroller, "mousedown", nr(o, vg)), w && S < 11 ? ft(u.scroller, "dblclick", nr(o, function (F) {
                if (!fn(o, F)) {
                    var H = Oo(o, F);
                    if (!(!H || uu(o, F) || fo(o.display, F))) {
                        Sn(F);
                        var X = o.findWordAt(H);
                        xl(o.doc, X.anchor, X.head)
                    }
                }
            })) : ft(u.scroller, "dblclick", function (F) {
                return fn(o, F) || Sn(F)
            }), ft(u.scroller, "contextmenu", function (F) {
                return $d(o, F)
            }), ft(u.input.getField(), "contextmenu", function (F) {
                u.scroller.contains(F.target) || $d(o, F)
            });
            var p, f = {end: 0};

            function m() {
                u.activeTouch && (p = setTimeout(function () {
                    return u.activeTouch = null
                }, 1e3), f = u.activeTouch, f.end = +new Date)
            }

            function E(F) {
                if (F.touches.length != 1) return !1;
                var H = F.touches[0];
                return H.radiusX <= 1 && H.radiusY <= 1
            }

            function N(F, H) {
                if (H.left == null) return !0;
                var X = H.left - F.left, ie = H.top - F.top;
                return X * X + ie * ie > 20 * 20
            }

            ft(u.scroller, "touchstart", function (F) {
                if (!fn(o, F) && !E(F) && !uu(o, F)) {
                    u.input.ensurePolled(), clearTimeout(p);
                    var H = +new Date;
                    u.activeTouch = {
                        start: H,
                        moved: !1,
                        prev: H - f.end <= 300 ? f : null
                    }, F.touches.length == 1 && (u.activeTouch.left = F.touches[0].pageX, u.activeTouch.top = F.touches[0].pageY)
                }
            }), ft(u.scroller, "touchmove", function () {
                u.activeTouch && (u.activeTouch.moved = !0)
            }), ft(u.scroller, "touchend", function (F) {
                var H = u.activeTouch;
                if (H && !fo(u, F) && H.left != null && !H.moved && new Date - H.start < 300) {
                    var X = o.coordsChar(u.activeTouch, "page"), ie;
                    !H.prev || N(H, H.prev) ? ie = new Kt(X, X) : !H.prev.prev || N(H, H.prev.prev) ? ie = o.findWordAt(X) : ie = new Kt(_e(X.line, 0), Et(o.doc, _e(X.line + 1, 0))), o.setSelection(ie.anchor, ie.head), o.focus(), Sn(F)
                }
                m()
            }), ft(u.scroller, "touchcancel", m), ft(u.scroller, "scroll", function () {
                u.scroller.clientHeight && (kl(o, u.scroller.scrollTop), vs(o, u.scroller.scrollLeft, !0), cn(o, "scroll", o))
            }), ft(u.scroller, "mousewheel", function (F) {
                return Kc(o, F)
            }), ft(u.scroller, "DOMMouseScroll", function (F) {
                return Kc(o, F)
            }), ft(u.wrapper, "scroll", function () {
                return u.wrapper.scrollTop = u.wrapper.scrollLeft = 0
            }), u.dragFunctions = {
                enter: function (F) {
                    fn(o, F) || ti(F)
                }, over: function (F) {
                    fn(o, F) || ($m(o, F), ti(F))
                }, start: function (F) {
                    return Wm(o, F)
                }, drop: nr(o, iu), leave: function (F) {
                    fn(o, F) || ug(o)
                }
            };
            var P = u.input.getField();
            ft(P, "keyup", function (F) {
                return bg.call(o, F)
            }), ft(P, "keydown", nr(o, mg)), ft(P, "keypress", nr(o, kg)), ft(P, "focus", function (F) {
                return jc(o, F)
            }), ft(P, "blur", function (F) {
                return zo(o, F)
            })
        }

        var Ko = [];
        gn.defineInitHook = function (o) {
            return Ko.push(o)
        };

        function Da(o, u, p, f) {
            var m = o.doc, E;
            p == null && (p = "add"), p == "smart" && (m.mode.indent ? E = Bo(o, u).state : p = "prev");
            var N = o.options.tabSize, P = dt(m, u), F = vt(P.text, null, N);
            P.stateAfter && (P.stateAfter = null);
            var H = P.text.match(/^\s*/)[0], X;
            if (!f && !/\S/.test(P.text)) X = 0, p = "not"; else if (p == "smart" && (X = m.mode.indent(E, P.text.slice(H.length), P.text), X == ge || X > 150)) {
                if (!f) return;
                p = "prev"
            }
            p == "prev" ? u > m.first ? X = vt(dt(m, u - 1).text, null, N) : X = 0 : p == "add" ? X = F + o.options.indentUnit : p == "subtract" ? X = F - o.options.indentUnit : typeof p == "number" && (X = F + p), X = Math.max(0, X);
            var ie = "", be = 0;
            if (o.options.indentWithTabs) for (var fe = Math.floor(X / N); fe; --fe) be += N, ie += "	";
            if (be < X && (ie += ze(X - be)), ie != H) return Ds(m, ie, _e(u, 0), _e(u, H.length), "+input"), P.stateAfter = null, !0;
            for (var xe = 0; xe < m.sel.ranges.length; xe++) {
                var Ne = m.sel.ranges[xe];
                if (Ne.head.line == u && Ne.head.ch < H.length) {
                    var Ve = _e(u, H.length);
                    El(m, xe, new Kt(Ve, Ve));
                    break
                }
            }
        }

        var Jr = null;

        function Ss(o) {
            Jr = o
        }

        function vo(o, u, p, f, m) {
            var E = o.doc;
            o.display.shift = !1, f || (f = E.sel);
            var N = +new Date - 200, P = m == "paste" || o.state.pasteIncoming > N, F = Br(u), H = null;
            if (P && f.ranges.length > 1) if (Jr && Jr.text.join(`
`) == u) {
                if (f.ranges.length % Jr.text.length == 0) {
                    H = [];
                    for (var X = 0; X < Jr.text.length; X++) H.push(E.splitLines(Jr.text[X]))
                }
            } else F.length == f.ranges.length && o.options.pasteLinesPerSelection && (H = $(F, function ($e) {
                return [$e]
            }));
            for (var ie = o.curOp.updateInput, be = f.ranges.length - 1; be >= 0; be--) {
                var fe = f.ranges[be], xe = fe.from(), Ne = fe.to();
                fe.empty() && (p && p > 0 ? xe = _e(xe.line, xe.ch - p) : o.state.overwrite && !P ? Ne = _e(Ne.line, Math.min(dt(E, Ne.line).text.length, Ne.ch + V(F).length)) : P && Jr && Jr.lineWise && Jr.text.join(`
`) == F.join(`
`) && (xe = Ne = _e(xe.line, 0)));
                var Ve = {
                    from: xe,
                    to: Ne,
                    text: H ? H[be % H.length] : F,
                    origin: m || (P ? "paste" : o.state.cutIncoming > N ? "cut" : "+input")
                };
                ys(o.doc, Ve), Un(o, "inputRead", o, Ve)
            }
            u && !P && du(o, u), bs(o), o.curOp.updateInput < 2 && (o.curOp.updateInput = ie), o.curOp.typing = !0, o.state.pasteIncoming = o.state.cutIncoming = -1
        }

        function Ag(o, u) {
            var p = o.clipboardData && o.clipboardData.getData("Text");
            if (p) return o.preventDefault(), !u.isReadOnly() && !u.options.disableInput && u.hasFocus() && _r(u, function () {
                return vo(u, p, 0, null, "paste")
            }), !0
        }

        function du(o, u) {
            if (!(!o.options.electricChars || !o.options.smartIndent)) for (var p = o.doc.sel, f = p.ranges.length - 1; f >= 0; f--) {
                var m = p.ranges[f];
                if (!(m.head.ch > 100 || f && p.ranges[f - 1].head.line == m.head.line)) {
                    var E = o.getModeAt(m.head), N = !1;
                    if (E.electricChars) {
                        for (var P = 0; P < E.electricChars.length; P++) if (u.indexOf(E.electricChars.charAt(P)) > -1) {
                            N = Da(o, m.head.line, "smart");
                            break
                        }
                    } else E.electricInput && E.electricInput.test(dt(o.doc, m.head.line).text.slice(0, m.head.ch)) && (N = Da(o, m.head.line, "smart"));
                    N && Un(o, "electricInput", o, m.head.line)
                }
            }
        }

        function hu(o) {
            for (var u = [], p = [], f = 0; f < o.doc.sel.ranges.length; f++) {
                var m = o.doc.sel.ranges[f].head.line, E = {anchor: _e(m, 0), head: _e(m + 1, 0)};
                p.push(E), u.push(o.getRange(E.anchor, E.head))
            }
            return {text: u, ranges: p}
        }

        function Zd(o, u, p, f) {
            o.setAttribute("autocorrect", p ? "on" : "off"), o.setAttribute("autocapitalize", f ? "on" : "off"), o.setAttribute("spellcheck", !!u)
        }

        function jl() {
            var o = ee("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"),
                u = ee("div", [o], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
            return I ? o.style.width = "1000px" : o.setAttribute("wrap", "off"), G && (o.style.border = "1px solid black"), u
        }

        function nb(o) {
            var u = o.optionHandlers, p = o.helpers = {};
            o.prototype = {
                constructor: o,
                focus: function () {
                    Ye(this).focus(), this.display.input.focus()
                },
                setOption: function (f, m) {
                    var E = this.options, N = E[f];
                    E[f] == m && f != "mode" || (E[f] = m, u.hasOwnProperty(f) && nr(this, u[f])(this, m, N), cn(this, "optionChange", this, f))
                },
                getOption: function (f) {
                    return this.options[f]
                },
                getDoc: function () {
                    return this.doc
                },
                addKeyMap: function (f, m) {
                    this.state.keyMaps[m ? "push" : "unshift"](Bl(f))
                },
                removeKeyMap: function (f) {
                    for (var m = this.state.keyMaps, E = 0; E < m.length; ++E) if (m[E] == f || m[E].name == f) return m.splice(E, 1), !0
                },
                addOverlay: kr(function (f, m) {
                    var E = f.token ? f : o.getMode(this.options, f);
                    if (E.startState) throw new Error("Overlays may not be stateful.");
                    te(this.state.overlays, {
                        mode: E,
                        modeSpec: f,
                        opaque: m && m.opaque,
                        priority: m && m.priority || 0
                    }, function (N) {
                        return N.priority
                    }), this.state.modeGen++, Cr(this)
                }),
                removeOverlay: kr(function (f) {
                    for (var m = this.state.overlays, E = 0; E < m.length; ++E) {
                        var N = m[E].modeSpec;
                        if (N == f || typeof f == "string" && N.name == f) {
                            m.splice(E, 1), this.state.modeGen++, Cr(this);
                            return
                        }
                    }
                }),
                indentLine: kr(function (f, m, E) {
                    typeof m != "string" && typeof m != "number" && (m == null ? m = this.options.smartIndent ? "smart" : "prev" : m = m ? "add" : "subtract"), Te(this.doc, f) && Da(this, f, m, E)
                }),
                indentSelection: kr(function (f) {
                    for (var m = this.doc.sel.ranges, E = -1, N = 0; N < m.length; N++) {
                        var P = m[N];
                        if (P.empty()) P.head.line > E && (Da(this, P.head.line, f, !0), E = P.head.line, N == this.doc.sel.primIndex && bs(this)); else {
                            var F = P.from(), H = P.to(), X = Math.max(E, F.line);
                            E = Math.min(this.lastLine(), H.line - (H.ch ? 0 : 1)) + 1;
                            for (var ie = X; ie < E; ++ie) Da(this, ie, f);
                            var be = this.doc.sel.ranges;
                            F.ch == 0 && m.length == be.length && be[N].from().ch > 0 && El(this.doc, N, new Kt(F, be[N].to()), we)
                        }
                    }
                }),
                getTokenAt: function (f, m) {
                    return il(this, f, m)
                },
                getLineTokens: function (f, m) {
                    return il(this, _e(f), m, !0)
                },
                getTokenTypeAt: function (f) {
                    f = Et(this.doc, f);
                    var m = ls(this, dt(this.doc, f.line)), E = 0, N = (m.length - 1) / 2, P = f.ch, F;
                    if (P == 0) F = m[2]; else for (; ;) {
                        var H = E + N >> 1;
                        if ((H ? m[H * 2 - 1] : 0) >= P) N = H; else if (m[H * 2 + 1] < P) E = H + 1; else {
                            F = m[H * 2 + 2];
                            break
                        }
                    }
                    var X = F ? F.indexOf("overlay ") : -1;
                    return X < 0 ? F : X == 0 ? null : F.slice(0, X - 1)
                },
                getModeAt: function (f) {
                    var m = this.doc.mode;
                    return m.innerMode ? o.innerMode(m, this.getTokenAt(f).state).mode : m
                },
                getHelper: function (f, m) {
                    return this.getHelpers(f, m)[0]
                },
                getHelpers: function (f, m) {
                    var E = [];
                    if (!p.hasOwnProperty(m)) return E;
                    var N = p[m], P = this.getModeAt(f);
                    if (typeof P[m] == "string") N[P[m]] && E.push(N[P[m]]); else if (P[m]) for (var F = 0; F < P[m].length; F++) {
                        var H = N[P[m][F]];
                        H && E.push(H)
                    } else P.helperType && N[P.helperType] ? E.push(N[P.helperType]) : N[P.name] && E.push(N[P.name]);
                    for (var X = 0; X < N._global.length; X++) {
                        var ie = N._global[X];
                        ie.pred(P, this) && ct(E, ie.val) == -1 && E.push(ie.val)
                    }
                    return E
                },
                getStateAfter: function (f, m) {
                    var E = this.doc;
                    return f = lf(E, f ?? E.first + E.size - 1), Bo(this, f + 1, m).state
                },
                cursorCoords: function (f, m) {
                    var E, N = this.doc.sel.primary();
                    return f == null ? E = N.head : typeof f == "object" ? E = Et(this.doc, f) : E = f ? N.from() : N.to(), Ht(this, E, m || "page")
                },
                charCoords: function (f, m) {
                    return dl(this, Et(this.doc, f), m || "page")
                },
                coordsChar: function (f, m) {
                    return f = gd(this, f, m || "page"), po(this, f.left, f.top)
                },
                lineAtHeight: function (f, m) {
                    return f = gd(this, {top: f, left: 0}, m || "page").top, re(this.doc, f + this.display.viewOffset)
                },
                heightAtLine: function (f, m, E) {
                    var N = !1, P;
                    if (typeof f == "number") {
                        var F = this.doc.first + this.doc.size - 1;
                        f < this.doc.first ? f = this.doc.first : f > F && (f = F, N = !0), P = dt(this.doc, f)
                    } else P = f;
                    return ul(this, P, {top: 0, left: 0}, m || "page", E || N).top + (N ? this.doc.height - oi(P) : 0)
                },
                defaultTextHeight: function () {
                    return la(this.display)
                },
                defaultCharWidth: function () {
                    return ms(this.display)
                },
                getViewport: function () {
                    return {from: this.display.viewFrom, to: this.display.viewTo}
                },
                addWidget: function (f, m, E, N, P) {
                    var F = this.display;
                    f = Ht(this, Et(this.doc, f));
                    var H = f.bottom, X = f.left;
                    if (m.style.position = "absolute", m.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(m), F.sizer.appendChild(m), N == "over") H = f.top; else if (N == "above" || N == "near") {
                        var ie = Math.max(F.wrapper.clientHeight, this.doc.height),
                            be = Math.max(F.sizer.clientWidth, F.lineSpace.clientWidth);
                        (N == "above" || f.bottom + m.offsetHeight > ie) && f.top > m.offsetHeight ? H = f.top - m.offsetHeight : f.bottom + m.offsetHeight <= ie && (H = f.bottom), X + m.offsetWidth > be && (X = be - m.offsetWidth)
                    }
                    m.style.top = H + "px", m.style.left = m.style.right = "", P == "right" ? (X = F.sizer.clientWidth - m.offsetWidth, m.style.right = "0px") : (P == "left" ? X = 0 : P == "middle" && (X = (F.sizer.clientWidth - m.offsetWidth) / 2), m.style.left = X + "px"), E && Uf(this, {
                        left: X,
                        top: H,
                        right: X + m.offsetWidth,
                        bottom: H + m.offsetHeight
                    })
                },
                triggerOnKeyDown: kr(mg),
                triggerOnKeyPress: kr(kg),
                triggerOnKeyUp: bg,
                triggerOnMouseDown: kr(vg),
                execCommand: function (f) {
                    if (Nl.hasOwnProperty(f)) return Nl[f].call(null, this)
                },
                triggerElectric: kr(function (f) {
                    du(this, f)
                }),
                findPosH: function (f, m, E, N) {
                    var P = 1;
                    m < 0 && (P = -1, m = -m);
                    for (var F = Et(this.doc, f), H = 0; H < m && (F = Yd(this.doc, F, P, E, N), !F.hitSide); ++H) ;
                    return F
                },
                moveH: kr(function (f, m) {
                    var E = this;
                    this.extendSelectionsBy(function (N) {
                        return E.display.shift || E.doc.extend || N.empty() ? Yd(E.doc, N.head, f, m, E.options.rtlMoveVisually) : f < 0 ? N.from() : N.to()
                    }, Be)
                }),
                deleteH: kr(function (f, m) {
                    var E = this.doc.sel, N = this.doc;
                    E.somethingSelected() ? N.replaceSelection("", null, "+delete") : Aa(this, function (P) {
                        var F = Yd(N, P.head, f, m, !1);
                        return f < 0 ? {from: F, to: P.head} : {from: P.head, to: F}
                    })
                }),
                findPosV: function (f, m, E, N) {
                    var P = 1, F = N;
                    m < 0 && (P = -1, m = -m);
                    for (var H = Et(this.doc, f), X = 0; X < m; ++X) {
                        var ie = Ht(this, H, "div");
                        if (F == null ? F = ie.left : ie.left = F, H = fu(this, ie, P, E), H.hitSide) break
                    }
                    return H
                },
                moveV: kr(function (f, m) {
                    var E = this, N = this.doc, P = [],
                        F = !this.display.shift && !N.extend && N.sel.somethingSelected();
                    if (N.extendSelectionsBy(function (X) {
                        if (F) return f < 0 ? X.from() : X.to();
                        var ie = Ht(E, X.head, "div");
                        X.goalColumn != null && (ie.left = X.goalColumn), P.push(ie.left);
                        var be = fu(E, ie, f, m);
                        return m == "page" && X == N.sel.primary() && Hc(E, dl(E, be, "div").top - ie.top), be
                    }, Be), P.length) for (var H = 0; H < N.sel.ranges.length; H++) N.sel.ranges[H].goalColumn = P[H]
                }),
                findWordAt: function (f) {
                    var m = this.doc, E = dt(m, f.line).text, N = f.ch, P = f.ch;
                    if (E) {
                        var F = this.getHelper(f, "wordChars");
                        (f.sticky == "before" || P == E.length) && N ? --N : ++P;
                        for (var H = E.charAt(N), X = De(H, F) ? function (ie) {
                            return De(ie, F)
                        } : /\s/.test(H) ? function (ie) {
                            return /\s/.test(ie)
                        } : function (ie) {
                            return !/\s/.test(ie) && !De(ie)
                        }; N > 0 && X(E.charAt(N - 1));) --N;
                        for (; P < E.length && X(E.charAt(P));) ++P
                    }
                    return new Kt(_e(f.line, N), _e(f.line, P))
                },
                toggleOverwrite: function (f) {
                    f != null && f == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? it(this.display.cursorDiv, "CodeMirror-overwrite") : ke(this.display.cursorDiv, "CodeMirror-overwrite"), cn(this, "overwriteToggle", this, this.state.overwrite))
                },
                hasFocus: function () {
                    return this.display.input.getField() == Le(At(this))
                },
                isReadOnly: function () {
                    return !!(this.options.readOnly || this.doc.cantEdit)
                },
                scrollTo: kr(function (f, m) {
                    ks(this, f, m)
                }),
                getScrollInfo: function () {
                    var f = this.display.scroller;
                    return {
                        left: f.scrollLeft,
                        top: f.scrollTop,
                        height: f.scrollHeight - Vi(this) - this.display.barHeight,
                        width: f.scrollWidth - Vi(this) - this.display.barWidth,
                        clientHeight: aa(this),
                        clientWidth: gs(this)
                    }
                },
                scrollIntoView: kr(function (f, m) {
                    f == null ? (f = {
                        from: this.doc.sel.primary().head,
                        to: null
                    }, m == null && (m = this.options.cursorScrollMargin)) : typeof f == "number" ? f = {
                        from: _e(f, 0),
                        to: null
                    } : f.from == null && (f = {
                        from: f,
                        to: null
                    }), f.to || (f.to = f.from), f.margin = m || 0, f.from.line != null ? Fm(this, f) : qf(this, f.from, f.to, f.margin)
                }),
                setSize: kr(function (f, m) {
                    var E = this, N = function (F) {
                        return typeof F == "number" || /^\d+$/.test(String(F)) ? F + "px" : F
                    };
                    f != null && (this.display.wrapper.style.width = N(f)), m != null && (this.display.wrapper.style.height = N(m)), this.options.lineWrapping && dd(this);
                    var P = this.display.viewFrom;
                    this.doc.iter(P, this.display.viewTo, function (F) {
                        if (F.widgets) {
                            for (var H = 0; H < F.widgets.length; H++) if (F.widgets[H].noHScroll) {
                                Lt(E, P, "widget");
                                break
                            }
                        }
                        ++P
                    }), this.curOp.forceUpdate = !0, cn(this, "refresh", this)
                }),
                operation: function (f) {
                    return _r(this, f)
                },
                startOperation: function () {
                    return ws(this)
                },
                endOperation: function () {
                    return br(this)
                },
                refresh: kr(function () {
                    var f = this.display.cachedTextHeight;
                    Cr(this), this.curOp.forceUpdate = !0, cl(this), ks(this, this.doc.scrollLeft, this.doc.scrollTop), Wc(this.display), (f == null || Math.abs(f - la(this.display)) > .5 || this.options.lineWrapping) && ca(this), cn(this, "refresh", this)
                }),
                swapDoc: kr(function (f) {
                    var m = this.doc;
                    return m.cm = null, this.state.selectingText && this.state.selectingText(), _l(this, f), cl(this), this.display.input.reset(), ks(this, f.scrollLeft, f.scrollTop), this.curOp.forceScroll = !0, Un(this, "swapDoc", this, m), m
                }),
                phrase: function (f) {
                    var m = this.options.phrases;
                    return m && Object.prototype.hasOwnProperty.call(m, f) ? m[f] : f
                },
                getInputField: function () {
                    return this.display.input.getField()
                },
                getWrapperElement: function () {
                    return this.display.wrapper
                },
                getScrollerElement: function () {
                    return this.display.scroller
                },
                getGutterElement: function () {
                    return this.display.gutters
                }
            }, Hr(o), o.registerHelper = function (f, m, E) {
                p.hasOwnProperty(f) || (p[f] = o[f] = {_global: []}), p[f][m] = E
            }, o.registerGlobalHelper = function (f, m, E, N) {
                o.registerHelper(f, m, N), p[f]._global.push({pred: E, val: N})
            }
        }

        function Yd(o, u, p, f, m) {
            var E = u, N = p, P = dt(o, u.line), F = m && o.direction == "rtl" ? -p : p;

            function H() {
                var et = u.line + F;
                return et < o.first || et >= o.first + o.size ? !1 : (u = new _e(et, u.ch, u.sticky), P = dt(o, et))
            }

            function X(et) {
                var Ke;
                if (f == "codepoint") {
                    var at = P.text.charCodeAt(u.ch + (p > 0 ? 0 : -1));
                    if (isNaN(at)) Ke = null; else {
                        var pt = p > 0 ? at >= 55296 && at < 56320 : at >= 56320 && at < 57343;
                        Ke = new _e(u.line, Math.max(0, Math.min(P.text.length, u.ch + p * (pt ? 2 : 1))), -p)
                    }
                } else m ? Ke = zd(o.cm, P, u, p) : Ke = Rd(P, u, p);
                if (Ke == null) if (!et && H()) u = Ca(m, o.cm, P, u.line, F); else return !1; else u = Ke;
                return !0
            }

            if (f == "char" || f == "codepoint") X(); else if (f == "column") X(!0); else if (f == "word" || f == "group") for (var ie = null, be = f == "group", fe = o.cm && o.cm.getHelper(u, "wordChars"), xe = !0; !(p < 0 && !X(!xe)); xe = !1) {
                var Ne = P.text.charAt(u.ch) || `
`, Ve = De(Ne, fe) ? "w" : be && Ne == `
` ? "n" : !be || /\s/.test(Ne) ? null : "p";
                if (be && !xe && !Ve && (Ve = "s"), ie && ie != Ve) {
                    p < 0 && (p = 1, X(), u.sticky = "after");
                    break
                }
                if (Ve && (ie = Ve), p > 0 && !X(!xe)) break
            }
            var $e = tu(o, u, E, N, !0);
            return Qt(E, $e) && ($e.hitSide = !0), $e
        }

        function fu(o, u, p, f) {
            var m = o.doc, E = u.left, N;
            if (f == "page") {
                var P = Math.min(o.display.wrapper.clientHeight, Ye(o).innerHeight || m(o).documentElement.clientHeight),
                    F = Math.max(P - .5 * la(o.display), 3);
                N = (p > 0 ? u.bottom : u.top) + p * F
            } else f == "line" && (N = p > 0 ? u.bottom + 3 : u.top - 3);
            for (var H; H = po(o, E, N), !!H.outside;) {
                if (p < 0 ? N <= 0 : N >= m.height) {
                    H.hitSide = !0;
                    break
                }
                N += p * 5
            }
            return H
        }

        var rn = function (o) {
            this.cm = o, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new Vt, this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null
        };
        rn.prototype.init = function (o) {
            var u = this, p = this, f = p.cm, m = p.div = o.lineDiv;
            m.contentEditable = !0, Zd(m, f.options.spellcheck, f.options.autocorrect, f.options.autocapitalize);

            function E(P) {
                for (var F = P.target; F; F = F.parentNode) {
                    if (F == m) return !0;
                    if (/\bCodeMirror-(?:line)?widget\b/.test(F.className)) break
                }
                return !1
            }

            ft(m, "paste", function (P) {
                !E(P) || fn(f, P) || Ag(P, f) || S <= 11 && setTimeout(nr(f, function () {
                    return u.updateFromDOM()
                }), 20)
            }), ft(m, "compositionstart", function (P) {
                u.composing = {data: P.data, done: !1}
            }), ft(m, "compositionupdate", function (P) {
                u.composing || (u.composing = {data: P.data, done: !1})
            }), ft(m, "compositionend", function (P) {
                u.composing && (P.data != u.composing.data && u.readFromDOMSoon(), u.composing.done = !0)
            }), ft(m, "touchstart", function () {
                return p.forceCompositionEnd()
            }), ft(m, "input", function () {
                u.composing || u.readFromDOMSoon()
            });

            function N(P) {
                if (!(!E(P) || fn(f, P))) {
                    if (f.somethingSelected()) Ss({
                        lineWise: !1,
                        text: f.getSelections()
                    }), P.type == "cut" && f.replaceSelection("", null, "cut"); else if (f.options.lineWiseCopyCut) {
                        var F = hu(f);
                        Ss({lineWise: !0, text: F.text}), P.type == "cut" && f.operation(function () {
                            f.setSelections(F.ranges, 0, we), f.replaceSelection("", null, "cut")
                        })
                    } else return;
                    if (P.clipboardData) {
                        P.clipboardData.clearData();
                        var H = Jr.text.join(`
`);
                        if (P.clipboardData.setData("Text", H), P.clipboardData.getData("Text") == H) {
                            P.preventDefault();
                            return
                        }
                    }
                    var X = jl(), ie = X.firstChild;
                    Zd(ie), f.display.lineSpace.insertBefore(X, f.display.lineSpace.firstChild), ie.value = Jr.text.join(`
`);
                    var be = Le(mt(m));
                    Tt(ie), setTimeout(function () {
                        f.display.lineSpace.removeChild(X), be.focus(), be == m && p.showPrimarySelection()
                    }, 50)
                }
            }

            ft(m, "copy", N), ft(m, "cut", N)
        }, rn.prototype.screenReaderLabelChanged = function (o) {
            o ? this.div.setAttribute("aria-label", o) : this.div.removeAttribute("aria-label")
        }, rn.prototype.prepareSelection = function () {
            var o = ua(this.cm, !1);
            return o.focus = Le(mt(this.div)) == this.div, o
        }, rn.prototype.showSelection = function (o, u) {
            !o || !this.cm.display.view.length || ((o.focus || u) && this.showPrimarySelection(), this.showMultipleSelections(o))
        }, rn.prototype.getSelection = function () {
            return this.cm.display.wrapper.ownerDocument.getSelection()
        }, rn.prototype.showPrimarySelection = function () {
            var o = this.getSelection(), u = this.cm, p = u.doc.sel.primary(), f = p.from(), m = p.to();
            if (u.display.viewTo == u.display.viewFrom || f.line >= u.display.viewTo || m.line < u.display.viewFrom) {
                o.removeAllRanges();
                return
            }
            var E = Vl(u, o.anchorNode, o.anchorOffset), N = Vl(u, o.focusNode, o.focusOffset);
            if (!(E && !E.bad && N && !N.bad && Qe(as(E, N), f) == 0 && Qe(Hn(E, N), m) == 0)) {
                var P = u.display.view,
                    F = f.line >= u.display.viewFrom && Zo(u, f) || {node: P[0].measure.map[2], offset: 0},
                    H = m.line < u.display.viewTo && Zo(u, m);
                if (!H) {
                    var X = P[P.length - 1].measure, ie = X.maps ? X.maps[X.maps.length - 1] : X.map;
                    H = {node: ie[ie.length - 1], offset: ie[ie.length - 2] - ie[ie.length - 3]}
                }
                if (!F || !H) {
                    o.removeAllRanges();
                    return
                }
                var be = o.rangeCount && o.getRangeAt(0), fe;
                try {
                    fe = Ze(F.node, F.offset, H.offset, H.node)
                } catch {
                }
                fe && (!C && u.state.focused ? (o.collapse(F.node, F.offset), fe.collapsed || (o.removeAllRanges(), o.addRange(fe))) : (o.removeAllRanges(), o.addRange(fe)), be && o.anchorNode == null ? o.addRange(be) : C && this.startGracePeriod()), this.rememberSelection()
            }
        }, rn.prototype.startGracePeriod = function () {
            var o = this;
            clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function () {
                o.gracePeriod = !1, o.selectionChanged() && o.cm.operation(function () {
                    return o.cm.curOp.selectionChanged = !0
                })
            }, 20)
        }, rn.prototype.showMultipleSelections = function (o) {
            ye(this.cm.display.cursorDiv, o.cursors), ye(this.cm.display.selectionDiv, o.selection)
        }, rn.prototype.rememberSelection = function () {
            var o = this.getSelection();
            this.lastAnchorNode = o.anchorNode, this.lastAnchorOffset = o.anchorOffset, this.lastFocusNode = o.focusNode, this.lastFocusOffset = o.focusOffset
        }, rn.prototype.selectionInEditor = function () {
            var o = this.getSelection();
            if (!o.rangeCount) return !1;
            var u = o.getRangeAt(0).commonAncestorContainer;
            return Xe(this.div, u)
        }, rn.prototype.focus = function () {
            this.cm.options.readOnly != "nocursor" && ((!this.selectionInEditor() || Le(mt(this.div)) != this.div) && this.showSelection(this.prepareSelection(), !0), this.div.focus())
        }, rn.prototype.blur = function () {
            this.div.blur()
        }, rn.prototype.getField = function () {
            return this.div
        }, rn.prototype.supportsTouch = function () {
            return !0
        }, rn.prototype.receivedFocus = function () {
            var o = this, u = this;
            this.selectionInEditor() ? setTimeout(function () {
                return o.pollSelection()
            }, 20) : _r(this.cm, function () {
                return u.cm.curOp.selectionChanged = !0
            });

            function p() {
                u.cm.state.focused && (u.pollSelection(), u.polling.set(u.cm.options.pollInterval, p))
            }

            this.polling.set(this.cm.options.pollInterval, p)
        }, rn.prototype.selectionChanged = function () {
            var o = this.getSelection();
            return o.anchorNode != this.lastAnchorNode || o.anchorOffset != this.lastAnchorOffset || o.focusNode != this.lastFocusNode || o.focusOffset != this.lastFocusOffset
        }, rn.prototype.pollSelection = function () {
            if (!(this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())) {
                var o = this.getSelection(), u = this.cm;
                if (Z && D && this.cm.display.gutterSpecs.length && Cg(o.anchorNode)) {
                    this.cm.triggerOnKeyDown({
                        type: "keydown",
                        keyCode: 8,
                        preventDefault: Math.abs
                    }), this.blur(), this.focus();
                    return
                }
                if (!this.composing) {
                    this.rememberSelection();
                    var p = Vl(u, o.anchorNode, o.anchorOffset), f = Vl(u, o.focusNode, o.focusOffset);
                    p && f && _r(u, function () {
                        yn(u.doc, Vo(p, f), we), (p.bad || f.bad) && (u.curOp.selectionChanged = !0)
                    })
                }
            }
        }, rn.prototype.pollContent = function () {
            this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
            var o = this.cm, u = o.display, p = o.doc.sel.primary(), f = p.from(), m = p.to();
            if (f.ch == 0 && f.line > o.firstLine() && (f = _e(f.line - 1, dt(o.doc, f.line - 1).length)), m.ch == dt(o.doc, m.line).text.length && m.line < o.lastLine() && (m = _e(m.line + 1, 0)), f.line < u.viewFrom || m.line > u.viewTo - 1) return !1;
            var E, N, P;
            f.line == u.viewFrom || (E = Fo(o, f.line)) == 0 ? (N = W(u.view[0].line), P = u.view[0].node) : (N = W(u.view[E].line), P = u.view[E - 1].node.nextSibling);
            var F = Fo(o, m.line), H, X;
            if (F == u.view.length - 1 ? (H = u.viewTo - 1, X = u.lineDiv.lastChild) : (H = W(u.view[F + 1].line) - 1, X = u.view[F + 1].node.previousSibling), !P) return !1;
            for (var ie = o.doc.splitLines(rb(o, P, X, N, H)), be = uo(o.doc, _e(N, 0), _e(H, dt(o.doc, H).text.length)); ie.length > 1 && be.length > 1;) if (V(ie) == V(be)) ie.pop(), be.pop(), H--; else if (ie[0] == be[0]) ie.shift(), be.shift(), N++; else break;
            for (var fe = 0, xe = 0, Ne = ie[0], Ve = be[0], $e = Math.min(Ne.length, Ve.length); fe < $e && Ne.charCodeAt(fe) == Ve.charCodeAt(fe);) ++fe;
            for (var et = V(ie), Ke = V(be), at = Math.min(et.length - (ie.length == 1 ? fe : 0), Ke.length - (be.length == 1 ? fe : 0)); xe < at && et.charCodeAt(et.length - xe - 1) == Ke.charCodeAt(Ke.length - xe - 1);) ++xe;
            if (ie.length == 1 && be.length == 1 && N == f.line) for (; fe && fe > f.ch && et.charCodeAt(et.length - xe - 1) == Ke.charCodeAt(Ke.length - xe - 1);) fe--, xe++;
            ie[ie.length - 1] = et.slice(0, et.length - xe).replace(/^\u200b+/, ""), ie[0] = ie[0].slice(fe).replace(/\u200b+$/, "");
            var pt = _e(N, fe), gt = _e(H, be.length ? V(be).length - xe : 0);
            if (ie.length > 1 || ie[0] || Qe(pt, gt)) return Ds(o.doc, ie, pt, gt, "+input"), !0
        }, rn.prototype.ensurePolled = function () {
            this.forceCompositionEnd()
        }, rn.prototype.reset = function () {
            this.forceCompositionEnd()
        }, rn.prototype.forceCompositionEnd = function () {
            this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus())
        }, rn.prototype.readFromDOMSoon = function () {
            var o = this;
            this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(function () {
                if (o.readDOMTimeout = null, o.composing) if (o.composing.done) o.composing = null; else return;
                o.updateFromDOM()
            }, 80))
        }, rn.prototype.updateFromDOM = function () {
            var o = this;
            (this.cm.isReadOnly() || !this.pollContent()) && _r(this.cm, function () {
                return Cr(o.cm)
            })
        }, rn.prototype.setUneditable = function (o) {
            o.contentEditable = "false"
        }, rn.prototype.onKeyPress = function (o) {
            o.charCode == 0 || this.composing || (o.preventDefault(), this.cm.isReadOnly() || nr(this.cm, vo)(this.cm, String.fromCharCode(o.charCode == null ? o.keyCode : o.charCode), 0))
        }, rn.prototype.readOnlyChanged = function (o) {
            this.div.contentEditable = String(o != "nocursor")
        }, rn.prototype.onContextMenu = function () {
        }, rn.prototype.resetPosition = function () {
        }, rn.prototype.needsContentAttribute = !0;

        function Zo(o, u) {
            var p = Lc(o, u.line);
            if (!p || p.hidden) return null;
            var f = dt(o.doc, u.line), m = Pf(p, f, u.line), E = ot(f, o.doc.direction), N = "left";
            if (E) {
                var P = Ot(E, u.ch);
                N = P % 2 ? "right" : "left"
            }
            var F = Ff(m.map, u.ch, N);
            return F.offset = F.collapse == "right" ? F.end : F.start, F
        }

        function Cg(o) {
            for (var u = o; u; u = u.parentNode) if (/CodeMirror-gutter-wrapper/.test(u.className)) return !0;
            return !1
        }

        function Yo(o, u) {
            return u && (o.bad = !0), o
        }

        function rb(o, u, p, f, m) {
            var E = "", N = !1, P = o.doc.lineSeparator(), F = !1;

            function H(fe) {
                return function (xe) {
                    return xe.id == fe
                }
            }

            function X() {
                N && (E += P, F && (E += P), N = F = !1)
            }

            function ie(fe) {
                fe && (X(), E += fe)
            }

            function be(fe) {
                if (fe.nodeType == 1) {
                    var xe = fe.getAttribute("cm-text");
                    if (xe) {
                        ie(xe);
                        return
                    }
                    var Ne = fe.getAttribute("cm-marker"), Ve;
                    if (Ne) {
                        var $e = o.findMarks(_e(f, 0), _e(m + 1, 0), H(+Ne));
                        $e.length && (Ve = $e[0].find(0)) && ie(uo(o.doc, Ve.from, Ve.to).join(P));
                        return
                    }
                    if (fe.getAttribute("contenteditable") == "false") return;
                    var et = /^(pre|div|p|li|table|br)$/i.test(fe.nodeName);
                    if (!/^br$/i.test(fe.nodeName) && fe.textContent.length == 0) return;
                    et && X();
                    for (var Ke = 0; Ke < fe.childNodes.length; Ke++) be(fe.childNodes[Ke]);
                    /^(pre|p)$/i.test(fe.nodeName) && (F = !0), et && (N = !0)
                } else fe.nodeType == 3 && ie(fe.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "))
            }

            for (; be(u), u != p;) u = u.nextSibling, F = !1;
            return E
        }

        function Vl(o, u, p) {
            var f;
            if (u == o.display.lineDiv) {
                if (f = o.display.lineDiv.childNodes[p], !f) return Yo(o.clipPos(_e(o.display.viewTo - 1)), !0);
                u = null, p = 0
            } else for (f = u; ; f = f.parentNode) {
                if (!f || f == o.display.lineDiv) return null;
                if (f.parentNode && f.parentNode == o.display.lineDiv) break
            }
            for (var m = 0; m < o.display.view.length; m++) {
                var E = o.display.view[m];
                if (E.node == f) return Qd(E, u, p)
            }
        }

        function Qd(o, u, p) {
            var f = o.text.firstChild, m = !1;
            if (!u || !Xe(f, u)) return Yo(_e(W(o.line), 0), !0);
            if (u == f && (m = !0, u = f.childNodes[p], p = 0, !u)) {
                var E = o.rest ? V(o.rest) : o.line;
                return Yo(_e(W(E), E.text.length), m)
            }
            var N = u.nodeType == 3 ? u : null, P = u;
            for (!N && u.childNodes.length == 1 && u.firstChild.nodeType == 3 && (N = u.firstChild, p && (p = N.nodeValue.length)); P.parentNode != f;) P = P.parentNode;
            var F = o.measure, H = F.maps;

            function X(Ve, $e, et) {
                for (var Ke = -1; Ke < (H ? H.length : 0); Ke++) for (var at = Ke < 0 ? F.map : H[Ke], pt = 0; pt < at.length; pt += 3) {
                    var gt = at[pt + 2];
                    if (gt == Ve || gt == $e) {
                        var Mt = W(Ke < 0 ? o.line : o.rest[Ke]), hn = at[pt] + et;
                        return (et < 0 || gt != Ve) && (hn = at[pt + (et ? 1 : 0)]), _e(Mt, hn)
                    }
                }
            }

            var ie = X(N, P, p);
            if (ie) return Yo(ie, m);
            for (var be = P.nextSibling, fe = N ? N.nodeValue.length - p : 0; be; be = be.nextSibling) {
                if (ie = X(be, be.firstChild, 0), ie) return Yo(_e(ie.line, ie.ch - fe), m);
                fe += be.textContent.length
            }
            for (var xe = P.previousSibling, Ne = p; xe; xe = xe.previousSibling) {
                if (ie = X(xe, xe.firstChild, -1), ie) return Yo(_e(ie.line, ie.ch + Ne), m);
                Ne += xe.textContent.length
            }
        }

        var In = function (o) {
            this.cm = o, this.prevInput = "", this.pollingFast = !1, this.polling = new Vt, this.hasSelection = !1, this.composing = null, this.resetting = !1
        };
        In.prototype.init = function (o) {
            var u = this, p = this, f = this.cm;
            this.createField(o);
            var m = this.textarea;
            o.wrapper.insertBefore(this.wrapper, o.wrapper.firstChild), G && (m.style.width = "0px"), ft(m, "input", function () {
                w && S >= 9 && u.hasSelection && (u.hasSelection = null), p.poll()
            }), ft(m, "paste", function (N) {
                fn(f, N) || Ag(N, f) || (f.state.pasteIncoming = +new Date, p.fastPoll())
            });

            function E(N) {
                if (!fn(f, N)) {
                    if (f.somethingSelected()) Ss({
                        lineWise: !1,
                        text: f.getSelections()
                    }); else if (f.options.lineWiseCopyCut) {
                        var P = hu(f);
                        Ss({
                            lineWise: !0,
                            text: P.text
                        }), N.type == "cut" ? f.setSelections(P.ranges, null, we) : (p.prevInput = "", m.value = P.text.join(`
`), Tt(m))
                    } else return;
                    N.type == "cut" && (f.state.cutIncoming = +new Date)
                }
            }

            ft(m, "cut", E), ft(m, "copy", E), ft(o.scroller, "paste", function (N) {
                if (!(fo(o, N) || fn(f, N))) {
                    if (!m.dispatchEvent) {
                        f.state.pasteIncoming = +new Date, p.focus();
                        return
                    }
                    var P = new Event("paste");
                    P.clipboardData = N.clipboardData, m.dispatchEvent(P)
                }
            }), ft(o.lineSpace, "selectstart", function (N) {
                fo(o, N) || Sn(N)
            }), ft(m, "compositionstart", function () {
                var N = f.getCursor("from");
                p.composing && p.composing.range.clear(), p.composing = {
                    start: N,
                    range: f.markText(N, f.getCursor("to"), {className: "CodeMirror-composing"})
                }
            }), ft(m, "compositionend", function () {
                p.composing && (p.poll(), p.composing.range.clear(), p.composing = null)
            })
        }, In.prototype.createField = function (o) {
            this.wrapper = jl(), this.textarea = this.wrapper.firstChild;
            var u = this.cm.options;
            Zd(this.textarea, u.spellcheck, u.autocorrect, u.autocapitalize)
        }, In.prototype.screenReaderLabelChanged = function (o) {
            o ? this.textarea.setAttribute("aria-label", o) : this.textarea.removeAttribute("aria-label")
        }, In.prototype.prepareSelection = function () {
            var o = this.cm, u = o.display, p = o.doc, f = ua(o);
            if (o.options.moveInputWithCursor) {
                var m = Ht(o, p.sel.primary().head, "div"), E = u.wrapper.getBoundingClientRect(),
                    N = u.lineDiv.getBoundingClientRect();
                f.teTop = Math.max(0, Math.min(u.wrapper.clientHeight - 10, m.top + N.top - E.top)), f.teLeft = Math.max(0, Math.min(u.wrapper.clientWidth - 10, m.left + N.left - E.left))
            }
            return f
        }, In.prototype.showSelection = function (o) {
            var u = this.cm, p = u.display;
            ye(p.cursorDiv, o.cursors), ye(p.selectionDiv, o.selection), o.teTop != null && (this.wrapper.style.top = o.teTop + "px", this.wrapper.style.left = o.teLeft + "px")
        }, In.prototype.reset = function (o) {
            if (!(this.contextMenuPending || this.composing && o)) {
                var u = this.cm;
                if (this.resetting = !0, u.somethingSelected()) {
                    this.prevInput = "";
                    var p = u.getSelection();
                    this.textarea.value = p, u.state.focused && Tt(this.textarea), w && S >= 9 && (this.hasSelection = p)
                } else o || (this.prevInput = this.textarea.value = "", w && S >= 9 && (this.hasSelection = null));
                this.resetting = !1
            }
        }, In.prototype.getField = function () {
            return this.textarea
        }, In.prototype.supportsTouch = function () {
            return !1
        }, In.prototype.focus = function () {
            if (this.cm.options.readOnly != "nocursor" && (!Y || Le(mt(this.textarea)) != this.textarea)) try {
                this.textarea.focus()
            } catch {
            }
        }, In.prototype.blur = function () {
            this.textarea.blur()
        }, In.prototype.resetPosition = function () {
            this.wrapper.style.top = this.wrapper.style.left = 0
        }, In.prototype.receivedFocus = function () {
            this.slowPoll()
        }, In.prototype.slowPoll = function () {
            var o = this;
            this.pollingFast || this.polling.set(this.cm.options.pollInterval, function () {
                o.poll(), o.cm.state.focused && o.slowPoll()
            })
        }, In.prototype.fastPoll = function () {
            var o = !1, u = this;
            u.pollingFast = !0;

            function p() {
                var f = u.poll();
                !f && !o ? (o = !0, u.polling.set(60, p)) : (u.pollingFast = !1, u.slowPoll())
            }

            u.polling.set(20, p)
        }, In.prototype.poll = function () {
            var o = this, u = this.cm, p = this.textarea, f = this.prevInput;
            if (this.contextMenuPending || this.resetting || !u.state.focused || Io(p) && !f && !this.composing || u.isReadOnly() || u.options.disableInput || u.state.keySeq) return !1;
            var m = p.value;
            if (m == f && !u.somethingSelected()) return !1;
            if (w && S >= 9 && this.hasSelection === m || ce && /[\uf700-\uf7ff]/.test(m)) return u.display.input.reset(), !1;
            if (u.doc.sel == u.display.selForContextMenu) {
                var E = m.charCodeAt(0);
                if (E == 8203 && !f && (f = "​"), E == 8666) return this.reset(), this.cm.execCommand("undo")
            }
            for (var N = 0, P = Math.min(f.length, m.length); N < P && f.charCodeAt(N) == m.charCodeAt(N);) ++N;
            return _r(u, function () {
                vo(u, m.slice(N), f.length - N, null, o.composing ? "*compose" : null), m.length > 1e3 || m.indexOf(`
`) > -1 ? p.value = o.prevInput = "" : o.prevInput = m, o.composing && (o.composing.range.clear(), o.composing.range = u.markText(o.composing.start, u.getCursor("to"), {className: "CodeMirror-composing"}))
            }), !0
        }, In.prototype.ensurePolled = function () {
            this.pollingFast && this.poll() && (this.pollingFast = !1)
        }, In.prototype.onKeyPress = function () {
            w && S >= 9 && (this.hasSelection = null), this.fastPoll()
        }, In.prototype.onContextMenu = function (o) {
            var u = this, p = u.cm, f = p.display, m = u.textarea;
            u.contextMenuPending && u.contextMenuPending();
            var E = Oo(p, o), N = f.scroller.scrollTop;
            if (!E || L) return;
            var P = p.options.resetSelectionOnContextMenu;
            P && p.doc.sel.contains(E) == -1 && nr(p, yn)(p.doc, Vo(E), we);
            var F = m.style.cssText, H = u.wrapper.style.cssText, X = u.wrapper.offsetParent.getBoundingClientRect();
            u.wrapper.style.cssText = "position: static", m.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: ` + (o.clientY - X.top - 5) + "px; left: " + (o.clientX - X.left - 5) + `px;
      z-index: 1000; background: ` + (w ? "rgba(255, 255, 255, .05)" : "transparent") + `;
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;
            var ie;
            I && (ie = m.ownerDocument.defaultView.scrollY), f.input.focus(), I && m.ownerDocument.defaultView.scrollTo(null, ie), f.input.reset(), p.somethingSelected() || (m.value = u.prevInput = " "), u.contextMenuPending = fe, f.selForContextMenu = p.doc.sel, clearTimeout(f.detectingSelectAll);

            function be() {
                if (m.selectionStart != null) {
                    var Ne = p.somethingSelected(), Ve = "​" + (Ne ? m.value : "");
                    m.value = "⇚", m.value = Ve, u.prevInput = Ne ? "" : "​", m.selectionStart = 1, m.selectionEnd = Ve.length, f.selForContextMenu = p.doc.sel
                }
            }

            function fe() {
                if (u.contextMenuPending == fe && (u.contextMenuPending = !1, u.wrapper.style.cssText = H, m.style.cssText = F, w && S < 9 && f.scrollbars.setScrollTop(f.scroller.scrollTop = N), m.selectionStart != null)) {
                    (!w || w && S < 9) && be();
                    var Ne = 0, Ve = function () {
                        f.selForContextMenu == p.doc.sel && m.selectionStart == 0 && m.selectionEnd > 0 && u.prevInput == "​" ? nr(p, Md)(p) : Ne++ < 10 ? f.detectingSelectAll = setTimeout(Ve, 500) : (f.selForContextMenu = null, f.input.reset())
                    };
                    f.detectingSelectAll = setTimeout(Ve, 200)
                }
            }

            if (w && S >= 9 && be(), ue) {
                ti(o);
                var xe = function () {
                    Rn(window, "mouseup", xe), setTimeout(fe, 20)
                };
                ft(window, "mouseup", xe)
            } else setTimeout(fe, 50)
        }, In.prototype.readOnlyChanged = function (o) {
            o || this.reset(), this.textarea.disabled = o == "nocursor", this.textarea.readOnly = !!o
        }, In.prototype.setUneditable = function () {
        }, In.prototype.needsContentAttribute = !1;

        function ib(o, u) {
            if (u = u ? ht(u) : {}, u.value = o.value, !u.tabindex && o.tabIndex && (u.tabindex = o.tabIndex), !u.placeholder && o.placeholder && (u.placeholder = o.placeholder), u.autofocus == null) {
                var p = Le(mt(o));
                u.autofocus = p == o || o.getAttribute("autofocus") != null && p == document.body
            }

            function f() {
                o.value = P.getValue()
            }

            var m;
            if (o.form && (ft(o.form, "submit", f), !u.leaveSubmitMethodAlone)) {
                var E = o.form;
                m = E.submit;
                try {
                    var N = E.submit = function () {
                        f(), E.submit = m, E.submit(), E.submit = N
                    }
                } catch {
                }
            }
            u.finishInit = function (F) {
                F.save = f, F.getTextArea = function () {
                    return o
                }, F.toTextArea = function () {
                    F.toTextArea = isNaN, f(), o.parentNode.removeChild(F.getWrapperElement()), o.style.display = "", o.form && (Rn(o.form, "submit", f), !u.leaveSubmitMethodAlone && typeof o.form.submit == "function" && (o.form.submit = m))
                }
            }, o.style.display = "none";
            var P = gn(function (F) {
                return o.parentNode.insertBefore(F, o.nextSibling)
            }, u);
            return P
        }

        function _g(o) {
            o.off = Rn, o.on = ft, o.wheelEventPixels = Gc, o.Doc = yr, o.splitLines = Br, o.countColumn = vt, o.findColumn = Ue, o.isWordChar = Ae, o.Pass = ge, o.signal = cn, o.Line = ia, o.changeEnd = bo, o.scrollbarModel = Wf, o.Pos = _e, o.cmpPos = Qe, o.modes = ni, o.mimeModes = Yr, o.resolveMode = Qs, o.getMode = ii, o.modeExtensions = Mo, o.extendMode = Js, o.copyState = Ri, o.startState = Xs, o.innerMode = rl, o.commands = Nl, o.keyMap = Gi, o.keyName = Od, o.isModifierKey = hg, o.lookupKey = Go, o.normalizeKeyMap = Pd, o.StringStream = Tn, o.SharedTextMarker = Ei, o.TextMarker = ko, o.LineWidget = ka, o.e_preventDefault = Sn, o.e_stopPropagation = ur, o.e_stop = ti, o.addClass = it, o.contains = Xe, o.rmClass = ke, o.keyNames = $o
        }

        Gd(gn), nb(gn);
        var Jd = "iter insert remove copy getEditor constructor".split(" ");
        for (var Qo in yr.prototype) yr.prototype.hasOwnProperty(Qo) && ct(Jd, Qo) < 0 && (gn.prototype[Qo] = function (o) {
            return function () {
                return o.apply(this.doc, arguments)
            }
        }(yr.prototype[Qo]));
        return Hr(yr), gn.inputStyles = {textarea: In, contenteditable: rn}, gn.defineMode = function (o) {
            !gn.defaults.mode && o != "null" && (gn.defaults.mode = o), ri.apply(this, arguments)
        }, gn.defineMIME = ss, gn.defineMode("null", function () {
            return {
                token: function (o) {
                    return o.skipToEnd()
                }
            }
        }), gn.defineMIME("text/plain", "null"), gn.defineExtension = function (o, u) {
            gn.prototype[o] = u
        }, gn.defineDocExtension = function (o, u) {
            yr.prototype[o] = u
        }, gn.fromTextArea = ib, _g(gn), gn.version = "5.65.16", gn
    })
})(N5);
var sf = N5.exports;
const L5 = of(sf);
(function (a, c) {
    (function (h) {
        h(sf)
    })(function (h) {
        var b = h.Pos, C = "http://www.w3.org/2000/svg";

        function k(V, $) {
            this.mv = V, this.type = $, this.classes = $ == "left" ? {
                chunk: "CodeMirror-merge-l-chunk",
                start: "CodeMirror-merge-l-chunk-start",
                end: "CodeMirror-merge-l-chunk-end",
                insert: "CodeMirror-merge-l-inserted",
                del: "CodeMirror-merge-l-deleted",
                connect: "CodeMirror-merge-l-connect"
            } : {
                chunk: "CodeMirror-merge-r-chunk",
                start: "CodeMirror-merge-r-chunk-start",
                end: "CodeMirror-merge-r-chunk-end",
                insert: "CodeMirror-merge-r-inserted",
                del: "CodeMirror-merge-r-deleted",
                connect: "CodeMirror-merge-r-connect"
            }
        }

        k.prototype = {
            constructor: k, init: function (V, $, te) {
                this.edit = this.mv.edit, (this.edit.state.diffViews || (this.edit.state.diffViews = [])).push(this), this.orig = h(V, ht({
                    value: $,
                    readOnly: !this.mv.options.allowEditingOriginals
                }, ht(te))), this.mv.options.connect == "align" && (this.edit.state.trackAlignable || (this.edit.state.trackAlignable = new ge(this.edit)), this.orig.state.trackAlignable = new ge(this.orig)), this.lockButton.title = this.edit.phrase("Toggle locked scrolling"), this.lockButton.setAttribute("aria-label", this.lockButton.title), this.orig.state.diffViews = [this];
                var oe = te.chunkClassLocation || "background";
                Object.prototype.toString.call(oe) != "[object Array]" && (oe = [oe]), this.classes.classLocation = oe, this.diff = qe(ye($), ye(te.value), this.mv.options.ignoreWhitespace), this.chunks = Ze(this.diff), this.diffOutOfDate = this.dealigned = !1, this.needsScrollSync = null, this.showDifferences = te.showDifferences !== !1
            }, registerEvents: function (V) {
                this.forceUpdate = w(this), D(this, !0, !1), S(this, V)
            }, setShowDifferences: function (V) {
                V = V !== !1, V != this.showDifferences && (this.showDifferences = V, this.forceUpdate("full"))
            }
        };

        function A(V) {
            V.diffOutOfDate && (V.diff = qe(V.orig.getValue(), V.edit.getValue(), V.mv.options.ignoreWhitespace), V.chunks = Ze(V.diff), V.diffOutOfDate = !1, h.signal(V.edit, "updateDiff", V.diff))
        }

        var y = !1;

        function w(V) {
            var $ = {from: 0, to: 0, marked: []}, te = {from: 0, to: 0, marked: []}, oe, de = !1;

            function he(st) {
                y = !0, de = !1, st == "full" && (V.svg && Ye(V.svg), V.copyButtons && Ye(V.copyButtons), L(V.edit, $.marked, V.classes), L(V.orig, te.marked, V.classes), $.from = $.to = te.from = te.to = 0), A(V), V.showDifferences && (z(V.edit, V.diff, $, DIFF_INSERT, V.classes), z(V.orig, V.diff, te, DIFF_DELETE, V.classes)), V.mv.options.connect == "align" && me(V), G(V), V.needsScrollSync != null && I(V, V.needsScrollSync), y = !1
            }

            function Ae(st) {
                y || (V.dealigned = !0, De(st))
            }

            function De(st) {
                y || de || (clearTimeout(oe), st === !0 && (de = !0), oe = setTimeout(he, st === !0 ? 20 : 250))
            }

            function Ie(st, Dt) {
                V.diffOutOfDate || (V.diffOutOfDate = !0, $.from = $.to = te.from = te.to = 0), Ae(Dt.text.length - 1 != Dt.to.line - Dt.from.line)
            }

            function nt() {
                V.diffOutOfDate = !0, V.dealigned = !0, he("full")
            }

            return V.edit.on("change", Ie), V.orig.on("change", Ie), V.edit.on("swapDoc", nt), V.orig.on("swapDoc", nt), V.mv.options.connect == "align" && (h.on(V.edit.state.trackAlignable, "realign", Ae), h.on(V.orig.state.trackAlignable, "realign", Ae)), V.edit.on("viewportChange", function () {
                De(!1)
            }), V.orig.on("viewportChange", function () {
                De(!1)
            }), he(), he
        }

        function S(V, $) {
            V.edit.on("scroll", function () {
                I(V, !0) && G(V)
            }), V.orig.on("scroll", function () {
                I(V, !1) && G(V), $ && I($, !0) && G($)
            })
        }

        function I(V, $) {
            if (V.diffOutOfDate) return V.lockScroll && V.needsScrollSync == null && (V.needsScrollSync = $), !1;
            if (V.needsScrollSync = null, !V.lockScroll) return !0;
            var te, oe, de = +new Date;
            if ($ ? (te = V.edit, oe = V.orig) : (te = V.orig, oe = V.edit), te.state.scrollSetBy == V && (te.state.scrollSetAt || 0) + 250 > de) return !1;
            var he = te.getScrollInfo();
            if (V.mv.options.connect == "align") Nt = he.top; else {
                var Ae = .5 * he.clientHeight, De = he.top + Ae, Ie = te.lineAtHeight(De, "local"),
                    nt = it(V.chunks, Ie, $), st = T(te, $ ? nt.edit : nt.orig), Dt = T(oe, $ ? nt.orig : nt.edit),
                    zt = (De - st.top) / (st.bot - st.top), Nt = Dt.top - Ae + zt * (Dt.bot - Dt.top), $t, Ot;
                if (Nt > he.top && (Ot = he.top / Ae) < 1) Nt = Nt * Ot + he.top * (1 - Ot); else if (($t = he.height - he.clientHeight - he.top) < Ae) {
                    var Gt = oe.getScrollInfo(), ot = Gt.height - Gt.clientHeight - Nt;
                    ot > $t && (Ot = $t / Ae) < 1 && (Nt = Nt * Ot + (Gt.height - Gt.clientHeight - $t) * (1 - Ot))
                }
            }
            return oe.scrollTo(he.left, Nt), oe.state.scrollSetAt = de, oe.state.scrollSetBy = V, !0
        }

        function T(V, $) {
            var te = $.after;
            return te == null && (te = V.lastLine() + 1), {
                top: V.heightAtLine($.before || 0, "local"),
                bot: V.heightAtLine(te, "local")
            }
        }

        function D(V, $, te) {
            V.lockScroll = $, $ && te != !1 && I(V, DIFF_INSERT) && G(V), ($ ? h.addClass : h.rmClass)(V.lockButton, "CodeMirror-merge-scrolllock-enabled")
        }

        function B(V, $, te) {
            for (var oe = te.classLocation, de = 0; de < oe.length; de++) V.removeLineClass($, oe[de], te.chunk), V.removeLineClass($, oe[de], te.start), V.removeLineClass($, oe[de], te.end)
        }

        function L(V, $, te) {
            for (var oe = 0; oe < $.length; ++oe) {
                var de = $[oe];
                de instanceof h.TextMarker ? de.clear() : de.parent && B(V, de, te)
            }
            $.length = 0
        }

        function z(V, $, te, oe, de) {
            var he = V.getViewport();
            V.operation(function () {
                te.from == te.to || he.from - te.to > 20 || te.from - he.to > 20 ? (L(V, te.marked, de), Q(V, $, oe, te.marked, he.from, he.to, de), te.from = he.from, te.to = he.to) : (he.from < te.from && (Q(V, $, oe, te.marked, he.from, te.from, de), te.from = he.from), he.to > te.to && (Q(V, $, oe, te.marked, te.to, he.to, de), te.to = he.to))
            })
        }

        function q(V, $, te, oe, de, he) {
            for (var Ae = te.classLocation, De = V.getLineHandle($), Ie = 0; Ie < Ae.length; Ie++) oe && V.addLineClass(De, Ae[Ie], te.chunk), de && V.addLineClass(De, Ae[Ie], te.start), he && V.addLineClass(De, Ae[Ie], te.end);
            return De
        }

        function Q(V, $, te, oe, de, he, Ae) {
            var De = b(0, 0), Ie = b(de, 0), nt = V.clipPos(b(he - 1)), st = te == DIFF_DELETE ? Ae.del : Ae.insert;

            function Dt(fn, cr) {
                for (var zn = Math.max(de, fn), Hr = Math.min(he, cr), Sn = zn; Sn < Hr; ++Sn) oe.push(q(V, Sn, Ae, !0, Sn == fn, Sn == cr - 1));
                fn == cr && zn == cr && Hr == cr && (zn ? oe.push(q(V, zn - 1, Ae, !1, !1, !0)) : oe.push(q(V, zn, Ae, !1, !0, !1)))
            }

            for (var zt = 0, Nt = !1, $t = 0; $t < $.length; ++$t) {
                var Ot = $[$t], Gt = Ot[0], ot = Ot[1];
                if (Gt == DIFF_EQUAL) {
                    var lr = De.line + (Le($, $t) ? 0 : 1);
                    vt(De, ot);
                    var ft = De.line + (Xe($, $t) ? 1 : 0);
                    ft > lr && (Nt && (Dt(zt, lr), Nt = !1), zt = ft)
                } else if (Nt = !0, Gt == te) {
                    var Ir = vt(De, ot, !0), Rn = Me(Ie, De), cn = we(nt, Ir);
                    Be(Rn, cn) || oe.push(V.markText(Rn, cn, {className: st})), De = Ir
                }
            }
            Nt && Dt(zt, De.line + 1)
        }

        function G(V) {
            if (V.showDifferences) {
                if (V.svg) {
                    Ye(V.svg);
                    var $ = V.gap.offsetWidth;
                    Oe(V.svg, "width", $, "height", V.gap.offsetHeight)
                }
                V.copyButtons && Ye(V.copyButtons);
                for (var te = V.edit.getViewport(), oe = V.orig.getViewport(), de = V.mv.wrap.getBoundingClientRect().top, he = de - V.edit.getScrollerElement().getBoundingClientRect().top + V.edit.getScrollInfo().top, Ae = de - V.orig.getScrollerElement().getBoundingClientRect().top + V.orig.getScrollInfo().top, De = 0; De < V.chunks.length; De++) {
                    var Ie = V.chunks[De];
                    Ie.editFrom <= te.to && Ie.editTo >= te.from && Ie.origFrom <= oe.to && Ie.origTo >= oe.from && ue(V, Ie, Ae, he, $)
                }
            }
        }

        function Z(V, $) {
            for (var te = 0, oe = 0, de = 0; de < $.length; de++) {
                var he = $[de];
                if (he.editTo > V && he.editFrom <= V) return null;
                if (he.editFrom > V) break;
                te = he.editTo, oe = he.origTo
            }
            return oe + (V - te)
        }

        function Y(V, $, te) {
            for (var oe = V.state.trackAlignable, de = V.firstLine(), he = 0, Ae = [], De = 0; ; De++) {
                for (var Ie = $[De], nt = Ie ? te ? Ie.origFrom : Ie.editFrom : 1e9; he < oe.alignable.length; he += 2) {
                    var st = oe.alignable[he] + 1;
                    if (!(st <= de)) if (st <= nt) Ae.push(st); else break
                }
                if (!Ie) break;
                Ae.push(de = te ? Ie.origTo : Ie.editTo)
            }
            return Ae
        }

        function ce(V, $, te, oe) {
            var de = 0, he = 0, Ae = 0, De = 0;
            e:for (; ; de++) {
                var Ie = V[de], nt = $[he];
                if (!Ie && nt == null) break;
                for (var st = Ie ? Ie[0] : 1e9, Dt = nt ?? 1e9; Ae < te.length;) {
                    var zt = te[Ae];
                    if (zt.origFrom <= Dt && zt.origTo > Dt) {
                        he++, de--;
                        continue e
                    }
                    if (zt.editTo > st) {
                        if (zt.editFrom <= st) continue e;
                        break
                    }
                    De += zt.origTo - zt.origFrom - (zt.editTo - zt.editFrom), Ae++
                }
                if (st == Dt - De) Ie[oe] = Dt, he++; else if (st < Dt - De) Ie[oe] = st + De; else {
                    var Nt = [Dt - De, null, null];
                    Nt[oe] = Dt, V.splice(de, 0, Nt), he++
                }
            }
        }

        function Ce(V, $) {
            var te = Y(V.edit, V.chunks, !1), oe = [];
            if ($) for (var de = 0, he = 0; de < $.chunks.length; de++) {
                for (var Ae = $.chunks[de].editTo; he < te.length && te[he] < Ae;) he++;
                (he == te.length || te[he] != Ae) && te.splice(he++, 0, Ae)
            }
            for (var de = 0; de < te.length; de++) oe.push([te[de], null, null]);
            return ce(oe, Y(V.orig, V.chunks, !0), V.chunks, 1), $ && ce(oe, Y($.orig, $.chunks, !0), $.chunks, 2), oe
        }

        function me(V, $) {
            if (!(!V.dealigned && !$)) {
                if (!V.orig.curOp) return V.orig.operation(function () {
                    me(V, $)
                });
                V.dealigned = !1;
                var te = V.mv.left == V ? V.mv.right : V.mv.left;
                te && (A(te), te.dealigned = !1);
                for (var oe = Ce(V, te), de = V.mv.aligners, he = 0; he < de.length; he++) de[he].clear();
                de.length = 0;
                var Ae = [V.edit, V.orig], De = [], Ie = [];
                te && Ae.push(te.orig);
                for (var he = 0; he < Ae.length; he++) De.push(Ae[he].getScrollInfo().top), Ie.push(-Ae[he].getScrollerElement().getBoundingClientRect().top);
                (Ie[0] != Ie[1] || Ae.length == 3 && Ie[1] != Ie[2]) && R(Ae, Ie, [0, 0, 0], de);
                for (var nt = 0; nt < oe.length; nt++) R(Ae, Ie, oe[nt], de);
                for (var he = 0; he < Ae.length; he++) Ae[he].scrollTo(null, De[he])
            }
        }

        function R(V, $, te, oe) {
            for (var de = -1e8, he = [], Ae = 0; Ae < V.length; Ae++) if (te[Ae] != null) {
                var De = V[Ae].heightAtLine(te[Ae], "local") - $[Ae];
                he[Ae] = De, de = Math.max(de, De)
            }
            for (var Ae = 0; Ae < V.length; Ae++) if (te[Ae] != null) {
                var Ie = de - he[Ae];
                Ie > 1 && oe.push(ae(V[Ae], te[Ae], Ie))
            }
        }

        function ae(V, $, te) {
            var oe = !0;
            $ > V.lastLine() && ($--, oe = !1);
            var de = document.createElement("div");
            return de.className = "CodeMirror-merge-spacer", de.style.height = te + "px", de.style.minWidth = "1px", V.addLineWidget($, de, {
                height: te,
                above: oe,
                mergeSpacer: !0,
                handleMouseEvents: !0
            })
        }

        function ue(V, $, te, oe, de) {
            var he = V.type == "left", Ae = V.orig.heightAtLine($.origFrom, "local", !0) - te;
            if (V.svg) {
                var De = Ae, Ie = V.edit.heightAtLine($.editFrom, "local", !0) - oe;
                if (he) {
                    var nt = De;
                    De = Ie, Ie = nt
                }
                var st = V.orig.heightAtLine($.origTo, "local", !0) - te,
                    Dt = V.edit.heightAtLine($.editTo, "local", !0) - oe;
                if (he) {
                    var nt = st;
                    st = Dt, Dt = nt
                }
                var zt = " C " + de / 2 + " " + Ie + " " + de / 2 + " " + De + " " + (de + 2) + " " + De,
                    Nt = " C " + de / 2 + " " + st + " " + de / 2 + " " + Dt + " -1 " + Dt;
                Oe(V.svg.appendChild(document.createElementNS(C, "path")), "d", "M -1 " + Ie + zt + " L " + (de + 2) + " " + st + Nt + " z", "class", V.classes.connect)
            }
            if (V.copyButtons) {
                var $t = V.copyButtons.appendChild(mt("div", V.type == "left" ? "⇝" : "⇜", "CodeMirror-merge-copy")),
                    Ot = V.mv.options.allowEditingOriginals;
                if ($t.title = V.edit.phrase(Ot ? "Push to left" : "Revert chunk"), $t.chunk = $, $t.style.top = ($.origTo > $.origFrom ? Ae : V.edit.heightAtLine($.editFrom, "local") - oe) + "px", $t.setAttribute("role", "button"), $t.setAttribute("tabindex", "0"), $t.setAttribute("aria-label", $t.title), Ot) {
                    var Gt = V.edit.heightAtLine($.editFrom, "local") - oe,
                        ot = V.copyButtons.appendChild(mt("div", V.type == "right" ? "⇝" : "⇜", "CodeMirror-merge-copy-reverse"));
                    ot.title = "Push to right", ot.chunk = {
                        editFrom: $.origFrom,
                        editTo: $.origTo,
                        origFrom: $.editFrom,
                        origTo: $.editTo
                    }, ot.style.top = Gt + "px", V.type == "right" ? ot.style.left = "2px" : ot.style.right = "2px", ot.setAttribute("role", "button"), ot.setAttribute("tabindex", "0"), ot.setAttribute("aria-label", ot.title)
                }
            }
        }

        function ve(V, $, te, oe) {
            if (!V.diffOutOfDate) {
                var de = oe.origTo > te.lastLine() ? b(oe.origFrom - 1) : b(oe.origFrom, 0), he = b(oe.origTo, 0),
                    Ae = oe.editTo > $.lastLine() ? b(oe.editFrom - 1) : b(oe.editFrom, 0), De = b(oe.editTo, 0),
                    Ie = V.mv.options.revertChunk;
                Ie ? Ie(V.mv, te, de, he, $, Ae, De) : $.replaceRange(te.getRange(de, he), Ae, De)
            }
        }

        var ke = h.MergeView = function (V, $) {
            if (!(this instanceof ke)) return new ke(V, $);
            this.options = $;
            var te = $.origLeft, oe = $.origRight == null ? $.orig : $.origRight, de = te != null, he = oe != null,
                Ae = 1 + (de ? 1 : 0) + (he ? 1 : 0), De = [], Ie = this.left = null, nt = this.right = null, st = this;
            if (de) {
                Ie = this.left = new k(this, "left");
                var Dt = mt("div", null, "CodeMirror-merge-pane CodeMirror-merge-left");
                De.push(Dt), De.push(le(Ie))
            }
            var zt = mt("div", null, "CodeMirror-merge-pane CodeMirror-merge-editor");
            if (De.push(zt), he) {
                nt = this.right = new k(this, "right"), De.push(le(nt));
                var Nt = mt("div", null, "CodeMirror-merge-pane CodeMirror-merge-right");
                De.push(Nt)
            }
            (he ? Nt : zt).className += " CodeMirror-merge-pane-rightmost", De.push(mt("div", null, null, "height: 0; clear: both;"));
            var $t = this.wrap = V.appendChild(mt("div", De, "CodeMirror-merge CodeMirror-merge-" + Ae + "pane"));
            this.edit = h(zt, ht($)), Ie && Ie.init(Dt, te, $), nt && nt.init(Nt, oe, $), $.collapseIdentical && this.editor().operation(function () {
                At(st, $.collapseIdentical)
            }), $.connect == "align" && (this.aligners = [], me(this.left || this.right, !0)), Ie && Ie.registerEvents(nt), nt && nt.registerEvents(Ie);
            var Ot = function () {
                Ie && G(Ie), nt && G(nt)
            };
            h.on(window, "resize", Ot);
            var Gt = setInterval(function () {
                for (var ot = $t.parentNode; ot && ot != document.body; ot = ot.parentNode) ;
                ot || (clearInterval(Gt), h.off(window, "resize", Ot))
            }, 5e3)
        };

        function le(V) {
            var $ = V.lockButton = mt("div", null, "CodeMirror-merge-scrolllock");
            $.setAttribute("role", "button"), $.setAttribute("tabindex", "0");
            var te = mt("div", [$], "CodeMirror-merge-scrolllock-wrap");
            h.on($, "click", function () {
                D(V, !V.lockScroll)
            }), h.on($, "keyup", function (Ae) {
                (Ae.key === "Enter" || Ae.code === "Space") && D(V, !V.lockScroll)
            });
            var oe = [te];
            if (V.mv.options.revertButtons !== !1) {
                V.copyButtons = mt("div", null, "CodeMirror-merge-copybuttons-" + V.type);
                var de = function (Ae) {
                    var De = Ae.target || Ae.srcElement;
                    if (De.chunk) {
                        if (De.className == "CodeMirror-merge-copy-reverse") {
                            ve(V, V.orig, V.edit, De.chunk);
                            return
                        }
                        ve(V, V.edit, V.orig, De.chunk)
                    }
                };
                h.on(V.copyButtons, "click", de), h.on(V.copyButtons, "keyup", function (Ae) {
                    (Ae.key === "Enter" || Ae.code === "Space") && de(Ae)
                }), oe.unshift(V.copyButtons)
            }
            if (V.mv.options.connect != "align") {
                var he = document.createElementNS && document.createElementNS(C, "svg");
                he && !he.createSVGRect && (he = null), V.svg = he, he && oe.push(he)
            }
            return V.gap = mt("div", oe, "CodeMirror-merge-gap")
        }

        ke.prototype = {
            constructor: ke, editor: function () {
                return this.edit
            }, rightOriginal: function () {
                return this.right && this.right.orig
            }, leftOriginal: function () {
                return this.left && this.left.orig
            }, setShowDifferences: function (V) {
                this.right && this.right.setShowDifferences(V), this.left && this.left.setShowDifferences(V)
            }, rightChunks: function () {
                if (this.right) return A(this.right), this.right.chunks
            }, leftChunks: function () {
                if (this.left) return A(this.left), this.left.chunks
            }
        };

        function ye(V) {
            return typeof V == "string" ? V : V.getValue()
        }

        var ee;

        function qe(V, $, te) {
            ee || (ee = new diff_match_patch);
            for (var oe = ee.diff_main(V, $), de = 0; de < oe.length; ++de) {
                var he = oe[de];
                (te ? !/[^ \t]/.test(he[1]) : !he[1]) ? oe.splice(de--, 1) : de && oe[de - 1][0] == he[0] && (oe.splice(de--, 1), oe[de][1] += he[1])
            }
            return oe
        }

        function Ze(V) {
            var $ = [];
            if (!V.length) return $;
            for (var te = 0, oe = 0, de = b(0, 0), he = b(0, 0), Ae = 0; Ae < V.length; ++Ae) {
                var De = V[Ae], Ie = De[0];
                if (Ie == DIFF_EQUAL) {
                    var nt = !Le(V, Ae) || de.line < te || he.line < oe ? 1 : 0, st = de.line + nt, Dt = he.line + nt;
                    vt(de, De[1], null, he);
                    var zt = Xe(V, Ae) ? 1 : 0, Nt = de.line + zt, $t = he.line + zt;
                    Nt > st && (Ae && $.push({origFrom: oe, origTo: Dt, editFrom: te, editTo: st}), te = Nt, oe = $t)
                } else vt(Ie == DIFF_INSERT ? de : he, De[1])
            }
            return (te <= de.line || oe <= he.line) && $.push({
                origFrom: oe,
                origTo: he.line + 1,
                editFrom: te,
                editTo: de.line + 1
            }), $
        }

        function Xe(V, $) {
            if ($ == V.length - 1) return !0;
            var te = V[$ + 1][1];
            return te.length == 1 && $ < V.length - 2 || te.charCodeAt(0) != 10 ? !1 : $ == V.length - 2 ? !0 : (te = V[$ + 2][1], (te.length > 1 || $ == V.length - 3) && te.charCodeAt(0) == 10)
        }

        function Le(V, $) {
            if ($ == 0) return !0;
            var te = V[$ - 1][1];
            return te.charCodeAt(te.length - 1) != 10 ? !1 : $ == 1 ? !0 : (te = V[$ - 2][1], te.charCodeAt(te.length - 1) == 10)
        }

        function it(V, $, te) {
            for (var oe, de, he, Ae, De = 0; De < V.length; De++) {
                var Ie = V[De], nt = te ? Ie.editFrom : Ie.origFrom, st = te ? Ie.editTo : Ie.origTo;
                de == null && (nt > $ ? (de = Ie.editFrom, Ae = Ie.origFrom) : st > $ && (de = Ie.editTo, Ae = Ie.origTo)), st <= $ ? (oe = Ie.editTo, he = Ie.origTo) : nt <= $ && (oe = Ie.editFrom, he = Ie.origFrom)
            }
            return {edit: {before: oe, after: de}, orig: {before: he, after: Ae}}
        }

        function _t(V, $, te) {
            V.addLineClass($, "wrap", "CodeMirror-merge-collapsed-line");
            var oe = document.createElement("span");
            oe.className = "CodeMirror-merge-collapsed-widget", oe.title = V.phrase("Identical text collapsed. Click to expand.");
            var de = V.markText(b($, 0), b(te - 1), {
                inclusiveLeft: !0,
                inclusiveRight: !0,
                replacedWith: oe,
                clearOnEnter: !0
            });

            function he() {
                de.clear(), V.removeLineClass($, "wrap", "CodeMirror-merge-collapsed-line")
            }

            return de.explicitlyCleared && he(), h.on(oe, "click", he), de.on("clear", he), h.on(oe, "click", he), {
                mark: de,
                clear: he
            }
        }

        function Tt(V, $) {
            var te = [];

            function oe() {
                for (var De = 0; De < te.length; De++) te[De].clear()
            }

            for (var de = 0; de < $.length; de++) {
                var he = $[de], Ae = _t(he.cm, he.line, he.line + V);
                te.push(Ae), Ae.mark.on("clear", oe)
            }
            return te[0].mark
        }

        function Pe(V, $, te, oe) {
            for (var de = 0; de < V.chunks.length; de++) for (var he = V.chunks[de], Ae = he.editFrom - $; Ae < he.editTo + $; Ae++) {
                var De = Ae + te;
                De >= 0 && De < oe.length && (oe[De] = !1)
            }
        }

        function At(V, $) {
            typeof $ != "number" && ($ = 2);
            for (var te = [], oe = V.editor(), de = oe.firstLine(), he = de, Ae = oe.lastLine(); he <= Ae; he++) te.push(!0);
            V.left && Pe(V.left, $, de, te), V.right && Pe(V.right, $, de, te);
            for (var De = 0; De < te.length; De++) if (te[De]) {
                for (var Ie = De + de, nt = 1; De < te.length - 1 && te[De + 1]; De++, nt++) ;
                if (nt > $) {
                    var st = [{line: Ie, cm: oe}];
                    V.left && st.push({
                        line: Z(Ie, V.left.chunks),
                        cm: V.left.orig
                    }), V.right && st.push({line: Z(Ie, V.right.chunks), cm: V.right.orig});
                    var Dt = Tt(nt, st);
                    V.options.onCollapse && V.options.onCollapse(V, Ie, nt, Dt)
                }
            }
        }

        function mt(V, $, te, oe) {
            var de = document.createElement(V);
            if (te && (de.className = te), oe && (de.style.cssText = oe), typeof $ == "string") de.appendChild(document.createTextNode($)); else if ($) for (var he = 0; he < $.length; ++he) de.appendChild($[he]);
            return de
        }

        function Ye(V) {
            for (var $ = V.childNodes.length; $ > 0; --$) V.removeChild(V.firstChild)
        }

        function Oe(V) {
            for (var $ = 1; $ < arguments.length; $ += 2) V.setAttribute(arguments[$], arguments[$ + 1])
        }

        function ht(V, $) {
            $ || ($ = {});
            for (var te in V) V.hasOwnProperty(te) && ($[te] = V[te]);
            return $
        }

        function vt(V, $, te, oe) {
            for (var de = te ? b(V.line, V.ch) : V, he = 0; ;) {
                var Ae = $.indexOf(`
`, he);
                if (Ae == -1) break;
                ++de.line, oe && ++oe.line, he = Ae + 1
            }
            return de.ch = (he ? 0 : de.ch) + ($.length - he), oe && (oe.ch = (he ? 0 : oe.ch) + ($.length - he)), de
        }

        var Vt = 1, ct = 2, se = 4;

        function ge(V) {
            this.cm = V, this.alignable = [], this.height = V.doc.height;
            var $ = this;
            V.on("markerAdded", function (te, oe) {
                if (oe.collapsed) {
                    var de = oe.find(1);
                    de != null && $.set(de.line, se)
                }
            }), V.on("markerCleared", function (te, oe, de, he) {
                he != null && oe.collapsed && $.check(he, se, $.hasMarker)
            }), V.on("markerChanged", this.signal.bind(this)), V.on("lineWidgetAdded", function (te, oe, de) {
                oe.mergeSpacer || (oe.above ? $.set(de - 1, ct) : $.set(de, Vt))
            }), V.on("lineWidgetCleared", function (te, oe, de) {
                oe.mergeSpacer || (oe.above ? $.check(de - 1, ct, $.hasWidgetBelow) : $.check(de, Vt, $.hasWidget))
            }), V.on("lineWidgetChanged", this.signal.bind(this)), V.on("change", function (te, oe) {
                var de = oe.from.line, he = oe.to.line - oe.from.line, Ae = oe.text.length - 1, De = de + Ae;
                (he || Ae) && $.map(de, he, Ae), $.check(De, se, $.hasMarker), (he || Ae) && $.check(oe.from.line, se, $.hasMarker)
            }), V.on("viewportChange", function () {
                $.cm.doc.height != $.height && $.signal()
            })
        }

        ge.prototype = {
            signal: function () {
                h.signal(this, "realign"), this.height = this.cm.doc.height
            }, set: function (V, $) {
                for (var te = -1; te < this.alignable.length; te += 2) {
                    var oe = this.alignable[te] - V;
                    if (oe == 0) {
                        if ((this.alignable[te + 1] & $) == $) return;
                        this.alignable[te + 1] |= $, this.signal();
                        return
                    }
                    if (oe > 0) break
                }
                this.signal(), this.alignable.splice(te, 0, V, $)
            }, find: function (V) {
                for (var $ = 0; $ < this.alignable.length; $ += 2) if (this.alignable[$] == V) return $;
                return -1
            }, check: function (V, $, te) {
                var oe = this.find(V);
                if (!(oe == -1 || !(this.alignable[oe + 1] & $)) && !te.call(this, V)) {
                    this.signal();
                    var de = this.alignable[oe + 1] & ~$;
                    de ? this.alignable[oe + 1] = de : this.alignable.splice(oe, 2)
                }
            }, hasMarker: function (V) {
                var $ = this.cm.getLineHandle(V);
                if ($.markedSpans) {
                    for (var te = 0; te < $.markedSpans.length; te++) if ($.markedSpans[te].marker.collapsed && $.markedSpans[te].to != null) return !0
                }
                return !1
            }, hasWidget: function (V) {
                var $ = this.cm.getLineHandle(V);
                if ($.widgets) {
                    for (var te = 0; te < $.widgets.length; te++) if (!$.widgets[te].above && !$.widgets[te].mergeSpacer) return !0
                }
                return !1
            }, hasWidgetBelow: function (V) {
                if (V == this.cm.lastLine()) return !1;
                var $ = this.cm.getLineHandle(V + 1);
                if ($.widgets) {
                    for (var te = 0; te < $.widgets.length; te++) if ($.widgets[te].above && !$.widgets[te].mergeSpacer) return !0
                }
                return !1
            }, map: function (V, $, te) {
                for (var oe = te - $, de = V + $, he = -1, Ae = -1, De = 0; De < this.alignable.length; De += 2) {
                    var Ie = this.alignable[De];
                    Ie == V && this.alignable[De + 1] & ct && (he = De), Ie == de && this.alignable[De + 1] & ct && (Ae = De), !(Ie <= V) && (Ie < de ? this.alignable.splice(De--, 2) : this.alignable[De] += oe)
                }
                if (he > -1) {
                    var nt = this.alignable[he + 1];
                    nt == ct ? this.alignable.splice(he, 2) : this.alignable[he + 1] = nt & ~ct
                }
                Ae > -1 && te && this.set(V + te, ct)
            }
        };

        function we(V, $) {
            return (V.line - $.line || V.ch - $.ch) < 0 ? V : $
        }

        function Me(V, $) {
            return (V.line - $.line || V.ch - $.ch) > 0 ? V : $
        }

        function Be(V, $) {
            return V.line == $.line && V.ch == $.ch
        }

        function Ue(V, $, te) {
            for (var oe = V.length - 1; oe >= 0; oe--) {
                var de = V[oe], he = (te ? de.origTo : de.editTo) - 1;
                if (he < $) return he
            }
        }

        function Ge(V, $, te) {
            for (var oe = 0; oe < V.length; oe++) {
                var de = V[oe], he = te ? de.origFrom : de.editFrom;
                if (he > $) return he
            }
        }

        function ze(V, $) {
            var te = null, oe = V.state.diffViews, de = V.getCursor().line;
            if (oe) for (var he = 0; he < oe.length; he++) {
                var Ae = oe[he], De = V == Ae.orig;
                A(Ae);
                var Ie = $ < 0 ? Ue(Ae.chunks, de, De) : Ge(Ae.chunks, de, De);
                Ie != null && (te == null || ($ < 0 ? Ie > te : Ie < te)) && (te = Ie)
            }
            if (te != null) V.setCursor(te, 0); else return h.Pass
        }

        h.commands.goNextDiff = function (V) {
            return ze(V, 1)
        }, h.commands.goPrevDiff = function (V) {
            return ze(V, -1)
        }
    })
})();
var P5 = {exports: {}};
(function (a) {
    var c = function () {
        this.Diff_Timeout = 1, this.Diff_EditCost = 4, this.Match_Threshold = .5, this.Match_Distance = 1e3, this.Patch_DeleteThreshold = .5, this.Patch_Margin = 4, this.Match_MaxBits = 32
    }, h = -1, b = 1, C = 0;
    c.Diff = function (k, A) {
        return [k, A]
    }, c.prototype.diff_main = function (k, A, y, w) {
        typeof w > "u" && (this.Diff_Timeout <= 0 ? w = Number.MAX_VALUE : w = new Date().getTime() + this.Diff_Timeout * 1e3);
        var S = w;
        if (k == null || A == null) throw new Error("Null input. (diff_main)");
        if (k == A) return k ? [new c.Diff(C, k)] : [];
        typeof y > "u" && (y = !0);
        var I = y, T = this.diff_commonPrefix(k, A), D = k.substring(0, T);
        k = k.substring(T), A = A.substring(T), T = this.diff_commonSuffix(k, A);
        var B = k.substring(k.length - T);
        k = k.substring(0, k.length - T), A = A.substring(0, A.length - T);
        var L = this.diff_compute_(k, A, I, S);
        return D && L.unshift(new c.Diff(C, D)), B && L.push(new c.Diff(C, B)), this.diff_cleanupMerge(L), L
    }, c.prototype.diff_compute_ = function (k, A, y, w) {
        var S;
        if (!k) return [new c.Diff(b, A)];
        if (!A) return [new c.Diff(h, k)];
        var I = k.length > A.length ? k : A, T = k.length > A.length ? A : k, D = I.indexOf(T);
        if (D != -1) return S = [new c.Diff(b, I.substring(0, D)), new c.Diff(C, T), new c.Diff(b, I.substring(D + T.length))], k.length > A.length && (S[0][0] = S[2][0] = h), S;
        if (T.length == 1) return [new c.Diff(h, k), new c.Diff(b, A)];
        var B = this.diff_halfMatch_(k, A);
        if (B) {
            var L = B[0], z = B[1], q = B[2], Q = B[3], G = B[4], Z = this.diff_main(L, q, y, w),
                Y = this.diff_main(z, Q, y, w);
            return Z.concat([new c.Diff(C, G)], Y)
        }
        return y && k.length > 100 && A.length > 100 ? this.diff_lineMode_(k, A, w) : this.diff_bisect_(k, A, w)
    }, c.prototype.diff_lineMode_ = function (k, A, y) {
        var w = this.diff_linesToChars_(k, A);
        k = w.chars1, A = w.chars2;
        var S = w.lineArray, I = this.diff_main(k, A, !1, y);
        this.diff_charsToLines_(I, S), this.diff_cleanupSemantic(I), I.push(new c.Diff(C, ""));
        for (var T = 0, D = 0, B = 0, L = "", z = ""; T < I.length;) {
            switch (I[T][0]) {
                case b:
                    B++, z += I[T][1];
                    break;
                case h:
                    D++, L += I[T][1];
                    break;
                case C:
                    if (D >= 1 && B >= 1) {
                        I.splice(T - D - B, D + B), T = T - D - B;
                        for (var q = this.diff_main(L, z, !1, y), Q = q.length - 1; Q >= 0; Q--) I.splice(T, 0, q[Q]);
                        T = T + q.length
                    }
                    B = 0, D = 0, L = "", z = "";
                    break
            }
            T++
        }
        return I.pop(), I
    }, c.prototype.diff_bisect_ = function (k, A, y) {
        for (var w = k.length, S = A.length, I = Math.ceil((w + S) / 2), T = I, D = 2 * I, B = new Array(D), L = new Array(D), z = 0; z < D; z++) B[z] = -1, L[z] = -1;
        B[T + 1] = 0, L[T + 1] = 0;
        for (var q = w - S, Q = q % 2 != 0, G = 0, Z = 0, Y = 0, ce = 0, Ce = 0; Ce < I && !(new Date().getTime() > y); Ce++) {
            for (var me = -Ce + G; me <= Ce - Z; me += 2) {
                var R = T + me, ae;
                me == -Ce || me != Ce && B[R - 1] < B[R + 1] ? ae = B[R + 1] : ae = B[R - 1] + 1;
                for (var ue = ae - me; ae < w && ue < S && k.charAt(ae) == A.charAt(ue);) ae++, ue++;
                if (B[R] = ae, ae > w) Z += 2; else if (ue > S) G += 2; else if (Q) {
                    var ve = T + q - me;
                    if (ve >= 0 && ve < D && L[ve] != -1) {
                        var ke = w - L[ve];
                        if (ae >= ke) return this.diff_bisectSplit_(k, A, ae, ue, y)
                    }
                }
            }
            for (var le = -Ce + Y; le <= Ce - ce; le += 2) {
                var ve = T + le, ke;
                le == -Ce || le != Ce && L[ve - 1] < L[ve + 1] ? ke = L[ve + 1] : ke = L[ve - 1] + 1;
                for (var ye = ke - le; ke < w && ye < S && k.charAt(w - ke - 1) == A.charAt(S - ye - 1);) ke++, ye++;
                if (L[ve] = ke, ke > w) ce += 2; else if (ye > S) Y += 2; else if (!Q) {
                    var R = T + q - le;
                    if (R >= 0 && R < D && B[R] != -1) {
                        var ae = B[R], ue = T + ae - R;
                        if (ke = w - ke, ae >= ke) return this.diff_bisectSplit_(k, A, ae, ue, y)
                    }
                }
            }
        }
        return [new c.Diff(h, k), new c.Diff(b, A)]
    }, c.prototype.diff_bisectSplit_ = function (k, A, y, w, S) {
        var I = k.substring(0, y), T = A.substring(0, w), D = k.substring(y), B = A.substring(w),
            L = this.diff_main(I, T, !1, S), z = this.diff_main(D, B, !1, S);
        return L.concat(z)
    }, c.prototype.diff_linesToChars_ = function (k, A) {
        var y = [], w = {};
        y[0] = "";

        function S(B) {
            for (var L = "", z = 0, q = -1, Q = y.length; q < B.length - 1;) {
                q = B.indexOf(`
`, z), q == -1 && (q = B.length - 1);
                var G = B.substring(z, q + 1);
                (w.hasOwnProperty ? w.hasOwnProperty(G) : w[G] !== void 0) ? L += String.fromCharCode(w[G]) : (Q == I && (G = B.substring(z), q = B.length), L += String.fromCharCode(Q), w[G] = Q, y[Q++] = G), z = q + 1
            }
            return L
        }

        var I = 4e4, T = S(k);
        I = 65535;
        var D = S(A);
        return {chars1: T, chars2: D, lineArray: y}
    }, c.prototype.diff_charsToLines_ = function (k, A) {
        for (var y = 0; y < k.length; y++) {
            for (var w = k[y][1], S = [], I = 0; I < w.length; I++) S[I] = A[w.charCodeAt(I)];
            k[y][1] = S.join("")
        }
    }, c.prototype.diff_commonPrefix = function (k, A) {
        if (!k || !A || k.charAt(0) != A.charAt(0)) return 0;
        for (var y = 0, w = Math.min(k.length, A.length), S = w, I = 0; y < S;) k.substring(I, S) == A.substring(I, S) ? (y = S, I = y) : w = S, S = Math.floor((w - y) / 2 + y);
        return S
    }, c.prototype.diff_commonSuffix = function (k, A) {
        if (!k || !A || k.charAt(k.length - 1) != A.charAt(A.length - 1)) return 0;
        for (var y = 0, w = Math.min(k.length, A.length), S = w, I = 0; y < S;) k.substring(k.length - S, k.length - I) == A.substring(A.length - S, A.length - I) ? (y = S, I = y) : w = S, S = Math.floor((w - y) / 2 + y);
        return S
    }, c.prototype.diff_commonOverlap_ = function (k, A) {
        var y = k.length, w = A.length;
        if (y == 0 || w == 0) return 0;
        y > w ? k = k.substring(y - w) : y < w && (A = A.substring(0, y));
        var S = Math.min(y, w);
        if (k == A) return S;
        for (var I = 0, T = 1; ;) {
            var D = k.substring(S - T), B = A.indexOf(D);
            if (B == -1) return I;
            T += B, (B == 0 || k.substring(S - T) == A.substring(0, T)) && (I = T, T++)
        }
    }, c.prototype.diff_halfMatch_ = function (k, A) {
        if (this.Diff_Timeout <= 0) return null;
        var y = k.length > A.length ? k : A, w = k.length > A.length ? A : k;
        if (y.length < 4 || w.length * 2 < y.length) return null;
        var S = this;

        function I(Z, Y, ce) {
            for (var Ce = Z.substring(ce, ce + Math.floor(Z.length / 4)), me = -1, R = "", ae, ue, ve, ke; (me = Y.indexOf(Ce, me + 1)) != -1;) {
                var le = S.diff_commonPrefix(Z.substring(ce), Y.substring(me)),
                    ye = S.diff_commonSuffix(Z.substring(0, ce), Y.substring(0, me));
                R.length < ye + le && (R = Y.substring(me - ye, me) + Y.substring(me, me + le), ae = Z.substring(0, ce - ye), ue = Z.substring(ce + le), ve = Y.substring(0, me - ye), ke = Y.substring(me + le))
            }
            return R.length * 2 >= Z.length ? [ae, ue, ve, ke, R] : null
        }

        var T = I(y, w, Math.ceil(y.length / 4)), D = I(y, w, Math.ceil(y.length / 2)), B;
        if (!T && !D) return null;
        D ? T ? B = T[4].length > D[4].length ? T : D : B = D : B = T;
        var L, z, q, Q;
        k.length > A.length ? (L = B[0], z = B[1], q = B[2], Q = B[3]) : (q = B[0], Q = B[1], L = B[2], z = B[3]);
        var G = B[4];
        return [L, z, q, Q, G]
    }, c.prototype.diff_cleanupSemantic = function (k) {
        for (var A = !1, y = [], w = 0, S = null, I = 0, T = 0, D = 0, B = 0, L = 0; I < k.length;) k[I][0] == C ? (y[w++] = I, T = B, D = L, B = 0, L = 0, S = k[I][1]) : (k[I][0] == b ? B += k[I][1].length : L += k[I][1].length, S && S.length <= Math.max(T, D) && S.length <= Math.max(B, L) && (k.splice(y[w - 1], 0, new c.Diff(h, S)), k[y[w - 1] + 1][0] = b, w--, w--, I = w > 0 ? y[w - 1] : -1, T = 0, D = 0, B = 0, L = 0, S = null, A = !0)), I++;
        for (A && this.diff_cleanupMerge(k), this.diff_cleanupSemanticLossless(k), I = 1; I < k.length;) {
            if (k[I - 1][0] == h && k[I][0] == b) {
                var z = k[I - 1][1], q = k[I][1], Q = this.diff_commonOverlap_(z, q),
                    G = this.diff_commonOverlap_(q, z);
                Q >= G ? (Q >= z.length / 2 || Q >= q.length / 2) && (k.splice(I, 0, new c.Diff(C, q.substring(0, Q))), k[I - 1][1] = z.substring(0, z.length - Q), k[I + 1][1] = q.substring(Q), I++) : (G >= z.length / 2 || G >= q.length / 2) && (k.splice(I, 0, new c.Diff(C, z.substring(0, G))), k[I - 1][0] = b, k[I - 1][1] = q.substring(0, q.length - G), k[I + 1][0] = h, k[I + 1][1] = z.substring(G), I++), I++
            }
            I++
        }
    }, c.prototype.diff_cleanupSemanticLossless = function (k) {
        function A(G, Z) {
            if (!G || !Z) return 6;
            var Y = G.charAt(G.length - 1), ce = Z.charAt(0), Ce = Y.match(c.nonAlphaNumericRegex_),
                me = ce.match(c.nonAlphaNumericRegex_), R = Ce && Y.match(c.whitespaceRegex_),
                ae = me && ce.match(c.whitespaceRegex_), ue = R && Y.match(c.linebreakRegex_),
                ve = ae && ce.match(c.linebreakRegex_), ke = ue && G.match(c.blanklineEndRegex_),
                le = ve && Z.match(c.blanklineStartRegex_);
            return ke || le ? 5 : ue || ve ? 4 : Ce && !R && ae ? 3 : R || ae ? 2 : Ce || me ? 1 : 0
        }

        for (var y = 1; y < k.length - 1;) {
            if (k[y - 1][0] == C && k[y + 1][0] == C) {
                var w = k[y - 1][1], S = k[y][1], I = k[y + 1][1], T = this.diff_commonSuffix(w, S);
                if (T) {
                    var D = S.substring(S.length - T);
                    w = w.substring(0, w.length - T), S = D + S.substring(0, S.length - T), I = D + I
                }
                for (var B = w, L = S, z = I, q = A(w, S) + A(S, I); S.charAt(0) === I.charAt(0);) {
                    w += S.charAt(0), S = S.substring(1) + I.charAt(0), I = I.substring(1);
                    var Q = A(w, S) + A(S, I);
                    Q >= q && (q = Q, B = w, L = S, z = I)
                }
                k[y - 1][1] != B && (B ? k[y - 1][1] = B : (k.splice(y - 1, 1), y--), k[y][1] = L, z ? k[y + 1][1] = z : (k.splice(y + 1, 1), y--))
            }
            y++
        }
    }, c.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/, c.whitespaceRegex_ = /\s/, c.linebreakRegex_ = /[\r\n]/, c.blanklineEndRegex_ = /\n\r?\n$/, c.blanklineStartRegex_ = /^\r?\n\r?\n/, c.prototype.diff_cleanupEfficiency = function (k) {
        for (var A = !1, y = [], w = 0, S = null, I = 0, T = !1, D = !1, B = !1, L = !1; I < k.length;) k[I][0] == C ? (k[I][1].length < this.Diff_EditCost && (B || L) ? (y[w++] = I, T = B, D = L, S = k[I][1]) : (w = 0, S = null), B = L = !1) : (k[I][0] == h ? L = !0 : B = !0, S && (T && D && B && L || S.length < this.Diff_EditCost / 2 && T + D + B + L == 3) && (k.splice(y[w - 1], 0, new c.Diff(h, S)), k[y[w - 1] + 1][0] = b, w--, S = null, T && D ? (B = L = !0, w = 0) : (w--, I = w > 0 ? y[w - 1] : -1, B = L = !1), A = !0)), I++;
        A && this.diff_cleanupMerge(k)
    }, c.prototype.diff_cleanupMerge = function (k) {
        k.push(new c.Diff(C, ""));
        for (var A = 0, y = 0, w = 0, S = "", I = "", T; A < k.length;) switch (k[A][0]) {
            case b:
                w++, I += k[A][1], A++;
                break;
            case h:
                y++, S += k[A][1], A++;
                break;
            case C:
                y + w > 1 ? (y !== 0 && w !== 0 && (T = this.diff_commonPrefix(I, S), T !== 0 && (A - y - w > 0 && k[A - y - w - 1][0] == C ? k[A - y - w - 1][1] += I.substring(0, T) : (k.splice(0, 0, new c.Diff(C, I.substring(0, T))), A++), I = I.substring(T), S = S.substring(T)), T = this.diff_commonSuffix(I, S), T !== 0 && (k[A][1] = I.substring(I.length - T) + k[A][1], I = I.substring(0, I.length - T), S = S.substring(0, S.length - T))), A -= y + w, k.splice(A, y + w), S.length && (k.splice(A, 0, new c.Diff(h, S)), A++), I.length && (k.splice(A, 0, new c.Diff(b, I)), A++), A++) : A !== 0 && k[A - 1][0] == C ? (k[A - 1][1] += k[A][1], k.splice(A, 1)) : A++, w = 0, y = 0, S = "", I = "";
                break
        }
        k[k.length - 1][1] === "" && k.pop();
        var D = !1;
        for (A = 1; A < k.length - 1;) k[A - 1][0] == C && k[A + 1][0] == C && (k[A][1].substring(k[A][1].length - k[A - 1][1].length) == k[A - 1][1] ? (k[A][1] = k[A - 1][1] + k[A][1].substring(0, k[A][1].length - k[A - 1][1].length), k[A + 1][1] = k[A - 1][1] + k[A + 1][1], k.splice(A - 1, 1), D = !0) : k[A][1].substring(0, k[A + 1][1].length) == k[A + 1][1] && (k[A - 1][1] += k[A + 1][1], k[A][1] = k[A][1].substring(k[A + 1][1].length) + k[A + 1][1], k.splice(A + 1, 1), D = !0)), A++;
        D && this.diff_cleanupMerge(k)
    }, c.prototype.diff_xIndex = function (k, A) {
        var y = 0, w = 0, S = 0, I = 0, T;
        for (T = 0; T < k.length && (k[T][0] !== b && (y += k[T][1].length), k[T][0] !== h && (w += k[T][1].length), !(y > A)); T++) S = y, I = w;
        return k.length != T && k[T][0] === h ? I : I + (A - S)
    }, c.prototype.diff_prettyHtml = function (k) {
        for (var A = [], y = /&/g, w = /</g, S = />/g, I = /\n/g, T = 0; T < k.length; T++) {
            var D = k[T][0], B = k[T][1],
                L = B.replace(y, "&amp;").replace(w, "&lt;").replace(S, "&gt;").replace(I, "&para;<br>");
            switch (D) {
                case b:
                    A[T] = '<ins style="background:#e6ffe6;">' + L + "</ins>";
                    break;
                case h:
                    A[T] = '<del style="background:#ffe6e6;">' + L + "</del>";
                    break;
                case C:
                    A[T] = "<span>" + L + "</span>";
                    break
            }
        }
        return A.join("")
    }, c.prototype.diff_text1 = function (k) {
        for (var A = [], y = 0; y < k.length; y++) k[y][0] !== b && (A[y] = k[y][1]);
        return A.join("")
    }, c.prototype.diff_text2 = function (k) {
        for (var A = [], y = 0; y < k.length; y++) k[y][0] !== h && (A[y] = k[y][1]);
        return A.join("")
    }, c.prototype.diff_levenshtein = function (k) {
        for (var A = 0, y = 0, w = 0, S = 0; S < k.length; S++) {
            var I = k[S][0], T = k[S][1];
            switch (I) {
                case b:
                    y += T.length;
                    break;
                case h:
                    w += T.length;
                    break;
                case C:
                    A += Math.max(y, w), y = 0, w = 0;
                    break
            }
        }
        return A += Math.max(y, w), A
    }, c.prototype.diff_toDelta = function (k) {
        for (var A = [], y = 0; y < k.length; y++) switch (k[y][0]) {
            case b:
                A[y] = "+" + encodeURI(k[y][1]);
                break;
            case h:
                A[y] = "-" + k[y][1].length;
                break;
            case C:
                A[y] = "=" + k[y][1].length;
                break
        }
        return A.join("	").replace(/%20/g, " ")
    }, c.prototype.diff_fromDelta = function (k, A) {
        for (var y = [], w = 0, S = 0, I = A.split(/\t/g), T = 0; T < I.length; T++) {
            var D = I[T].substring(1);
            switch (I[T].charAt(0)) {
                case"+":
                    try {
                        y[w++] = new c.Diff(b, decodeURI(D))
                    } catch {
                        throw new Error("Illegal escape in diff_fromDelta: " + D)
                    }
                    break;
                case"-":
                case"=":
                    var B = parseInt(D, 10);
                    if (isNaN(B) || B < 0) throw new Error("Invalid number in diff_fromDelta: " + D);
                    var L = k.substring(S, S += B);
                    I[T].charAt(0) == "=" ? y[w++] = new c.Diff(C, L) : y[w++] = new c.Diff(h, L);
                    break;
                default:
                    if (I[T]) throw new Error("Invalid diff operation in diff_fromDelta: " + I[T])
            }
        }
        if (S != k.length) throw new Error("Delta length (" + S + ") does not equal source text length (" + k.length + ").");
        return y
    }, c.prototype.match_main = function (k, A, y) {
        if (k == null || A == null || y == null) throw new Error("Null input. (match_main)");
        return y = Math.max(0, Math.min(y, k.length)), k == A ? 0 : k.length ? k.substring(y, y + A.length) == A ? y : this.match_bitap_(k, A, y) : -1
    }, c.prototype.match_bitap_ = function (k, A, y) {
        if (A.length > this.Match_MaxBits) throw new Error("Pattern too long for this browser.");
        var w = this.match_alphabet_(A), S = this;

        function I(ae, ue) {
            var ve = ae / A.length, ke = Math.abs(y - ue);
            return S.Match_Distance ? ve + ke / S.Match_Distance : ke ? 1 : ve
        }

        var T = this.Match_Threshold, D = k.indexOf(A, y);
        D != -1 && (T = Math.min(I(0, D), T), D = k.lastIndexOf(A, y + A.length), D != -1 && (T = Math.min(I(0, D), T)));
        var B = 1 << A.length - 1;
        D = -1;
        for (var L, z, q = A.length + k.length, Q, G = 0; G < A.length; G++) {
            for (L = 0, z = q; L < z;) I(G, y + z) <= T ? L = z : q = z, z = Math.floor((q - L) / 2 + L);
            q = z;
            var Z = Math.max(1, y - z + 1), Y = Math.min(y + z, k.length) + A.length, ce = Array(Y + 2);
            ce[Y + 1] = (1 << G) - 1;
            for (var Ce = Y; Ce >= Z; Ce--) {
                var me = w[k.charAt(Ce - 1)];
                if (G === 0 ? ce[Ce] = (ce[Ce + 1] << 1 | 1) & me : ce[Ce] = (ce[Ce + 1] << 1 | 1) & me | ((Q[Ce + 1] | Q[Ce]) << 1 | 1) | Q[Ce + 1], ce[Ce] & B) {
                    var R = I(G, Ce - 1);
                    if (R <= T) if (T = R, D = Ce - 1, D > y) Z = Math.max(1, 2 * y - D); else break
                }
            }
            if (I(G + 1, y) > T) break;
            Q = ce
        }
        return D
    }, c.prototype.match_alphabet_ = function (k) {
        for (var A = {}, y = 0; y < k.length; y++) A[k.charAt(y)] = 0;
        for (var y = 0; y < k.length; y++) A[k.charAt(y)] |= 1 << k.length - y - 1;
        return A
    }, c.prototype.patch_addContext_ = function (k, A) {
        if (A.length != 0) {
            if (k.start2 === null) throw Error("patch not initialized");
            for (var y = A.substring(k.start2, k.start2 + k.length1), w = 0; A.indexOf(y) != A.lastIndexOf(y) && y.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin;) w += this.Patch_Margin, y = A.substring(k.start2 - w, k.start2 + k.length1 + w);
            w += this.Patch_Margin;
            var S = A.substring(k.start2 - w, k.start2);
            S && k.diffs.unshift(new c.Diff(C, S));
            var I = A.substring(k.start2 + k.length1, k.start2 + k.length1 + w);
            I && k.diffs.push(new c.Diff(C, I)), k.start1 -= S.length, k.start2 -= S.length, k.length1 += S.length + I.length, k.length2 += S.length + I.length
        }
    }, c.prototype.patch_make = function (k, A, y) {
        var w, S;
        if (typeof k == "string" && typeof A == "string" && typeof y > "u") w = k, S = this.diff_main(w, A, !0), S.length > 2 && (this.diff_cleanupSemantic(S), this.diff_cleanupEfficiency(S)); else if (k && typeof k == "object" && typeof A > "u" && typeof y > "u") S = k, w = this.diff_text1(S); else if (typeof k == "string" && A && typeof A == "object" && typeof y > "u") w = k, S = A; else if (typeof k == "string" && typeof A == "string" && y && typeof y == "object") w = k, S = y; else throw new Error("Unknown call format to patch_make.");
        if (S.length === 0) return [];
        for (var I = [], T = new c.patch_obj, D = 0, B = 0, L = 0, z = w, q = w, Q = 0; Q < S.length; Q++) {
            var G = S[Q][0], Z = S[Q][1];
            switch (!D && G !== C && (T.start1 = B, T.start2 = L), G) {
                case b:
                    T.diffs[D++] = S[Q], T.length2 += Z.length, q = q.substring(0, L) + Z + q.substring(L);
                    break;
                case h:
                    T.length1 += Z.length, T.diffs[D++] = S[Q], q = q.substring(0, L) + q.substring(L + Z.length);
                    break;
                case C:
                    Z.length <= 2 * this.Patch_Margin && D && S.length != Q + 1 ? (T.diffs[D++] = S[Q], T.length1 += Z.length, T.length2 += Z.length) : Z.length >= 2 * this.Patch_Margin && D && (this.patch_addContext_(T, z), I.push(T), T = new c.patch_obj, D = 0, z = q, B = L);
                    break
            }
            G !== b && (B += Z.length), G !== h && (L += Z.length)
        }
        return D && (this.patch_addContext_(T, z), I.push(T)), I
    }, c.prototype.patch_deepCopy = function (k) {
        for (var A = [], y = 0; y < k.length; y++) {
            var w = k[y], S = new c.patch_obj;
            S.diffs = [];
            for (var I = 0; I < w.diffs.length; I++) S.diffs[I] = new c.Diff(w.diffs[I][0], w.diffs[I][1]);
            S.start1 = w.start1, S.start2 = w.start2, S.length1 = w.length1, S.length2 = w.length2, A[y] = S
        }
        return A
    }, c.prototype.patch_apply = function (k, A) {
        if (k.length == 0) return [A, []];
        k = this.patch_deepCopy(k);
        var y = this.patch_addPadding(k);
        A = y + A + y, this.patch_splitMax(k);
        for (var w = 0, S = [], I = 0; I < k.length; I++) {
            var T = k[I].start2 + w, D = this.diff_text1(k[I].diffs), B, L = -1;
            if (D.length > this.Match_MaxBits ? (B = this.match_main(A, D.substring(0, this.Match_MaxBits), T), B != -1 && (L = this.match_main(A, D.substring(D.length - this.Match_MaxBits), T + D.length - this.Match_MaxBits), (L == -1 || B >= L) && (B = -1))) : B = this.match_main(A, D, T), B == -1) S[I] = !1, w -= k[I].length2 - k[I].length1; else {
                S[I] = !0, w = B - T;
                var z;
                if (L == -1 ? z = A.substring(B, B + D.length) : z = A.substring(B, L + this.Match_MaxBits), D == z) A = A.substring(0, B) + this.diff_text2(k[I].diffs) + A.substring(B + D.length); else {
                    var q = this.diff_main(D, z, !1);
                    if (D.length > this.Match_MaxBits && this.diff_levenshtein(q) / D.length > this.Patch_DeleteThreshold) S[I] = !1; else {
                        this.diff_cleanupSemanticLossless(q);
                        for (var Q = 0, G, Z = 0; Z < k[I].diffs.length; Z++) {
                            var Y = k[I].diffs[Z];
                            Y[0] !== C && (G = this.diff_xIndex(q, Q)), Y[0] === b ? A = A.substring(0, B + G) + Y[1] + A.substring(B + G) : Y[0] === h && (A = A.substring(0, B + G) + A.substring(B + this.diff_xIndex(q, Q + Y[1].length))), Y[0] !== h && (Q += Y[1].length)
                        }
                    }
                }
            }
        }
        return A = A.substring(y.length, A.length - y.length), [A, S]
    }, c.prototype.patch_addPadding = function (k) {
        for (var A = this.Patch_Margin, y = "", w = 1; w <= A; w++) y += String.fromCharCode(w);
        for (var w = 0; w < k.length; w++) k[w].start1 += A, k[w].start2 += A;
        var S = k[0], I = S.diffs;
        if (I.length == 0 || I[0][0] != C) I.unshift(new c.Diff(C, y)), S.start1 -= A, S.start2 -= A, S.length1 += A, S.length2 += A; else if (A > I[0][1].length) {
            var T = A - I[0][1].length;
            I[0][1] = y.substring(I[0][1].length) + I[0][1], S.start1 -= T, S.start2 -= T, S.length1 += T, S.length2 += T
        }
        if (S = k[k.length - 1], I = S.diffs, I.length == 0 || I[I.length - 1][0] != C) I.push(new c.Diff(C, y)), S.length1 += A, S.length2 += A; else if (A > I[I.length - 1][1].length) {
            var T = A - I[I.length - 1][1].length;
            I[I.length - 1][1] += y.substring(0, T), S.length1 += T, S.length2 += T
        }
        return y
    }, c.prototype.patch_splitMax = function (k) {
        for (var A = this.Match_MaxBits, y = 0; y < k.length; y++) if (!(k[y].length1 <= A)) {
            var w = k[y];
            k.splice(y--, 1);
            for (var S = w.start1, I = w.start2, T = ""; w.diffs.length !== 0;) {
                var D = new c.patch_obj, B = !0;
                for (D.start1 = S - T.length, D.start2 = I - T.length, T !== "" && (D.length1 = D.length2 = T.length, D.diffs.push(new c.Diff(C, T))); w.diffs.length !== 0 && D.length1 < A - this.Patch_Margin;) {
                    var L = w.diffs[0][0], z = w.diffs[0][1];
                    L === b ? (D.length2 += z.length, I += z.length, D.diffs.push(w.diffs.shift()), B = !1) : L === h && D.diffs.length == 1 && D.diffs[0][0] == C && z.length > 2 * A ? (D.length1 += z.length, S += z.length, B = !1, D.diffs.push(new c.Diff(L, z)), w.diffs.shift()) : (z = z.substring(0, A - D.length1 - this.Patch_Margin), D.length1 += z.length, S += z.length, L === C ? (D.length2 += z.length, I += z.length) : B = !1, D.diffs.push(new c.Diff(L, z)), z == w.diffs[0][1] ? w.diffs.shift() : w.diffs[0][1] = w.diffs[0][1].substring(z.length))
                }
                T = this.diff_text2(D.diffs), T = T.substring(T.length - this.Patch_Margin);
                var q = this.diff_text1(w.diffs).substring(0, this.Patch_Margin);
                q !== "" && (D.length1 += q.length, D.length2 += q.length, D.diffs.length !== 0 && D.diffs[D.diffs.length - 1][0] === C ? D.diffs[D.diffs.length - 1][1] += q : D.diffs.push(new c.Diff(C, q))), B || k.splice(++y, 0, D)
            }
        }
    }, c.prototype.patch_toText = function (k) {
        for (var A = [], y = 0; y < k.length; y++) A[y] = k[y];
        return A.join("")
    }, c.prototype.patch_fromText = function (k) {
        var A = [];
        if (!k) return A;
        for (var y = k.split(`
`), w = 0, S = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; w < y.length;) {
            var I = y[w].match(S);
            if (!I) throw new Error("Invalid patch string: " + y[w]);
            var T = new c.patch_obj;
            for (A.push(T), T.start1 = parseInt(I[1], 10), I[2] === "" ? (T.start1--, T.length1 = 1) : I[2] == "0" ? T.length1 = 0 : (T.start1--, T.length1 = parseInt(I[2], 10)), T.start2 = parseInt(I[3], 10), I[4] === "" ? (T.start2--, T.length2 = 1) : I[4] == "0" ? T.length2 = 0 : (T.start2--, T.length2 = parseInt(I[4], 10)), w++; w < y.length;) {
                var D = y[w].charAt(0);
                try {
                    var B = decodeURI(y[w].substring(1))
                } catch {
                    throw new Error("Illegal escape in patch_fromText: " + B)
                }
                if (D == "-") T.diffs.push(new c.Diff(h, B)); else if (D == "+") T.diffs.push(new c.Diff(b, B)); else if (D == " ") T.diffs.push(new c.Diff(C, B)); else {
                    if (D == "@") break;
                    if (D !== "") throw new Error('Invalid patch mode "' + D + '" in: ' + B)
                }
                w++
            }
        }
        return A
    }, c.patch_obj = function () {
        this.diffs = [], this.start1 = null, this.start2 = null, this.length1 = 0, this.length2 = 0
    }, c.patch_obj.prototype.toString = function () {
        var k, A;
        this.length1 === 0 ? k = this.start1 + ",0" : this.length1 == 1 ? k = this.start1 + 1 : k = this.start1 + 1 + "," + this.length1, this.length2 === 0 ? A = this.start2 + ",0" : this.length2 == 1 ? A = this.start2 + 1 : A = this.start2 + 1 + "," + this.length2;
        for (var y = ["@@ -" + k + " +" + A + ` @@
`], w, S = 0; S < this.diffs.length; S++) {
            switch (this.diffs[S][0]) {
                case b:
                    w = "+";
                    break;
                case h:
                    w = "-";
                    break;
                case C:
                    w = " ";
                    break
            }
            y[S + 1] = w + encodeURI(this.diffs[S][1]) + `
`
        }
        return y.join("").replace(/%20/g, " ")
    }, a.exports = c, a.exports.diff_match_patch = c, a.exports.DIFF_DELETE = h, a.exports.DIFF_INSERT = b, a.exports.DIFF_EQUAL = C
})(P5);
var p8 = P5.exports;
const m8 = of(p8);
(function (a, c) {
    (function (h) {
        h(sf)
    })(function (h) {
        h.defineSimpleMode = function (D, B) {
            h.defineMode(D, function (L) {
                return h.simpleMode(L, B)
            })
        }, h.simpleMode = function (D, B) {
            b(B, "start");
            var L = {}, z = B.meta || {}, q = !1;
            for (var Q in B) if (Q != z && B.hasOwnProperty(Q)) for (var G = L[Q] = [], Z = B[Q], Y = 0; Y < Z.length; Y++) {
                var ce = Z[Y];
                G.push(new A(ce, B)), (ce.indent || ce.dedent) && (q = !0)
            }
            var Ce = {
                startState: function () {
                    return {state: "start", pending: null, local: null, localState: null, indent: q ? [] : null}
                }, copyState: function (R) {
                    var ae = {
                        state: R.state,
                        pending: R.pending,
                        local: R.local,
                        localState: null,
                        indent: R.indent && R.indent.slice(0)
                    };
                    R.localState && (ae.localState = h.copyState(R.local.mode, R.localState)), R.stack && (ae.stack = R.stack.slice(0));
                    for (var ue = R.persistentStates; ue; ue = ue.next) ae.persistentStates = {
                        mode: ue.mode,
                        spec: ue.spec,
                        state: ue.state == R.localState ? ae.localState : h.copyState(ue.mode, ue.state),
                        next: ae.persistentStates
                    };
                    return ae
                }, token: y(L, D), innerMode: function (R) {
                    return R.local && {mode: R.local.mode, state: R.localState}
                }, indent: T(L, z)
            };
            if (z) for (var me in z) z.hasOwnProperty(me) && (Ce[me] = z[me]);
            return Ce
        };

        function b(D, B) {
            if (!D.hasOwnProperty(B)) throw new Error("Undefined state " + B + " in simple mode")
        }

        function C(D, B) {
            if (!D) return /(?:)/;
            var L = "";
            return D instanceof RegExp ? (D.ignoreCase && (L = "i"), D.unicode && (L += "u"), D = D.source) : D = String(D), new RegExp((B === !1 ? "" : "^") + "(?:" + D + ")", L)
        }

        function k(D) {
            if (!D) return null;
            if (D.apply) return D;
            if (typeof D == "string") return D.replace(/\./g, " ");
            for (var B = [], L = 0; L < D.length; L++) B.push(D[L] && D[L].replace(/\./g, " "));
            return B
        }

        function A(D, B) {
            (D.next || D.push) && b(B, D.next || D.push), this.regex = C(D.regex), this.token = k(D.token), this.data = D
        }

        function y(D, B) {
            return function (L, z) {
                if (z.pending) {
                    var q = z.pending.shift();
                    return z.pending.length == 0 && (z.pending = null), L.pos += q.text.length, q.token
                }
                if (z.local) if (z.local.end && L.match(z.local.end)) {
                    var Q = z.local.endToken || null;
                    return z.local = z.localState = null, Q
                } else {
                    var Q = z.local.mode.token(L, z.localState), G;
                    return z.local.endScan && (G = z.local.endScan.exec(L.current())) && (L.pos = L.start + G.index), Q
                }
                for (var Z = D[z.state], Y = 0; Y < Z.length; Y++) {
                    var ce = Z[Y], Ce = (!ce.data.sol || L.sol()) && L.match(ce.regex);
                    if (Ce) {
                        ce.data.next ? z.state = ce.data.next : ce.data.push ? ((z.stack || (z.stack = [])).push(z.state), z.state = ce.data.push) : ce.data.pop && z.stack && z.stack.length && (z.state = z.stack.pop()), ce.data.mode && S(B, z, ce.data.mode, ce.token), ce.data.indent && z.indent.push(L.indentation() + B.indentUnit), ce.data.dedent && z.indent.pop();
                        var me = ce.token;
                        if (me && me.apply && (me = me(Ce)), Ce.length > 2 && ce.token && typeof ce.token != "string") {
                            for (var R = 2; R < Ce.length; R++) Ce[R] && (z.pending || (z.pending = [])).push({
                                text: Ce[R],
                                token: ce.token[R - 1]
                            });
                            return L.backUp(Ce[0].length - (Ce[1] ? Ce[1].length : 0)), me[0]
                        } else return me && me.join ? me[0] : me
                    }
                }
                return L.next(), null
            }
        }

        function w(D, B) {
            if (D === B) return !0;
            if (!D || typeof D != "object" || !B || typeof B != "object") return !1;
            var L = 0;
            for (var z in D) if (D.hasOwnProperty(z)) {
                if (!B.hasOwnProperty(z) || !w(D[z], B[z])) return !1;
                L++
            }
            for (var z in B) B.hasOwnProperty(z) && L--;
            return L == 0
        }

        function S(D, B, L, z) {
            var q;
            if (L.persistent) for (var Q = B.persistentStates; Q && !q; Q = Q.next) (L.spec ? w(L.spec, Q.spec) : L.mode == Q.mode) && (q = Q);
            var G = q ? q.mode : L.mode || h.getMode(D, L.spec), Z = q ? q.state : h.startState(G);
            L.persistent && !q && (B.persistentStates = {
                mode: G,
                spec: L.spec,
                state: Z,
                next: B.persistentStates
            }), B.localState = Z, B.local = {
                mode: G,
                end: L.end && C(L.end),
                endScan: L.end && L.forceEnd !== !1 && C(L.end, !1),
                endToken: z && z.join ? z[z.length - 1] : z
            }
        }

        function I(D, B) {
            for (var L = 0; L < B.length; L++) if (B[L] === D) return !0
        }

        function T(D, B) {
            return function (L, z, q) {
                if (L.local && L.local.mode.indent) return L.local.mode.indent(L.localState, z, q);
                if (L.indent == null || L.local || B.dontIndentStates && I(L.state, B.dontIndentStates) > -1) return h.Pass;
                var Q = L.indent.length - 1, G = D[L.state];
                e:for (; ;) {
                    for (var Z = 0; Z < G.length; Z++) {
                        var Y = G[Z];
                        if (Y.data.dedent && Y.data.dedentIfLineStart !== !1) {
                            var ce = Y.regex.exec(z);
                            if (ce && ce[0]) {
                                Q--, (Y.next || Y.push) && (G = D[Y.next || Y.push]), z = z.slice(ce[0].length);
                                continue e
                            }
                        }
                    }
                    break
                }
                return Q < 0 ? 0 : L.indent[Q]
            }
        }
    })
})();
!window.CodeMirror && (window.CodeMirror = L5);
const af = window.CodeMirror || L5, b8 = tl({
    name: "DefaultMode",
    props: {
        name: {type: String, default: `cm-textarea-${+new Date}`},
        value: {type: String, default: ""},
        content: {type: String, default: ""},
        options: {type: Object, default: () => ({})},
        cminstance: {type: Object, default: () => null},
        placeholder: {type: String, default: ""}
    },
    emits: {ready: a => a, "update:cminstance": a => a},
    setup(a, {emit: c}) {
        const h = yt(), b = yt(null), C = () => {
            b.value = Gs(af.fromTextArea(h.value, a.options)), c("update:cminstance", b.value);
            const k = or(() => a.cminstance, A => {
                var y;
                A && ((y = a.cminstance) == null || y.setValue(a.value || a.content)), c("ready", xt(b)), k == null || k()
            }, {deep: !0})
        };
        return Oi(() => {
            C()
        }), {textarea: h, initialize: C}
    }
}), vv = (a, c) => {
    const h = a.__vccOpts || a;
    for (const [b, C] of c) h[b] = C;
    return h
}, k8 = ["name", "placeholder"];

function v8(a, c, h, b, C, k) {
    return He(), tt("textarea", {ref: "textarea", name: a.$props.name, placeholder: a.$props.placeholder}, null, 8, k8)
}

const ID = vv(b8, [["render", v8]]);
window.diff_match_patch = m8;
window.DIFF_DELETE = -1;
window.DIFF_INSERT = 1;
window.DIFF_EQUAL = 0;
const w8 = tl({
    name: "MergeMode",
    props: {options: {type: Object, default: () => ({})}, cminstance: {type: Object, default: () => ({})}},
    emits: ["update:cminstance", "ready"],
    setup(a, {emit: c}) {
        const h = yt(), b = yt(), C = () => {
            h.value = Gs(af.MergeView(b.value, a.options)), c("update:cminstance", h.value), c("ready", h)
        };
        return Oi(() => {
            C()
        }), {mergeView: b, initialize: C}
    }
}), A8 = {ref: "mergeView"};

function C8(a, c, h, b, C, k) {
    return He(), tt("div", A8, null, 512)
}

const _8 = vv(w8, [["render", C8]]);

function y8(a) {
    const c = /#link#(.+)#link#/g, h = [];
    let b;
    for (b = c.exec(a); b;) {
        const C = document.createElement("a"), k = JSON.parse(b[1]), A = Object.entries(k);
        for (const [y, w] of A) C.setAttribute(y, w);
        C.className = "editor_custom_link", C.innerHTML = "logDownload", h.push({
            start: b.index,
            end: b.index + b[0].length,
            node: C
        }), b = c.exec(a)
    }
    return h
}

function D8(a) {
    const c = [];

    function h() {
        const b = /#log<(\w*)>log#((.|\r\n|\n)*?)#log<(\w*)>log#/g;
        let C;
        for (C = b.exec(a); C;) {
            const k = C[0].replace(/\r\n/g, `
`).split(`
`), A = C[2].replace(/\r\n/g, `
`).split(`
`), y = document.createElement("span"), w = C[1];
            y.className = `c-editor--log__${w}`;
            let S = 0;
            for (let I = 0; I < k.length; I++) {
                const T = k[I], D = A[I], B = y.cloneNode(!1);
                B.innerText = D, c.push({
                    start: C.index + S,
                    end: C.index + S + T.length,
                    node: B
                }), S = S + T.length + 1
            }
            C = b.exec(a)
        }
    }

    return h(), c
}

const wp = [{
    regex: /(\[.*?\])([ \t]*)(<error>[ \t])(.+)/,
    token: ["tag", "", "error.strong", "error.strong"],
    sol: !0
}, {
    regex: /(\[.*?\])([ \t]*)(<info>)(.+)(.?)/,
    token: ["tag", "", "bracket", "bracket", "hr"],
    sol: !0
}, {regex: /(\[.*?\])([ \t]*)(<warning>)(.+)(.?)/, token: ["tag", "", "comment", "comment", "hr"], sol: !0}];
af.defineSimpleMode("fclog", {
    start: [...wp, {regex: /.*/, token: "hr"}],
    error: [...wp, {regex: /.*/, token: "error.strong"}],
    info: [...wp, {regex: /.*/, token: "bracket"}],
    warning: [...wp, {regex: /.*\[/, token: "comment"}]
});
af.defineSimpleMode("log", {
    start: [{regex: /^[=]+[^=]*[=]+/, token: "strong"}, {
        regex: /([^\w])([A-Z][\w]*)/,
        token: ["", "string"]
    }, {regex: /(^[A-Z][\w]*)/, token: "string"}]
});
const x8 = tl({
    name: "CodemirrorFclog",
    props: {
        value: {type: String, default: ""},
        name: {type: String, default: `cm-textarea-${+new Date}`},
        options: {type: Object, default: () => ({})},
        cminstance: {type: Object, default: () => ({})},
        placeholder: {type: String, default: ""}
    },
    emits: ["update:cminstance", "ready"],
    setup(a, {emit: c}) {
        const h = yt(), b = yt(null), C = (A = a.cminstance) => {
            A.getAllMarks().forEach(S => S.clear());
            const y = A.getValue(), w = [].concat(y8(y)).concat(D8(y));
            for (let S = 0; S < w.length; S++) {
                const I = w[S];
                A.markText(A.posFromIndex(I.start), A.posFromIndex(I.end), {replacedWith: I.node})
            }
        }, k = () => {
            var A;
            b.value = Gs(af.fromTextArea(h.value, a.options)), c("update:cminstance", xt(b)), (A = b.value) == null || A.on("change", C)
        };
        return or(() => a.cminstance, A => {
            var y;
            A && (C(a.cminstance), (y = a.cminstance) == null || y.setValue(a.value), c("ready", b))
        }, {deep: !0, immediate: !0}), Oi(() => {
            k()
        }), {initialize: k, textarea: h}
    }
}), E8 = ["name", "placeholder"];

function S8(a, c, h, b, C, k) {
    return He(), tt("textarea", {ref: "textarea", name: a.$props.name, placeholder: a.$props.placeholder}, null, 8, E8)
}

const T8 = vv(x8, [["render", S8]]),
    O5 = {"update:value": () => !0, change: (a, c) => ({value: a, cm: c}), input: () => !0, ready: a => a},
    I8 = ["changes", "scroll", "beforeChange", "cursorActivity", "keyHandled", "inputRead", "electricInput", "beforeSelectionChange", "viewportChange", "swapDoc", "gutterClick", "gutterContextMenu", "focus", "blur", "refresh", "optionChange", "scrollCursorIntoView", "update"],
    M8 = () => {
        const a = {};
        return I8.forEach(c => {
            a[c] = (...h) => h
        }), a
    }, B8 = {...O5, ...M8()}, Ik = {mode: "text", theme: "default", lineNumbers: !0, smartIndent: !0, indentUnit: 2};

function N8(a) {
    Promise.resolve().then(() => {
        const c = a.getScrollInfo();
        a.scrollTo(c.left, c.height)
    })
}

const L8 = ({props: a, cminstance: c, emit: h, internalInstance: b, content: C}) => {
    const k = tn(() => {
        var y;
        return a.merge ? (y = xt(c)) == null ? void 0 : y.editor() : xt(c)
    }), A = () => {
        const y = [];
        return Object.keys(b == null ? void 0 : b.vnode.props).forEach(w => {
            if (w.startsWith("on")) {
                const S = w.replace(w[2], w[2].toLowerCase()).slice(2);
                !O5[S] && y.push(S)
            }
        }), y
    };
    return {
        listenerEvents: () => {
            k.value.on("change", w => {
                const S = w.getValue();
                S === C.value && S !== "" || (C.value = S, h("update:value", C.value || ""), h("input", C.value || " "), Promise.resolve().then(() => {
                    h("change", C.value, w)
                }), a.keepCursorInEnd && N8(w))
            });
            const y = {};
            A().filter(w => !y[w] && (y[w] = !0)).forEach(w => {
                k.value.on(w, (...S) => {
                    h(w, ...S)
                })
            })
        }
    }
};

function P8({props: a, cminstance: c, presetRef: h}) {
    const b = yt(null), C = yt(null), k = tn(() => {
        var T;
        return a.merge ? (T = xt(c)) == null ? void 0 : T.editor() : xt(c)
    }), A = () => {
        uc(() => {
            var T;
            (T = k.value) == null || T.refresh()
        })
    }, y = (T = a.width, D = a.height) => {
        var B;
        b.value = String(T).replace("px", ""), C.value = String(D).replace("px", "");
        const L = C.value;
        (B = k.value) == null || B.setSize(b.value, L)
    }, w = () => {
        var T;
        const D = (T = k.value) == null ? void 0 : T.getWrapperElement();
        D == null || D.remove()
    }, S = () => {
        var T, D, B;
        const L = (T = k.value) == null ? void 0 : T.getDoc().getHistory();
        (D = h.value) == null || D.initialize(), w(), (B = k.value) == null || B.getDoc().setHistory(L)
    }, I = () => {
        const T = document.querySelector(".CodeMirror-gutters");
        return (T == null ? void 0 : T.style.left.replace("px", "")) !== "0"
    };
    return {
        reload: S, refresh: A, resize: y, destroy: w, containerHeight: C, reviseStyle: () => {
            if (A(), !I()) return;
            const T = setInterval(() => {
                I() ? A() : clearInterval(T)
            }, 60), D = setTimeout(() => {
                clearInterval(T), clearTimeout(D)
            }, 400)
        }
    }
}

const i0 = tl({
        __name: "index",
        props: {
            value: {type: String, default: ""},
            options: {type: Object, default: () => Ik},
            globalOptions: {type: Object, default: () => Ik},
            placeholder: {type: String, default: ""},
            border: {type: Boolean, default: !1},
            width: {type: [String, Number], default: null},
            height: {type: [String, Number], default: null},
            originalStyle: {type: Boolean, default: !1},
            keepCursorInEnd: {type: Boolean, default: !1},
            merge: {type: Boolean, default: !1},
            name: {type: String, default: ""},
            marker: {type: Function, default: () => null},
            unseenLines: {type: Array, default: () => []}
        },
        emits: B8,
        setup(a, {expose: c, emit: h}) {
            var b, C;
            const k = a;
            typeof Object.assign != "function" && Object.defineProperty(Object, "assign", {
                value(R) {
                    if (R == null) throw new TypeError("Cannot convert undefined or null to object");
                    const ae = Object(R);
                    for (let ue = 1; ue < arguments.length; ue++) {
                        const ve = arguments[ue];
                        if (ve != null) for (const ke in ve) Object.prototype.hasOwnProperty.call(ve, ke) && (ae[ke] = ve[ke])
                    }
                    return ae
                }, writable: !0, configurable: !0
            });
            const A = yt(null), y = yt(""), w = b0(ID), S = yt({...Ik, ...k.globalOptions, ...k.options}), I = co(),
                T = k.name || ((C = (b = I == null ? void 0 : I.parent) == null ? void 0 : b.type) == null ? void 0 : C.name) || void 0,
                D = yt(null), B = tn(() => {
                    var R;
                    return k.merge ? (R = xt(A)) == null ? void 0 : R.editor() : xt(A)
                }), {refresh: L, resize: z, destroy: q, containerHeight: Q, reviseStyle: G} = P8({
                    props: k,
                    cminstance: A,
                    presetRef: D
                }), {listenerEvents: Z} = L8({props: k, cminstance: A, emit: h, internalInstance: I, content: y}), Y = () => {
                    k.unseenLines !== void 0 && k.marker !== void 0 && k.unseenLines.forEach(R => {
                        var ae, ue;
                        const ve = (ae = A.value) == null ? void 0 : ae.lineInfo(R);
                        (ue = A.value) == null || ue.setGutterMarker(R, "breakpoints", ve != null && ve.gutterMarkers ? null : k.marker())
                    })
                }, ce = R => {
                    var ae, ue;
                    const ve = (ae = A.value) == null ? void 0 : ae.getValue();
                    R !== ve && ((ue = A.value) == null || ue.setValue(R), y.value = R, G()), Y()
                }, Ce = () => {
                    Z(), Y(), z(k.width, k.height), h("ready", A.value), or([() => k.width, () => k.height], ([R, ae]) => {
                        z(R, ae)
                    }, {deep: !0})
                }, me = () => {
                    if (k.options.mode === "fclog" || k.options.mode === "log") {
                        w.value = T8;
                        return
                    }
                    if (k.merge) {
                        w.value = _8;
                        return
                    }
                    w.value = ID
                };
            return or(() => k.options, R => {
                var ae;
                for (const ue in k.options) (ae = B.value) == null || ae.setOption(ue, xt(R[ue]))
            }, {deep: !0}), or(() => k.value, R => {
                ce(R)
            }), or(() => k.merge, me, {immediate: !0}), kc(() => {
                q()
            }), c({
                cminstance: A,
                resize: z,
                refresh: L,
                destroy: q
            }), (R, ae) => (He(), tt("div", {
                class: On(["codemirror-container", {
                    merge: R.$props.merge,
                    bordered: R.$props.border || R.$props.merge && !k.originalStyle,
                    "width-auto": !R.$props.width || R.$props.width == "100%",
                    "height-auto": !R.$props.height || R.$props.height == "100%",
                    "original-style": k.originalStyle
                }]), style: bc({height: xt(Q) + "px"})
            }, [(He(), gr(Oh(xt(w)), pm({
                ref_key: "presetRef",
                ref: D,
                cminstance: A.value,
                "onUpdate:cminstance": ae[0] || (ae[0] = ue => A.value = ue),
                style: {height: "100%"}
            }, {
                ...R.$props, ...R.$attrs,
                options: S.value,
                name: xt(T),
                content: y.value
            }, {onReady: Ce}), null, 16, ["cminstance"]))], 6))
        }
    }),
    O8 = (a, c) => (c && c.options && (i0.props.globalOptions.default = () => c.options), a.component((c == null ? void 0 : c.componentName) || "Codemirror", i0), a),
    F8 = O8;

function R8(a, c) {
    c === void 0 && (c = {});
    var h = c.insertAt;
    if (!(!a || typeof document > "u")) {
        var b = document.head || document.getElementsByTagName("head")[0], C = document.createElement("style");
        C.type = "text/css", h === "top" && b.firstChild ? b.insertBefore(C, b.firstChild) : b.appendChild(C), C.styleSheet ? C.styleSheet.cssText = a : C.appendChild(document.createTextNode(a))
    }
}

R8(`.codemirror-container {
  position: relative;
  display: inline-block;
  height: 100%;
  width: fit-content;
  font-size: 12px;
  overflow: hidden;
}
.codemirror-container.bordered {
  border-radius: 4px;
  border: 1px solid #dddddd;
}
.codemirror-container.width-auto {
  width: 100%;
}
.codemirror-container.height-auto {
  height: 100%;
}
.codemirror-container.height-auto .CodeMirror,
.codemirror-container.height-auto .cm-s-default {
  height: 100% !important;
}
.codemirror-container .editor_custom_link {
  cursor: pointer;
  color: #1474f1;
  text-decoration: underline;
}
.codemirror-container .editor_custom_link:hover {
  color: #04b4fa;
}
.codemirror-container:not(.original-style) .CodeMirror-lines .CodeMirror-placeholder.CodeMirror-line-like {
  color: #666;
}
.codemirror-container:not(.original-style) .CodeMirror,
.codemirror-container:not(.original-style) .CodeMirror-merge-pane {
  height: 100%;
  font-family: consolas !important;
}
.codemirror-container:not(.original-style) .CodeMirror-merge,
.codemirror-container:not(.original-style) .CodeMirror-merge-right .CodeMirror {
  height: 100%;
  border: none !important;
}
.codemirror-container:not(.original-style) .c-editor--log__error {
  color: #bb0606;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__info {
  color: #333333;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__warning {
  color: #ee9900;
}
.codemirror-container:not(.original-style) .c-editor--log__success {
  color: #669600;
}
.codemirror-container:not(.original-style) .cm-header,
.codemirror-container:not(.original-style) .cm-strong {
  font-weight: bold;
}
`);
const z8 = {}, j8 = {xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24"},
    V8 = J("path", {d: "m40-120 440-760 440 760H40Zm138-80h604L480-720 178-200Zm302-40q17 0 28.5-11.5T520-280q0-17-11.5-28.5T480-320q-17 0-28.5 11.5T440-280q0 17 11.5 28.5T480-240Zm-40-120h80v-200h-80v200Zm40-100Z"}, null, -1),
    H8 = [V8];

function U8(a, c) {
    return He(), tt("svg", j8, H8)
}

const o0 = Tr(z8, [["render", U8]]);
(function (a, c) {
    (function (h) {
        h(sf)
    })(function (h) {
        h.defineMode("javascript", function (b, C) {
            var k = b.indentUnit, A = C.statementIndent, y = C.jsonld, w = C.json || y, S = C.trackScope !== !1,
                I = C.typescript, T = C.wordCharacters || /[\w$\xa1-\uffff]/, D = function () {
                    function W(tr) {
                        return {type: tr, style: "keyword"}
                    }

                    var re = W("keyword a"), Te = W("keyword b"), je = W("keyword c"), _e = W("keyword d"),
                        Qe = W("operator"), Qt = {type: "atom", style: "atom"};
                    return {
                        if: W("if"),
                        while: re,
                        with: re,
                        else: Te,
                        do: Te,
                        try: Te,
                        finally: Te,
                        return: _e,
                        break: _e,
                        continue: _e,
                        new: W("new"),
                        delete: je,
                        void: je,
                        throw: je,
                        debugger: W("debugger"),
                        var: W("var"),
                        const: W("var"),
                        let: W("var"),
                        function: W("function"),
                        catch: W("catch"),
                        for: W("for"),
                        switch: W("switch"),
                        case: W("case"),
                        default: W("default"),
                        in: Qe,
                        typeof: Qe,
                        instanceof: Qe,
                        true: Qt,
                        false: Qt,
                        null: Qt,
                        undefined: Qt,
                        NaN: Qt,
                        Infinity: Qt,
                        this: W("this"),
                        class: W("class"),
                        super: W("atom"),
                        yield: je,
                        export: W("export"),
                        import: W("import"),
                        extends: je,
                        await: je
                    }
                }(), B = /[+\-*&%=<>!?|~^@]/,
                L = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

            function z(W) {
                for (var re = !1, Te, je = !1; (Te = W.next()) != null;) {
                    if (!re) {
                        if (Te == "/" && !je) return;
                        Te == "[" ? je = !0 : je && Te == "]" && (je = !1)
                    }
                    re = !re && Te == "\\"
                }
            }

            var q, Q;

            function G(W, re, Te) {
                return q = W, Q = Te, re
            }

            function Z(W, re) {
                var Te = W.next();
                if (Te == '"' || Te == "'") return re.tokenize = Y(Te), re.tokenize(W, re);
                if (Te == "." && W.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) return G("number", "number");
                if (Te == "." && W.match("..")) return G("spread", "meta");
                if (/[\[\]{}\(\),;\:\.]/.test(Te)) return G(Te);
                if (Te == "=" && W.eat(">")) return G("=>", "operator");
                if (Te == "0" && W.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) return G("number", "number");
                if (/\d/.test(Te)) return W.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), G("number", "number");
                if (Te == "/") return W.eat("*") ? (re.tokenize = ce, ce(W, re)) : W.eat("/") ? (W.skipToEnd(), G("comment", "comment")) : mr(W, re, 1) ? (z(W), W.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), G("regexp", "string-2")) : (W.eat("="), G("operator", "operator", W.current()));
                if (Te == "`") return re.tokenize = Ce, Ce(W, re);
                if (Te == "#" && W.peek() == "!") return W.skipToEnd(), G("meta", "meta");
                if (Te == "#" && W.eatWhile(T)) return G("variable", "property");
                if (Te == "<" && W.match("!--") || Te == "-" && W.match("->") && !/\S/.test(W.string.slice(0, W.start))) return W.skipToEnd(), G("comment", "comment");
                if (B.test(Te)) return (Te != ">" || !re.lexical || re.lexical.type != ">") && (W.eat("=") ? (Te == "!" || Te == "=") && W.eat("=") : /[<>*+\-|&?]/.test(Te) && (W.eat(Te), Te == ">" && W.eat(Te))), Te == "?" && W.eat(".") ? G(".") : G("operator", "operator", W.current());
                if (T.test(Te)) {
                    W.eatWhile(T);
                    var je = W.current();
                    if (re.lastType != ".") {
                        if (D.propertyIsEnumerable(je)) {
                            var _e = D[je];
                            return G(_e.type, _e.style, je)
                        }
                        if (je == "async" && W.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, !1)) return G("async", "keyword", je)
                    }
                    return G("variable", "variable", je)
                }
            }

            function Y(W) {
                return function (re, Te) {
                    var je = !1, _e;
                    if (y && re.peek() == "@" && re.match(L)) return Te.tokenize = Z, G("jsonld-keyword", "meta");
                    for (; (_e = re.next()) != null && !(_e == W && !je);) je = !je && _e == "\\";
                    return je || (Te.tokenize = Z), G("string", "string")
                }
            }

            function ce(W, re) {
                for (var Te = !1, je; je = W.next();) {
                    if (je == "/" && Te) {
                        re.tokenize = Z;
                        break
                    }
                    Te = je == "*"
                }
                return G("comment", "comment")
            }

            function Ce(W, re) {
                for (var Te = !1, je; (je = W.next()) != null;) {
                    if (!Te && (je == "`" || je == "$" && W.eat("{"))) {
                        re.tokenize = Z;
                        break
                    }
                    Te = !Te && je == "\\"
                }
                return G("quasi", "string-2", W.current())
            }

            var me = "([{}])";

            function R(W, re) {
                re.fatArrowAt && (re.fatArrowAt = null);
                var Te = W.string.indexOf("=>", W.start);
                if (!(Te < 0)) {
                    if (I) {
                        var je = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(W.string.slice(W.start, Te));
                        je && (Te = je.index)
                    }
                    for (var _e = 0, Qe = !1, Qt = Te - 1; Qt >= 0; --Qt) {
                        var tr = W.string.charAt(Qt), Hn = me.indexOf(tr);
                        if (Hn >= 0 && Hn < 3) {
                            if (!_e) {
                                ++Qt;
                                break
                            }
                            if (--_e == 0) {
                                tr == "(" && (Qe = !0);
                                break
                            }
                        } else if (Hn >= 3 && Hn < 6) ++_e; else if (T.test(tr)) Qe = !0; else if (/["'\/`]/.test(tr)) for (; ; --Qt) {
                            if (Qt == 0) return;
                            var as = W.string.charAt(Qt - 1);
                            if (as == tr && W.string.charAt(Qt - 2) != "\\") {
                                Qt--;
                                break
                            }
                        } else if (Qe && !_e) {
                            ++Qt;
                            break
                        }
                    }
                    Qe && !_e && (re.fatArrowAt = Qt)
                }
            }

            var ae = {
                atom: !0,
                number: !0,
                variable: !0,
                string: !0,
                regexp: !0,
                this: !0,
                import: !0,
                "jsonld-keyword": !0
            };

            function ue(W, re, Te, je, _e, Qe) {
                this.indented = W, this.column = re, this.type = Te, this.prev = _e, this.info = Qe, je != null && (this.align = je)
            }

            function ve(W, re) {
                if (!S) return !1;
                for (var Te = W.localVars; Te; Te = Te.next) if (Te.name == re) return !0;
                for (var je = W.context; je; je = je.prev) for (var Te = je.vars; Te; Te = Te.next) if (Te.name == re) return !0
            }

            function ke(W, re, Te, je, _e) {
                var Qe = W.cc;
                for (le.state = W, le.stream = _e, le.marked = null, le.cc = Qe, le.style = re, W.lexical.hasOwnProperty("align") || (W.lexical.align = !0); ;) {
                    var Qt = Qe.length ? Qe.pop() : w ? ct : vt;
                    if (Qt(Te, je)) {
                        for (; Qe.length && Qe[Qe.length - 1].lex;) Qe.pop()();
                        return le.marked ? le.marked : Te == "variable" && ve(W, je) ? "variable-2" : re
                    }
                }
            }

            var le = {state: null, column: null, marked: null, cc: null};

            function ye() {
                for (var W = arguments.length - 1; W >= 0; W--) le.cc.push(arguments[W])
            }

            function ee() {
                return ye.apply(null, arguments), !0
            }

            function qe(W, re) {
                for (var Te = re; Te; Te = Te.next) if (Te.name == W) return !0;
                return !1
            }

            function Ze(W) {
                var re = le.state;
                if (le.marked = "def", !!S) {
                    if (re.context) {
                        if (re.lexical.info == "var" && re.context && re.context.block) {
                            var Te = Xe(W, re.context);
                            if (Te != null) {
                                re.context = Te;
                                return
                            }
                        } else if (!qe(W, re.localVars)) {
                            re.localVars = new _t(W, re.localVars);
                            return
                        }
                    }
                    C.globalVars && !qe(W, re.globalVars) && (re.globalVars = new _t(W, re.globalVars))
                }
            }

            function Xe(W, re) {
                if (re) if (re.block) {
                    var Te = Xe(W, re.prev);
                    return Te ? Te == re.prev ? re : new it(Te, re.vars, !0) : null
                } else return qe(W, re.vars) ? re : new it(re.prev, new _t(W, re.vars), !1); else return null
            }

            function Le(W) {
                return W == "public" || W == "private" || W == "protected" || W == "abstract" || W == "readonly"
            }

            function it(W, re, Te) {
                this.prev = W, this.vars = re, this.block = Te
            }

            function _t(W, re) {
                this.name = W, this.next = re
            }

            var Tt = new _t("this", new _t("arguments", null));

            function Pe() {
                le.state.context = new it(le.state.context, le.state.localVars, !1), le.state.localVars = Tt
            }

            function At() {
                le.state.context = new it(le.state.context, le.state.localVars, !0), le.state.localVars = null
            }

            Pe.lex = At.lex = !0;

            function mt() {
                le.state.localVars = le.state.context.vars, le.state.context = le.state.context.prev
            }

            mt.lex = !0;

            function Ye(W, re) {
                var Te = function () {
                    var je = le.state, _e = je.indented;
                    if (je.lexical.type == "stat") _e = je.lexical.indented; else for (var Qe = je.lexical; Qe && Qe.type == ")" && Qe.align; Qe = Qe.prev) _e = Qe.indented;
                    je.lexical = new ue(_e, le.stream.column(), W, null, je.lexical, re)
                };
                return Te.lex = !0, Te
            }

            function Oe() {
                var W = le.state;
                W.lexical.prev && (W.lexical.type == ")" && (W.indented = W.lexical.indented), W.lexical = W.lexical.prev)
            }

            Oe.lex = !0;

            function ht(W) {
                function re(Te) {
                    return Te == W ? ee() : W == ";" || Te == "}" || Te == ")" || Te == "]" ? ye() : ee(re)
                }

                return re
            }

            function vt(W, re) {
                return W == "var" ? ee(Ye("vardef", re), ur, ht(";"), Oe) : W == "keyword a" ? ee(Ye("form"), ge, vt, Oe) : W == "keyword b" ? ee(Ye("form"), vt, Oe) : W == "keyword d" ? le.stream.match(/^\s*$/, !1) ? ee() : ee(Ye("stat"), Me, ht(";"), Oe) : W == "debugger" ? ee(ht(";")) : W == "{" ? ee(Ye("}"), At, zt, Oe, mt) : W == ";" ? ee() : W == "if" ? (le.state.lexical.info == "else" && le.state.cc[le.state.cc.length - 1] == Oe && le.state.cc.pop()(), ee(Ye("form"), ge, vt, Oe, Ys)) : W == "function" ? ee(Br) : W == "for" ? ee(Ye("form"), At, Ac, vt, mt, Oe) : W == "class" || I && re == "interface" ? (le.marked = "keyword", ee(Ye("form", W == "class" ? W : re), ni, Oe)) : W == "variable" ? I && re == "declare" ? (le.marked = "keyword", ee(vt)) : I && (re == "module" || re == "enum" || re == "type") && le.stream.match(/^\s*\w/, !1) ? (le.marked = "keyword", re == "enum" ? ee(dt) : re == "type" ? ee(Cc, ht("operator"), ot, ht(";")) : ee(Ye("form"), Mr, ht("{"), Ye("}"), zt, Oe, Oe)) : I && re == "namespace" ? (le.marked = "keyword", ee(Ye("form"), ct, vt, Oe)) : I && re == "abstract" ? (le.marked = "keyword", ee(vt)) : ee(Ye("stat"), he) : W == "switch" ? ee(Ye("form"), ge, ht("{"), Ye("}", "switch"), At, zt, Oe, Oe, mt) : W == "case" ? ee(ct, ht(":")) : W == "default" ? ee(ht(":")) : W == "catch" ? ee(Ye("form"), Pe, Vt, vt, Oe, mt) : W == "export" ? ee(Ye("stat"), Qs, Oe) : W == "import" ? ee(Ye("stat"), Mo, Oe) : W == "async" ? ee(vt) : re == "@" ? ee(ct, vt) : ye(Ye("stat"), ct, ht(";"), Oe)
            }

            function Vt(W) {
                if (W == "(") return ee(Ai, ht(")"))
            }

            function ct(W, re) {
                return we(W, re, !1)
            }

            function se(W, re) {
                return we(W, re, !0)
            }

            function ge(W) {
                return W != "(" ? ye() : ee(Ye(")"), Me, ht(")"), Oe)
            }

            function we(W, re, Te) {
                if (le.state.fatArrowAt == le.stream.start) {
                    var je = Te ? $ : V;
                    if (W == "(") return ee(Pe, Ye(")"), st(Ai, ")"), Oe, ht("=>"), je, mt);
                    if (W == "variable") return ye(Pe, Mr, ht("=>"), je, mt)
                }
                var _e = Te ? Ue : Be;
                return ae.hasOwnProperty(W) ? ee(_e) : W == "function" ? ee(Br, _e) : W == "class" || I && re == "interface" ? (le.marked = "keyword", ee(Ye("form"), Zu, Oe)) : W == "keyword c" || W == "async" ? ee(Te ? se : ct) : W == "(" ? ee(Ye(")"), Me, ht(")"), Oe, _e) : W == "operator" || W == "spread" ? ee(Te ? se : ct) : W == "[" ? ee(Ye("]"), Tn, Oe, _e) : W == "{" ? Dt(De, "}", null, _e) : W == "quasi" ? ye(Ge, _e) : W == "new" ? ee(te(Te)) : ee()
            }

            function Me(W) {
                return W.match(/[;\}\)\],]/) ? ye() : ye(ct)
            }

            function Be(W, re) {
                return W == "," ? ee(Me) : Ue(W, re, !1)
            }

            function Ue(W, re, Te) {
                var je = Te == !1 ? Be : Ue, _e = Te == !1 ? ct : se;
                if (W == "=>") return ee(Pe, Te ? $ : V, mt);
                if (W == "operator") return /\+\+|--/.test(re) || I && re == "!" ? ee(je) : I && re == "<" && le.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? ee(Ye(">"), st(ot, ">"), Oe, je) : re == "?" ? ee(ct, ht(":"), _e) : ee(_e);
                if (W == "quasi") return ye(Ge, je);
                if (W != ";") {
                    if (W == "(") return Dt(se, ")", "call", je);
                    if (W == ".") return ee(Ae, je);
                    if (W == "[") return ee(Ye("]"), Me, ht("]"), Oe, je);
                    if (I && re == "as") return le.marked = "keyword", ee(ot, je);
                    if (W == "regexp") return le.state.lastType = le.marked = "operator", le.stream.backUp(le.stream.pos - le.stream.start - 1), ee(_e)
                }
            }

            function Ge(W, re) {
                return W != "quasi" ? ye() : re.slice(re.length - 2) != "${" ? ee(Ge) : ee(Me, ze)
            }

            function ze(W) {
                if (W == "}") return le.marked = "string-2", le.state.tokenize = Ce, ee(Ge)
            }

            function V(W) {
                return R(le.stream, le.state), ye(W == "{" ? vt : ct)
            }

            function $(W) {
                return R(le.stream, le.state), ye(W == "{" ? vt : se)
            }

            function te(W) {
                return function (re) {
                    return re == "." ? ee(W ? de : oe) : re == "variable" && I ? ee(zn, W ? Ue : Be) : ye(W ? se : ct)
                }
            }

            function oe(W, re) {
                if (re == "target") return le.marked = "keyword", ee(Be)
            }

            function de(W, re) {
                if (re == "target") return le.marked = "keyword", ee(Ue)
            }

            function he(W) {
                return W == ":" ? ee(Oe, vt) : ye(Be, ht(";"), Oe)
            }

            function Ae(W) {
                if (W == "variable") return le.marked = "property", ee()
            }

            function De(W, re) {
                if (W == "async") return le.marked = "property", ee(De);
                if (W == "variable" || le.style == "keyword") {
                    if (le.marked = "property", re == "get" || re == "set") return ee(Ie);
                    var Te;
                    return I && le.state.fatArrowAt == le.stream.start && (Te = le.stream.match(/^\s*:\s*/, !1)) && (le.state.fatArrowAt = le.stream.pos + Te[0].length), ee(nt)
                } else {
                    if (W == "number" || W == "string") return le.marked = y ? "property" : le.style + " property", ee(nt);
                    if (W == "jsonld-keyword") return ee(nt);
                    if (I && Le(re)) return le.marked = "keyword", ee(De);
                    if (W == "[") return ee(ct, Nt, ht("]"), nt);
                    if (W == "spread") return ee(se, nt);
                    if (re == "*") return le.marked = "keyword", ee(De);
                    if (W == ":") return ye(nt)
                }
            }

            function Ie(W) {
                return W != "variable" ? ye(nt) : (le.marked = "property", ee(Br))
            }

            function nt(W) {
                if (W == ":") return ee(se);
                if (W == "(") return ye(Br)
            }

            function st(W, re, Te) {
                function je(_e, Qe) {
                    if (Te ? Te.indexOf(_e) > -1 : _e == ",") {
                        var Qt = le.state.lexical;
                        return Qt.info == "call" && (Qt.pos = (Qt.pos || 0) + 1), ee(function (tr, Hn) {
                            return tr == re || Hn == re ? ye() : ye(W)
                        }, je)
                    }
                    return _e == re || Qe == re ? ee() : Te && Te.indexOf(";") > -1 ? ye(W) : ee(ht(re))
                }

                return function (_e, Qe) {
                    return _e == re || Qe == re ? ee() : ye(W, je)
                }
            }

            function Dt(W, re, Te) {
                for (var je = 3; je < arguments.length; je++) le.cc.push(arguments[je]);
                return ee(Ye(re, Te), st(W, re), Oe)
            }

            function zt(W) {
                return W == "}" ? ee() : ye(vt, zt)
            }

            function Nt(W, re) {
                if (I) {
                    if (W == ":") return ee(ot);
                    if (re == "?") return ee(Nt)
                }
            }

            function $t(W, re) {
                if (I && (W == ":" || re == "in")) return ee(ot)
            }

            function Ot(W) {
                if (I && W == ":") return le.stream.match(/^\s*\w+\s+is\b/, !1) ? ee(ct, Gt, ot) : ee(ot)
            }

            function Gt(W, re) {
                if (re == "is") return le.marked = "keyword", ee()
            }

            function ot(W, re) {
                if (re == "keyof" || re == "typeof" || re == "infer" || re == "readonly") return le.marked = "keyword", ee(re == "typeof" ? se : ot);
                if (W == "variable" || re == "void") return le.marked = "type", ee(cr);
                if (re == "|" || re == "&") return ee(ot);
                if (W == "string" || W == "number" || W == "atom") return ee(cr);
                if (W == "[") return ee(Ye("]"), st(ot, "]", ","), Oe, cr);
                if (W == "{") return ee(Ye("}"), ft, Oe, cr);
                if (W == "(") return ee(st(fn, ")"), lr, cr);
                if (W == "<") return ee(st(ot, ">"), ot);
                if (W == "quasi") return ye(Rn, cr)
            }

            function lr(W) {
                if (W == "=>") return ee(ot)
            }

            function ft(W) {
                return W.match(/[\}\)\]]/) ? ee() : W == "," || W == ";" ? ee(ft) : ye(Ir, ft)
            }

            function Ir(W, re) {
                if (W == "variable" || le.style == "keyword") return le.marked = "property", ee(Ir);
                if (re == "?" || W == "number" || W == "string") return ee(Ir);
                if (W == ":") return ee(ot);
                if (W == "[") return ee(ht("variable"), $t, ht("]"), Ir);
                if (W == "(") return ye(Io, Ir);
                if (!W.match(/[;\}\)\],]/)) return ee()
            }

            function Rn(W, re) {
                return W != "quasi" ? ye() : re.slice(re.length - 2) != "${" ? ee(Rn) : ee(ot, cn)
            }

            function cn(W) {
                if (W == "}") return le.marked = "string-2", le.state.tokenize = Ce, ee(Rn)
            }

            function fn(W, re) {
                return W == "variable" && le.stream.match(/^\s*[?:]/, !1) || re == "?" ? ee(fn) : W == ":" ? ee(ot) : W == "spread" ? ee(fn) : ye(ot)
            }

            function cr(W, re) {
                if (re == "<") return ee(Ye(">"), st(ot, ">"), Oe, cr);
                if (re == "|" || W == "." || re == "&") return ee(ot);
                if (W == "[") return ee(ot, ht("]"), cr);
                if (re == "extends" || re == "implements") return le.marked = "keyword", ee(ot);
                if (re == "?") return ee(ot, ht(":"), ot)
            }

            function zn(W, re) {
                if (re == "<") return ee(Ye(">"), st(ot, ">"), Oe, cr)
            }

            function Hr() {
                return ye(ot, Sn)
            }

            function Sn(W, re) {
                if (re == "=") return ee(ot)
            }

            function ur(W, re) {
                return re == "enum" ? (le.marked = "keyword", ee(dt)) : ye(Mr, Nt, wi, Ku)
            }

            function Mr(W, re) {
                if (I && Le(re)) return le.marked = "keyword", ee(Mr);
                if (W == "variable") return Ze(re), ee();
                if (W == "spread") return ee(Mr);
                if (W == "[") return Dt(To, "]");
                if (W == "{") return Dt(ti, "}")
            }

            function ti(W, re) {
                return W == "variable" && !le.stream.match(/^\s*:/, !1) ? (Ze(re), ee(wi)) : (W == "variable" && (le.marked = "property"), W == "spread" ? ee(Mr) : W == "}" ? ye() : W == "[" ? ee(ct, ht("]"), ht(":"), ti) : ee(ht(":"), Mr, wi))
            }

            function To() {
                return ye(Mr, wi)
            }

            function wi(W, re) {
                if (re == "=") return ee(se)
            }

            function Ku(W) {
                if (W == ",") return ee(ur)
            }

            function Ys(W, re) {
                if (W == "keyword b" && re == "else") return ee(Ye("form", "else"), vt, Oe)
            }

            function Ac(W, re) {
                if (re == "await") return ee(Ac);
                if (W == "(") return ee(Ye(")"), nl, Oe)
            }

            function nl(W) {
                return W == "var" ? ee(ur, Zr) : W == "variable" ? ee(Zr) : ye(Zr)
            }

            function Zr(W, re) {
                return W == ")" ? ee() : W == ";" ? ee(Zr) : re == "in" || re == "of" ? (le.marked = "keyword", ee(ct, Zr)) : ye(ct, Zr)
            }

            function Br(W, re) {
                if (re == "*") return le.marked = "keyword", ee(Br);
                if (W == "variable") return Ze(re), ee(Br);
                if (W == "(") return ee(Pe, Ye(")"), st(Ai, ")"), Oe, Ot, vt, mt);
                if (I && re == "<") return ee(Ye(">"), st(Hr, ">"), Oe, Br)
            }

            function Io(W, re) {
                if (re == "*") return le.marked = "keyword", ee(Io);
                if (W == "variable") return Ze(re), ee(Io);
                if (W == "(") return ee(Pe, Ye(")"), st(Ai, ")"), Oe, Ot, mt);
                if (I && re == "<") return ee(Ye(">"), st(Hr, ">"), Oe, Io)
            }

            function Cc(W, re) {
                if (W == "keyword" || W == "variable") return le.marked = "type", ee(Cc);
                if (re == "<") return ee(Ye(">"), st(Hr, ">"), Oe)
            }

            function Ai(W, re) {
                return re == "@" && ee(ct, Ai), W == "spread" ? ee(Ai) : I && Le(re) ? (le.marked = "keyword", ee(Ai)) : I && W == "this" ? ee(Nt, wi) : ye(Mr, Nt, wi)
            }

            function Zu(W, re) {
                return W == "variable" ? ni(W, re) : Yr(W, re)
            }

            function ni(W, re) {
                if (W == "variable") return Ze(re), ee(Yr)
            }

            function Yr(W, re) {
                if (re == "<") return ee(Ye(">"), st(Hr, ">"), Oe, Yr);
                if (re == "extends" || re == "implements" || I && W == ",") return re == "implements" && (le.marked = "keyword"), ee(I ? ot : ct, Yr);
                if (W == "{") return ee(Ye("}"), ri, Oe)
            }

            function ri(W, re) {
                if (W == "async" || W == "variable" && (re == "static" || re == "get" || re == "set" || I && Le(re)) && le.stream.match(/^\s+#?[\w$\xa1-\uffff]/, !1)) return le.marked = "keyword", ee(ri);
                if (W == "variable" || le.style == "keyword") return le.marked = "property", ee(ss, ri);
                if (W == "number" || W == "string") return ee(ss, ri);
                if (W == "[") return ee(ct, Nt, ht("]"), ss, ri);
                if (re == "*") return le.marked = "keyword", ee(ri);
                if (I && W == "(") return ye(Io, ri);
                if (W == ";" || W == ",") return ee(ri);
                if (W == "}") return ee();
                if (re == "@") return ee(ct, ri)
            }

            function ss(W, re) {
                if (re == "!" || re == "?") return ee(ss);
                if (W == ":") return ee(ot, wi);
                if (re == "=") return ee(se);
                var Te = le.state.lexical.prev, je = Te && Te.info == "interface";
                return ye(je ? Io : Br)
            }

            function Qs(W, re) {
                return re == "*" ? (le.marked = "keyword", ee(Xs, ht(";"))) : re == "default" ? (le.marked = "keyword", ee(ct, ht(";"))) : W == "{" ? ee(st(ii, "}"), Xs, ht(";")) : ye(vt)
            }

            function ii(W, re) {
                if (re == "as") return le.marked = "keyword", ee(ht("variable"));
                if (W == "variable") return ye(se, ii)
            }

            function Mo(W) {
                return W == "string" ? ee() : W == "(" ? ye(ct) : W == "." ? ye(Be) : ye(Js, Ri, Xs)
            }

            function Js(W, re) {
                return W == "{" ? Dt(Js, "}") : (W == "variable" && Ze(re), re == "*" && (le.marked = "keyword"), ee(rl))
            }

            function Ri(W) {
                if (W == ",") return ee(Js, Ri)
            }

            function rl(W, re) {
                if (re == "as") return le.marked = "keyword", ee(Js)
            }

            function Xs(W, re) {
                if (re == "from") return le.marked = "keyword", ee(ct)
            }

            function Tn(W) {
                return W == "]" ? ee() : ye(st(se, "]"))
            }

            function dt() {
                return ye(Ye("form"), Mr, ht("{"), Ye("}"), st(uo, "}"), Oe, Oe)
            }

            function uo() {
                return ye(Mr, wi)
            }

            function Ci(W, re) {
                return W.lastType == "operator" || W.lastType == "," || B.test(re.charAt(0)) || /[,.]/.test(re.charAt(0))
            }

            function mr(W, re, Te) {
                return re.tokenize == Z && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(re.lastType) || re.lastType == "quasi" && /\{\s*$/.test(W.string.slice(0, W.pos - (Te || 0)))
            }

            return {
                startState: function (W) {
                    var re = {
                        tokenize: Z,
                        lastType: "sof",
                        cc: [],
                        lexical: new ue((W || 0) - k, 0, "block", !1),
                        localVars: C.localVars,
                        context: C.localVars && new it(null, null, !1),
                        indented: W || 0
                    };
                    return C.globalVars && typeof C.globalVars == "object" && (re.globalVars = C.globalVars), re
                },
                token: function (W, re) {
                    if (W.sol() && (re.lexical.hasOwnProperty("align") || (re.lexical.align = !1), re.indented = W.indentation(), R(W, re)), re.tokenize != ce && W.eatSpace()) return null;
                    var Te = re.tokenize(W, re);
                    return q == "comment" ? Te : (re.lastType = q == "operator" && (Q == "++" || Q == "--") ? "incdec" : q, ke(re, Te, q, Q, W))
                },
                indent: function (W, re) {
                    if (W.tokenize == ce || W.tokenize == Ce) return h.Pass;
                    if (W.tokenize != Z) return 0;
                    var Te = re && re.charAt(0), je = W.lexical, _e;
                    if (!/^\s*else\b/.test(re)) for (var Qe = W.cc.length - 1; Qe >= 0; --Qe) {
                        var Qt = W.cc[Qe];
                        if (Qt == Oe) je = je.prev; else if (Qt != Ys && Qt != mt) break
                    }
                    for (; (je.type == "stat" || je.type == "form") && (Te == "}" || (_e = W.cc[W.cc.length - 1]) && (_e == Be || _e == Ue) && !/^[,\.=+\-*:?[\(]/.test(re));) je = je.prev;
                    A && je.type == ")" && je.prev.type == "stat" && (je = je.prev);
                    var tr = je.type, Hn = Te == tr;
                    return tr == "vardef" ? je.indented + (W.lastType == "operator" || W.lastType == "," ? je.info.length + 1 : 0) : tr == "form" && Te == "{" ? je.indented : tr == "form" ? je.indented + k : tr == "stat" ? je.indented + (Ci(W, re) ? A || k : 0) : je.info == "switch" && !Hn && C.doubleIndentSwitch != !1 ? je.indented + (/^(?:case|default)\b/.test(re) ? k : 2 * k) : je.align ? je.column + (Hn ? 0 : 1) : je.indented + (Hn ? 0 : k)
                },
                electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
                blockCommentStart: w ? null : "/*",
                blockCommentEnd: w ? null : "*/",
                blockCommentContinue: w ? null : " * ",
                lineComment: w ? null : "//",
                fold: "brace",
                closeBrackets: "()[]{}''\"\"``",
                helperType: w ? "json" : "javascript",
                jsonldMode: y,
                jsonMode: w,
                expressionAllowed: mr,
                skipExpression: function (W) {
                    ke(W, "atom", "atom", "true", new h.StringStream("", 2, null))
                }
            }
        }), h.registerHelper("wordChars", "javascript", /[\w$]/), h.defineMIME("text/javascript", "javascript"), h.defineMIME("text/ecmascript", "javascript"), h.defineMIME("application/javascript", "javascript"), h.defineMIME("application/x-javascript", "javascript"), h.defineMIME("application/ecmascript", "javascript"), h.defineMIME("application/json", {
            name: "javascript",
            json: !0
        }), h.defineMIME("application/x-json", {
            name: "javascript",
            json: !0
        }), h.defineMIME("application/manifest+json", {
            name: "javascript",
            json: !0
        }), h.defineMIME("application/ld+json", {
            name: "javascript",
            jsonld: !0
        }), h.defineMIME("text/typescript", {
            name: "javascript",
            typescript: !0
        }), h.defineMIME("application/typescript", {name: "javascript", typescript: !0})
    })
})();
(function (a, c) {
    (function (h) {
        h(sf)
    })(function (h) {
        h.defineOption("autoRefresh", !1, function (k, A) {
            k.state.autoRefresh && (C(k, k.state.autoRefresh), k.state.autoRefresh = null), A && k.display.wrapper.offsetHeight == 0 && b(k, k.state.autoRefresh = {delay: A.delay || 250})
        });

        function b(k, A) {
            function y() {
                k.display.wrapper.offsetHeight ? (C(k, A), k.display.lastWrapHeight != k.display.wrapper.clientHeight && k.refresh()) : A.timeout = setTimeout(y, A.delay)
            }

            A.timeout = setTimeout(y, A.delay), A.hurry = function () {
                clearTimeout(A.timeout), A.timeout = setTimeout(y, 50)
            }, h.on(window, "mouseup", A.hurry), h.on(window, "keyup", A.hurry)
        }

        function C(k, A) {
            clearTimeout(A.timeout), h.off(window, "mouseup", A.hurry), h.off(window, "keyup", A.hurry)
        }
    })
})();
const q8 = {
        data() {
            return {uniqueId: this.generateUniqueId(), isEditable: !this.isAdvanced}
        },
        props: {
            title: String,
            description: String,
            modelValue: [String, Boolean],
            error: Boolean,
            errorMessage: String,
            isAdvanced: Boolean,
            type: {type: String, default: "text"}
        },
        emits: ["update:modelValue"],
        methods: {
            updateValue(a) {
                const c = this.type === "checkbox" ? a.target.checked : a.target.value;
                this.$emit("update:modelValue", c)
            }, generateUniqueId() {
                return Math.random().toString(36).substring(2, 15)
            }
        },
        watch: {
            isAdvanced(a) {
                this.isEditable = !a
            }
        }
    }, W8 = {class: "cf-configurator-modal-form-block-item-title", style: {display: "flex"}},
    $8 = {key: 0, class: "cf-configurator-modal-form-block-label"}, G8 = ["id"], K8 = ["for"],
    Z8 = {class: "cf-form-helper-text"}, Y8 = ["for"], Q8 = ["id", "value", "disabled", "type", "checked"],
    J8 = J("div", {class: "cf-slider cf-round"}, null, -1), X8 = ["id", "value", "disabled", "type"], e7 = {key: 2};

function t7(a, c, h, b, C, k) {
    return He(), tt("div", {class: On(["cf-configurator-modal-form-block-item", {disabled: !C.isEditable}])}, [J("div", null, [J("span", W8, [Yt(Fn(h.title) + " ", 1), h.isAdvanced ? (He(), tt("div", $8, [Bt(J("input", {
        type: "checkbox",
        "onUpdate:modelValue": c[0] || (c[0] = A => C.isEditable = A),
        id: "advanced-setting-" + C.uniqueId
    }, null, 8, G8), [[vc, C.isEditable]]), J("label", {
        for: "advanced-setting-" + C.uniqueId,
        style: {"margin-left": "5px", "font-size": "0.7rem", "font-weight": "normal"}
    }, "advanced setting", 8, K8)])) : Rt("", !0)]), J("div", Z8, Fn(h.description), 1), h.type === "checkbox" ? (He(), tt("label", {
        key: 0,
        class: "cf-switch",
        for: "input-" + C.uniqueId
    }, [J("input", {
        id: "input-" + C.uniqueId,
        value: h.modelValue,
        onInput: c[1] || (c[1] = (...A) => k.updateValue && k.updateValue(...A)),
        disabled: !C.isEditable,
        class: On({error: h.error}),
        type: h.type,
        checked: h.modelValue === !0
    }, null, 42, Q8), J8], 8, Y8)) : (He(), tt("input", {
        key: 1,
        id: "input-" + C.uniqueId,
        value: h.modelValue,
        onInput: c[2] || (c[2] = (...A) => k.updateValue && k.updateValue(...A)),
        disabled: !C.isEditable,
        class: On({error: h.error}),
        type: h.type
    }, null, 42, X8)), h.error ? (He(), tt("span", e7, Fn(h.errorMessage), 1)) : Rt("", !0)])], 2)
}

const wv = Tr(q8, [["render", t7]]);
var Zp = {exports: {}};
Zp.exports;
(function (a, c) {
    (function (h) {
        const b = h.en = h.en || {};
        b.dictionary = Object.assign(b.dictionary || {}, {
            "%0 of %1": "%0 of %1",
            Accept: "Accept",
            "Align cell text to the bottom": "Align cell text to the bottom",
            "Align cell text to the center": "Align cell text to the center",
            "Align cell text to the left": "Align cell text to the left",
            "Align cell text to the middle": "Align cell text to the middle",
            "Align cell text to the right": "Align cell text to the right",
            "Align cell text to the top": "Align cell text to the top",
            "Align table to the left": "Align table to the left",
            "Align table to the right": "Align table to the right",
            Alignment: "Alignment",
            Aquamarine: "Aquamarine",
            Background: "Background",
            Black: "Black",
            "Block quote": "Block quote",
            Blue: "Blue",
            Bold: "Bold",
            Border: "Border",
            "Break text": "Break text",
            "Bulleted List": "Bulleted List",
            "Bulleted list styles toolbar": "Bulleted list styles toolbar",
            Cancel: "Cancel",
            "Cannot access default workspace.": "Cannot access default workspace.",
            "Cannot determine a category for the uploaded file.": "Cannot determine a category for the uploaded file.",
            "Cannot upload file:": "Cannot upload file:",
            "Caption for image: %0": "Caption for image: %0",
            "Caption for the image": "Caption for the image",
            "Cell properties": "Cell properties",
            "Center table": "Center table",
            "Centered image": "Centered image",
            "Change image text alternative": "Change image text alternative",
            "Choose heading": "Choose heading",
            Circle: "Circle",
            Clear: "Clear",
            "Click to edit block": "Click to edit block",
            Code: "Code",
            Color: "Color",
            "Color picker": "Color picker",
            Column: "Column",
            "Could not insert image at the current position.": "Could not insert image at the current position.",
            "Could not obtain resized image URL.": "Could not obtain resized image URL.",
            Dashed: "Dashed",
            Decimal: "Decimal",
            "Decimal with leading zero": "Decimal with leading zero",
            "Decrease indent": "Decrease indent",
            "Delete column": "Delete column",
            "Delete row": "Delete row",
            "Dim grey": "Dim grey",
            Dimensions: "Dimensions",
            Disc: "Disc",
            Dotted: "Dotted",
            Double: "Double",
            Downloadable: "Downloadable",
            "Drag to move": "Drag to move",
            "Dropdown toolbar": "Dropdown toolbar",
            "Edit block": "Edit block",
            "Edit image": "Edit image",
            "Edit link": "Edit link",
            "Editor block content toolbar": "Editor block content toolbar",
            "Editor contextual toolbar": "Editor contextual toolbar",
            "Editor editing area: %0": "Editor editing area: %0",
            "Editor toolbar": "Editor toolbar",
            "Enter image caption": "Enter image caption",
            "Enter table caption": "Enter table caption",
            "Failed to determine category of edited image.": "Failed to determine category of edited image.",
            "Full size image": "Full size image",
            Green: "Green",
            Grey: "Grey",
            Groove: "Groove",
            "Header column": "Header column",
            "Header row": "Header row",
            Heading: "Heading",
            "Heading 1": "Heading 1",
            "Heading 2": "Heading 2",
            "Heading 3": "Heading 3",
            "Heading 4": "Heading 4",
            "Heading 5": "Heading 5",
            "Heading 6": "Heading 6",
            Height: "Height",
            HEX: "HEX",
            "Horizontal text alignment toolbar": "Horizontal text alignment toolbar",
            "Image resize list": "Image resize list",
            "Image toolbar": "Image toolbar",
            "image widget": "image widget",
            "In line": "In line",
            "Increase indent": "Increase indent",
            Insert: "Insert",
            "Insert column left": "Insert column left",
            "Insert column right": "Insert column right",
            "Insert image": "Insert image",
            "Insert image or file": "Insert image or file",
            "Insert image via URL": "Insert image via URL",
            "Insert image with file manager": "Insert image with file manager",
            "Insert media": "Insert media",
            "Insert paragraph after block": "Insert paragraph after block",
            "Insert paragraph before block": "Insert paragraph before block",
            "Insert row above": "Insert row above",
            "Insert row below": "Insert row below",
            "Insert table": "Insert table",
            "Insert with file manager": "Insert with file manager",
            "Inserting image failed": "Inserting image failed",
            Inset: "Inset",
            Italic: "Italic",
            "Justify cell text": "Justify cell text",
            "Left aligned image": "Left aligned image",
            "Light blue": "Light blue",
            "Light green": "Light green",
            "Light grey": "Light grey",
            Link: "Link",
            "Link image": "Link image",
            "Link URL": "Link URL",
            "List properties": "List properties",
            "Lower-latin": "Lower-latin",
            "Lower–roman": "Lower–roman",
            "Media toolbar": "Media toolbar",
            "Media URL": "Media URL",
            "media widget": "media widget",
            "Merge cell down": "Merge cell down",
            "Merge cell left": "Merge cell left",
            "Merge cell right": "Merge cell right",
            "Merge cell up": "Merge cell up",
            "Merge cells": "Merge cells",
            Next: "Next",
            "No results found": "No results found",
            "No searchable items": "No searchable items",
            None: "None",
            "Numbered List": "Numbered List",
            "Numbered list styles toolbar": "Numbered list styles toolbar",
            "Open file manager": "Open file manager",
            "Open in a new tab": "Open in a new tab",
            "Open link in new tab": "Open link in new tab",
            "Open media in new tab": "Open media in new tab",
            Orange: "Orange",
            Original: "Original",
            Outset: "Outset",
            Padding: "Padding",
            Paragraph: "Paragraph",
            "Paste the media URL in the input.": "Paste the media URL in the input.",
            "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget",
            Previous: "Previous",
            "Processing the edited image.": "Processing the edited image.",
            Purple: "Purple",
            Red: "Red",
            Redo: "Redo",
            "Remove color": "Remove color",
            "Replace from computer": "Replace from computer",
            "Replace image": "Replace image",
            "Replace image from computer": "Replace image from computer",
            "Replace image with file manager": "Replace image with file manager",
            "Replace with file manager": "Replace with file manager",
            "Resize image": "Resize image",
            "Resize image to %0": "Resize image to %0",
            "Resize image to the original size": "Resize image to the original size",
            "Restore default": "Restore default",
            "Reversed order": "Reversed order",
            "Rich Text Editor": "Rich Text Editor",
            Ridge: "Ridge",
            "Right aligned image": "Right aligned image",
            Row: "Row",
            Save: "Save",
            "Select all": "Select all",
            "Select column": "Select column",
            "Select row": "Select row",
            "Selecting resized image failed": "Selecting resized image failed",
            "Server failed to process the image.": "Server failed to process the image.",
            "Show more items": "Show more items",
            "Side image": "Side image",
            Solid: "Solid",
            "Split cell horizontally": "Split cell horizontally",
            "Split cell vertically": "Split cell vertically",
            Square: "Square",
            "Start at": "Start at",
            "Start index must be greater than 0.": "Start index must be greater than 0.",
            Strikethrough: "Strikethrough",
            Style: "Style",
            Subscript: "Subscript",
            Superscript: "Superscript",
            "Table alignment toolbar": "Table alignment toolbar",
            "Table cell text alignment": "Table cell text alignment",
            "Table properties": "Table properties",
            "Table toolbar": "Table toolbar",
            "Text alternative": "Text alternative",
            'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
            "The URL must not be empty.": "The URL must not be empty.",
            'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".',
            "This link has no URL": "This link has no URL",
            "This media URL is not supported.": "This media URL is not supported.",
            "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.",
            "To-do List": "To-do List",
            "Toggle caption off": "Toggle caption off",
            "Toggle caption on": "Toggle caption on",
            "Toggle the circle list style": "Toggle the circle list style",
            "Toggle the decimal list style": "Toggle the decimal list style",
            "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style",
            "Toggle the disc list style": "Toggle the disc list style",
            "Toggle the lower–latin list style": "Toggle the lower–latin list style",
            "Toggle the lower–roman list style": "Toggle the lower–roman list style",
            "Toggle the square list style": "Toggle the square list style",
            "Toggle the upper–latin list style": "Toggle the upper–latin list style",
            "Toggle the upper–roman list style": "Toggle the upper–roman list style",
            Turquoise: "Turquoise",
            "Type or paste your content here.": "Type or paste your content here.",
            "Type your title": "Type your title",
            Underline: "Underline",
            Undo: "Undo",
            Unlink: "Unlink",
            Update: "Update",
            "Update image URL": "Update image URL",
            "Upload failed": "Upload failed",
            "Upload from computer": "Upload from computer",
            "Upload image from computer": "Upload image from computer",
            "Upload in progress": "Upload in progress",
            "Upper-latin": "Upper-latin",
            "Upper-roman": "Upper-roman",
            "Vertical text alignment toolbar": "Vertical text alignment toolbar",
            White: "White",
            "Widget toolbar": "Widget toolbar",
            Width: "Width",
            "Wrap text": "Wrap text",
            Yellow: "Yellow"
        })
    })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), function (h, b) {
        a.exports = b()
    }(self, () => (() => {
        var h = {
            4959: (A, y, w) => {
                const S = w(1103), I = {};
                for (const D of Object.keys(S)) I[S[D]] = D;
                const T = {
                    rgb: {channels: 3, labels: "rgb"},
                    hsl: {channels: 3, labels: "hsl"},
                    hsv: {channels: 3, labels: "hsv"},
                    hwb: {channels: 3, labels: "hwb"},
                    cmyk: {channels: 4, labels: "cmyk"},
                    xyz: {channels: 3, labels: "xyz"},
                    lab: {channels: 3, labels: "lab"},
                    lch: {channels: 3, labels: "lch"},
                    hex: {channels: 1, labels: ["hex"]},
                    keyword: {channels: 1, labels: ["keyword"]},
                    ansi16: {channels: 1, labels: ["ansi16"]},
                    ansi256: {channels: 1, labels: ["ansi256"]},
                    hcg: {channels: 3, labels: ["h", "c", "g"]},
                    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
                    gray: {channels: 1, labels: ["gray"]}
                };
                A.exports = T;
                for (const D of Object.keys(T)) {
                    if (!("channels" in T[D])) throw new Error("missing channels property: " + D);
                    if (!("labels" in T[D])) throw new Error("missing channel labels property: " + D);
                    if (T[D].labels.length !== T[D].channels) throw new Error("channel and label counts mismatch: " + D);
                    const {channels: B, labels: L} = T[D];
                    delete T[D].channels, delete T[D].labels, Object.defineProperty(T[D], "channels", {value: B}), Object.defineProperty(T[D], "labels", {value: L})
                }
                T.rgb.hsl = function (D) {
                    const B = D[0] / 255, L = D[1] / 255, z = D[2] / 255, q = Math.min(B, L, z), Q = Math.max(B, L, z),
                        G = Q - q;
                    let Z, Y;
                    Q === q ? Z = 0 : B === Q ? Z = (L - z) / G : L === Q ? Z = 2 + (z - B) / G : z === Q && (Z = 4 + (B - L) / G), Z = Math.min(60 * Z, 360), Z < 0 && (Z += 360);
                    const ce = (q + Q) / 2;
                    return Y = Q === q ? 0 : ce <= .5 ? G / (Q + q) : G / (2 - Q - q), [Z, 100 * Y, 100 * ce]
                }, T.rgb.hsv = function (D) {
                    let B, L, z, q, Q;
                    const G = D[0] / 255, Z = D[1] / 255, Y = D[2] / 255, ce = Math.max(G, Z, Y),
                        Ce = ce - Math.min(G, Z, Y), me = function (R) {
                            return (ce - R) / 6 / Ce + .5
                        };
                    return Ce === 0 ? (q = 0, Q = 0) : (Q = Ce / ce, B = me(G), L = me(Z), z = me(Y), G === ce ? q = z - L : Z === ce ? q = .3333333333333333 + B - z : Y === ce && (q = .6666666666666666 + L - B), q < 0 ? q += 1 : q > 1 && (q -= 1)), [360 * q, 100 * Q, 100 * ce]
                }, T.rgb.hwb = function (D) {
                    const B = D[0], L = D[1];
                    let z = D[2];
                    const q = T.rgb.hsl(D)[0], Q = 1 / 255 * Math.min(B, Math.min(L, z));
                    return z = 1 - .00392156862745098 * Math.max(B, Math.max(L, z)), [q, 100 * Q, 100 * z]
                }, T.rgb.cmyk = function (D) {
                    const B = D[0] / 255, L = D[1] / 255, z = D[2] / 255, q = Math.min(1 - B, 1 - L, 1 - z);
                    return [100 * ((1 - B - q) / (1 - q) || 0), 100 * ((1 - L - q) / (1 - q) || 0), 100 * ((1 - z - q) / (1 - q) || 0), 100 * q]
                }, T.rgb.keyword = function (D) {
                    const B = I[D];
                    if (B) return B;
                    let L, z = 1 / 0;
                    for (const G of Object.keys(S)) {
                        const Z = S[G], Y = (Q = Z, ((q = D)[0] - Q[0]) ** 2 + (q[1] - Q[1]) ** 2 + (q[2] - Q[2]) ** 2);
                        Y < z && (z = Y, L = G)
                    }
                    var q, Q;
                    return L
                }, T.keyword.rgb = function (D) {
                    return S[D]
                }, T.rgb.xyz = function (D) {
                    let B = D[0] / 255, L = D[1] / 255, z = D[2] / 255;
                    return B = B > .04045 ? ((B + .055) / 1.055) ** 2.4 : B / 12.92, L = L > .04045 ? ((L + .055) / 1.055) ** 2.4 : L / 12.92, z = z > .04045 ? ((z + .055) / 1.055) ** 2.4 : z / 12.92, [100 * (.4124 * B + .3576 * L + .1805 * z), 100 * (.2126 * B + .7152 * L + .0722 * z), 100 * (.0193 * B + .1192 * L + .9505 * z)]
                }, T.rgb.lab = function (D) {
                    const B = T.rgb.xyz(D);
                    let L = B[0], z = B[1], q = B[2];
                    return L /= 95.047, z /= 100, q /= 108.883, L = L > .008856 ? L ** .3333333333333333 : 7.787 * L + .13793103448275862, z = z > .008856 ? z ** .3333333333333333 : 7.787 * z + .13793103448275862, q = q > .008856 ? q ** .3333333333333333 : 7.787 * q + .13793103448275862, [116 * z - 16, 500 * (L - z), 200 * (z - q)]
                }, T.hsl.rgb = function (D) {
                    const B = D[0] / 360, L = D[1] / 100, z = D[2] / 100;
                    let q, Q, G;
                    if (L === 0) return G = 255 * z, [G, G, G];
                    q = z < .5 ? z * (1 + L) : z + L - z * L;
                    const Z = 2 * z - q, Y = [0, 0, 0];
                    for (let ce = 0; ce < 3; ce++) Q = B + .3333333333333333 * -(ce - 1), Q < 0 && Q++, Q > 1 && Q--, G = 6 * Q < 1 ? Z + 6 * (q - Z) * Q : 2 * Q < 1 ? q : 3 * Q < 2 ? Z + (q - Z) * (.6666666666666666 - Q) * 6 : Z, Y[ce] = 255 * G;
                    return Y
                }, T.hsl.hsv = function (D) {
                    const B = D[0];
                    let L = D[1] / 100, z = D[2] / 100, q = L;
                    const Q = Math.max(z, .01);
                    return z *= 2, L *= z <= 1 ? z : 2 - z, q *= Q <= 1 ? Q : 2 - Q, [B, 100 * (z === 0 ? 2 * q / (Q + q) : 2 * L / (z + L)), 100 * ((z + L) / 2)]
                }, T.hsv.rgb = function (D) {
                    const B = D[0] / 60, L = D[1] / 100;
                    let z = D[2] / 100;
                    const q = Math.floor(B) % 6, Q = B - Math.floor(B), G = 255 * z * (1 - L),
                        Z = 255 * z * (1 - L * Q), Y = 255 * z * (1 - L * (1 - Q));
                    switch (z *= 255, q) {
                        case 0:
                            return [z, Y, G];
                        case 1:
                            return [Z, z, G];
                        case 2:
                            return [G, z, Y];
                        case 3:
                            return [G, Z, z];
                        case 4:
                            return [Y, G, z];
                        case 5:
                            return [z, G, Z]
                    }
                }, T.hsv.hsl = function (D) {
                    const B = D[0], L = D[1] / 100, z = D[2] / 100, q = Math.max(z, .01);
                    let Q, G;
                    G = (2 - L) * z;
                    const Z = (2 - L) * q;
                    return Q = L * q, Q /= Z <= 1 ? Z : 2 - Z, Q = Q || 0, G /= 2, [B, 100 * Q, 100 * G]
                }, T.hwb.rgb = function (D) {
                    const B = D[0] / 360;
                    let L = D[1] / 100, z = D[2] / 100;
                    const q = L + z;
                    let Q;
                    q > 1 && (L /= q, z /= q);
                    const G = Math.floor(6 * B), Z = 1 - z;
                    Q = 6 * B - G, 1 & G && (Q = 1 - Q);
                    const Y = L + Q * (Z - L);
                    let ce, Ce, me;
                    switch (G) {
                        default:
                        case 6:
                        case 0:
                            ce = Z, Ce = Y, me = L;
                            break;
                        case 1:
                            ce = Y, Ce = Z, me = L;
                            break;
                        case 2:
                            ce = L, Ce = Z, me = Y;
                            break;
                        case 3:
                            ce = L, Ce = Y, me = Z;
                            break;
                        case 4:
                            ce = Y, Ce = L, me = Z;
                            break;
                        case 5:
                            ce = Z, Ce = L, me = Y
                    }
                    return [255 * ce, 255 * Ce, 255 * me]
                }, T.cmyk.rgb = function (D) {
                    const B = D[0] / 100, L = D[1] / 100, z = D[2] / 100, q = D[3] / 100;
                    return [255 * (1 - Math.min(1, B * (1 - q) + q)), 255 * (1 - Math.min(1, L * (1 - q) + q)), 255 * (1 - Math.min(1, z * (1 - q) + q))]
                }, T.xyz.rgb = function (D) {
                    const B = D[0] / 100, L = D[1] / 100, z = D[2] / 100;
                    let q, Q, G;
                    return q = 3.2406 * B + -1.5372 * L + -.4986 * z, Q = -.9689 * B + 1.8758 * L + .0415 * z, G = .0557 * B + -.204 * L + 1.057 * z, q = q > .0031308 ? 1.055 * q ** .4166666666666667 - .055 : 12.92 * q, Q = Q > .0031308 ? 1.055 * Q ** .4166666666666667 - .055 : 12.92 * Q, G = G > .0031308 ? 1.055 * G ** .4166666666666667 - .055 : 12.92 * G, q = Math.min(Math.max(0, q), 1), Q = Math.min(Math.max(0, Q), 1), G = Math.min(Math.max(0, G), 1), [255 * q, 255 * Q, 255 * G]
                }, T.xyz.lab = function (D) {
                    let B = D[0], L = D[1], z = D[2];
                    return B /= 95.047, L /= 100, z /= 108.883, B = B > .008856 ? B ** .3333333333333333 : 7.787 * B + .13793103448275862, L = L > .008856 ? L ** .3333333333333333 : 7.787 * L + .13793103448275862, z = z > .008856 ? z ** .3333333333333333 : 7.787 * z + .13793103448275862, [116 * L - 16, 500 * (B - L), 200 * (L - z)]
                }, T.lab.xyz = function (D) {
                    let B, L, z;
                    L = (D[0] + 16) / 116, B = D[1] / 500 + L, z = L - D[2] / 200;
                    const q = L ** 3, Q = B ** 3, G = z ** 3;
                    return L = q > .008856 ? q : (L - .13793103448275862) / 7.787, B = Q > .008856 ? Q : (B - .13793103448275862) / 7.787, z = G > .008856 ? G : (z - .13793103448275862) / 7.787, B *= 95.047, L *= 100, z *= 108.883, [B, L, z]
                }, T.lab.lch = function (D) {
                    const B = D[0], L = D[1], z = D[2];
                    let q;
                    return q = 360 * Math.atan2(z, L) / 2 / Math.PI, q < 0 && (q += 360), [B, Math.sqrt(L * L + z * z), q]
                }, T.lch.lab = function (D) {
                    const B = D[0], L = D[1], z = D[2] / 360 * 2 * Math.PI;
                    return [B, L * Math.cos(z), L * Math.sin(z)]
                }, T.rgb.ansi16 = function (D, B = null) {
                    const [L, z, q] = D;
                    let Q = B === null ? T.rgb.hsv(D)[2] : B;
                    if (Q = Math.round(Q / 50), Q === 0) return 30;
                    let G = 30 + (Math.round(q / 255) << 2 | Math.round(z / 255) << 1 | Math.round(L / 255));
                    return Q === 2 && (G += 60), G
                }, T.hsv.ansi16 = function (D) {
                    return T.rgb.ansi16(T.hsv.rgb(D), D[2])
                }, T.rgb.ansi256 = function (D) {
                    const B = D[0], L = D[1], z = D[2];
                    return B === L && L === z ? B < 8 ? 16 : B > 248 ? 231 : Math.round((B - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(B / 255 * 5) + 6 * Math.round(L / 255 * 5) + Math.round(z / 255 * 5)
                }, T.ansi16.rgb = function (D) {
                    let B = D % 10;
                    if (B === 0 || B === 7) return D > 50 && (B += 3.5), B = B / 10.5 * 255, [B, B, B];
                    const L = .5 * (1 + ~~(D > 50));
                    return [(1 & B) * L * 255, (B >> 1 & 1) * L * 255, (B >> 2 & 1) * L * 255]
                }, T.ansi256.rgb = function (D) {
                    if (D >= 232) {
                        const L = 10 * (D - 232) + 8;
                        return [L, L, L]
                    }
                    let B;
                    return D -= 16, [Math.floor(D / 36) / 5 * 255, Math.floor((B = D % 36) / 6) / 5 * 255, B % 6 / 5 * 255]
                }, T.rgb.hex = function (D) {
                    const B = (((255 & Math.round(D[0])) << 16) + ((255 & Math.round(D[1])) << 8) + (255 & Math.round(D[2]))).toString(16).toUpperCase();
                    return "000000".substring(B.length) + B
                }, T.hex.rgb = function (D) {
                    const B = D.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                    if (!B) return [0, 0, 0];
                    let L = B[0];
                    B[0].length === 3 && (L = L.split("").map(q => q + q).join(""));
                    const z = parseInt(L, 16);
                    return [z >> 16 & 255, z >> 8 & 255, 255 & z]
                }, T.rgb.hcg = function (D) {
                    const B = D[0] / 255, L = D[1] / 255, z = D[2] / 255, q = Math.max(Math.max(B, L), z),
                        Q = Math.min(Math.min(B, L), z), G = q - Q;
                    let Z, Y;
                    return Z = G < 1 ? Q / (1 - G) : 0, Y = G <= 0 ? 0 : q === B ? (L - z) / G % 6 : q === L ? 2 + (z - B) / G : 4 + (B - L) / G, Y /= 6, Y %= 1, [360 * Y, 100 * G, 100 * Z]
                }, T.hsl.hcg = function (D) {
                    const B = D[1] / 100, L = D[2] / 100, z = L < .5 ? 2 * B * L : 2 * B * (1 - L);
                    let q = 0;
                    return z < 1 && (q = (L - .5 * z) / (1 - z)), [D[0], 100 * z, 100 * q]
                }, T.hsv.hcg = function (D) {
                    const B = D[1] / 100, L = D[2] / 100, z = B * L;
                    let q = 0;
                    return z < 1 && (q = (L - z) / (1 - z)), [D[0], 100 * z, 100 * q]
                }, T.hcg.rgb = function (D) {
                    const B = D[0] / 360, L = D[1] / 100, z = D[2] / 100;
                    if (L === 0) return [255 * z, 255 * z, 255 * z];
                    const q = [0, 0, 0], Q = B % 1 * 6, G = Q % 1, Z = 1 - G;
                    let Y = 0;
                    switch (Math.floor(Q)) {
                        case 0:
                            q[0] = 1, q[1] = G, q[2] = 0;
                            break;
                        case 1:
                            q[0] = Z, q[1] = 1, q[2] = 0;
                            break;
                        case 2:
                            q[0] = 0, q[1] = 1, q[2] = G;
                            break;
                        case 3:
                            q[0] = 0, q[1] = Z, q[2] = 1;
                            break;
                        case 4:
                            q[0] = G, q[1] = 0, q[2] = 1;
                            break;
                        default:
                            q[0] = 1, q[1] = 0, q[2] = Z
                    }
                    return Y = (1 - L) * z, [255 * (L * q[0] + Y), 255 * (L * q[1] + Y), 255 * (L * q[2] + Y)]
                }, T.hcg.hsv = function (D) {
                    const B = D[1] / 100, L = B + D[2] / 100 * (1 - B);
                    let z = 0;
                    return L > 0 && (z = B / L), [D[0], 100 * z, 100 * L]
                }, T.hcg.hsl = function (D) {
                    const B = D[1] / 100, L = D[2] / 100 * (1 - B) + .5 * B;
                    let z = 0;
                    return L > 0 && L < .5 ? z = B / (2 * L) : L >= .5 && L < 1 && (z = B / (2 * (1 - L))), [D[0], 100 * z, 100 * L]
                }, T.hcg.hwb = function (D) {
                    const B = D[1] / 100, L = B + D[2] / 100 * (1 - B);
                    return [D[0], 100 * (L - B), 100 * (1 - L)]
                }, T.hwb.hcg = function (D) {
                    const B = D[1] / 100, L = 1 - D[2] / 100, z = L - B;
                    let q = 0;
                    return z < 1 && (q = (L - z) / (1 - z)), [D[0], 100 * z, 100 * q]
                }, T.apple.rgb = function (D) {
                    return [D[0] / 65535 * 255, D[1] / 65535 * 255, D[2] / 65535 * 255]
                }, T.rgb.apple = function (D) {
                    return [D[0] / 255 * 65535, D[1] / 255 * 65535, D[2] / 255 * 65535]
                }, T.gray.rgb = function (D) {
                    return [D[0] / 100 * 255, D[0] / 100 * 255, D[0] / 100 * 255]
                }, T.gray.hsl = function (D) {
                    return [0, 0, D[0]]
                }, T.gray.hsv = T.gray.hsl, T.gray.hwb = function (D) {
                    return [0, 100, D[0]]
                }, T.gray.cmyk = function (D) {
                    return [0, 0, 0, D[0]]
                }, T.gray.lab = function (D) {
                    return [D[0], 0, 0]
                }, T.gray.hex = function (D) {
                    const B = 255 & Math.round(D[0] / 100 * 255),
                        L = ((B << 16) + (B << 8) + B).toString(16).toUpperCase();
                    return "000000".substring(L.length) + L
                }, T.rgb.gray = function (D) {
                    return [(D[0] + D[1] + D[2]) / 3 / 255 * 100]
                }
            }, 841: (A, y, w) => {
                const S = w(4959), I = w(9325), T = {};
                Object.keys(S).forEach(D => {
                    T[D] = {}, Object.defineProperty(T[D], "channels", {value: S[D].channels}), Object.defineProperty(T[D], "labels", {value: S[D].labels});
                    const B = I(D);
                    Object.keys(B).forEach(L => {
                        const z = B[L];
                        T[D][L] = function (q) {
                            const Q = function (...G) {
                                const Z = G[0];
                                if (Z == null) return Z;
                                Z.length > 1 && (G = Z);
                                const Y = q(G);
                                if (typeof Y == "object") for (let ce = Y.length, Ce = 0; Ce < ce; Ce++) Y[Ce] = Math.round(Y[Ce]);
                                return Y
                            };
                            return "conversion" in q && (Q.conversion = q.conversion), Q
                        }(z), T[D][L].raw = function (q) {
                            const Q = function (...G) {
                                const Z = G[0];
                                return Z == null ? Z : (Z.length > 1 && (G = Z), q(G))
                            };
                            return "conversion" in q && (Q.conversion = q.conversion), Q
                        }(z)
                    })
                }), A.exports = T
            }, 9325: (A, y, w) => {
                const S = w(4959);

                function I(B) {
                    const L = function () {
                        const q = {}, Q = Object.keys(S);
                        for (let G = Q.length, Z = 0; Z < G; Z++) q[Q[Z]] = {distance: -1, parent: null};
                        return q
                    }(), z = [B];
                    for (L[B].distance = 0; z.length;) {
                        const q = z.pop(), Q = Object.keys(S[q]);
                        for (let G = Q.length, Z = 0; Z < G; Z++) {
                            const Y = Q[Z], ce = L[Y];
                            ce.distance === -1 && (ce.distance = L[q].distance + 1, ce.parent = q, z.unshift(Y))
                        }
                    }
                    return L
                }

                function T(B, L) {
                    return function (z) {
                        return L(B(z))
                    }
                }

                function D(B, L) {
                    const z = [L[B].parent, B];
                    let q = S[L[B].parent][B], Q = L[B].parent;
                    for (; L[Q].parent;) z.unshift(L[Q].parent), q = T(S[L[Q].parent][Q], q), Q = L[Q].parent;
                    return q.conversion = z, q
                }

                A.exports = function (B) {
                    const L = I(B), z = {}, q = Object.keys(L);
                    for (let Q = q.length, G = 0; G < Q; G++) {
                        const Z = q[G];
                        L[Z].parent !== null && (z[Z] = D(Z, L))
                    }
                    return z
                }
            }, 1103: A => {
                A.exports = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    rebeccapurple: [102, 51, 153],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                }
            }, 8603: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-basic-styles/theme/code.css"],
                    names: [],
                    mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content code {
	background-color: hsla(0, 0%, 78%, 0.3);
	padding: .15em;
	border-radius: 2px;
}

.ck.ck-editor__editable .ck-code_selected  {
	background-color: hsla(0, 0%, 78%, 0.5);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3062: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"],
                    names: [],
                    mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content blockquote {
	/* See #12 */
	overflow: hidden;

	/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */
	padding-right: 1.5em;
	padding-left: 1.5em;

	margin-left: 0;
	margin-right: 0;
	font-style: italic;
	border-left: solid 5px hsl(0, 0%, 80%);
}

.ck-content[dir="rtl"] blockquote {
	border-left: 0;
	border-right: solid 5px hsl(0, 0%, 80%);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 443: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ':root{--ck-image-processing-highlight-color:#f9fafa;--ck-image-processing-background-color:#e3e5e8}.ck.ck-editor__editable .image.image-processing{position:relative}.ck.ck-editor__editable .image.image-processing:before{animation:ck-image-processing-animation 2s linear infinite;background:linear-gradient(90deg,var(--ck-image-processing-background-color),var(--ck-image-processing-highlight-color),var(--ck-image-processing-background-color));background-size:200% 100%;content:"";height:100%;left:0;position:absolute;top:0;width:100%;z-index:1}.ck.ck-editor__editable .image.image-processing img{height:100%}@keyframes ck-image-processing-animation{0%{background-position:200% 0}to{background-position:-200% 0}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ckbox/theme/ckboximageedit.css"],
                    names: [],
                    mappings: "AAKA,MAEC,6CAAyD,CACzD,8CACD,CAIE,gDACC,iBA2BD,CAzBC,uDAmBC,0DAA2D,CAR3D,oKAKC,CACD,yBAA0B,CAhB1B,UAAW,CAOX,WAAY,CAHZ,MAAO,CAFP,iBAAkB,CAClB,KAAM,CAKN,UAAW,CAHX,SAcD,CAEA,oDACC,WACD,CAKH,yCACC,GACC,0BACD,CACA,GACC,2BACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Based on default CKBox theme colors */
	--ck-image-processing-highlight-color: hsl(220, 10%, 98%);
	--ck-image-processing-background-color: hsl(220, 10%, 90%);
}

.ck.ck-editor__editable {
	& .image {
		&.image-processing {
			position: relative;

			&:before {
				content: '';

				position: absolute;
				top: 0;
				left: 0;
				z-index: 1;

				height: 100%;
				width: 100%;

				background: linear-gradient(
					90deg,
					var(--ck-image-processing-background-color),
					var(--ck-image-processing-highlight-color),
					var(--ck-image-processing-background-color)
				);
				background-size: 200% 100%;

				animation: ck-image-processing-animation 2s linear infinite;
			}

			& img {
				height: 100%;
			}
		}
	}
}

@keyframes ck-image-processing-animation {
	0% {
		background-position: 200% 0;
	}
	100% {
		background-position: -200% 0;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 903: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}.ck.ck-clipboard-drop-target-line:before{border-style:solid;content:"";height:0;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-width)*-.5);width:0}[dir=ltr] .ck.ck-clipboard-drop-target-line:before{border-color:transparent transparent transparent var(--ck-clipboard-drop-target-color);border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height);left:-1px}[dir=rtl] .ck.ck-clipboard-drop-target-line:before{border-color:transparent var(--ck-clipboard-drop-target-color) transparent transparent;border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0;right:-1px}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"],
                    names: [],
                    mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CC9BA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eAwBD,CAtBC,yCAMC,kBAAmB,CALnB,UAAW,CAIX,QAAS,CAHT,iBAAkB,CAClB,uDAA0D,CAC1D,OAiBD,CArBA,mDAYE,sFAAuF,CADvF,+JAAoK,CAFpK,SAYF,CArBA,mDAmBE,sFAAuF,CADvF,+JAAmK,CAFnK,UAKF",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		display: inline;
		position: relative;
		pointer-events: none;

		& span {
			position: absolute;
			width: 0;
		}
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		& > .ck-widget__selection-handle {
			display: none;
		}

		& > .ck-widget__type-around {
			display: none;
		}
	}
}

.ck.ck-clipboard-drop-target-line {
	position: absolute;
	pointer-events: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-clipboard-drop-target-dot-width: 12px;
	--ck-clipboard-drop-target-dot-height: 8px;
	--ck-clipboard-drop-target-color: var(--ck-color-focus-border);
}

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		& span {
			bottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			border: 1px solid var(--ck-clipboard-drop-target-color);
			background: var(--ck-clipboard-drop-target-color);
			margin-left: -1px;

			/* The triangle above the marker */
			&::after {
				content: '';
				width: 0;
				height: 0;

				display: block;
				position: absolute;
				left: 50%;
				top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));

				transform: translateX(-50%);
				border-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;
				border-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));
				border-style: solid;
			}
		}
	}

	/*
	 * Styles of the widget that it a drop target.
	 */
	& .ck-widget.ck-clipboard-drop-target-range {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		zoom: 0.6;
		outline: none !important;
	}
}

.ck.ck-clipboard-drop-target-line {
	height: 0;
	border: 1px solid var(--ck-clipboard-drop-target-color);
	background: var(--ck-clipboard-drop-target-color);
	margin-top: -1px;

	&::before {
		content: '';
		position: absolute;
		top: calc(-.5 * var(--ck-clipboard-drop-target-dot-width));
		width: 0;
		height: 0;
		border-style: solid;

		@mixin ck-dir ltr {
			left: -1px;

			border-width: calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height);
			border-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);
		}

		@mixin ck-dir rtl {
			right: -1px;

			border-width:calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0;
			border-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3143: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor {
	/* All the elements within \`.ck-editor\` are positioned relatively to it.
	 If any element needs to be positioned with respect to the <body>, etc.,
	 it must land outside of the \`.ck-editor\` in DOM. */
	position: relative;

	& .ck-editor__top .ck-sticky-panel .ck-toolbar {
		/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */
		z-index: var(--ck-z-modal);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

.ck.ck-editor__top {
	& .ck-sticky-panel {
		& .ck-toolbar {
			@mixin ck-rounded-corners {
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}

			border-bottom-width: 0;
		}

		& .ck-sticky-panel__content_sticky .ck-toolbar {
			border-bottom-width: 1px;

			@mixin ck-rounded-corners {
				border-radius: 0;
			}
		}
	}
}

/* Note: Use ck-editor__main to make sure these styles don't apply to other editor types */
.ck.ck-editor__main > .ck-editor__editable {
	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */
	background: var(--ck-color-base-background);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not(.ck-focused) {
		border-color: var(--ck-color-base-border);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4717: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"],
                    names: [],
                    mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder,
.ck .ck-placeholder {
	position: relative;

	&::before {
		position: absolute;
		left: 0;
		right: 0;
		content: attr(data-placeholder);

		/* See ckeditor/ckeditor5#469. */
		pointer-events: none;
	}
}

/* See ckeditor/ckeditor5#1987. */
.ck.ck-read-only .ck-placeholder {
	&::before {
		display: none;
	}
}

/*
 * Rules for the \`ck-placeholder\` are loaded before the rules for \`ck-reset_all\` in the base CKEditor 5 DLL build.
 * This fix overwrites the incorrectly set \`position: static\` from \`ck-reset_all\`.
 * See https://github.com/ckeditor/ckeditor5/issues/11418.
 */
.ck.ck-reset_all .ck-placeholder {
	position: relative;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder, .ck .ck-placeholder {
	&::before {
		cursor: text;
		color: var(--ck-color-engine-placeholder-text);
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 9315: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"],
                    names: [],
                    mappings: "AAMA,qDACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Elements marked by the Renderer as hidden should be invisible in the editor. */
.ck.ck-editor__editable span[data-ck-unsafe-element] {
	display: none;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 8733: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"],
                    names: [],
                    mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-heading_heading1 {
	font-size: 20px;
}

.ck.ck-heading_heading2 {
	font-size: 17px;
}

.ck.ck-heading_heading3 {
	font-size: 14px;
}

.ck[class*="ck-heading_heading"] {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Resize dropdown's button label. */
.ck.ck-dropdown.ck-heading-dropdown {
	& .ck-dropdown__button .ck-button__label {
		width: 8em;
	}

	& .ck-dropdown__panel .ck-list__item {
		min-width: 18em;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3508: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;height:auto;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image{z-index:1}.ck.ck-editor__editable .image.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable .image-inline img{height:auto}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/image.css"],
                    names: [],
                    mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBA2BD,CAjBC,uBAEC,aAAc,CAad,WAAY,CAVZ,aAAc,CAGd,cAAe,CAGf,cAKD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAKA,+BACC,SASD,CAHC,kDACC,SACD,CAMD,sCACC,SAkBD,CAZC,yDACC,SAUD,CAHC,qEACC,YACD,CAMF,0CACC,WACD,CAMC,0FACC,cACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content {
	& .image {
		display: table;
		clear: both;
		text-align: center;

		/* Make sure there is some space between the content and the image. Center image by default. */
		/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	 	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
		margin: 0.9em auto;

		/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */
		min-width: 50px;

		& img {
			/* Prevent unnecessary margins caused by line-height (see #44). */
			display: block;

			/* Center the image if its width is smaller than the content's width. */
			margin: 0 auto;

			/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */
			max-width: 100%;

			/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */
			min-width: 100%;

			/* Keep proportions of the block image if the height is set and the image is wider than the editor width.
			See https://github.com/ckeditor/ckeditor5/issues/14542. */
			height: auto;
		}
	}

	& .image-inline {
		/*
		 * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).
		 * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.
		 * This strange behavior does not happen with inline-flex.
		 */
		display: inline-flex;

		/* While being resized, don't allow the image to exceed the width of the editing root. */
		max-width: 100%;

		/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */
		align-items: flex-start;

		/* When the picture is present it must act as a flex container to let the img resize properly */
		& picture {
			display: flex;
		}

		/* When the picture is present, it must act like a resizable img. */
		& picture,
		& img {
			/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */
			flex-grow: 1;
			flex-shrink: 1;

			/* Prevents overflowing the editing root boundaries when an inline image is very wide. */
			max-width: 100%;
		}
	}
}

.ck.ck-editor__editable {
	/*
	 * Inhertit the content styles padding of the <figcaption> in case the integration overrides \`text-align: center\`
	 * of \`.image\` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native
	 * caret does, and not at the edge of <figcaption>.
	 */
	& .image > figcaption.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the image caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	/*
	 * See https://github.com/ckeditor/ckeditor5/issues/15115.
	 */
	& .image {
		z-index: 1;

		/*
		 * Make sure the selected image always stays on top of its siblings.
		 * See https://github.com/ckeditor/ckeditor5/issues/9108.
		 */
		&.ck-widget_selected {
			z-index: 2;
		}
	}

	/*
	 * See https://github.com/ckeditor/ckeditor5/issues/15115.
	 */
	& .image-inline {
		z-index: 1;

		/*
		 * Make sure the selected inline image always stays on top of its siblings.
		 * See https://github.com/ckeditor/ckeditor5/issues/9108.
		 */
		&.ck-widget_selected {
			z-index: 2;

			/*
			 * Make sure the native browser selection style is not displayed.
			 * Inline image widgets have their own styles for the selected state and
			 * leaving this up to the browser is asking for a visual collision.
			 */
			& ::selection {
				display: none;
			}
		}
	}

	/* Keep proportions of the inline image if the height is set and the image is wider than the editor width.
	See https://github.com/ckeditor/ckeditor5/issues/14542. */
	& .image-inline img {
		height: auto;
	}

	/* The inline image nested in the table should have its original size if not resized.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline img {
			max-width: none;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 2640: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css"],
                    names: [],
                    mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-caption-background: hsl(0, 0%, 97%);
	--ck-color-image-caption-text: hsl(0, 0%, 20%);
	--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .image > figcaption {
	display: table-caption;
	caption-side: bottom;
	word-break: break-word;
	color: var(--ck-color-image-caption-text);
	background-color: var(--ck-color-image-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;
}

/* Editing styles */
.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {
	animation: ck-image-caption-highlight .6s ease-out;
}

@keyframes ck-image-caption-highlight {
	0% {
		background-color: var(--ck-color-image-caption-highligted-background);
	}

	100% {
		background-color: var(--ck-color-image-caption-background);
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3535: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-image-insert-url .ck-image-insert-url__action-row{display:grid;grid-template-columns:repeat(2,1fr)}:root{--ck-image-insert-insert-by-url-width:250px}.ck.ck-image-insert-url{--ck-input-width:100%}.ck.ck-image-insert-url .ck-image-insert-url__action-row{grid-column-gap:var(--ck-spacing-large);margin-top:var(--ck-spacing-large)}.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button-cancel,.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button-save{justify-content:center;min-width:auto}.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}.ck.ck-image-insert-form>.ck.ck-button{display:block;padding:var(--ck-list-button-padding);width:100%}[dir=ltr] .ck.ck-image-insert-form>.ck.ck-button{text-align:left}[dir=rtl] .ck.ck-image-insert-form>.ck.ck-button{text-align:right}.ck.ck-image-insert-form>.ck.ck-collapsible:not(:first-child){border-top:1px solid var(--ck-color-base-border)}.ck.ck-image-insert-form>.ck.ck-collapsible:not(:last-child){border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-image-insert-form>.ck.ck-collapsible,.ck.ck-image-insert-form>.ck.ck-image-insert-url{min-width:var(--ck-image-insert-insert-by-url-width)}.ck.ck-image-insert-form>.ck.ck-image-insert-url{padding:var(--ck-spacing-large)}.ck.ck-image-insert-form:focus{outline:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageinsert.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageinsert.css"],
                    names: [],
                    mappings: "AAMC,yDACC,YAAa,CACb,mCACD,CCFD,MACC,2CACD,CAEA,wBACC,qBAgBD,CAdC,yDACC,uCAAwC,CACxC,kCAWD,CATC,oJAEC,sBAAuB,CACvB,cACD,CAEA,sFACC,0BACD,CAKD,uCACC,aAAc,CAEd,qCAAsC,CADtC,UAUD,CAZA,iDAME,eAMF,CAZA,iDAUE,gBAEF,CAGC,8DACC,gDACD,CAEA,6DACC,mDACD,CAMD,6FAJC,oDAOD,CAHA,iDAEC,+BACD,CAEA,+BACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-image-insert-url {
	& .ck-image-insert-url__action-row {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-image-insert-insert-by-url-width: 250px;
}

.ck.ck-image-insert-url {
	--ck-input-width: 100%;

	& .ck-image-insert-url__action-row {
		grid-column-gap: var(--ck-spacing-large);
		margin-top: var(--ck-spacing-large);

		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
			min-width: auto;
		}

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}

.ck.ck-image-insert-form {
	& > .ck.ck-button {
		display: block;
		width: 100%;
		padding: var(--ck-list-button-padding);

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& > .ck.ck-collapsible {
		&:not(:first-child) {
			border-top: 1px solid var(--ck-color-base-border);
		}

		&:not(:last-child) {
			border-bottom: 1px solid var(--ck-color-base-border);
		}

		min-width: var(--ck-image-insert-insert-by-url-width);
	}

	/* This is the case when there are no other integrations configured than insert by URL */
	& > .ck.ck-image-insert-url {
		min-width: var(--ck-image-insert-insert-by-url-width);
		padding: var(--ck-spacing-large);
	}

	&:focus {
		outline: none;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 2873: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-editor__editable img.image_placeholder{background-size:100% 100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageplaceholder.css"],
                    names: [],
                    mappings: "AAMC,8CACC,yBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& img.image_placeholder {
		background-size: 100% 100%;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6270: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-content img.image_resized{height:auto}.ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageresize.css"],
                    names: [],
                    mappings: "AAMA,8BACC,WACD,CAEA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Preserve aspect ratio of the resized image after introducing image height attribute. */
.ck-content img.image_resized {
	height: auto;
}

.ck-content .image.image_resized {
	max-width: 100%;
	/*
	The \`<figure>\` element for resized images must not use \`display:table\` as browsers do not support \`max-width\` for it well.
	See https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.
	Fortunately, since we control the width, there is no risk that the image will look bad.
	*/
	display: block;
	box-sizing: border-box;

	& img {
		/* For resized images it is the \`<figure>\` element that determines the image width. */
		width: 100%;
	}

	& > figcaption {
		/* The \`<figure>\` element uses \`display:block\`, so \`<figcaption>\` also has to. */
		display: block;
	}
}

.ck.ck-editor__editable {
	/* The resized inline image nested in the table should respect its parent size.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline.image_resized img {
			max-width: 100%;
		}
	}
}

[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-right: var(--ck-spacing-standard);
}

[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-left: var(--ck-spacing-standard);
}

.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {
	width: 4em;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 5083: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"],
                    names: [],
                    mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-image-style-spacing: 1.5em;
	--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);
}

.ck-content {
	/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback
	confirming successful application of the style if image width exceeds the editor's size.
	See https://github.com/ckeditor/ckeditor5/issues/9342 */
	& .image-style-block-align-left,
	& .image-style-block-align-right {
		max-width: calc(100% - var(--ck-image-style-spacing));
	}

	/* Allows displaying multiple floating images in the same line.
	See https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */
	& .image-style-align-left,
	& .image-style-align-right {
		clear: none;
	}

	& .image-style-side {
		float: right;
		margin-left: var(--ck-image-style-spacing);
		max-width: 50%;
	}

	& .image-style-align-left {
		float: left;
		margin-right: var(--ck-image-style-spacing);
	}

	& .image-style-align-center {
		margin-left: auto;
		margin-right: auto;
	}

	& .image-style-align-right {
		float: right;
		margin-left: var(--ck-image-style-spacing);
	}

	& .image-style-block-align-right {
		margin-right: 0;
		margin-left: auto;
	}

	& .image-style-block-align-left {
		margin-left: 0;
		margin-right: auto;
	}

	/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */
	& p + .image-style-align-left,
	& p + .image-style-align-right,
	& p + .image-style-side {
		margin-top: 0;
	}

	& .image-inline {
		&.image-style-align-left,
		&.image-style-align-right {
			margin-top: var(--ck-inline-image-style-spacing);
			margin-bottom: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-left {
			margin-right: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-right {
			margin-left: var(--ck-inline-image-style-spacing);
		}
	}
}

.ck.ck-splitbutton {
	/* The button should display as a regular drop-down if the action button
	is forced to fire the same action as the arrow button. */
	&.ck-splitbutton_flatten {
		&:hover,
		&.ck-splitbutton_open {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-background);

				&::after {
					display: none;
				}
			}
		}

		&.ck-splitbutton_open:hover {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-hover-background);
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4036: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"],
                    names: [],
                    mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-image-upload-complete-icon {
	display: block;
	position: absolute;

	/*
	 * Smaller images should have the icon closer to the border.
	 * Match the icon position with the linked image indicator brought by the link image feature.
	 */
	top: min(var(--ck-spacing-medium), 6%);
	right: min(var(--ck-spacing-medium), 6%);
	border-radius: 50%;
	z-index: 1;

	&::after {
		content: "";
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-upload-icon: hsl(0, 0%, 100%);
	--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);

	/* Match the icon size with the linked image indicator brought by the link image feature. */
	--ck-image-upload-icon-size: 20;
	--ck-image-upload-icon-width: 2px;
	--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck-image-upload-complete-icon {
	opacity: 0;
	background: var(--ck-color-image-upload-icon-background);
	animation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;
	animation-fill-mode: forwards, forwards;
	animation-duration: 500ms, 500ms;

	/* To make animation scalable. */
	font-size: calc(1px * var(--ck-image-upload-icon-size));

	/* Hide completed upload icon after 3 seconds. */
	animation-delay: 0ms, 3000ms;

	/*
	 * Use CSS math to simulate container queries.
	 * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
	 */
	overflow: hidden;
	width: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));
	height: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));

	/* This is check icon element made from border-width mixed with animations. */
	&::after {
		/* Because of border transformation we need to "hard code" left position. */
		left: 25%;

		top: 50%;
		opacity: 0;
		height: 0;
		width: 0;

		transform: scaleX(-1) rotate(135deg);
		transform-origin: left top;
		border-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);
		border-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);

		animation-name: ck-upload-complete-icon-check;
		animation-duration: 500ms;
		animation-delay: 500ms;
		animation-fill-mode: forwards;

		/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */
		box-sizing: border-box;
	}
}

@keyframes ck-upload-complete-icon-show {
	from {
		opacity: 0;
	}

	to {
		opacity: 1;
	}
}

@keyframes ck-upload-complete-icon-hide {
	from {
		opacity: 1;
	}

	to {
		opacity: 0;
	}
}

@keyframes ck-upload-complete-icon-check {
	0% {
		opacity: 1;
		width: 0;
		height: 0;
	}
	33% {
		width: 0.3em;
		height: 0;
	}
	100% {
		opacity: 1;
		width: 0.3em;
		height: 0.45em;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3773: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"],
                    names: [],
                    mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-upload-placeholder-loader {
	position: absolute;
	display: flex;
	align-items: center;
	justify-content: center;
	top: 0;
	left: 0;

	&::before {
		content: '';
		position: relative;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);
	--ck-upload-placeholder-loader-size: 32px;
	--ck-upload-placeholder-image-aspect-ratio: 2.8;
}

.ck .ck-image-upload-placeholder {
	/* We need to control the full width of the SVG gray background. */
	width: 100%;
	margin: 0;

	&.image-inline {
		width: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );
	}

	& img {
		/*
		 * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.
		 * There's nothing special about this number except that it should make the image placeholder look like
		 * a real image during this short period after the upload started and before the image was read from the
		 * file system (and a rich preview was loaded).
		 */
		aspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);
	}
}

.ck .ck-upload-placeholder-loader {
	width: 100%;
	height: 100%;

	&::before {
		width: var(--ck-upload-placeholder-loader-size);
		height: var(--ck-upload-placeholder-loader-size);
		border-radius: 50%;
		border-top: 3px solid var(--ck-color-upload-placeholder-loader);
		border-right: 2px solid transparent;
		animation: ck-upload-placeholder-loader 1s linear infinite;
	}
}

@keyframes ck-upload-placeholder-loader {
	to {
		transform: rotate( 360deg );
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3689: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"],
                    names: [],
                    mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		position: relative;
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		position: absolute;
		top: 0;
		left: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		/* Showing animation. */
		&.ck-appear {
			animation: fadeIn 700ms;
		}
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		height: 2px;
		width: 0;
		background: var(--ck-color-upload-bar-background);
		transition: width 100ms;
	}
}

@keyframes fadeIn {
	from { opacity: 0; }
	to   { opacity: 1; }
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 1905: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                    names: [],
                    mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-text-alternative-form {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-labeled-field-view {
		display: inline-block;
	}

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 9773: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"],
                    names: [],
                    mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Class added to span element surrounding currently selected link. */
.ck .ck-link_selected {
	background: var(--ck-color-link-selected-background);

	/* Give linked inline images some outline to let the user know they are also part of the link. */
	& span.image-inline {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);
	}
}

/*
 * Classes used by the "fake visual selection" displayed in the content when an input
 * in the link UI has focus (the browser does not render the native selection in this state).
 */
.ck .ck-fake-link-selection {
	background: var(--ck-color-link-fake-selection);
}

/* A collapsed fake visual selection. */
.ck .ck-fake-link-selection_collapsed {
	height: 100%;
	border-right: 1px solid var(--ck-color-base-text);
	margin-right: -1px;
	outline: solid 1px hsla(0, 0%, 100%, .5);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 2347: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"],
                    names: [],
                    mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-link-actions__preview {
		display: inline-block;

		& .ck-button__label {
			overflow: hidden;
		}
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-link-actions__preview {
			flex-basis: 100%;
		}

		& .ck-button:not(.ck-link-actions__preview) {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	& .ck-button.ck-link-actions__preview {
		padding-left: 0;
		padding-right: 0;

		& .ck-button__label {
			padding: 0 var(--ck-spacing-medium);
			color: var(--ck-color-link-default);
			text-overflow: ellipsis;
			cursor: pointer;

			/* Match the box model of the link editor form's input so the balloon
			does not change width when moving between actions and the form. */
			max-width: var(--ck-input-width);
			min-width: 3em;
			text-align: center;

			&:hover {
				text-decoration: underline;
			}
		}

		&,
		&:hover,
		&:focus,
		&:active {
			background: none;
		}

		&:active {
			box-shadow: none;
		}

		&:focus {
			& .ck-button__label {
				text-decoration: underline;
			}
		}
	}

	@mixin ck-dir ltr {
		& .ck-button:not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-button:not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		& .ck-button.ck-link-actions__preview {
			margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;

			& .ck-button__label {
				min-width: 0;
				max-width: 100%;
			}
		}

		& .ck-button:not(.ck-link-actions__preview) {
			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 7754: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"],
                    names: [],
                    mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-form {
	display: flex;

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	display: block;

	/*
	 * Whether the form is in the responsive mode or not, if there are decorator buttons
	 * keep the top margin of action buttons medium.
	 */
	& .ck-button {
		&.ck-button-save,
		&.ck-button-cancel {
			margin-top: var(--ck-spacing-medium);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	padding: 0;
	min-width: var(--ck-input-width);

	& .ck-labeled-field-view {
		margin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);

		& .ck-input-text {
			min-width: 0;
			width: 100%;
		}
	}

	& > .ck-button {
		padding: var(--ck-spacing-standard);
		margin: 0;
		width: 50%;
		border-radius: 0;

		&:not(:focus) {
			border-top: 1px solid var(--ck-color-base-border);
		}

		@mixin ck-dir ltr {
			margin-left: 0;
		}

		@mixin ck-dir rtl {
			margin-left: 0;

			&:last-of-type {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}
	}

	/* Using additional \`.ck\` class for stronger CSS specificity than \`.ck.ck-link-form > :not(:first-child)\`. */
	& .ck.ck-list {
		margin: var(--ck-spacing-standard) var(--ck-spacing-large);

		& .ck-button.ck-switchbutton {
			padding: 0;
			width: 100%;

			&:hover {
				background: none;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 111: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-link/theme/linkimage.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"],
                    names: [],
                    mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			display: block;
			position: absolute;
		}
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Match the icon size with the upload indicator brought by the image upload feature. */
	--ck-link-image-indicator-icon-size: 20;
	--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			content: "";

			/*
			 * Smaller images should have the icon closer to the border.
			 * Match the icon position with the upload indicator brought by the image upload feature.
			 */
			top: min(var(--ck-spacing-medium), 6%);
			right: min(var(--ck-spacing-medium), 6%);

			background-color: hsla(0, 0%, 0%, .4);
			background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");
			background-size: 14px;
			background-repeat: no-repeat;
			background-position: center;
			border-radius: 100%;

			/*
			* Use CSS math to simulate container queries.
			* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
			*/
			overflow: hidden;
			width: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
			height: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
		}
	}
}

`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 5730: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/documentlist.css"],
                    names: [],
                    mappings: "AAKA,8CACC,aACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-editor__editable .ck-list-bogus-paragraph {
	display: block;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4564: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/list.css"],
                    names: [],
                    mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content ol {
	list-style-type: decimal;

	& ol {
		list-style-type: lower-latin;

		& ol {
			list-style-type: lower-roman;

			& ol {
				list-style-type: upper-latin;

				& ol {
					list-style-type: upper-roman;
				}
			}
		}
	}
}

.ck-content ul {
	list-style-type: disc;

	& ul {
		list-style-type: circle;

		& ul {
			list-style-type: square;

			& ul {
				list-style-type: square;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6082: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"],
                    names: [],
                    mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-properties {
	/* When there are no list styles and there is no collapsible. */
	&.ck-list-properties_without-styles {
		padding: var(--ck-spacing-large);

		& > * {
			min-width: 14em;

			& + * {
				margin-top: var(--ck-spacing-standard);
			}
		}
	}

	/*
	 * When the numbered list property fields (start at, reversed) should be displayed,
	 * more horizontal space is needed. Reconfigure the style grid to create that space.
	 */
	&.ck-list-properties_with-numbered-properties {
		& > .ck-list-styles-list {
			grid-template-columns: repeat( 4, auto );
		}

		/* When list styles are rendered and property fields are in a collapsible. */
		& > .ck-collapsible {
			border-top: 1px solid var(--ck-color-base-border);

			& > .ck-collapsible__children {
				& > * {
					width: 100%;

					& + * {
						margin-top: var(--ck-spacing-standard);
					}
				}
			}
		}
	}

	& .ck.ck-numbered-list-properties__start-index .ck-input {
		min-width: auto;
		width: 100%;
	}

	& .ck.ck-numbered-list-properties__reversed-order {
		background: transparent;
		padding-left: 0;
		padding-right: 0;
		margin-bottom: calc(-1 * var(--ck-spacing-tiny));

		&:active, &:hover {
			box-shadow: none;
			border-color: transparent;
			background: none;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 2417: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/liststyles.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"],
                    names: [],
                    mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-styles-list {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-list-style-button-size: 44px;
}

.ck.ck-list-styles-list {
	grid-template-columns: repeat( 3, auto );
	row-gap: var(--ck-spacing-medium);
	column-gap: var(--ck-spacing-medium);
	padding: var(--ck-spacing-large);

	& .ck-button {
		/* Make the button look like a thumbnail (the icon "takes it all"). */
		width: var(--ck-list-style-button-size);
		height: var(--ck-list-style-button-size);
		padding: 0;

		/*
		 * Buttons are aligned by the grid so disable default button margins to not collide with the
		 * gaps in the grid.
		 */
		margin: 0;

		/*
		 * Make sure the button border (which is displayed on focus, BTW) does not steal pixels
		 * from the button dimensions and, as a result, decrease the size of the icon
		 * (which becomes blurry as it scales down).
		 */
		box-sizing: content-box;

		& .ck-icon {
			width: var(--ck-list-style-button-size);
			height: var(--ck-list-style-button-size);
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 1199: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px;position:relative}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}.ck-editor__editable.ck-content .todo-list .todo-list__label>input,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{cursor:pointer}.ck-editor__editable.ck-content .todo-list .todo-list__label>input:hover:before,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-editor__editable.ck-content[dir=rtl] .todo-list .todo-list__label>span[contenteditable=false]>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:after{border-color:#fff}.ck-editor__editable.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/todolist.css"],
                    names: [],
                    mappings: "AAKA,MACC,kCACD,CAwEA,uBACC,eAwBD,CAtBC,0BAEC,iBAAkB,CADlB,iBAMD,CAHC,qCACC,cACD,CAIA,+CAlFD,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAiFC,CAFA,wDAhEA,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAgEA,CA5DD,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,sCAAwC,CAJxC,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAwBA,wEACC,qBACD,CAEA,mGACC,iBACD,CAYD,kKAEC,cAKD,CAHC,4LACC,mCACD,CAMD,+FApHA,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAmHA,CAFA,wGAlGC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAkGD,CA9FA,sGAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,sCAAwC,CAJxC,UAKD,CAEA,qGAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+GACC,kBAA8B,CAC9B,oBACD,CAEA,8GACC,iBACD,CA2DA,uHACC,iBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-todo-list-checkmark-size: 16px;
}

@define-mixin todo-list-checkbox {
	-webkit-appearance: none;
	display: inline-block;
	position: relative;
	width: var(--ck-todo-list-checkmark-size);
	height: var(--ck-todo-list-checkmark-size);
	vertical-align: middle;

	/* Needed on iOS */
	border: 0;

	/* LTR styles */
	left: -25px;
	margin-right: -15px;
	right: 0;
	margin-left: 0;

	/* RTL styles */
	@nest [dir=rtl]& {
		left: 0;
		margin-right: 0;
		right: -25px;
		margin-left: -15px;
	}

	&::before {
		display: block;
		position: absolute;
		box-sizing: border-box;
		content: '';
		width: 100%;
		height: 100%;
		border: 1px solid hsl(0, 0%, 20%);
		border-radius: 2px;
		transition: 250ms ease-in-out box-shadow;
	}

	&::after {
		display: block;
		position: absolute;
		box-sizing: content-box;
		pointer-events: none;
		content: '';

		/* Calculate tick position, size and border-width proportional to the checkmark size. */
		left: calc( var(--ck-todo-list-checkmark-size) / 3 );
		top: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
		width: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
		height: calc( var(--ck-todo-list-checkmark-size) / 2.6 );
		border-style: solid;
		border-color: transparent;
		border-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;
		transform: rotate(45deg);
	}

	&[checked] {
		&::before {
			background: hsl(126, 64%, 41%);
			border-color: hsl(126, 64%, 41%);
		}

		&::after {
			border-color: hsl(0, 0%, 100%);
		}
	}
}

/*
 * To-do list content styles.
 */
.ck-content .todo-list {
	list-style: none;

	& li {
		position: relative;
		margin-bottom: 5px;

		& .todo-list {
			margin-top: 5px;
		}
	}

	& .todo-list__label {
		& > input {
			@mixin todo-list-checkbox;
		}

		& .todo-list__label__description {
			vertical-align: middle;
		}

		&.todo-list__label_without-description input[type=checkbox] {
			position: absolute;
		}
	}
}

/*
 * To-do list editing view styles.
 */
.ck-editor__editable.ck-content .todo-list .todo-list__label {
	/*
	 * To-do list should be interactive only during the editing
	 * (https://github.com/ckeditor/ckeditor5/issues/2090).
	 */
	& > input,
	& > span[contenteditable=false] > input {
		cursor: pointer;

		&:hover::before {
			box-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);
		}
	}

	/*
	 * Document Lists - editing view has an additional span around checkbox.
	 */
	& > span[contenteditable=false] > input {
		@mixin todo-list-checkbox;
	}

	&.todo-list__label_without-description {
		& input[type=checkbox] {
			position: absolute;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4652: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembed.css"],
                    names: [],
                    mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .media {
	/* Don't allow floated content overlap the media.
	https://github.com/ckeditor/ckeditor5-media-embed/issues/53 */
	clear: both;

	/* Make sure there is some space between the content and the media. */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em 0;

	/* Make sure media is not overriden with Bootstrap default \`flex\` value.
	See: https://github.com/ckeditor/ckeditor5/issues/1373. */
	display: block;

	/* Give the media some minimal width in the content to prevent them
	from being "squashed" in tight spaces, e.g. in table cells (#44) */
	min-width: 15em;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 7442: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"],
                    names: [],
                    mappings: "AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-media__wrapper {
	& .ck-media__placeholder {
		display: flex;
		flex-direction: column;
		align-items: center;

		& .ck-media__placeholder__url {
			/* Otherwise the URL will overflow when the content is very narrow. */
			max-width: 100%;

			position: relative;

			& .ck-media__placeholder__url__text {
				overflow: hidden;
				display: block;
			}
		}
	}

	&[data-oembed-url*="twitter.com"],
	&[data-oembed-url*="google.com/maps"],
	&[data-oembed-url*="goo.gl/maps"],
	&[data-oembed-url*="maps.google.com"],
	&[data-oembed-url*="maps.app.goo.gl"],
	&[data-oembed-url*="facebook.com"],
	&[data-oembed-url*="instagram.com"] {
		& .ck-media__placeholder__icon * {
			display: none;
		}
	}
}

/* Disable all mouse interaction as long as the editor is not read–only.
   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */
.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {
	pointer-events: none;
}

/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).
   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */
.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {
	pointer-events: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-media-embed-placeholder-icon-size: 3em;

	--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);
	--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);
}

.ck-media__wrapper {
	margin: 0 auto;

	& .ck-media__placeholder {
		padding: calc( 3 * var(--ck-spacing-standard) );
		background: var(--ck-color-base-foreground);

		& .ck-media__placeholder__icon {
			min-width: var(--ck-media-embed-placeholder-icon-size);
			height: var(--ck-media-embed-placeholder-icon-size);
			margin-bottom: var(--ck-spacing-large);
			background-position: center;
			background-size: cover;

			& .ck-icon {
				width: 100%;
				height: 100%;
			}
		}

		& .ck-media__placeholder__url__text {
			color: var(--ck-color-media-embed-placeholder-url-text);
			white-space: nowrap;
			text-align: center;
			font-style: italic;
			text-overflow: ellipsis;

			&:hover {
				color: var(--ck-color-media-embed-placeholder-url-text-hover);
				cursor: pointer;
				text-decoration: underline;
			}
		}
	}

	&[data-oembed-url*="open.spotify.com"] {
		max-width: 300px;
		max-height: 380px;
	}

	&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,
	&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,
	&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,
	&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {
		background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);
	}

	&[data-oembed-url*="facebook.com"] .ck-media__placeholder {
		background: hsl(220, 46%, 48%);

		& .ck-media__placeholder__icon {
			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);
		}

		& .ck-media__placeholder__url__text {
			color: hsl(220, 100%, 90%);

			&:hover {
				color: hsl(0, 0%, 100%);
			}
		}
	}

	&[data-oembed-url*="instagram.com"] .ck-media__placeholder {
		background: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));

		& .ck-media__placeholder__icon {
			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);
		}

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-media__placeholder__url__text {
			color: hsl(302, 100%, 94%);

			&:hover {
				color: hsl(0, 0%, 100%);
			}
		}
	}

	&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {
		/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */
		background: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );

		& .ck-media__placeholder__icon {
			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);
		}

		& .ck-media__placeholder__url__text {
			color: hsl(201, 100%, 86%);

			&:hover {
				color: hsl(0, 0%, 100%);
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 9292: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-media-embed/theme/mediaform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                    names: [],
                    mappings: "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-media-form {
	display: flex;
	align-items: flex-start;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-labeled-field-view {
		display: inline-block;
	}

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 7368: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-input-color {
	width: 100%;
	display: flex;
	flex-direction: row-reverse;

	& > input.ck.ck-input-text {
		min-width: auto;
		flex-grow: 1;
	}

	& > div.ck.ck-dropdown {
		min-width: auto;

		/* This dropdown has no arrow but a color preview instead. */
		& > .ck-input-color__button .ck-dropdown__arrow {
			display: none;
		}
	}

	& .ck.ck-input-color__button {
		/* Resolving issue with misaligned buttons on Safari (see #10589) */
		display: flex;

		& .ck.ck-input-color__button__preview {
			position: relative;
			overflow: hidden;

			& > .ck.ck-input-color__button__preview__no-color-indicator {
				position: absolute;
				display: block;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_rounded.css";

.ck.ck-input-color {
	& > .ck.ck-input-text {
		@mixin ck-dir ltr {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* Make sure the focused input is always on top of the dropdown button so its
		   outline and border are never cropped (also when the input is read-only). */
		&:focus {
			z-index: 0;
		}
	}

	& > .ck.ck-dropdown {
		& > .ck.ck-button.ck-input-color__button {
			padding: 0;

			@mixin ck-dir ltr {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;

				&:not(:focus) {
					border-left: 1px solid transparent;
				}
			}

			@mixin ck-dir rtl {
				border-top-right-radius: 0;
				border-bottom-right-radius: 0;

				&:not(:focus) {
					border-right: 1px solid transparent;
				}
			}

			&.ck-disabled {
				background: var(--ck-color-input-disabled-background);
			}

			& > .ck.ck-input-color__button__preview {
				@mixin ck-rounded-corners;

				width: 20px;
				height: 20px;
				border: 1px solid var(--ck-color-input-border);

				& > .ck.ck-input-color__button__preview__no-color-indicator {
					top: -30%;
					left: 50%;
					height: 150%;
					width: 8%;
					background: hsl(0, 100%, 50%);
					border-radius: 2px;
					transform: rotate(45deg);
					transform-origin: 50%;
				}
			}
		}
	}

	& .ck.ck-input-color__remove-color {
		width: 100%;
		padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);

		border-bottom-left-radius: 0;
		border-bottom-right-radius: 0;

		&:not(:focus) {
			border-bottom: 1px solid var(--ck-color-input-border);
		}

		@mixin ck-dir ltr {
			border-top-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
		}

		& .ck.ck-icon {
			margin-right: var(--ck-spacing-standard);

			@mixin ck-dir rtl {
				margin-right: 0;
				margin-left: var(--ck-spacing-standard);
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4070: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/form.css"],
                    names: [],
                    mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form {
	padding: 0 0 var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	& .ck.ck-input-text {
		min-width: 100%;
		width: 0;
	}

	& .ck.ck-dropdown {
		min-width: 100%;

		& .ck-dropdown__button {
			&:not(:focus) {
				border: 1px solid var(--ck-color-base-border);
			}

			& .ck-button__label {
				width: 100%;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 9247: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/formrow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"],
                    names: [],
                    mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		flex-grow: 1;
	}

	&.ck-table-form__action-row {
		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-form__row {
	padding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		& + * {
			@mixin ck-dir ltr {
				margin-left: var(--ck-spacing-large);
			}

			@mixin ck-dir rtl {
				margin-right: var(--ck-spacing-large);
			}
		}
	}

	& > .ck-label {
		width: 100%;
		min-width: 100%;
	}

	&.ck-table-form__action-row {
		margin-top: var(--ck-spacing-large);

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 1613: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"],
                    names: [],
                    mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-insert-table-dropdown__grid {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-insert-table-dropdown-padding: 10px;
	--ck-insert-table-dropdown-box-height: 11px;
	--ck-insert-table-dropdown-box-width: 12px;
	--ck-insert-table-dropdown-box-margin: 1px;
}

.ck .ck-insert-table-dropdown__grid {
	/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */
	width: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);
	padding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;
}

.ck .ck-insert-table-dropdown__label,
.ck[dir=rtl] .ck-insert-table-dropdown__label {
	text-align: center;
}

.ck .ck-insert-table-dropdown-grid-box {
	min-width: var(--ck-insert-table-dropdown-box-width);
	min-height: var(--ck-insert-table-dropdown-box-height);
	margin: var(--ck-insert-table-dropdown-box-margin);
	border: 1px solid var(--ck-color-base-border);
	border-radius: 1px;
	outline: none;
	transition: none;

	&:focus {
		box-shadow: none;
	}

	&.ck-on {
		border-color: var(--ck-color-focus-border);
		background: var(--ck-color-focus-outer-shadow);
	}
}

`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6306: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/table.css"],
                    names: [],
                    mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .table {
	/* Give the table widget some air and center it horizontally */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	display: table;

	& table {
		/* The table cells should have slight borders */
		border-collapse: collapse;
		border-spacing: 0;

		/* Table width and height are set on the parent <figure>. Make sure the table inside stretches
		to the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */
		width: 100%;
		height: 100%;

		/* The outer border of the table should be slightly darker than the inner lines.
		Also see https://github.com/ckeditor/ckeditor5-table/issues/50. */
		border: 1px double hsl(0, 0%, 70%);

		& td,
		& th {
			min-width: 2em;
			padding: .4em;

			/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it's not necessary here.
			However, the border is a content style, so it should use .ck-content (so it works outside the editor).
			Hence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */
			border: 1px solid hsl(0, 0%, 75%);
		}

		& th {
			font-weight: bold;
			background: hsla(0, 0%, 0%, 5%);
		}
	}
}

/* Text alignment of the table header should match the editor settings and override the native browser styling,
when content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */
.ck-content[dir="rtl"] .table th {
	text-align: right;
}

.ck-content[dir="ltr"] .table th {
	text-align: left;
}

.ck-editor__editable .ck-table-bogus-paragraph {
	/*
	 * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
	 * See https://github.com/ckeditor/ckeditor5/issues/6062.
	 */
	display: inline-block;

	/*
	 * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.
	 * See https://github.com/ckeditor/ckeditor5/issues/9117.
	 */
	width: 100%;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 2128: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-color-selector-caption-background:#f7f7f7;--ck-color-selector-caption-text:#333;--ck-color-selector-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-selector-caption-background);caption-side:top;color:var(--ck-color-selector-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-selector-caption-highlighted-background)}to{background-color:var(--ck-color-selector-caption-background)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecaption.css"],
                    names: [],
                    mappings: "AAKA,MACC,8CAAuD,CACvD,qCAAiD,CACjD,uDACD,CAGA,8BAMC,4DAA6D,CAJ7D,gBAAiB,CAGjB,2CAA4C,CAJ5C,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,wEACD,CAEA,GACC,4DACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-selector-caption-background: hsl(0, 0%, 97%);
	--ck-color-selector-caption-text: hsl(0, 0%, 20%);
	--ck-color-selector-caption-highlighted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .table > figcaption {
	display: table-caption;
	caption-side: top;
	word-break: break-word;
	text-align: center;
	color: var(--ck-color-selector-caption-text);
	background-color: var(--ck-color-selector-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;
}

/* Editing styles */
.ck.ck-editor__editable .table > figcaption {
	&.table__caption_highlighted {
		animation: ck-table-caption-highlight .6s ease-out;
	}

	&.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the table caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}
}

@keyframes ck-table-caption-highlight {
	0% {
		background-color: var(--ck-color-selector-caption-highlighted-background);
	}

	100% {
		background-color: var(--ck-color-selector-caption-background);
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 5087: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecellproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"],
                    names: [],
                    mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	& .ck-form__row {
		&.ck-table-cell-properties-form__alignment-row {
			flex-wrap: wrap;

			& .ck.ck-toolbar {
				&:first-of-type {
					/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */
					flex-grow: 0.57;
				}

				&:last-of-type {
					/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */
					flex-grow: 0.43;
				}

				& .ck-button {
					flex-grow: 1;
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-cell-properties-form__padding-row {
			align-self: flex-end;
			padding: 0;
			width: 25%;
		}

		&.ck-table-cell-properties-form__alignment-row {
			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4101: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-color-selector-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{overflow-wrap:break-word;position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:0;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:0;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-selector-column-resizer-hover);bottom:-999999px;opacity:.25;top:-999999px}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecolumnresize.css"],
                    names: [],
                    mappings: "AAKA,MACC,oEAAqE,CACrE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAIC,wBAAyB,CACzB,iBACD,CAEA,wDAGC,QAAS,CAGT,iBAAkB,CALlB,iBAAkB,CAGlB,oDAAqD,CAFrD,KAAM,CAKN,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,8DAA+D,CAO/D,gBAAiB,CANjB,WAAa,CAKb,aAED,CAEA,iEACC,mDAAoD,CACpD,WACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-selector-column-resizer-hover: var(--ck-color-base-active);
	--ck-table-column-resizer-width: 7px;

	/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.
	   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */
	--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);
}

.ck-content .table .ck-table-resized {
	table-layout: fixed;
}

.ck-content .table table {
	overflow: hidden;
}

.ck-content .table td,
.ck-content .table th {
	/* To prevent text overflowing beyond its cell when columns are resized by resize handler
	(https://github.com/ckeditor/ckeditor5/pull/14379#issuecomment-1589460978). */
	overflow-wrap: break-word;
	position: relative;
}

.ck.ck-editor__editable .table .ck-table-column-resizer {
	position: absolute;
	top: 0;
	bottom: 0;
	right: var(--ck-table-column-resizer-position-offset);
	width: var(--ck-table-column-resizer-width);
	cursor: col-resize;
	user-select: none;
	z-index: var(--ck-z-default);
}

.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {
	display: none;
}

/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,
   all resizers must be hidden while the table is dragged. */
.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {
	display: none;
}

.ck.ck-editor__editable .table .ck-table-column-resizer:hover,
.ck.ck-editor__editable .table .ck-table-column-resizer__active {
	background-color: var(--ck-color-selector-column-resizer-hover);
	opacity: 0.25;
	/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,
	   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as
	   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally
	   unrealistic height for a single table. */
	top: -999999px;
	bottom: -999999px;
}

.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {
	left: var(--ck-table-column-resizer-position-offset);
	right: unset;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3881: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-color-selector-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-selector-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"],
                    names: [],
                    mappings: "AAKA,MACC,gEACD,CAKE,8QAGC,2DAA4D,CAK5D,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-selector-focused-cell-background: hsla(212, 90%, 80%, .3);
}

.ck-widget.table {
	& td,
	& th {
		&.ck-editor__nested-editable.ck-editor__nested-editable_focused,
		&.ck-editor__nested-editable:focus {
			/* A very slight background to highlight the focused cell */
			background: var(--ck-color-selector-focused-cell-background);

			/* Fixes the problem where surrounding cells cover the focused cell's border.
			It does not fix the problem in all places but the UX is improved.
			See https://github.com/ckeditor/ckeditor5-table/issues/29. */
			border-style: none;
			outline: 1px solid var(--ck-color-focus-border);
			outline-offset: -1px; /* progressive enhancement - no IE support */
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6237: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__background-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__dimensions-row {
			flex-wrap: wrap;
			align-items: center;

			& .ck-labeled-field-view {
				display: flex;
				flex-direction: column-reverse;
				align-items: center;

				& .ck.ck-dropdown {
					flex-grow: 0;
				}
			}

			& .ck-table-form__dimension-operator {
				flex-grow: 0;
			}
		}
	}

	& .ck.ck-labeled-field-view {
		/* Allow absolute positioning of the status (error) balloons. */
		position: relative;

		& .ck.ck-labeled-field-view__status {
			position: absolute;
			left: 50%;
			bottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );
			transform: translate(-50%,100%);

			/* Make sure the balloon status stays on top of other form elements. */
			z-index: 1;

			/* The arrow pointing towards the field. */
			&::after {
				content: "";
				position: absolute;
				top: calc( -1 * var(--ck-table-properties-error-arrow-size) );
				left: 50%;
				transform: translateX( -50% );
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

:root {
	--ck-table-properties-error-arrow-size: 6px;
	--ck-table-properties-min-error-width: 150px;
}

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			& .ck-labeled-field-view {
				& > .ck-label {
					font-size: var(--ck-font-size-tiny);
					text-align: center;
				}
			}

			& .ck-table-form__border-style,
			& .ck-table-form__border-width {
				width: 80px;
				min-width: 80px;
				max-width: 80px;
			}
		}

		&.ck-table-form__dimensions-row {
			padding: 0;

			& .ck-table-form__dimensions-row__width,
			& .ck-table-form__dimensions-row__height {
				margin: 0
			}

			& .ck-table-form__dimension-operator {
				align-self: flex-end;
				display: inline-block;
				height: var(--ck-ui-component-min-height);
				line-height: var(--ck-ui-component-min-height);
				margin: 0 var(--ck-spacing-small);
			}
		}
	}

	& .ck.ck-labeled-field-view {
		padding-top: var(--ck-spacing-standard);

		& .ck.ck-labeled-field-view__status {
			@mixin ck-rounded-corners;

			background: var(--ck-color-base-error);
			color: var(--ck-color-base-background);
			padding: var(--ck-spacing-small) var(--ck-spacing-medium);
			min-width: var(--ck-table-properties-min-error-width);
			text-align: center;

			/* The arrow pointing towards the field. */
			&::after {
				border-color: transparent transparent var(--ck-color-base-error) transparent;
				border-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);
				border-style: solid;
			}

			animation: ck-table-form-labeled-view-status-appear .15s ease both;
		}

		/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */
		& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {
			display: none;
		}
	}
}

@keyframes ck-table-form-labeled-view-status-appear {
	0% {
		opacity: 0;
	}

	100% {
		opacity: 1;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 7341: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tableproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"],
                    names: [],
                    mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			flex-wrap: wrap;
			flex-basis: 0;
			align-content: baseline;

			& .ck.ck-toolbar .ck-toolbar__items {
				flex-wrap: nowrap;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			align-self: flex-end;
			padding: 0;

			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);

				& .ck-toolbar__items > * {
					width: 40px;
				}
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6945: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"],
                    names: [],
                    mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);
}

.ck.ck-editor__editable .table table {
	& td.ck-editor__editable_selected,
	& th.ck-editor__editable_selected {
		position: relative;
		caret-color: transparent;
		outline: unset;
		box-shadow: unset;

		/* https://github.com/ckeditor/ckeditor5/issues/6446 */
		&:after {
			content: '';
			pointer-events: none;
			background-color: var(--ck-table-selected-cell-background);
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
		}

		& ::selection,
		&:focus {
			background-color: transparent;
		}

		/*
		 * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.
		 * See https://github.com/ckeditor/ckeditor5/issues/9491.
		 */
		& .ck-widget {
			outline: unset;

			& > .ck-widget__selection-handle {
				display: none;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3210: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-aria-live-announcer{left:-10000px;position:absolute;top:-10000px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/arialiveannouncer/arialiveannouncer.css"],
                    names: [],
                    mappings: "AAKA,2BAEC,aAAc,CADd,iBAAkB,CAElB,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-aria-live-announcer {
	position: absolute;
	left: -10000px;
	top: -10000px;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 8157: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-autocomplete{position:relative}.ck.ck-autocomplete>.ck-search__results{position:absolute;z-index:var(--ck-z-modal)}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{bottom:100%}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{bottom:auto;top:100%}.ck.ck-autocomplete>.ck-search__results{border-radius:0}.ck-rounded-corners .ck.ck-autocomplete>.ck-search__results,.ck.ck-autocomplete>.ck-search__results.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-autocomplete>.ck-search__results{background:var(--ck-color-base-background);border:1px solid var(--ck-color-dropdown-panel-border);box-shadow:var(--ck-drop-shadow),0 0;max-height:200px;min-width:auto;overflow-y:auto}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{border-bottom-left-radius:0;border-bottom-right-radius:0;margin-bottom:-1px}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{border-top-left-radius:0;border-top-right-radius:0;margin-top:-1px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/autocomplete/autocomplete.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/autocomplete/autocomplete.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,oBACC,iBAeD,CAbC,wCACC,iBAAkB,CAClB,yBAUD,CARC,6DACC,WACD,CAEA,6DAEC,WAAY,CADZ,QAED,CCVD,wCCEA,eDuBA,CAzBA,uHCMC,qCDmBD,CAzBA,wCAMC,0CAA2C,CAC3C,sDAAuD,CEPxD,oCAA8B,CFI7B,gBAAiB,CAIjB,cAAe,CAHf,eAoBD,CAfC,6DACC,2BAA4B,CAC5B,4BAA6B,CAG7B,kBACD,CAEA,6DACC,wBAAyB,CACzB,yBAA0B,CAG1B,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-autocomplete {
	position: relative;

	& > .ck-search__results {
		position: absolute;
		z-index: var(--ck-z-modal);

		&.ck-search__results_n {
			bottom: 100%;
		}

		&.ck-search__results_s {
			top: 100%;
			bottom: auto;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";
@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";

.ck.ck-autocomplete {
	& > .ck-search__results {
		@mixin ck-rounded-corners;
		@mixin ck-drop-shadow;

		max-height: 200px;
		overflow-y: auto;
		background: var(--ck-color-base-background);
		border: 1px solid var(--ck-color-dropdown-panel-border);
		min-width: auto;

		&.ck-search__results_n {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;

			/* Prevent duplicated borders between the input and the results pane. */
			margin-bottom: -1px;
		}

		&.ck-search__results_s {
			border-top-left-radius: 0;
			border-top-right-radius: 0;

			/* Prevent duplicated borders between the input and the results pane. */
			margin-top: -1px;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4906: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}[dir=ltr] .ck.ck-button,[dir=ltr] a.ck.ck-button{justify-content:left}[dir=rtl] .ck.ck-button,[dir=rtl] a.ck.ck-button{justify-content:right}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                    names: [],
                    mappings: "AAQA,6BAMC,kBAAmB,CADnB,mBAAoB,CADpB,iBAAkB,CCHlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD0BD,CA9BA,iDASE,oBAqBF,CA9BA,iDAaE,qBAiBF,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEzBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";
@import "../../mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-unselectable;

	position: relative;
	display: inline-flex;
	align-items: center;

	@mixin ck-dir ltr {
		justify-content: left;
	}

	@mixin ck-dir rtl {
		justify-content: right;
	}

	& .ck-button__label {
		display: none;
	}

	&.ck-button_with-text {
		& .ck-button__label {
			display: inline-block;
		}
	}

	/* Center the icon horizontally in a button without text. */
	&:not(.ck-button_with-text)  {
		justify-content: center;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-button-colors --ck-color-button-default;
	@mixin ck-rounded-corners;

	white-space: nowrap;
	cursor: default;
	vertical-align: middle;
	padding: var(--ck-spacing-tiny);
	text-align: center;

	/* A very important piece of styling. Go to variable declaration to learn more. */
	min-width: var(--ck-ui-component-min-height);
	min-height: var(--ck-ui-component-min-height);

	/* Normalize the height of the line. Removing this will break consistent height
	among text and text-less buttons (with icons). */
	line-height: 1;

	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	/* Avoid flickering when the foucs border shows up. */
	border: 1px solid transparent;

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .2s ease-in-out, border .2s ease-in-out;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */
	-webkit-appearance: none;

	&:active,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	/* Allow icon coloring using the text "color" property. */
	& .ck-button__icon {
		& use,
		& use * {
			color: inherit;
		}
	}

	& .ck-button__label {
		/* Enable font size inheritance, which allows fluid UI scaling. */
		font-size: inherit;
		font-weight: inherit;
		color: inherit;
		cursor: inherit;

		/* Must be consistent with .ck-icon's vertical align. Otherwise, buttons with and
		without labels (but with icons) have different sizes in Chrome */
		vertical-align: middle;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& .ck-button__keystroke {
		color: inherit;

		@mixin ck-dir ltr {
			margin-left: var(--ck-spacing-large);
		}

		@mixin ck-dir rtl {
			margin-right: var(--ck-spacing-large);
		}

		font-weight: bold;
		opacity: .7;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
	&.ck-disabled {
		&:active,
		&:focus {
			/* The disabled button should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}

		& .ck-button__icon {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
		& .ck-button__label {
			@mixin ck-disabled;
		}

		& .ck-button__keystroke {
			opacity: .3;
		}
	}

	&.ck-button_with-text {
		padding: var(--ck-spacing-tiny) var(--ck-spacing-standard);

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__icon {
			@mixin ck-dir ltr {
				margin-left: calc(-1 * var(--ck-spacing-small));
				margin-right: var(--ck-spacing-small);
			}

			@mixin ck-dir rtl {
				margin-right: calc(-1 * var(--ck-spacing-small));
				margin-left: var(--ck-spacing-small);
			}
		}
	}

	&.ck-button_with-keystroke {
		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__label {
			flex-grow: 1;
		}
	}

	/* A style of the button which is currently on, e.g. its feature is active. */
	&.ck-on {
		@mixin ck-button-colors --ck-color-button-on;

		color: var(--ck-color-button-on-color);
	}

	&.ck-button-save {
		color: var(--ck-color-button-save);
	}

	&.ck-button-cancel {
		color: var(--ck-color-button-cancel);
	}
}

/* A style of the button which handles the primary action. */
.ck.ck-button-action,
a.ck.ck-button-action {
	@mixin ck-button-colors --ck-color-button-action;

	color: var(--ck-color-button-action-text);
}

.ck.ck-button-bold,
a.ck.ck-button-bold {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements a button of given background color.
 *
 * @param {String} $background - Background color of the button.
 * @param {String} $border - Border color of the button.
 */
@define-mixin ck-button-colors $prefix {
	background: var($(prefix)-background);

	&:not(.ck-disabled) {
		&:hover {
			background: var($(prefix)-hover-background);
		}

		&:active {
			background: var($(prefix)-active-background);
		}
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
	&.ck-disabled {
		background: var($(prefix)-disabled-background);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 5332: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                    names: [],
                    mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-button.ck-switchbutton {
	& .ck-button__toggle {
		display: block;

		& .ck-button__toggle__inner {
			display: block;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature
of the component, floating–point numbers have been used which, for the default font size
(see: --ck-font-size-base), will generate simple integers. */
:root {
	/* 34px at 13px font-size */
	--ck-switch-button-toggle-width: 2.6153846154em;
	/* 14px at 13px font-size */
	--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);
	--ck-switch-button-translation: calc(
		var(--ck-switch-button-toggle-width) -
		var(--ck-switch-button-toggle-inner-size) -
		2px /* Border */
	);
	--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);
}

.ck.ck-button.ck-switchbutton {
	/* Unlike a regular button, the switch button text color and background should never change.
	 * Changing toggle switch (background, outline) is enough to carry the information about the
	 * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)
	 */
	&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {
		color: inherit;
		background: transparent;
	}

	& .ck-button__label {
		@mixin ck-dir ltr {
			/* Separate the label from the switch */
			margin-right: calc(2 * var(--ck-spacing-large));
		}

		@mixin ck-dir rtl {
			/* Separate the label from the switch */
			margin-left: calc(2 * var(--ck-spacing-large));
		}
	}

	& .ck-button__toggle {
		@mixin ck-rounded-corners;

		@mixin ck-dir ltr {
			/* Make sure the toggle is always to the right as far as possible. */
			margin-left: auto;
		}

		@mixin ck-dir rtl {
			/* Make sure the toggle is always to the left as far as possible. */
			margin-right: auto;
		}

		/* Apply some smooth transition to the box-shadow and border. */
		/* Gently animate the background color of the toggle switch */
		transition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;
		border: 1px solid transparent;
		width: var(--ck-switch-button-toggle-width);
		background: var(--ck-color-switch-button-off-background);

		& .ck-button__toggle__inner {
			@mixin ck-rounded-corners {
				border-radius: calc(.5 * var(--ck-border-radius));
			}

			width: var(--ck-switch-button-toggle-inner-size);
			height: var(--ck-switch-button-toggle-inner-size);
			background: var(--ck-color-switch-button-inner-background);

			/* Gently animate the inner part of the toggle switch */
			transition: all 300ms ease;
		}

		&:hover {
			background: var(--ck-color-switch-button-off-hover-background);

			& .ck-button__toggle__inner {
				box-shadow: var(--ck-switch-button-inner-hover-shadow);
			}
		}
	}

	&.ck-disabled .ck-button__toggle {
		@mixin ck-disabled;
	}

	/* Overriding default .ck-button:focus styles + an outline around the toogle */
	&:focus {
		border-color: transparent;
		outline: none;
		box-shadow: none;

		& .ck-button__toggle {
			box-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);
			outline-offset: 1px;
			outline: var(--ck-focus-ring);
		}
	}

	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-on {
		& .ck-button__toggle {
			background: var(--ck-color-switch-button-on-background);

			&:hover {
				background: var(--ck-color-switch-button-on-hover-background);
			}

			& .ck-button__toggle__inner {
				/*
				* Move the toggle switch to the right. It will be animated.
				*/
				@mixin ck-dir ltr {
					transform: translateX( var( --ck-switch-button-translation ) );
				}

				@mixin ck-dir rtl {
					transform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 8010: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-list-button-padding);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:var(--ck-spacing-medium) var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/collapsible/collapsible.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/collapsible/collapsible.css"],
                    names: [],
                    mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,qCAAsC,CAFtC,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,gFACD,CAGC,mEACC,wBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-collapsible.ck-collapsible_collapsed {
	& > .ck-collapsible__children {
		display: none;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-collapsible {
	& > .ck.ck-button {
		width: 100%;
		font-weight: bold;
		padding: var(--ck-list-button-padding);
		border-radius: 0;
		color: inherit;

		&:focus {
			background: transparent;
		}

		&:active, &:not(:focus), &:hover:not(:focus) {
			background: transparent;
			border-color: transparent;
			box-shadow: none;
		}

		& > .ck-icon {
			margin-right: var(--ck-spacing-medium);
			width: var(--ck-collapsible-arrow-size);
		}
	}

	& > .ck-collapsible__children {
		padding: var(--ck-spacing-medium) var(--ck-spacing-large) var(--ck-spacing-large);
	}

	&.ck-collapsible_collapsed {
		& > .ck.ck-button .ck-icon {
			transform: rotate(-90deg);
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6781: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-selector__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"],
                    names: [],
                    mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,+DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-color-grid {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-grid-tile-size: 24px;

	/* Not using global colors here because these may change but some colors in a pallette
	 * require special treatment. For instance, this ensures no matter what the UI text color is,
	 * the check icon will look good on the black color tile. */
	--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);
}

.ck.ck-color-grid {
	grid-gap: 5px;
	padding: 8px;
}

.ck.ck-color-grid__tile {
	width: var(--ck-color-grid-tile-size);
	height: var(--ck-color-grid-tile-size);
	min-width: var(--ck-color-grid-tile-size);
	min-height: var(--ck-color-grid-tile-size);
	padding: 0;
	transition: .2s ease box-shadow;
	border: 0;

	&.ck-disabled {
		cursor: unset;
		transition: unset;
	}

	&.ck-color-selector__color-tile_bordered {
		box-shadow: 0 0 0 1px var(--ck-color-base-border);
	}

	& .ck.ck-icon {
		display: none;
		color: var(--ck-color-color-grid-check-icon);
	}

	&.ck-on {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);

		& .ck.ck-icon {
			display: block;
		}
	}

	&.ck-on,
	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		/* Disable the default .ck-button's border ring. */
		border: 0;
	}

	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
	}
}

.ck.ck-color-grid__label {
	padding: 0 var(--ck-spacing-standard);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3398: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;margin:var(--ck-spacing-large) 0 0;width:unset}.ck.ck-color-picker__row .ck.ck-labeled-field-view{padding-top:unset}.ck.ck-color-picker__row .ck.ck-input-text{width:unset}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/colorpicker/colorpicker.css"],
                    names: [],
                    mappings: "AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAA8B,CAC9B,kCAAmC,CACnC,WAcD,CAZC,mDACC,iBACD,CAEA,2CACC,WACD,CAEA,qDAEC,sCAAuC,CADvC,kCAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.color-picker-hex-input {
	width: max-content;

	& .ck.ck-input {
		min-width: unset;
	}
}

.ck.ck-color-picker__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;
	margin: var(--ck-spacing-large) 0 0;
	width: unset;

	& .ck.ck-labeled-field-view {
		padding-top: unset;
	}

	& .ck.ck-input-text {
		width: unset;
	}

	& .ck-color-picker__hash-view {
		padding-top: var(--ck-spacing-tiny);
		padding-right: var(--ck-spacing-medium);
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4157: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{align-items:center;display:flex}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{justify-content:flex-start}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{display:flex;flex-direction:row;justify-content:space-around}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-cancel,.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-save{flex:1}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{width:100%}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker{padding:8px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker{height:100px;min-width:180px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{padding:0 8px 8px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/colorselector/colorselector.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorselector/colorselector.css"],
                    names: [],
                    mappings: "AAUE,oLAGC,kBAAmB,CADnB,YAMD,CARA,wMAME,0BAEF,CAKA,iFACC,YAAa,CACb,kBAAmB,CACnB,4BAMD,CAJC,oMAEC,MACD,CCrBD,oLAEC,UACD,CAEA,0FAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,sGACC,gDACD,CAEA,gHAEE,uCAMF,CARA,gHAME,sCAEF,CAGD,6EACC,iBACD,CAKA,oEACC,WAoBD,CAlBC,sFACC,YAAa,CACb,eAeD,CAbC,wGACC,iEACD,CAEA,iGACC,iEACD,CAEA,yNAGC,WAAY,CADZ,UAED,CAIF,iFACC,iBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-color-selector {
	/* View fragment with color grids. */
	& .ck-color-grids-fragment {
		& .ck-button.ck-color-selector__remove-color,
		& .ck-button.ck-color-selector__color-picker {
			display: flex;
			align-items: center;

			@mixin ck-dir rtl {
				justify-content: flex-start;
			}
		}
	}

	/* View fragment with a color picker. */
	& .ck-color-picker-fragment {
		& .ck.ck-color-selector_action-bar {
			display: flex;
			flex-direction: row;
			justify-content: space-around;

			& .ck-button-save,
			& .ck-button-cancel {
				flex: 1
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-color-selector {
	/* View fragment with color grids. */
	& .ck-color-grids-fragment {
		& .ck-button.ck-color-selector__remove-color,
		& .ck-button.ck-color-selector__color-picker {
			width: 100%;
		}

		& .ck-button.ck-color-selector__color-picker {
			padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;

			&:not(:focus) {
				border-top: 1px solid var(--ck-color-base-border);
			}

			& .ck.ck-icon {
				@mixin ck-dir ltr {
					margin-right: var(--ck-spacing-standard);
				}

				@mixin ck-dir rtl {
					margin-left: var(--ck-spacing-standard);
				}
			}
		}

		& label.ck.ck-color-grid__label {
			font-weight: unset;
		}
	}

	/* View fragment with a color picker. */
	& .ck-color-picker-fragment {
		& .ck.ck-color-picker {
			padding: 8px;

			& .hex-color-picker {
				height: 100px;
				min-width: 180px;

				&::part(saturation) {
					border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;
				}

				&::part(hue) {
					border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);
				}

				&::part(saturation-pointer),
				&::part(hue-pointer) {
					width: 15px;
					height: 15px;
				}
			}
		}

		& .ck.ck-color-selector_action-bar {
			padding: 0 8px 8px;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 5485: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}.ck.ck-dropdown__panel:focus{outline:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eHkHD,CAhCA,qFG9EE,qCH8GF,CAhCA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAuBD,CAnBC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD,CAEA,6BACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-dropdown-max-width: 75vw;
}

.ck.ck-dropdown {
	display: inline-block;
	position: relative;

	& .ck-dropdown__arrow {
		pointer-events: none;
		z-index: var(--ck-z-default);
	}

	/* Dropdown button should span horizontally, e.g. in vertical toolbars */
	& .ck-button.ck-dropdown__button {
		width: 100%;
	}

	& .ck-dropdown__panel {
		display: none;
		z-index: var(--ck-z-modal);
		max-width: var(--ck-dropdown-max-width);

		position: absolute;

		&.ck-dropdown__panel-visible {
			display: inline-block;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_n,
		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_nme {
			bottom: 100%;
		}

		&.ck-dropdown__panel_se,
		&.ck-dropdown__panel_sw,
		&.ck-dropdown__panel_smw,
		&.ck-dropdown__panel_sme,
		&.ck-dropdown__panel_s {
			/*
			 * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.
			 * See https://github.com/ckeditor/ckeditor5/issues/1053.
			 */
			top: 100%;
			bottom: auto;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_se {
			left: 0px;
		}

		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_sw {
			right: 0px;
		}

		&.ck-dropdown__panel_s,
		&.ck-dropdown__panel_n {
			/* Positioning panels relative to the center of the button */
			left: 50%;
			transform: translateX(-50%);
		}

		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_smw {
			/* Positioning panels relative to the middle-west of the button */
			left: 75%;
			transform: translateX(-75%);
		}

		&.ck-dropdown__panel_nme,
		&.ck-dropdown__panel_sme {
			/* Positioning panels relative to the middle-east of the button */
			left: 25%;
			transform: translateX(-25%);
		}
	}
}

/*
 * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.
 * See https://github.com/ckeditor/ckeditor5/issues/7874
 */
.ck.ck-toolbar .ck-dropdown__panel {
	z-index: calc( var(--ck-z-modal) + 1 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-dropdown {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-dropdown__arrow {
		width: var(--ck-dropdown-arrow-size);
	}

	@mixin ck-dir ltr {
		& .ck-dropdown__arrow {
			right: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-dropdown__arrow {
			left: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-right: var(--ck-spacing-small);
		}
	}

	&.ck-disabled .ck-dropdown__arrow {
		@mixin ck-disabled;
	}

	& .ck-button.ck-dropdown__button {
		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-right: var(--ck-spacing-small);
			}
		}

		/* #23 */
		& .ck-button__label {
			width: 7em;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
		&.ck-disabled .ck-button__label {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/816 */
		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		&.ck-dropdown__button_label-width_auto .ck-button__label {
			width: auto;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/8699 */
		&.ck-off:active,
		&.ck-on:active {
			box-shadow: none;

			&:focus {
				@mixin ck-box-shadow var(--ck-focus-outer-shadow);
			}
		}
	}
}

.ck.ck-dropdown__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;

	/* Make sure the panel is at least as wide as the drop-down's button. */
	min-width: 100%;

	/* Disabled corner border radius to be consistent with the .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-dropdown__panel_se {
		border-top-left-radius: 0;
	}

	&.ck-dropdown__panel_sw {
		border-top-right-radius: 0;
	}

	&.ck-dropdown__panel_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-dropdown__panel_nw {
		border-bottom-right-radius: 0;
	}

	&:focus {
		outline: none;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3949: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-dropdown .ck-dropdown__panel .ck-list {
	/* Disabled radius of top-left border to be consistent with .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
	}

	/* Make sure the button belonging to the first/last child of the list goes well with the
	border radius of the entire panel. */
	& .ck-list__item {
		&:first-child .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}
		}

		&:last-child .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-top-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 7686: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-splitbutton {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-splitbutton__action:focus {
		z-index: calc(var(--ck-z-default) + 1);
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-split-button-hover-background: hsl(0, 0%, 92%);
	--ck-color-split-button-hover-border: hsl(0, 0%, 70%);
}

.ck.ck-splitbutton {
	/*
	 * Note: ck-rounded and ck-dir mixins don't go together (because they both use @nest).
	 */
	&:hover > .ck-splitbutton__action,
	&.ck-splitbutton_open > .ck-splitbutton__action {
		@nest [dir="ltr"] & {
			/* Don't round the action button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the action button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}
	}

	& > .ck-splitbutton__arrow {
		/* It's a text-less button and since the icon is positioned absolutely in such situation,
		it must get some arbitrary min-width. */
		min-width: unset;

		@nest [dir="ltr"] & {
			/* Don't round the arrow button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the arrow button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		& svg {
			width: var(--ck-dropdown-arrow-size);
		}
	}

	/* Make sure the divider stretches 100% height of the button
	https://github.com/ckeditor/ckeditor5/issues/10936 */
	& > .ck-splitbutton__arrow:not(:focus) {
		border-top-width: 0px;
		border-bottom-width: 0px;
	}

	/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling
	as a whole. The background of both buttons should stand out and there should be a visual
	separation between both buttons. */
	&.ck-splitbutton_open,
	&:hover {
		/* When the split button hovered as a whole, not as individual buttons. */
		& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {
			background: var(--ck-color-split-button-hover-background);
		}

		/* Splitbutton separator needs to be set with the ::after pseudoselector
		to display properly the borders on focus */
		& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
			content: '';
			position: absolute;
			width: 1px;
			height: 100%;
			background-color: var(--ck-color-split-button-hover-border);
		}

		/* Make sure the divider between the buttons looks fine when the button is focused */
		& > .ck-splitbutton__arrow:focus::after {
			--ck-color-split-button-hover-border: var(--ck-color-focus-border);
		}

		@nest [dir="ltr"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				left: -1px;
			}
		}

		@nest [dir="rtl"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				right: -1px;
			}
		}
	}

	/* Don't round the bottom left and right corners of the buttons when "open"
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-splitbutton_open {
		@mixin ck-rounded-corners {
			& > .ck-splitbutton__action {
				border-bottom-left-radius: 0;
			}

			& > .ck-splitbutton__arrow {
				border-bottom-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 7339: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"],
                    names: [],
                    mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-dropdown-max-width: 60vw;
}

.ck.ck-toolbar-dropdown > .ck-dropdown__panel {
	/* https://github.com/ckeditor/ckeditor5/issues/5586 */
	width: max-content;
	max-width: var(--ck-toolbar-dropdown-max-width);

	& .ck-button {
		&:focus {
			z-index: calc(var(--ck-z-default) + 1);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-toolbar-dropdown .ck-toolbar {
	border: 0;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 9688: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,oDACD,CAIA,gEACC,iDACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_focus.css";
@import "../../mixins/_button.css";

:root {
	--ck-color-editable-blur-selection: hsl(0, 0%, 85%);
}

.ck.ck-editor__editable:not(.ck-editor__nested-editable) {
	@mixin ck-rounded-corners;

	&.ck-focused {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
	}
}

.ck.ck-editor__editable_inline {
	overflow: auto;
	padding: 0 var(--ck-spacing-standard);
	border: 1px solid transparent;

	&[dir="ltr"] {
		text-align: left;
	}

	&[dir="rtl"] {
		text-align: right;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */
	& > *:first-child {
		margin-top: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/847 */
	& > *:last-child {
		/*
		 * This value should match with the default margins of the block elements (like .media or .image)
		 * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).
		 */
		margin-bottom: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/6517 */
	&.ck-blurred ::selection {
		background: var(--ck-color-editable-blur-selection);
	}
}

/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */
.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {
	&::after {
		border-bottom-color: var(--ck-color-panel-background);
	}
}

.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {
	&::after {
		border-top-color: var(--ck-color-panel-background);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 8847: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__header h2.ck-form__header__label{flex-grow:1}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}[dir=ltr] .ck.ck-form__header .ck-icon{margin-right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-form__header .ck-icon{margin-left:var(--ck-spacing-medium)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"],
                    names: [],
                    mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BAKD,CAHC,8CACC,WACD,CCPD,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAkBD,CAbC,uCAEE,qCAMF,CARA,uCAME,oCAEF,CAEA,4CACC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__header {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	align-items: center;
	justify-content: space-between;

	& h2.ck-form__header__label {
		flex-grow: 1;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-form-header-height: 38px;
}

.ck.ck-form__header {
	padding: var(--ck-spacing-small) var(--ck-spacing-large);
	height: var(--ck-form-header-height);
	line-height: var(--ck-form-header-height);
	border-bottom: 1px solid var(--ck-color-base-border);

	& .ck-icon {
		@mixin ck-dir ltr {
			margin-right: var(--ck-spacing-medium);
		}

		@mixin ck-dir rtl {
			margin-left: var(--ck-spacing-medium);
		}
	}

	& .ck-form__header__label {
		font-weight: bold;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 8960: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-highlighted-text mark{background:var(--ck-color-highlight-background);font-size:inherit;font-weight:inherit;line-height:inherit;vertical-align:initial}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/highlightedtext/highlightedtext.css"],
                    names: [],
                    mappings: "AAKA,6BACC,+CAAgD,CAIhD,iBAAkB,CAFlB,mBAAoB,CACpB,mBAAoB,CAFpB,sBAID",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-highlighted-text mark {
	background: var(--ck-color-highlight-background);
	vertical-align: initial;
	font-weight: inherit;
	line-height: inherit;
	font-size: inherit;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6574: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"],
                    names: [],
                    mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-icon {
	vertical-align: middle;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));
}

.ck.ck-icon {
	width: var(--ck-icon-size);
	height: var(--ck-icon-size);

	/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */
	font-size: .8333350694em;

	/* Inherit cursor style (#5). */
	cursor: inherit;

	/* This will prevent blurry icons on Firefox. See #340. */
	will-change: transform;

	& * {
		/* Inherit cursor style (#5). */
		cursor: inherit;
	}

	/* Allows dynamic coloring of an icon by inheriting its color from the parent. */
	&.ck-icon_inherit-color {
		color: inherit;

		& * {
			color: inherit;

			&:not([fill]) {
				/* Needed by FF. */
				fill: currentColor;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4879: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-input-width: 18em;

	/* Backward compatibility. */
	--ck-input-text-width: var(--ck-input-width);
}

.ck.ck-input {
	@mixin ck-rounded-corners;

	background: var(--ck-color-input-background);
	border: 1px solid var(--ck-color-input-border);
	padding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);
	min-width: var(--ck-input-width);

	/* This is important to stay of the same height as surrounding buttons */
	min-height: var(--ck-ui-component-min-height);

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .1s ease-in-out, border .1s ease-in-out;

	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	&[readonly] {
		border: 1px solid var(--ck-color-input-disabled-border);
		background: var(--ck-color-input-disabled-background);
		color: var(--ck-color-input-disabled-text);

		&:focus {
			/* The read-only input should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}
	}

	&.ck-error {
		border-color: var(--ck-color-input-error-border);
		animation: ck-input-shake .3s ease both;

		&:focus {
			@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);
		}
	}
}

@keyframes ck-input-shake {
	20% {
		transform: translateX(-2px);
	}

	40% {
		transform: translateX(2px);
	}

	60% {
		transform: translateX(-1px);
	}

	80% {
		transform: translateX(1px);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3662: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"],
                    names: [],
                    mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	display: block;
}

.ck.ck-voice-label {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	font-weight: bold;
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 2577: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0;transform:translate(calc(var(--ck-spacing-medium)*-1),-6px) scale(.75);transform-origin:100% 0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD+GD,CA1GA,2FCDE,qCD2GF,CAvGC,mEACC,UAoCD,CAlCC,gFACC,KAgCD,CAjCA,0FAIE,MAAS,CAGT,6DAA+D,CAF/D,oBA4BF,CAjCA,0FAWE,OAAU,CAEV,sEAA0E,CAD1E,uBAqBF,CAjCA,gFAkBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAH9C,mBAAoB,CAQpB,sBAAuB,CAKvB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,4WAGE,+HAYF,CAfA,4WAOE,wIAQF,CAfA,wVAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-labeled-field-view {
	& > .ck.ck-labeled-field-view__input-wrapper {
		display: flex;
		position: relative;
	}

	& .ck.ck-label {
		display: block;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../../../mixins/_rounded.css";

:root {
	--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);
	--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));
	--ck-color-labeled-field-label-background: var(--ck-color-base-background);
}

.ck.ck-labeled-field-view {
	@mixin ck-rounded-corners;

	& > .ck.ck-labeled-field-view__input-wrapper {
		width: 100%;

		& > .ck.ck-label {
			top: 0px;

			@mixin ck-dir ltr {
				left: 0px;
				transform-origin: 0 0;
				/* By default, display the label scaled down above the field. */
				transform: translate(var(--ck-spacing-medium), -6px) scale(.75);
			}

			@mixin ck-dir rtl {
				right: 0px;
				transform-origin: 100% 0;
				transform: translate(calc(-1 * var(--ck-spacing-medium)), -6px) scale(.75);
			}

			pointer-events: none;

			background: var(--ck-color-labeled-field-label-background);
			padding: 0 calc(.5 * var(--ck-font-size-tiny));
			line-height: initial;
			font-weight: normal;

			/* Prevent overflow when the label is longer than the input */
			text-overflow: ellipsis;
			overflow: hidden;

			max-width: 100%;

			transition:
				transform var(--ck-labeled-field-view-transition),
				padding var(--ck-labeled-field-view-transition),
				background var(--ck-labeled-field-view-transition);
		}
	}

	&.ck-error {
		& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
			color: var(--ck-color-base-error);
		}

		& .ck-input:not([readonly]) + .ck.ck-label {
			color: var(--ck-color-base-error);
		}
	}

	& .ck-labeled-field-view__status {
		font-size: var(--ck-font-size-small);
		margin-top: var(--ck-spacing-small);

		/* Let the info wrap to the next line to avoid stretching the layout horizontally.
		The status could be very long. */
		white-space: normal;

		&.ck-labeled-field-view__status_error {
			color: var(--ck-color-base-error);
		}
	}

	/* Disabled fields and fields that have no focus should fade out. */
	&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		color: var(--ck-color-input-disabled-text);
	}

	/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */
	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		@mixin ck-dir ltr {
			transform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		@mixin ck-dir rtl {
			transform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		/* Compensate for the default translate position. */
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));

		background: transparent;
		padding: 0;
	}

	/*------ DropdownView integration ----------------------------------------------------------------------------------- */

	/* Make sure dropdown' background color in any of dropdown's state does not collide with labeled field. */
	& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {
		background: transparent;
	}

	/* When the dropdown is "empty", the labeled field label replaces its label. */
	&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {
		opacity: 0;
	}

	/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 1046: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}:root{--ck-list-button-padding:calc(var(--ck-line-height-base)*0.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;width:100%}[dir=ltr] .ck.ck-list__item .ck-button{text-align:left}[dir=rtl] .ck.ck-list__item .ck-button{text-align:right}.ck.ck-list__item .ck-button{padding:var(--ck-list-button-padding)}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck-list .ck-list__group{padding-top:var(--ck-spacing-medium);:not(.ck-hidden)~&{border-top:1px solid var(--ck-color-base-border)}}.ck-list .ck-list__group>.ck-label{font-size:11px;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-medium) 0 var(--ck-spacing-medium)}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEdD,MACC,oJAGD,CAEA,YCLC,eDUD,CALA,+DCDE,qCDMF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cAgED,CA9DC,6BAGC,eAAgB,CAFhB,gBAAiB,CACjB,UA6CD,CA/CA,uCAME,eAyCF,CA/CA,uCAUE,gBAqCF,CA/CA,6BAgBC,qCA+BD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,yBACC,oCAAqC,CAGrC,mBACC,gDACD,CAOD,CALC,mCACC,cAAe,CACf,eAAiB,CACjB,oFACD,CAGD,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-list {
	@mixin ck-unselectable;

	display: flex;
	flex-direction: column;

	& .ck-list__item,
	& .ck-list__separator {
		display: block;
	}

	/* Make sure that whatever child of the list item gets focus, it remains on the
	top. Thanks to that, styles like box-shadow, outline, etc. are not masked by
	adjacent list items. */
	& .ck-list__item > *:focus {
		position: relative;
		z-index: var(--ck-z-default);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-list-button-padding:
		calc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))
		calc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));
}

.ck.ck-list {
	@mixin ck-rounded-corners;

	list-style-type: none;
	background: var(--ck-color-list-background);
}

.ck.ck-list__item {
	cursor: default;
	min-width: 12em;

	& .ck-button {
		min-height: unset;
		width: 100%;
		border-radius: 0;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}

		/* List items should have the same height. Use absolute units to make sure it is so
		   because e.g. different heading styles may have different height
		   https://github.com/ckeditor/ckeditor5-heading/issues/63 */
		padding: var(--ck-list-button-padding);

		& .ck-button__label {
			/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */
			line-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));
		}

		&:active {
			box-shadow: none;
		}

		&.ck-on {
			background: var(--ck-color-list-button-on-background);
			color: var(--ck-color-list-button-on-text);

			&:active {
				box-shadow: none;
			}

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-on-background-focus);
			}

			&:focus:not(.ck-switchbutton):not(.ck-disabled) {
				border-color: var(--ck-color-base-background);
			}
		}

		&:hover:not(.ck-disabled) {
			background: var(--ck-color-list-button-hover-background);
		}
	}

	/* It's unnecessary to change the background/text of a switch toggle; it has different ways
	of conveying its state (like the switcher) */
	& .ck-switchbutton {
		&.ck-on {
			background: var(--ck-color-list-background);
			color: inherit;

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-hover-background);
				color: inherit;
			}
		}
	}
}

.ck-list .ck-list__group {
	padding-top: var(--ck-spacing-medium);

	/* The group should have a border when it's not the first item. */
	*:not(.ck-hidden) ~ & {
		border-top: 1px solid var(--ck-color-base-border);
	}

	& > .ck-label {
		font-size: 11px;
		font-weight: bold;
		padding: var(--ck-spacing-medium) var(--ck-spacing-medium) 0 var(--ck-spacing-medium);
	}
}

.ck.ck-list__separator {
	height: 1px;
	width: 100%;
	background: var(--ck-color-base-border);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 8793: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Make sure the balloon arrow does not float over its children. */
	--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);
}

.ck.ck-balloon-panel {
	display: none;
	position: absolute;

	z-index: var(--ck-z-modal);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			content: "";
			position: absolute;
		}

		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_n"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_s"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&.ck-balloon-panel_visible {
		display: block;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-border-width: 1px;
	--ck-balloon-arrow-offset: 2px;
	--ck-balloon-arrow-height: 10px;
	--ck-balloon-arrow-half-width: 8px;
	--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);
}

.ck.ck-balloon-panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			width: 0;
			height: 0;
			border-style: solid;
		}
	}

	&[class*="arrow_n"] {
		&::before,
		&::after {
			border-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: transparent transparent var(--ck-color-panel-border) transparent;
			margin-top: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent var(--ck-color-panel-background) transparent;
			margin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_s"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: var(--ck-color-panel-border) transparent transparent;
			filter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));
			margin-bottom: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: var(--ck-color-panel-background) transparent transparent transparent;
			margin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_e"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);
		}

		&::before {
			border-color: transparent transparent transparent var(--ck-color-panel-border);
			margin-right: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent transparent var(--ck-color-panel-background);
			margin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_w"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;
		}

		&::before {
			border-color: transparent var(--ck-color-panel-border) transparent transparent;
			margin-left: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent var(--ck-color-panel-background) transparent transparent;
			margin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&.ck-balloon-panel_arrow_n {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_ne {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_s {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_se {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_smw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nmw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_e {
		&::before,
		&::after {
			right: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}

	&.ck-balloon-panel_arrow_w {
		&::before,
		&::after {
			left: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4650: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"],
                    names: [],
                    mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Buttons inside a toolbar should be centered when rotator bar is wider.
 * See: https://github.com/ckeditor/ckeditor5-ui/issues/495
 */
.ck .ck-balloon-rotator__content .ck-toolbar {
	justify-content: center;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	background: var(--ck-color-toolbar-background);
	border-bottom: 1px solid var(--ck-color-toolbar-border);
	padding: 0 var(--ck-spacing-small);

	/* Let's keep similar appearance to \`ck-toolbar\`. */
	& > * {
		margin-right: var(--ck-spacing-small);
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	/* Gives counter more breath than buttons. */
	& .ck-balloon-rotator__counter {
		margin-right: var(--ck-spacing-standard);

		/* We need to use smaller margin because of previous button's right margin. */
		margin-left: var(--ck-spacing-small);
	}
}

.ck .ck-balloon-rotator__content {

	/* Disable default annotation shadow inside rotator with fake panels. */
	& .ck.ck-annotation-wrapper {
		box-shadow: none;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 7676: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-fake-panel {
	position: absolute;

	/* Fake panels should be placed under main balloon content. */
	z-index: calc(var(--ck-z-modal) - 1);
}

.ck .ck-fake-panel div {
	position: absolute;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	z-index: 2;
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	z-index: 1;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-fake-panel-offset-horizontal: 6px;
	--ck-balloon-fake-panel-offset-vertical: 6px;
}

/* Let's use \`.ck-balloon-panel\` appearance. See: balloonpanel.css. */
.ck .ck-fake-panel div {
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: 1px solid var(--ck-color-panel-border);
	border-radius: var(--ck-border-radius);

	width: 100%;
	height: 100%;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	margin-left: var(--ck-balloon-fake-panel-offset-horizontal);
	margin-top: var(--ck-balloon-fake-panel-offset-vertical);
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);
}
.ck .ck-fake-panel div:nth-child( 3 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);
}

/* If balloon is positioned above element, we need to move fake panel to the top. */
.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {
	--ck-balloon-fake-panel-offset-vertical: -6px;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 5868: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		z-index: var(--ck-z-modal); /* #315 */
		position: fixed;
		top: 0;
	}

	& .ck-sticky-panel__content_sticky_bottom-limit {
		top: auto;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		@mixin ck-drop-shadow;

		border-width: 0 1px 1px;
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6764: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"],
                    names: [],
                    mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck-vertical-form .ck-button {
	&::after {
		content: "";
		width: 0;
		position: absolute;
		right: -1px;
		top: -1px;
		bottom: -1px;
		z-index: 1;
	}

	&:focus::after {
		display: none;
	}
}

.ck.ck-responsive-form {
	@mixin ck-media-phone {
		& .ck-button {
			&::after {
				content: "";
				width: 0;
				position: absolute;
				right: -1px;
				top: -1px;
				bottom: -1px;
				z-index: 1;
			}

			&:focus::after {
				display: none;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck-vertical-form > .ck-button:nth-last-child(2)::after {
	border-right: 1px solid var(--ck-color-base-border);
}

.ck.ck-responsive-form {
	padding: var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	@mixin ck-dir ltr {
		& > :not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& > :not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		padding: 0;
		width: calc(.8 * var(--ck-input-width));

		& .ck-labeled-field-view {
			margin: var(--ck-spacing-large) var(--ck-spacing-large) 0;

			& .ck-input-text {
				min-width: 0;
				width: 100%;
			}

			/* Let the long error messages wrap in the narrow form. */
			& .ck-labeled-field-view__error {
				white-space: normal;
			}
		}

		/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */
		& > .ck-button:nth-last-child(2) {
			&::after {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}

		& > .ck-button:nth-last-child(1),
		& > .ck-button:nth-last-child(2) {
			padding: var(--ck-spacing-standard);
			margin-top: var(--ck-spacing-large);
			border-radius: 0;

			&:not(:focus) {
				border-top: 1px solid var(--ck-color-base-border);
			}

			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;

				&:last-of-type {
					border-right: 1px solid var(--ck-color-base-border);
				}
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 6770: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{left:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{right:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view .ck-search__reset{position:absolute;top:50%;transform:translateY(-50%)}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{display:block}.ck.ck-search>.ck-search__results>.ck-search__info:not(.ck-hidden)~*{display:none}:root{--ck-search-field-view-horizontal-spacing:calc(var(--ck-icon-size) + var(--ck-spacing-medium))}.ck.ck-search>.ck-labeled-field-view .ck-input{width:100%}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon{--ck-labeled-field-label-default-position-x:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon>.ck-labeled-field-view__input-wrapper>.ck-icon{opacity:.5;pointer-events:none}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input,[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input:not(.ck-input-text_empty){padding-left:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset{--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset.ck-labeled-field-view_empty{--ck-labeled-field-empty-unfocused-max-width:100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{background:none;min-height:auto;min-width:auto;opacity:.5;padding:0}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{left:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset:hover{opacity:1}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input:not(.ck-input-text_empty),[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{padding-right:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-search__results{min-width:100%}.ck.ck-search>.ck-search__results>.ck-search__info{padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-search>.ck-search__results>.ck-search__info *{white-space:normal}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{font-weight:700}.ck.ck-search>.ck-search__results>.ck-search__info>span:last-child{margin-top:var(--ck-spacing-medium)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/search/search.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/search/search.css"],
                    names: [],
                    mappings: "AASE,oFACC,iBAAkB,CAClB,OAAQ,CACR,0BASD,CAZA,8FAME,6BAMF,CAZA,8FAUE,8BAEF,CAEA,uDACC,iBAAkB,CAClB,OAAQ,CACR,0BACD,CAKC,oEACC,aACD,CAGA,qEACC,YACD,CChCH,MACC,8FACD,CAIE,+CACC,UACD,CAEA,gEACC,0FAoBD,CAlBC,+GACC,UAAW,CACX,mBACD,CAEA,0EACC,UAWD,CAJE,kMACC,2DACD,CAKH,iEACC,sGAwCD,CAtCC,6FACC,6HACD,CAEA,mFAIC,eAAgB,CAFhB,eAAgB,CADhB,cAAe,CAIf,UAAW,CACX,SAaD,CAnBA,6FASE,8BAUF,CAnBA,6FAaE,6BAMF,CAHC,yFACC,SACD,CAGD,2EACC,UAWD,CAZA,oMAUE,4DAEF,CAIF,kCACC,cAkBD,CAhBC,mDAEC,wDAAyD,CADzD,UAcD,CAXC,qDACC,kBACD,CAEA,oEACC,eACD,CAEA,mEACC,mCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-search {
	& > .ck-labeled-field-view {
		& > .ck-labeled-field-view__input-wrapper > .ck-icon {
			position: absolute;
			top: 50%;
			transform: translateY(-50%);

			@mixin ck-dir ltr {
				left: var(--ck-spacing-medium);
			}

			@mixin ck-dir rtl {
				right: var(--ck-spacing-medium);
			}
		}

		& .ck-search__reset {
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
		}
	}

	& > .ck-search__results {
		& > .ck-search__info {
			& > span:first-child {
				display: block;
			}

			/* Hide the filtered view when nothing was found */
			&:not(.ck-hidden) ~ * {
				display: none;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-search-field-view-horizontal-spacing: calc(var(--ck-icon-size) + var(--ck-spacing-medium));
}

.ck.ck-search {
	& > .ck-labeled-field-view {
		& .ck-input {
			width: 100%;
		}

		&.ck-search__query_with-icon {
			--ck-labeled-field-label-default-position-x: var(--ck-search-field-view-horizontal-spacing);

			& > .ck-labeled-field-view__input-wrapper > .ck-icon {
				opacity: .5;
				pointer-events: none;
			}

			& .ck-input {
				width: 100%;

				@mixin ck-dir ltr {
					padding-left: var(--ck-search-field-view-horizontal-spacing);
				}

				@mixin ck-dir rtl {
					&:not(.ck-input-text_empty) {
						padding-left: var(--ck-search-field-view-horizontal-spacing);
					}
				}
			}
		}

		&.ck-search__query_with-reset {
			--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-search-field-view-horizontal-spacing);

			&.ck-labeled-field-view_empty {
				--ck-labeled-field-empty-unfocused-max-width: 100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium);
			}

			& .ck-search__reset {
				min-width: auto;
				min-height: auto;

				background: none;
				opacity: .5;
				padding: 0;

				@mixin ck-dir ltr {
					right: var(--ck-spacing-medium);
				}

				@mixin ck-dir rtl {
					left: var(--ck-spacing-medium);
				}

				&:hover {
					opacity: 1;
				}
			}

			& .ck-input {
				width: 100%;

				@mixin ck-dir ltr {
					&:not(.ck-input-text_empty) {
						padding-right: var(--ck-search-field-view-horizontal-spacing);
					}
				}

				@mixin ck-dir rtl {
					padding-right: var(--ck-search-field-view-horizontal-spacing);
				}
			}
		}
	}

	& > .ck-search__results {
		min-width: 100%;

		& > .ck-search__info {
			width: 100%;
			padding: var(--ck-spacing-medium) var(--ck-spacing-large);

			& * {
				white-space: normal;
			}

			& > span:first-child {
				font-weight: bold;
			}

			& > span:last-child {
				margin-top: var(--ck-spacing-medium);
			}
		}
	}
}

`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 498: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-spinner-container{display:block;position:relative}.ck.ck-spinner{left:0;margin:0 auto;position:absolute;right:0;top:50%;transform:translateY(-50%);z-index:1}:root{--ck-toolbar-spinner-size:18px}.ck.ck-spinner-container{animation:rotate 1.5s linear infinite}.ck.ck-spinner,.ck.ck-spinner-container{height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}.ck.ck-spinner{border:2px solid var(--ck-color-text);border-radius:50%;border-top:2px solid transparent}@keyframes rotate{to{transform:rotate(1turn)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/spinner/spinner.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/spinner/spinner.css"],
                    names: [],
                    mappings: "AASA,yBACC,aAAc,CACd,iBACD,CAEA,eAGC,MAAO,CAEP,aAAc,CAJd,iBAAkB,CAGlB,OAAQ,CAFR,OAAQ,CAIR,0BAA2B,CAC3B,SACD,CCjBA,MACC,8BACD,CAEA,yBAGC,qCACD,CAEA,wCAJC,qCAAsC,CADtC,oCAWD,CANA,eAKC,qCAA6B,CAF7B,iBAAkB,CAElB,gCACD,CAEA,kBACC,GACC,uBACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-spinner-size: 18px;
}

.ck.ck-spinner-container {
	display: block;
	position: relative;
}

.ck.ck-spinner {
	position: absolute;
	top: 50%;
	left: 0;
	right: 0;
	margin: 0 auto;
	transform: translateY(-50%);
	z-index: 1;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-spinner-size: 18px;
}

.ck.ck-spinner-container {
	width: var(--ck-toolbar-spinner-size);
	height: var(--ck-toolbar-spinner-size);
	animation: 1.5s infinite rotate linear;
}

.ck.ck-spinner {
	width: var(--ck-toolbar-spinner-size);
	height: var(--ck-toolbar-spinner-size);
	border-radius: 50%;
	border: 2px solid var(--ck-color-text);
	border-top-color: transparent;
}

@keyframes rotate {
	to {
		transform: rotate(360deg)
	}
}

`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 8182: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-textarea{overflow-x:hidden}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/textarea/textarea.css"],
                    names: [],
                    mappings: "AASA,aACC,iBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/*
 * This fixes a problem in Firefox when the initial height of the complement does not match the number of rows.
 * This bug is especially visible when rows=1.
 */
.ck-textarea {
	overflow-x: hidden
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 9695: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"],
                    names: [],
                    mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-block-toolbar-button {
	position: absolute;
	z-index: var(--ck-z-default);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-block-toolbar-button: var(--ck-color-text);
	--ck-block-toolbar-button-size: var(--ck-font-size-normal);
}

.ck.ck-block-toolbar-button {
	color: var(--ck-color-block-toolbar-button);
	font-size: var(--ck-block-toolbar-size);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 5542: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-toolbar {
	@mixin ck-unselectable;

	display: flex;
	flex-flow: row nowrap;
	align-items: center;

	& > .ck-toolbar__items {
		display: flex;
		flex-flow: row wrap;
		align-items: center;
		flex-grow: 1;

	}

	& .ck.ck-toolbar__separator {
		display: inline-block;

		/*
		 * A leading or trailing separator makes no sense (separates from nothing on one side).
		 * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and
		 * moved to another toolbar in the dropdown.
		 */
		&:first-child,
		&:last-child {
			display: none;
		}
	}

	& .ck-toolbar__line-break {
		flex-basis: 100%;
	}

	&.ck-toolbar_grouping > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	&.ck-toolbar_vertical > .ck-toolbar__items {
		flex-direction: column;
	}

	&.ck-toolbar_floating > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		& > .ck-dropdown__button .ck-dropdown__arrow {
			display: none;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-toolbar {
	@mixin ck-rounded-corners;

	background: var(--ck-color-toolbar-background);
	padding: 0 var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);

	& .ck.ck-toolbar__separator {
		align-self: stretch;
		width: 1px;
		min-width: 1px;
		background: var(--ck-color-toolbar-border);

		/*
		 * These margins make the separators look better in balloon toolbars (when aligned with the "tip").
		 * See https://github.com/ckeditor/ckeditor5/issues/7493.
		 */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	& .ck-toolbar__line-break {
		height: 0;
	}

	& > .ck-toolbar__items {
		& > *:not(.ck-toolbar__line-break) {
			/* (#11) Separate toolbar items. */
			margin-right: var(--ck-spacing-small);
		}

		/* Don't display a separator after an empty items container, for instance,
		when all items were grouped */
		&:empty + .ck.ck-toolbar__separator {
			display: none;
		}
	}

	& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),
	& > .ck.ck-toolbar__grouped-dropdown {
		/* Make sure items wrapped to the next line have v-spacing */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	&.ck-toolbar_vertical {
		/* Items in a vertical toolbar span the entire width. */
		padding: 0;

		/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */
		& > .ck-toolbar__items > .ck {
			/* Items in a vertical toolbar should span the horizontal space. */
			width: 100%;

			/* Items in a vertical toolbar should have no margin. */
			margin: 0;

			/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */
			border-radius: 0;
		}
	}

	&.ck-toolbar_compact {
		/* No spacing around items. */
		padding: 0;

		& > .ck-toolbar__items > * {
			/* Compact toolbar items have no spacing between them. */
			margin: 0;

			/* "Middle" children should have no rounded corners. */
			&:not(:first-child):not(:last-child) {
				border-radius: 0;
			}
		}
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		/*
		 * Dropdown button has asymmetric padding to fit the arrow.
		 * This button has no arrow so let's revert that padding back to normal.
		 */
		& > .ck.ck-button.ck-dropdown__button {
			padding-left: var(--ck-spacing-tiny);
		}
	}

	/* A drop-down containing the nested toolbar with configured items. */
	& .ck-toolbar__nested-toolbar-dropdown {
		/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */
		& > .ck-dropdown__panel {
			min-width: auto;
		}

		& > .ck-button > .ck-button__label {
			max-width: 7em;
			width: auto;
		}
	}

	&:focus {
		outline: none;
	}

	@nest .ck-toolbar-container & {
		border: 0;
	}
}

/* stylelint-disable */

/*
 * Styles for RTL toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="rtl"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="rtl"] {
	& > .ck-toolbar__items > .ck {
		margin-right: 0;
	}

	&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {
		/* (#11) Separate toolbar items. */
		margin-left: var(--ck-spacing-small);
	}

	& > .ck-toolbar__items > .ck:last-child {
		margin-left: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-left: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-left: var(--ck-spacing-small);
	}
}

/*
 * Styles for LTR toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="ltr"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="ltr"] {
	& > .ck-toolbar__items > .ck:last-child {
		margin-right: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-right: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-right: var(--ck-spacing-small);
	}
}

/* stylelint-enable */
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3332: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-tooltip-text-padding:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip.ck-tooltip_multi-line .ck-tooltip__text{display:inline-block;padding:var(--ck-tooltip-text-padding) 0;white-space:break-spaces}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"],
                    names: [],
                    mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDRnC,mBAAoB,CAEpB,qCACD,CCOC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAEA,wEAEC,oBAAqB,CACrB,wCAAyC,CAFzC,wBAGD,CApBD,gCAuBC,eAMD,CAHC,uCACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-balloon-panel.ck-tooltip {
	/* Keep tooltips transparent for any interactions. */
	pointer-events: none;

	z-index: calc( var(--ck-z-modal) + 100 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-balloon-panel.ck-tooltip {
	--ck-balloon-border-width: 0px;
	--ck-balloon-arrow-offset: 0px;
	--ck-balloon-arrow-half-width: 4px;
	--ck-balloon-arrow-height: 4px;
	--ck-tooltip-text-padding: 4px;
	--ck-color-panel-background: var(--ck-color-tooltip-background);

	padding: 0 var(--ck-spacing-medium);

	& .ck-tooltip__text {
		font-size: .9em;
		line-height: 1.5;
		color: var(--ck-color-tooltip-text);
	}

	&.ck-tooltip_multi-line .ck-tooltip__text {
		white-space: break-spaces;
		display: inline-block;
		padding: var(--ck-tooltip-text-padding) 0;
	}

	/* Reset balloon panel styles */
	box-shadow: none;

	/* Hide the default shadow of the .ck-balloon-panel tip */
	&::before {
		display: none;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4793: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-modal) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-color-light-red:#fcc;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_reset.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-ui/theme/globals/_poweredby.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"],
                    names: [],
                    mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAyD,CAIzD,yBAAgD,CC3GhD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJ2GD,CIrGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which hides an element in DOM.
 */
.ck-hidden {
	/* Override selector specificity. Otherwise, all elements with some display
	style defined will override this one, which is not a desired result. */
	display: none !important;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	box-sizing: border-box;
	width: auto;
	height: auto;
	position: static;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-z-default: 1;
	--ck-z-modal: calc( var(--ck-z-default) + 999 );
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class that disables all transitions of the element and its children.
 */
.ck-transitions-disabled,
.ck-transitions-disabled * {
	transition: none !important;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-powered-by-line-height: 10px;
	--ck-powered-by-padding-vertical: 2px;
	--ck-powered-by-padding-horizontal: 4px;
	--ck-powered-by-text-color: hsl(0, 0%, 31%);
	--ck-powered-by-border-radius: var(--ck-border-radius);
	--ck-powered-by-background: hsl(0, 0%, 100%);
	--ck-powered-by-border-color: var(--ck-color-focus-border);
}

.ck.ck-balloon-panel.ck-powered-by-balloon {
	--ck-border-radius: var(--ck-powered-by-border-radius);

	box-shadow: none;
	background: var(--ck-powered-by-background);
	min-height: unset;
	z-index: calc( var(--ck-z-modal) - 1 );

	& .ck.ck-powered-by {
		line-height: var(--ck-powered-by-line-height);

		& a {
			cursor: pointer;
			display: flex;
			align-items: center;
			opacity: .66;
			filter: grayscale(80%);
			line-height: var(--ck-powered-by-line-height);
			padding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);
		}

		& .ck-powered-by__label {
			font-size: 7.5px;
			letter-spacing: -.2px;
			padding-left: 2px;
			text-transform: uppercase;
			font-weight: bold;
			margin-right: 4px;
			cursor: pointer;
			line-height: normal;
			color: var(--ck-powered-by-text-color);

		}

		& .ck-icon {
			display: block;
			cursor: pointer;
		}

		&:hover {
			& a {
				filter: grayscale(0%);
				opacity: 1;
			}
		}
	}

	&[class*="position_inside"] {
		border-color: transparent;
	}

	&[class*="position_border"] {
		border: var(--ck-focus-ring);
		border-color: var(--ck-powered-by-border-color);
	}
}

`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-base-foreground: 								hsl(0, 0%, 98%);
	--ck-color-base-background: 								hsl(0, 0%, 100%);
	--ck-color-base-border: 									hsl(220, 6%, 81%);
	--ck-color-base-action: 									hsl(104, 50.2%, 42.5%);
	--ck-color-base-focus: 										hsl(209, 92%, 70%);
	--ck-color-base-text: 										hsl(0, 0%, 20%);
	--ck-color-base-active: 									hsl(218.1, 100%, 58%);
	--ck-color-base-active-focus:								hsl(218.2, 100%, 52.5%);
	--ck-color-base-error:										hsl(15, 100%, 43%);

	/* -- Generic colors ------------------------------------------------------------------------ */

	--ck-color-focus-border-coordinates: 						218, 81.8%, 56.9%;
	--ck-color-focus-border: 									hsl(var(--ck-color-focus-border-coordinates));
	--ck-color-focus-outer-shadow:								hsl(212.4, 89.3%, 89%);
	--ck-color-focus-disabled-shadow:							hsla(209, 90%, 72%,.3);
	--ck-color-focus-error-shadow:								hsla(9,100%,56%,.3);
	--ck-color-text: 											var(--ck-color-base-text);
	--ck-color-shadow-drop: 									hsla(0, 0%, 0%, 0.15);
	--ck-color-shadow-drop-active:								hsla(0, 0%, 0%, 0.2);
	--ck-color-shadow-inner: 									hsla(0, 0%, 0%, 0.1);

	/* -- Buttons ------------------------------------------------------------------------------- */

	--ck-color-button-default-background: 						transparent;
	--ck-color-button-default-hover-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-active-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-disabled-background: 				transparent;

	--ck-color-button-on-background: 							hsl(212, 100%, 97.1%);
	--ck-color-button-on-hover-background: 						hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-active-background: 					hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-disabled-background: 					hsl(211, 15%, 95%);
	--ck-color-button-on-color:									hsl(218.1, 100%, 58%);


	--ck-color-button-action-background: 						var(--ck-color-base-action);
	--ck-color-button-action-hover-background: 					hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-active-background: 				hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-disabled-background: 				hsl(104, 44%, 58%);
	--ck-color-button-action-text: 								var(--ck-color-base-background);

	--ck-color-button-save: 									hsl(120, 100%, 27%);
	--ck-color-button-cancel: 									hsl(15, 100%, 43%);

	--ck-color-switch-button-off-background:					hsl(0, 0%, 57.6%);
	--ck-color-switch-button-off-hover-background:				hsl(0, 0%, 49%);
	--ck-color-switch-button-on-background:						var(--ck-color-button-action-background);
	--ck-color-switch-button-on-hover-background:				hsl(104, 53.2%, 40.2%);
	--ck-color-switch-button-inner-background:					var(--ck-color-base-background);
	--ck-color-switch-button-inner-shadow:						hsla(0, 0%, 0%, 0.1);

	/* -- Dropdown ------------------------------------------------------------------------------ */

	--ck-color-dropdown-panel-background: 						var(--ck-color-base-background);
	--ck-color-dropdown-panel-border: 							var(--ck-color-base-border);

	/* -- Input --------------------------------------------------------------------------------- */

	--ck-color-input-background: 								var(--ck-color-base-background);
	--ck-color-input-border: 									var(--ck-color-base-border);
	--ck-color-input-error-border:								var(--ck-color-base-error);
	--ck-color-input-text: 										var(--ck-color-base-text);
	--ck-color-input-disabled-background: 						hsl(0, 0%, 95%);
	--ck-color-input-disabled-border: 							var(--ck-color-base-border);
	--ck-color-input-disabled-text: 							hsl(0, 0%, 46%);

	/* -- List ---------------------------------------------------------------------------------- */

	--ck-color-list-background: 								var(--ck-color-base-background);
	--ck-color-list-button-hover-background: 					var(--ck-color-button-default-hover-background);
	--ck-color-list-button-on-background: 						var(--ck-color-button-on-color);
	--ck-color-list-button-on-background-focus: 				var(--ck-color-button-on-color);
	--ck-color-list-button-on-text:								var(--ck-color-base-background);

	/* -- Panel --------------------------------------------------------------------------------- */

	--ck-color-panel-background: 								var(--ck-color-base-background);
	--ck-color-panel-border: 									var(--ck-color-base-border);

	/* -- Toolbar ------------------------------------------------------------------------------- */

	--ck-color-toolbar-background: 								var(--ck-color-base-background);
	--ck-color-toolbar-border: 									var(--ck-color-base-border);

	/* -- Tooltip ------------------------------------------------------------------------------- */

	--ck-color-tooltip-background: 								var(--ck-color-base-text);
	--ck-color-tooltip-text: 									var(--ck-color-base-background);

	/* -- Engine -------------------------------------------------------------------------------- */

	--ck-color-engine-placeholder-text: 						hsl(0, 0%, 44%);

	/* -- Upload -------------------------------------------------------------------------------- */

	--ck-color-upload-bar-background:		 					hsl(209, 92%, 70%);

	/* -- Link -------------------------------------------------------------------------------- */

	--ck-color-link-default:									hsl(240, 100%, 47%);
	--ck-color-link-selected-background:						hsla(201, 100%, 56%, 0.1);
	--ck-color-link-fake-selection:								hsla(201, 100%, 56%, 0.3);

	/* -- Search result highlight ---------------------------------------------------------------- */

	--ck-color-highlight-background:							hsl(60, 100%, 50%);

	/* -- Generic colors ------------------------------------------------------------------------- */

	--ck-color-light-red:										hsl(0, 100%, 90%);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * An opacity value of disabled UI item.
	 */
	--ck-disabled-opacity: .5;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * The geometry of the of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow-geometry: 0 0 0 3px;

	/**
	 * A visual style of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);

	/**
	 * A visual style of focused element's outer shadow (when disabled).
	 */
	--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);

	/**
	 * A visual style of focused element's outer shadow (when has errors).
	 */
	--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);

	/**
	 * A visual style of focused element's border or outline.
	 */
	--ck-focus-ring: 1px solid var(--ck-color-focus-border);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-font-size-base: 13px;
	--ck-line-height-base: 1.84615;
	--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;

	--ck-font-size-tiny: 0.7em;
	--ck-font-size-small: 0.75em;
	--ck-font-size-normal: 1em;
	--ck-font-size-big: 1.4em;
	--ck-font-size-large: 1.8em;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* This is super-important. This is **manually** adjusted so a button without an icon
	is never smaller than a button with icon, additionally making sure that text-less buttons
	are perfect squares. The value is also shared by other components which should stay "in-line"
	with buttons. */
	--ck-ui-component-min-height: 2.3em;
}

/**
 * Resets an element, ignoring its children.
 */
.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* Do not include inheritable rules here. */
	margin: 0;
	padding: 0;
	border: 0;
	background: transparent;
	text-decoration: none;
	vertical-align: middle;
	transition: none;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */
	word-wrap: break-word;
}

/**
 * Resets an element AND its children.
 */
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* These are rule inherited by all children elements. */
	border-collapse: collapse;
	font: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);
	color: var(--ck-color-text);
	text-align: left;
	white-space: nowrap;
	cursor: auto;
	float: none;
}

.ck-reset_all {
	& .ck-rtl *:not(.ck-reset_all-excluded *) {
		text-align: right;
	}

	& iframe:not(.ck-reset_all-excluded *) {
		/* For IE */
		vertical-align: inherit;
	}

	& textarea:not(.ck-reset_all-excluded *) {
		white-space: pre-wrap;
	}

	& textarea:not(.ck-reset_all-excluded *),
	& input[type="text"]:not(.ck-reset_all-excluded *),
	& input[type="password"]:not(.ck-reset_all-excluded *) {
		cursor: text;
	}

	& textarea[disabled]:not(.ck-reset_all-excluded *),
	& input[type="text"][disabled]:not(.ck-reset_all-excluded *),
	& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {
		cursor: default;
	}

	& fieldset:not(.ck-reset_all-excluded *) {
		padding: 10px;
		border: 2px groove hsl(255, 7%, 88%);
	}

	& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {
		/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */
		padding: 0;
		border: 0
	}
}

/**
 * Default UI rules for RTL languages.
 */
.ck[dir="rtl"],
.ck[dir="rtl"] .ck {
	text-align: right;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Default border-radius value.
 */
:root{
	--ck-border-radius: 2px;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * A visual style of element's inner shadow (i.e. input).
	 */
	--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;

	/**
	 * A visual style of element's drop shadow (i.e. panel).
	 */
	--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);

	/**
	 * A visual style of element's active shadow (i.e. comment or suggestion).
	 */
	--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-spacing-unit: 						0.6em;
	--ck-spacing-large: 					calc(var(--ck-spacing-unit) * 1.5);
	--ck-spacing-standard: 					var(--ck-spacing-unit);
	--ck-spacing-medium: 					calc(var(--ck-spacing-unit) * 0.8);
	--ck-spacing-small: 					calc(var(--ck-spacing-unit) * 0.5);
	--ck-spacing-tiny: 						calc(var(--ck-spacing-unit) * 0.3);
	--ck-spacing-extra-tiny: 				calc(var(--ck-spacing-unit) * 0.16);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 3488: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-resizer: var(--ck-color-focus-border);
	--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);
	--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);

	--ck-resizer-border-radius: var(--ck-border-radius);
	--ck-resizer-tooltip-offset: 10px;
	--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);
}

.ck .ck-widget {
	/* This is neccessary for type around UI to be positioned properly. */
	position: relative;
}

.ck .ck-widget.ck-widget_with-selection-handle {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;

	& .ck-widget__selection-handle {
		position: absolute;

		& .ck-icon {
			/* Make sure the icon in not a subject to font-size or line-height to avoid
			unnecessary spacing around it. */
			display: block;
		}
	}

	/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		visibility: visible;
	}

	/* Show the selection handle when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected > .ck-widget__selection-handle {
		visibility: visible;
	}
}

.ck .ck-size-view {
	background: var(--ck-color-resizer-tooltip-background);
	color: var(--ck-color-resizer-tooltip-text);
	border: 1px solid var(--ck-color-resizer-tooltip-text);
	border-radius: var(--ck-resizer-border-radius);
	font-size: var(--ck-font-size-tiny);
	display: block;
	padding: 0 var(--ck-spacing-small);
	height: var(--ck-resizer-tooltip-height);
	line-height: var(--ck-resizer-tooltip-height);

	&.ck-orientation-top-left,
	&.ck-orientation-top-right,
	&.ck-orientation-bottom-right,
	&.ck-orientation-bottom-left,
	&.ck-orientation-above-center {
		position: absolute;
	}

	&.ck-orientation-top-left {
		top: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-top-right {
		top: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-right {
		bottom: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-left {
		bottom: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	/* Class applied if the widget is too small to contain the size label */
	&.ck-orientation-above-center {
		top: calc(var(--ck-resizer-tooltip-height) * -1);
		left: 50%;
		transform: translate(-50%);
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";

:root {
	--ck-widget-outline-thickness: 3px;
	--ck-widget-handler-icon-size: 16px;
	--ck-widget-handler-animation-duration: 200ms;
	--ck-widget-handler-animation-curve: ease;

	--ck-color-widget-blurred-border: hsl(0, 0%, 87%);
	--ck-color-widget-hover-border: hsl(43, 100%, 62%);
	--ck-color-widget-editable-focus-background: var(--ck-color-base-background);
	--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);
}

.ck .ck-widget {
	outline-width: var(--ck-widget-outline-thickness);
	outline-style: solid;
	outline-color: transparent;
	transition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);
	}

	&:hover {
		outline-color: var(--ck-color-widget-hover-border);
	}
}

.ck .ck-editor__nested-editable {
	border: 1px solid transparent;

	/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.
	These styles show a different border for a blink of an eye, so \`:focus\` need to have same styles applied. */
	&.ck-editor__nested-editable_focused,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);

		background-color: var(--ck-color-widget-editable-focus-background);
	}
}

.ck .ck-widget.ck-widget_with-selection-handle {
	& .ck-widget__selection-handle {
		padding: 4px;
		box-sizing: border-box;

		/* Background and opacity will be animated as the handler shows up or the widget gets selected. */
		background-color: transparent;
		opacity: 0;

		/* Transition:
		   * background-color for the .ck-widget_selected state change,
		   * visibility for hiding the handler,
		   * opacity for the proper look of the icon when the handler disappears. */
		transition:
			background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		/* Make only top corners round. */
		border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;

		/* Place the drag handler outside the widget wrapper. */
		transform: translateY(-100%);
		left: calc(0px - var(--ck-widget-outline-thickness));
		top: 0;

		& .ck-icon {
			/* Make sure the dimensions of the icon are independent of the fon-size of the content. */
			width: var(--ck-widget-handler-icon-size);
			height: var(--ck-widget-handler-icon-size);
			color: var(--ck-color-widget-drag-handler-icon-color);

			/* The "selected" part of the icon is invisible by default */
			& .ck-icon__selected-indicator {
				opacity: 0;

				/* Note: The animation is longer on purpose. Simply feels better. */
				transition: opacity 300ms var(--ck-widget-handler-animation-curve);
			}
		}

		/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */
		&:hover .ck-icon .ck-icon__selected-indicator {
			opacity: 1;
		}
	}

	/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		opacity: 1;
		background-color: var(--ck-color-widget-hover-border);
	}

	/* Show the selection handler when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		& > .ck-widget__selection-handle {
			opacity: 1;
			background-color: var(--ck-color-focus-border);

			/* When the widget is selected, notify the user using the proper look of the icon. */
			& .ck-icon .ck-icon__selected-indicator {
				opacity: 1;
			}
		}
	}
}

/* In a RTL environment, align the selection handler to the right side of the widget */
/* stylelint-disable-next-line no-descending-specificity */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {
	left: auto;
	right: calc(0px - var(--ck-widget-outline-thickness));
}

/* https://github.com/ckeditor/ckeditor5/issues/6415 */
.ck.ck-editor__editable.ck-read-only .ck-widget {
	/* Prevent the :hover outline from showing up because of the used outline-color transition. */
	transition: none;

	&:not(.ck-widget_selected) {
		/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.
		 * See: https://github.com/ckeditor/ckeditor5/issues/1261
		 *
		 * Leave the unit because this custom property is used in calc() by other features.
		 * See: https://github.com/ckeditor/ckeditor5/issues/6775
		 */
		--ck-widget-outline-thickness: 0px;
	}

	&.ck-widget_with-selection-handle {
		& .ck-widget__selection-handle,
		& .ck-widget__selection-handle:hover {
			background: var(--ck-color-widget-blurred-border);
		}
	}
}

/* Style the widget when it's selected but the editable it belongs to lost focus. */
/* stylelint-disable-next-line no-descending-specificity */
.ck.ck-editor__editable.ck-blurred .ck-widget {
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline-color: var(--ck-color-widget-blurred-border);

		&.ck-widget_with-selection-handle {
			& > .ck-widget__selection-handle,
			& > .ck-widget__selection-handle:hover {
				background: var(--ck-color-widget-blurred-border);
			}
		}
	}
}

.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,
.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {
	/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.
	In fact, anything with overflow: hidden.
	https://github.com/ckeditor/ckeditor5-block-quote/issues/28
	https://github.com/ckeditor/ckeditor5-widget/issues/44
	https://github.com/ckeditor/ckeditor5-widget/issues/66 */
	margin-top: calc(1em + var(--ck-widget-handler-icon-size));
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 8506: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"],
                    names: [],
                    mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget_with-resizer {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;
}

.ck .ck-widget__resizer {
	display: none;
	position: absolute;

	/* The wrapper itself should not interfere with the pointer device, only the handles should. */
	pointer-events: none;

	left: 0;
	top: 0;
}

.ck-focused .ck-widget_with-resizer.ck-widget_selected {
	& > .ck-widget__resizer {
		display: block;
	}
}

.ck .ck-widget__resizer__handle {
	position: absolute;

	/* Resizers are the only UI elements that should interfere with a pointer device. */
	pointer-events: all;

	&.ck-widget__resizer__handle-top-left,
	&.ck-widget__resizer__handle-bottom-right {
		cursor: nwse-resize;
	}

	&.ck-widget__resizer__handle-top-right,
	&.ck-widget__resizer__handle-bottom-left {
		cursor: nesw-resize;
	}
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-resizer-size: 10px;

	/* Set the resizer with a 50% offset. */
	--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);
	--ck-resizer-border-width: 1px;
}

.ck .ck-widget__resizer {
	outline: 1px solid var(--ck-color-resizer);
}

.ck .ck-widget__resizer__handle {
	width: var(--ck-resizer-size);
	height: var(--ck-resizer-size);
	background: var(--ck-color-focus-border);
	border: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);
	border-radius: var(--ck-resizer-border-radius);

	&.ck-widget__resizer__handle-top-left {
		top: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-top-right {
		top: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-right {
		bottom: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-left {
		bottom: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 4921: (A, y, w) => {
                w.d(y, {Z: () => B});
                var S = w(1799), I = w.n(S), T = w(2609), D = w.n(T)()(I());
                D.push([A.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"],
                    names: [],
                    mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		display: block;
		position: absolute;
		overflow: hidden;
		z-index: var(--ck-z-default);

		& svg {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: calc(var(--ck-z-default) + 2);
		}

		&.ck-widget__type-around__button_before {
			/* Place it in the middle of the outline */
			top: calc(-0.5 * var(--ck-widget-outline-thickness));
			left: min(10%, 30px);

			transform: translateY(-50%);
		}

		&.ck-widget__type-around__button_after {
			/* Place it in the middle of the outline */
			bottom: calc(-0.5 * var(--ck-widget-outline-thickness));
			right: min(10%, 30px);

			transform: translateY(50%);
		}
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		&::after {
			content: "";
			display: block;
			position: absolute;
			top: 1px;
			left: 1px;
			z-index: calc(var(--ck-z-default) + 1);
		}
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		display: none;
		position: absolute;
		left: 0;
		right: 0;
	}

	/*
	 * When the widget is hovered the "fake caret" would normally be narrower than the
	 * extra outline displayed around the widget. Let's extend the "fake caret" to match
	 * the full width of the widget.
	 */
	&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		left: calc( -1 * var(--ck-widget-outline-thickness) );
		right: calc( -1 * var(--ck-widget-outline-thickness) );
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		top: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		bottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}
}

/*
 * Integration with the read-only mode of the editor.
 */
.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the restricted editing mode (feature) of the editor.
 */
.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the #isEnabled property of the WidgetTypeAround plugin.
 */
.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-widget-type-around-button-size: 20px;
	--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);
	--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);
	--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);
	--ck-color-widget-type-around-button-radar-start-alpha: 0;
	--ck-color-widget-type-around-button-radar-end-alpha: .3;
	--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);
}

@define-mixin ck-widget-type-around-button-visible {
	opacity: 1;
	pointer-events: auto;
}

@define-mixin ck-widget-type-around-button-hidden {
	opacity: 0;
	pointer-events: none;
}

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		width: var(--ck-widget-type-around-button-size);
		height: var(--ck-widget-type-around-button-size);
		background: var(--ck-color-widget-type-around-button);
		border-radius: 100px;
		transition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		@mixin ck-widget-type-around-button-hidden;

		& svg {
			width: 10px;
			height: 8px;
			transform: translate(-50%,-50%);
			transition: transform .5s ease;
			margin-top: 1px;

			& * {
				stroke-dasharray: 10;
				stroke-dashoffset: 0;

				fill: none;
				stroke: var(--ck-color-widget-type-around-button-icon);
				stroke-width: 1.5px;
				stroke-linecap: round;
				stroke-linejoin: round;
			}

			& line {
				stroke-dasharray: 7;
			}
		}

		&:hover {
			/*
			 * Display the "sonar" around the button when hovered.
			 */
			animation: ck-widget-type-around-button-sonar 1s ease infinite;

			/*
			 * Animate active button's icon.
			 */
			& svg {
				& polyline {
					animation: ck-widget-type-around-arrow-dash 2s linear;
				}

				& line {
					animation: ck-widget-type-around-arrow-tip-dash 2s linear;
				}
			}
		}
	}

	/*
	 * Show type around buttons when the widget gets selected or being hovered.
	 */
	&.ck-widget_selected,
	&:hover {
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-visible;
		}
	}

	/*
	 * Styles for the buttons when the widget is NOT selected (but the buttons are visible
	 * and still can be hovered).
	 */
	&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {
		background: var(--ck-color-widget-type-around-button-hover);
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		background: var(--ck-color-widget-type-around-button-active);

		&::after {
			width: calc(var(--ck-widget-type-around-button-size) - 2px);
			height: calc(var(--ck-widget-type-around-button-size) - 2px);
			border-radius: 100px;
			background: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);
		}
	}

	/*
	 * Styles for the "before" button when the widget has a selection handle. Because some space
	 * is consumed by the handle, the button must be moved slightly to the right to let it breathe.
	 */
	&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {
		margin-left: 20px;
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& .ck-widget__type-around__fake-caret {
		pointer-events: none;
		height: 1px;
		animation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;

		/*
		 * The semi-transparent-outline+background combo improves the contrast
		 * when the background underneath the fake caret is dark.
		 */
		outline: solid 1px hsla(0, 0%, 100%, .5);
		background: var(--ck-color-base-text);
	}

	/*
	 * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).
	 * Despite the widget being physically selected in the model, its outline should disappear.
	 */
	&.ck-widget_selected {
		&.ck-widget_type-around_show-fake-caret_before,
		&.ck-widget_type-around_show-fake-caret_after {
			outline-color: transparent;
		}
	}

	&.ck-widget_type-around_show-fake-caret_before,
	&.ck-widget_type-around_show-fake-caret_after {
		/*
		 * When the "fake caret" is visible we simulate that the widget is not selected
		 * (despite being physically selected), so the outline color should be for the
		 * unselected widget.
		 */
		&.ck-widget_selected:hover {
			outline-color: var(--ck-color-widget-hover-border);
		}

		/*
		 * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).
		 * In this state, the type around buttons would collide with the fake carets so they should disappear.
		 */
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-hidden;
		}

		/*
		 * Fake horizontal caret integration with the selection handle. When the caret is visible, simply
		 * hide the handle because it intersects with the caret (and does not make much sense anyway).
		 */
		&.ck-widget_with-selection-handle {
			&.ck-widget_selected,
			&.ck-widget_selected:hover {
				& > .ck-widget__selection-handle {
					opacity: 0
				}
			}
		}

		/*
		 * Fake horizontal caret integration with the resize UI. When the caret is visible, simply
		 * hide the resize UI because it creates too much noise. It can be visible when the user
		 * hovers the widget, though.
		 */
		&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {
			opacity: 0
		}
	}
}

/*
 * Styles for the "before" button when the widget has a selection handle in an RTL environment.
 * The selection handler is aligned to the right side of the widget so there is no need to create
 * additional space for it next to the "before" button.
 */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {
	margin-left: 0;
	margin-right: 20px;
}

/*
 * Hide type around buttons when the widget is selected as a child of a selected
 * nested editable (e.g. mulit-cell table selection).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/7263.
 */
.ck-editor__nested-editable.ck-editor__editable_selected {
	& .ck-widget {
		&.ck-widget_selected,
		&:hover {
			& > .ck-widget__type-around > .ck-widget__type-around__button {
				@mixin ck-widget-type-around-button-hidden;
			}
		}
	}
}

/*
 * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).
 */
.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {
	background: var(--ck-color-widget-type-around-button-blurred-editable);

	& svg * {
		stroke: hsl(0,0%,60%);
	}
}

@keyframes ck-widget-type-around-arrow-dash {
	0% {
		stroke-dashoffset: 10;
	}
	20%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-arrow-tip-dash {
	0%, 20% {
		stroke-dashoffset: 7;
	}
	40%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-button-sonar {
	0% {
		box-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
	50% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));
	}
	100% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
}

@keyframes ck-widget-type-around-fake-caret-pulse {
	0% {
		opacity: 1;
	}
	49% {
		opacity: 1;
	}
	50% {
		opacity: 0;
	}
	99% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
`],
                    sourceRoot: ""
                }]);
                const B = D
            }, 2609: A => {
                A.exports = function (y) {
                    var w = [];
                    return w.toString = function () {
                        return this.map(function (S) {
                            var I = y(S);
                            return S[2] ? "@media ".concat(S[2], " {").concat(I, "}") : I
                        }).join("")
                    }, w.i = function (S, I, T) {
                        typeof S == "string" && (S = [[null, S, ""]]);
                        var D = {};
                        if (T) for (var B = 0; B < this.length; B++) {
                            var L = this[B][0];
                            L != null && (D[L] = !0)
                        }
                        for (var z = 0; z < S.length; z++) {
                            var q = [].concat(S[z]);
                            T && D[q[0]] || (I && (q[2] ? q[2] = "".concat(I, " and ").concat(q[2]) : q[2] = I), w.push(q))
                        }
                    }, w
                }
            }, 1799: A => {
                function y(S, I) {
                    return function (T) {
                        if (Array.isArray(T)) return T
                    }(S) || function (T, D) {
                        var B = T && (typeof Symbol < "u" && T[Symbol.iterator] || T["@@iterator"]);
                        if (B != null) {
                            var L, z, q = [], Q = !0, G = !1;
                            try {
                                for (B = B.call(T); !(Q = (L = B.next()).done) && (q.push(L.value), !D || q.length !== D); Q = !0) ;
                            } catch (Z) {
                                G = !0, z = Z
                            } finally {
                                try {
                                    Q || B.return == null || B.return()
                                } finally {
                                    if (G) throw z
                                }
                            }
                            return q
                        }
                    }(S, I) || function (T, D) {
                        if (T) {
                            if (typeof T == "string") return w(T, D);
                            var B = Object.prototype.toString.call(T).slice(8, -1);
                            if (B === "Object" && T.constructor && (B = T.constructor.name), B === "Map" || B === "Set") return Array.from(T);
                            if (B === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(B)) return w(T, D)
                        }
                    }(S, I) || function () {
                        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    }()
                }

                function w(S, I) {
                    (I == null || I > S.length) && (I = S.length);
                    for (var T = 0, D = new Array(I); T < I; T++) D[T] = S[T];
                    return D
                }

                A.exports = function (S) {
                    var I = y(S, 4), T = I[1], D = I[3];
                    if (!D) return T;
                    if (typeof btoa == "function") {
                        var B = btoa(unescape(encodeURIComponent(JSON.stringify(D)))),
                            L = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(B),
                            z = "/*# ".concat(L, " */"), q = D.sources.map(function (Q) {
                                return "/*# sourceURL=".concat(D.sourceRoot || "").concat(Q, " */")
                            });
                        return [T].concat(q).concat([z]).join(`
`)
                    }
                    return [T].join(`
`)
                }
            }, 6062: (A, y, w) => {
                var S, I = function () {
                    return S === void 0 && (S = !!(window && document && document.all && !window.atob)), S
                }, T = function () {
                    var me = {};
                    return function (R) {
                        if (me[R] === void 0) {
                            var ae = document.querySelector(R);
                            if (window.HTMLIFrameElement && ae instanceof window.HTMLIFrameElement) try {
                                ae = ae.contentDocument.head
                            } catch {
                                ae = null
                            }
                            me[R] = ae
                        }
                        return me[R]
                    }
                }(), D = [];

                function B(me) {
                    for (var R = -1, ae = 0; ae < D.length; ae++) if (D[ae].identifier === me) {
                        R = ae;
                        break
                    }
                    return R
                }

                function L(me, R) {
                    for (var ae = {}, ue = [], ve = 0; ve < me.length; ve++) {
                        var ke = me[ve], le = R.base ? ke[0] + R.base : ke[0], ye = ae[le] || 0,
                            ee = "".concat(le, " ").concat(ye);
                        ae[le] = ye + 1;
                        var qe = B(ee), Ze = {css: ke[1], media: ke[2], sourceMap: ke[3]};
                        qe !== -1 ? (D[qe].references++, D[qe].updater(Ze)) : D.push({
                            identifier: ee,
                            updater: Ce(Ze, R),
                            references: 1
                        }), ue.push(ee)
                    }
                    return ue
                }

                function z(me) {
                    var R = document.createElement("style"), ae = me.attributes || {};
                    if (ae.nonce === void 0) {
                        var ue = w.nc;
                        ue && (ae.nonce = ue)
                    }
                    if (Object.keys(ae).forEach(function (ke) {
                        R.setAttribute(ke, ae[ke])
                    }), typeof me.insert == "function") me.insert(R); else {
                        var ve = T(me.insert || "head");
                        if (!ve) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                        ve.appendChild(R)
                    }
                    return R
                }

                var q, Q = (q = [], function (me, R) {
                    return q[me] = R, q.filter(Boolean).join(`
`)
                });

                function G(me, R, ae, ue) {
                    var ve = ae ? "" : ue.media ? "@media ".concat(ue.media, " {").concat(ue.css, "}") : ue.css;
                    if (me.styleSheet) me.styleSheet.cssText = Q(R, ve); else {
                        var ke = document.createTextNode(ve), le = me.childNodes;
                        le[R] && me.removeChild(le[R]), le.length ? me.insertBefore(ke, le[R]) : me.appendChild(ke)
                    }
                }

                function Z(me, R, ae) {
                    var ue = ae.css, ve = ae.media, ke = ae.sourceMap;
                    if (ve ? me.setAttribute("media", ve) : me.removeAttribute("media"), ke && typeof btoa < "u" && (ue += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(ke)))), " */")), me.styleSheet) me.styleSheet.cssText = ue; else {
                        for (; me.firstChild;) me.removeChild(me.firstChild);
                        me.appendChild(document.createTextNode(ue))
                    }
                }

                var Y = null, ce = 0;

                function Ce(me, R) {
                    var ae, ue, ve;
                    if (R.singleton) {
                        var ke = ce++;
                        ae = Y || (Y = z(R)), ue = G.bind(null, ae, ke, !1), ve = G.bind(null, ae, ke, !0)
                    } else ae = z(R), ue = Z.bind(null, ae, R), ve = function () {
                        (function (le) {
                            if (le.parentNode === null) return !1;
                            le.parentNode.removeChild(le)
                        })(ae)
                    };
                    return ue(me), function (le) {
                        if (le) {
                            if (le.css === me.css && le.media === me.media && le.sourceMap === me.sourceMap) return;
                            ue(me = le)
                        } else ve()
                    }
                }

                A.exports = function (me, R) {
                    (R = R || {}).singleton || typeof R.singleton == "boolean" || (R.singleton = I());
                    var ae = L(me = me || [], R);
                    return function (ue) {
                        if (ue = ue || [], Object.prototype.toString.call(ue) === "[object Array]") {
                            for (var ve = 0; ve < ae.length; ve++) {
                                var ke = B(ae[ve]);
                                D[ke].references--
                            }
                            for (var le = L(ue, R), ye = 0; ye < ae.length; ye++) {
                                var ee = B(ae[ye]);
                                D[ee].references === 0 && (D[ee].updater(), D.splice(ee, 1))
                            }
                            ae = le
                        }
                    }
                }
            }
        }, b = {};

        function C(A) {
            var y = b[A];
            if (y !== void 0) return y.exports;
            var w = b[A] = {id: A, exports: {}};
            return h[A](w, w.exports, C), w.exports
        }

        C.n = A => {
            var y = A && A.__esModule ? () => A.default : () => A;
            return C.d(y, {a: y}), y
        }, C.d = (A, y) => {
            for (var w in y) C.o(y, w) && !C.o(A, w) && Object.defineProperty(A, w, {enumerable: !0, get: y[w]})
        }, C.o = (A, y) => Object.prototype.hasOwnProperty.call(A, y), C.nc = void 0;
        var k = {};
        return (() => {
            function A({emitter: r, activator: e, callback: t, contextElements: n}) {
                r.listenTo(document, "mousedown", (i, s) => {
                    if (!e()) return;
                    const l = typeof s.composedPath == "function" ? s.composedPath() : [],
                        d = typeof n == "function" ? n() : n;
                    for (const g of d) if (g.contains(s.target) || l.includes(g)) return;
                    t()
                })
            }

            function y(r) {
                return class extends r {
                    disableCssTransitions() {
                        this._isCssTransitionsDisabled = !0
                    }

                    enableCssTransitions() {
                        this._isCssTransitionsDisabled = !1
                    }

                    constructor(...e) {
                        super(...e), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin()
                    }

                    initializeCssTransitionDisablerMixin() {
                        this.extendTemplate({attributes: {class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")]}})
                    }
                }
            }

            function w({view: r}) {
                r.listenTo(r.element, "submit", (e, t) => {
                    t.preventDefault(), r.fire("submit")
                }, {useCapture: !0})
            }

            C.d(k, {default: () => bk});
            const S = function () {
                try {
                    return navigator.userAgent.toLowerCase()
                } catch {
                    return ""
                }
            }();
            var I;
            const T = {
                isMac: D(S), isWindows: (I = S, I.indexOf("windows") > -1), isGecko: function (r) {
                    return !!r.match(/gecko\/\d+/)
                }(S), isSafari: function (r) {
                    return r.indexOf(" applewebkit/") > -1 && r.indexOf("chrome") === -1
                }(S), isiOS: function (r) {
                    return !!r.match(/iphone|ipad/i) || D(r) && navigator.maxTouchPoints > 0
                }(S), isAndroid: function (r) {
                    return r.indexOf("android") > -1
                }(S), isBlink: function (r) {
                    return r.indexOf("chrome/") > -1 && r.indexOf("edge/") < 0
                }(S), features: {
                    isRegExpUnicodePropertySupported: function () {
                        let r = !1;
                        try {
                            r = "ć".search(new RegExp("[\\p{L}]", "u")) === 0
                        } catch {
                        }
                        return r
                    }()
                }
            };

            function D(r) {
                return r.indexOf("macintosh") > -1
            }

            function B(r, e, t, n) {
                t = t || function (g, v) {
                    return g === v
                };
                const i = Array.isArray(r) ? r : Array.prototype.slice.call(r),
                    s = Array.isArray(e) ? e : Array.prototype.slice.call(e), l = function (g, v, _) {
                        const x = L(g, v, _);
                        if (x === -1) return {firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1};
                        const M = z(g, x), O = z(v, x), j = L(M, O, _), U = g.length - j, K = v.length - j;
                        return {firstIndex: x, lastIndexOld: U, lastIndexNew: K}
                    }(i, s, t);
                return n ? function (g, v) {
                    const {firstIndex: _, lastIndexOld: x, lastIndexNew: M} = g;
                    if (_ === -1) return Array(v).fill("equal");
                    let O = [];
                    return _ > 0 && (O = O.concat(Array(_).fill("equal"))), M - _ > 0 && (O = O.concat(Array(M - _).fill("insert"))), x - _ > 0 && (O = O.concat(Array(x - _).fill("delete"))), M < v && (O = O.concat(Array(v - M).fill("equal"))), O
                }(l, s.length) : function (g, v) {
                    const _ = [], {firstIndex: x, lastIndexOld: M, lastIndexNew: O} = v;
                    return O - x > 0 && _.push({
                        index: x,
                        type: "insert",
                        values: g.slice(x, O)
                    }), M - x > 0 && _.push({index: x + (O - x), type: "delete", howMany: M - x}), _
                }(s, l)
            }

            function L(r, e, t) {
                for (let n = 0; n < Math.max(r.length, e.length); n++) if (r[n] === void 0 || e[n] === void 0 || !t(r[n], e[n])) return n;
                return -1
            }

            function z(r, e) {
                return r.slice(e).reverse()
            }

            function q(r, e, t) {
                t = t || function (U, K) {
                    return U === K
                };
                const n = r.length, i = e.length;
                if (n > 200 || i > 200 || n + i > 300) return q.fastDiff(r, e, t, !0);
                let s, l;
                if (i < n) {
                    const U = r;
                    r = e, e = U, s = "delete", l = "insert"
                } else s = "insert", l = "delete";
                const d = r.length, g = e.length, v = g - d, _ = {}, x = {};

                function M(U) {
                    const K = (x[U - 1] !== void 0 ? x[U - 1] : -1) + 1, ne = x[U + 1] !== void 0 ? x[U + 1] : -1,
                        pe = K > ne ? -1 : 1;
                    _[U + pe] && (_[U] = _[U + pe].slice(0)), _[U] || (_[U] = []), _[U].push(K > ne ? s : l);
                    let Se = Math.max(K, ne), Je = Se - U;
                    for (; Je < d && Se < g && t(r[Je], e[Se]);) Je++, Se++, _[U].push("equal");
                    return Se
                }

                let O, j = 0;
                do {
                    for (O = -j; O < v; O++) x[O] = M(O);
                    for (O = v + j; O > v; O--) x[O] = M(O);
                    x[v] = M(v), j++
                } while (x[v] !== g);
                return _[v].slice(1)
            }

            q.fastDiff = B;
            const Q = function () {
                return function r() {
                    r.called = !0
                }
            };

            class G {
                constructor(e, t) {
                    this.source = e, this.name = t, this.path = [], this.stop = Q(), this.off = Q()
                }
            }

            const Z = new Array(256).fill("").map((r, e) => ("0" + e.toString(16)).slice(-2));

            function Y() {
                const r = 4294967296 * Math.random() >>> 0, e = 4294967296 * Math.random() >>> 0,
                    t = 4294967296 * Math.random() >>> 0, n = 4294967296 * Math.random() >>> 0;
                return "e" + Z[r >> 0 & 255] + Z[r >> 8 & 255] + Z[r >> 16 & 255] + Z[r >> 24 & 255] + Z[e >> 0 & 255] + Z[e >> 8 & 255] + Z[e >> 16 & 255] + Z[e >> 24 & 255] + Z[t >> 0 & 255] + Z[t >> 8 & 255] + Z[t >> 16 & 255] + Z[t >> 24 & 255] + Z[n >> 0 & 255] + Z[n >> 8 & 255] + Z[n >> 16 & 255] + Z[n >> 24 & 255]
            }

            const ce = {
                get(r = "normal") {
                    return typeof r != "number" ? this[r] || this.normal : r
                }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5
            };

            function Ce(r, e) {
                const t = ce.get(e.priority);
                for (let n = 0; n < r.length; n++) if (ce.get(r[n].priority) < t) return void r.splice(n, 0, e);
                r.push(e)
            }

            const me = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";

            class R extends Error {
                constructor(e, t, n) {
                    super(function (i, s) {
                        const l = new WeakSet, d = (_, x) => {
                            if (typeof x == "object" && x !== null) {
                                if (l.has(x)) return `[object ${x.constructor.name}]`;
                                l.add(x)
                            }
                            return x
                        }, g = s ? ` ${JSON.stringify(s, d)}` : "", v = ve(i);
                        return i + g + v
                    }(e, n)), this.name = "CKEditorError", this.context = t, this.data = n
                }

                is(e) {
                    return e === "CKEditorError"
                }

                static rethrowUnexpectedError(e, t) {
                    if (e.is && e.is("CKEditorError")) throw e;
                    const n = new R(e.message, t);
                    throw n.stack = e.stack, n
                }
            }

            function ae(r, e) {
                console.warn(...ke(r, e))
            }

            function ue(r, e) {
                console.error(...ke(r, e))
            }

            function ve(r) {
                return `
Read more: ${me}#error-${r}`
            }

            function ke(r, e) {
                const t = ve(r);
                return e ? [r, e, t] : [r, t]
            }

            const le = "40.2.0", ye = new Date(2023, 11, 12);
            if (globalThis.CKEDITOR_VERSION) throw new R("ckeditor-duplicated-modules", null);
            globalThis.CKEDITOR_VERSION = le;
            const ee = Symbol("listeningTo"), qe = Symbol("emitterId"), Ze = Symbol("delegations"), Xe = Le(Object);

            function Le(r) {
                return r ? class extends r {
                    on(e, t, n) {
                        this.listenTo(this, e, t, n)
                    }

                    once(e, t, n) {
                        let i = !1;
                        this.listenTo(this, e, (s, ...l) => {
                            i || (i = !0, s.off(), t.call(this, s, ...l))
                        }, n)
                    }

                    off(e, t) {
                        this.stopListening(this, e, t)
                    }

                    listenTo(e, t, n, i = {}) {
                        let s, l;
                        this[ee] || (this[ee] = {});
                        const d = this[ee];
                        _t(e) || it(e);
                        const g = _t(e);
                        (s = d[g]) || (s = d[g] = {
                            emitter: e,
                            callbacks: {}
                        }), (l = s.callbacks[t]) || (l = s.callbacks[t] = []), l.push(n), function (v, _, x, M, O) {
                            _._addEventListener ? _._addEventListener(x, M, O) : v._addEventListener.call(_, x, M, O)
                        }(this, e, t, n, i)
                    }

                    stopListening(e, t, n) {
                        const i = this[ee];
                        let s = e && _t(e);
                        const l = i && s ? i[s] : void 0, d = l && t ? l.callbacks[t] : void 0;
                        if (!(!i || e && !l || t && !d)) if (n) Ye(this, e, t, n), d.indexOf(n) !== -1 && (d.length === 1 ? delete l.callbacks[t] : Ye(this, e, t, n)); else if (d) {
                            for (; n = d.pop();) Ye(this, e, t, n);
                            delete l.callbacks[t]
                        } else if (l) {
                            for (t in l.callbacks) this.stopListening(e, t);
                            delete i[s]
                        } else {
                            for (s in i) this.stopListening(i[s].emitter);
                            delete this[ee]
                        }
                    }

                    fire(e, ...t) {
                        try {
                            const n = e instanceof G ? e : new G(this, e), i = n.name;
                            let s = At(this, i);
                            if (n.path.push(this), s) {
                                const d = [n, ...t];
                                s = Array.from(s);
                                for (let g = 0; g < s.length && (s[g].callback.apply(this, d), n.off.called && (delete n.off.called, this._removeEventListener(i, s[g].callback)), !n.stop.called); g++) ;
                            }
                            const l = this[Ze];
                            if (l) {
                                const d = l.get(i), g = l.get("*");
                                d && mt(d, n, t), g && mt(g, n, t)
                            }
                            return n.return
                        } catch (n) {
                            R.rethrowUnexpectedError(n, this)
                        }
                    }

                    delegate(...e) {
                        return {
                            to: (t, n) => {
                                this[Ze] || (this[Ze] = new Map), e.forEach(i => {
                                    const s = this[Ze].get(i);
                                    s ? s.set(t, n) : this[Ze].set(i, new Map([[t, n]]))
                                })
                            }
                        }
                    }

                    stopDelegating(e, t) {
                        if (this[Ze]) if (e) if (t) {
                            const n = this[Ze].get(e);
                            n && n.delete(t)
                        } else this[Ze].delete(e); else this[Ze].clear()
                    }

                    _addEventListener(e, t, n) {
                        (function (l, d) {
                            const g = Tt(l);
                            if (g[d]) return;
                            let v = d, _ = null;
                            const x = [];
                            for (; v !== "" && !g[v];) g[v] = {
                                callbacks: [],
                                childEvents: []
                            }, x.push(g[v]), _ && g[v].childEvents.push(_), _ = v, v = v.substr(0, v.lastIndexOf(":"));
                            if (v !== "") {
                                for (const M of x) M.callbacks = g[v].callbacks.slice();
                                g[v].childEvents.push(_)
                            }
                        })(this, e);
                        const i = Pe(this, e), s = {callback: t, priority: ce.get(n.priority)};
                        for (const l of i) Ce(l, s)
                    }

                    _removeEventListener(e, t) {
                        const n = Pe(this, e);
                        for (const i of n) for (let s = 0; s < i.length; s++) i[s].callback == t && (i.splice(s, 1), s--)
                    }
                } : Xe
            }

            function it(r, e) {
                r[qe] || (r[qe] = e || Y())
            }

            function _t(r) {
                return r[qe]
            }

            function Tt(r) {
                return r._events || Object.defineProperty(r, "_events", {value: {}}), r._events
            }

            function Pe(r, e) {
                const t = Tt(r)[e];
                if (!t) return [];
                let n = [t.callbacks];
                for (let i = 0; i < t.childEvents.length; i++) {
                    const s = Pe(r, t.childEvents[i]);
                    n = n.concat(s)
                }
                return n
            }

            function At(r, e) {
                let t;
                return r._events && (t = r._events[e]) && t.callbacks.length ? t.callbacks : e.indexOf(":") > -1 ? At(r, e.substr(0, e.lastIndexOf(":"))) : null
            }

            function mt(r, e, t) {
                for (let [n, i] of r) {
                    i ? typeof i == "function" && (i = i(e.name)) : i = e.name;
                    const s = new G(e.source, i);
                    s.path = [...e.path], n.fire(s, ...t)
                }
            }

            function Ye(r, e, t, n) {
                e._removeEventListener ? e._removeEventListener(t, n) : r._removeEventListener.call(e, t, n)
            }

            ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(r => {
                Le[r] = Xe.prototype[r]
            });
            const Oe = function (r) {
                    var e = typeof r;
                    return r != null && (e == "object" || e == "function")
                }, ht = Symbol("observableProperties"), vt = Symbol("boundObservables"), Vt = Symbol("boundProperties"),
                ct = Symbol("decoratedMethods"), se = Symbol("decoratedOriginal"), ge = we(Le());

            function we(r) {
                return r ? class extends r {
                    set(e, t) {
                        if (Oe(e)) return void Object.keys(e).forEach(i => {
                            this.set(i, e[i])
                        }, this);
                        Me(this);
                        const n = this[ht];
                        if (e in this && !n.has(e)) throw new R("observable-set-cannot-override", this);
                        Object.defineProperty(this, e, {
                            enumerable: !0, configurable: !0, get: () => n.get(e), set(i) {
                                const s = n.get(e);
                                let l = this.fire(`set:${e}`, e, i, s);
                                l === void 0 && (l = i), s === l && n.has(e) || (n.set(e, l), this.fire(`change:${e}`, e, l, s))
                            }
                        }), this[e] = t
                    }

                    bind(...e) {
                        if (!e.length || !Ge(e)) throw new R("observable-bind-wrong-properties", this);
                        if (new Set(e).size !== e.length) throw new R("observable-bind-duplicate-properties", this);
                        Me(this);
                        const t = this[Vt];
                        e.forEach(i => {
                            if (t.has(i)) throw new R("observable-bind-rebind", this)
                        });
                        const n = new Map;
                        return e.forEach(i => {
                            const s = {property: i, to: []};
                            t.set(i, s), n.set(i, s)
                        }), {to: Be, toMany: Ue, _observable: this, _bindProperties: e, _to: [], _bindings: n}
                    }

                    unbind(...e) {
                        if (!this[ht]) return;
                        const t = this[Vt], n = this[vt];
                        if (e.length) {
                            if (!Ge(e)) throw new R("observable-unbind-wrong-properties", this);
                            e.forEach(i => {
                                const s = t.get(i);
                                s && (s.to.forEach(([l, d]) => {
                                    const g = n.get(l), v = g[d];
                                    v.delete(s), v.size || delete g[d], Object.keys(g).length || (n.delete(l), this.stopListening(l, "change"))
                                }), t.delete(i))
                            })
                        } else n.forEach((i, s) => {
                            this.stopListening(s, "change")
                        }), n.clear(), t.clear()
                    }

                    decorate(e) {
                        Me(this);
                        const t = this[e];
                        if (!t) throw new R("observablemixin-cannot-decorate-undefined", this, {
                            object: this,
                            methodName: e
                        });
                        this.on(e, (n, i) => {
                            n.return = t.apply(this, i)
                        }), this[e] = function (...n) {
                            return this.fire(e, n)
                        }, this[e][se] = t, this[ct] || (this[ct] = []), this[ct].push(e)
                    }

                    stopListening(e, t, n) {
                        if (!e && this[ct]) {
                            for (const i of this[ct]) this[i] = this[i][se];
                            delete this[ct]
                        }
                        super.stopListening(e, t, n)
                    }
                } : ge
            }

            function Me(r) {
                r[ht] || (Object.defineProperty(r, ht, {value: new Map}), Object.defineProperty(r, vt, {value: new Map}), Object.defineProperty(r, Vt, {value: new Map}))
            }

            function Be(...r) {
                const e = function (...s) {
                    if (!s.length) throw new R("observable-bind-to-parse-error", null);
                    const l = {to: []};
                    let d;
                    return typeof s[s.length - 1] == "function" && (l.callback = s.pop()), s.forEach(g => {
                        if (typeof g == "string") d.properties.push(g); else {
                            if (typeof g != "object") throw new R("observable-bind-to-parse-error", null);
                            d = {observable: g, properties: []}, l.to.push(d)
                        }
                    }), l
                }(...r), t = Array.from(this._bindings.keys()), n = t.length;
                if (!e.callback && e.to.length > 1) throw new R("observable-bind-to-no-callback", this);
                if (n > 1 && e.callback) throw new R("observable-bind-to-extra-callback", this);
                var i;
                e.to.forEach(s => {
                    if (s.properties.length && s.properties.length !== n) throw new R("observable-bind-to-properties-length", this);
                    s.properties.length || (s.properties = this._bindProperties)
                }), this._to = e.to, e.callback && (this._bindings.get(t[0]).callback = e.callback), i = this._observable, this._to.forEach(s => {
                    const l = i[vt];
                    let d;
                    l.get(s.observable) || i.listenTo(s.observable, "change", (g, v) => {
                        d = l.get(s.observable)[v], d && d.forEach(_ => {
                            ze(i, _.property)
                        })
                    })
                }), function (s) {
                    let l;
                    s._bindings.forEach((d, g) => {
                        s._to.forEach(v => {
                            l = v.properties[d.callback ? 0 : s._bindProperties.indexOf(g)], d.to.push([v.observable, l]), function (_, x, M, O) {
                                const j = _[vt], U = j.get(M), K = U || {};
                                K[O] || (K[O] = new Set), K[O].add(x), U || j.set(M, K)
                            }(s._observable, d, v.observable, l)
                        })
                    })
                }(this), this._bindProperties.forEach(s => {
                    ze(this._observable, s)
                })
            }

            function Ue(r, e, t) {
                if (this._bindings.size > 1) throw new R("observable-bind-to-many-not-one-binding", this);
                this.to(...function (n, i) {
                    const s = n.map(l => [l, i]);
                    return Array.prototype.concat.apply([], s)
                }(r, e), t)
            }

            function Ge(r) {
                return r.every(e => typeof e == "string")
            }

            function ze(r, e) {
                const t = r[Vt].get(e);
                let n;
                t.callback ? n = t.callback.apply(r, t.to.map(i => i[0][i[1]])) : (n = t.to[0], n = n[0][n[1]]), Object.prototype.hasOwnProperty.call(r, e) ? r[e] = n : r.set(e, n)
            }

            ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(r => {
                we[r] = ge.prototype[r]
            });

            class V {
                constructor() {
                    this._replacedElements = []
                }

                replace(e, t) {
                    this._replacedElements.push({
                        element: e,
                        newElement: t
                    }), e.style.display = "none", t && e.parentNode.insertBefore(t, e.nextSibling)
                }

                restore() {
                    this._replacedElements.forEach(({element: e, newElement: t}) => {
                        e.style.display = "", t && t.remove()
                    }), this._replacedElements = []
                }
            }

            function $(r) {
                let e = 0;
                for (const t of r) e++;
                return e
            }

            function te(r, e) {
                const t = Math.min(r.length, e.length);
                for (let n = 0; n < t; n++) if (r[n] != e[n]) return n;
                return r.length == e.length ? "same" : r.length < e.length ? "prefix" : "extension"
            }

            function oe(r) {
                return !(!r || !r[Symbol.iterator])
            }

            const de = typeof oo == "object" && oo && oo.Object === Object && oo;
            var he = typeof self == "object" && self && self.Object === Object && self;
            const Ae = de || he || Function("return this")(), De = Ae.Symbol;
            var Ie = Object.prototype, nt = Ie.hasOwnProperty, st = Ie.toString, Dt = De ? De.toStringTag : void 0;
            const zt = function (r) {
                var e = nt.call(r, Dt), t = r[Dt];
                try {
                    r[Dt] = void 0;
                    var n = !0
                } catch {
                }
                var i = st.call(r);
                return n && (e ? r[Dt] = t : delete r[Dt]), i
            };
            var Nt = Object.prototype.toString;
            const $t = function (r) {
                return Nt.call(r)
            };
            var Ot = De ? De.toStringTag : void 0;
            const Gt = function (r) {
                return r == null ? r === void 0 ? "[object Undefined]" : "[object Null]" : Ot && Ot in Object(r) ? zt(r) : $t(r)
            }, ot = Array.isArray, lr = function (r) {
                return r != null && typeof r == "object"
            }, ft = function (r) {
                return typeof r == "string" || !ot(r) && lr(r) && Gt(r) == "[object String]"
            };

            function Ir(r, e, t = {}, n = []) {
                const i = t && t.xmlns, s = i ? r.createElementNS(i, e) : r.createElement(e);
                for (const l in t) s.setAttribute(l, t[l]);
                !ft(n) && oe(n) || (n = [n]);
                for (let l of n) ft(l) && (l = r.createTextNode(l)), s.appendChild(l);
                return s
            }

            const Rn = function (r, e) {
                return function (t) {
                    return r(e(t))
                }
            }, cn = Rn(Object.getPrototypeOf, Object);
            var fn = Function.prototype, cr = Object.prototype, zn = fn.toString, Hr = cr.hasOwnProperty,
                Sn = zn.call(Object);
            const ur = function (r) {
                if (!lr(r) || Gt(r) != "[object Object]") return !1;
                var e = cn(r);
                if (e === null) return !0;
                var t = Hr.call(e, "constructor") && e.constructor;
                return typeof t == "function" && t instanceof t && zn.call(t) == Sn
            }, Mr = function () {
                this.__data__ = [], this.size = 0
            }, ti = function (r, e) {
                return r === e || r != r && e != e
            }, To = function (r, e) {
                for (var t = r.length; t--;) if (ti(r[t][0], e)) return t;
                return -1
            };
            var wi = Array.prototype.splice;
            const Ku = function (r) {
                var e = this.__data__, t = To(e, r);
                return !(t < 0) && (t == e.length - 1 ? e.pop() : wi.call(e, t, 1), --this.size, !0)
            }, Ys = function (r) {
                var e = this.__data__, t = To(e, r);
                return t < 0 ? void 0 : e[t][1]
            }, Ac = function (r) {
                return To(this.__data__, r) > -1
            }, nl = function (r, e) {
                var t = this.__data__, n = To(t, r);
                return n < 0 ? (++this.size, t.push([r, e])) : t[n][1] = e, this
            };

            function Zr(r) {
                var e = -1, t = r == null ? 0 : r.length;
                for (this.clear(); ++e < t;) {
                    var n = r[e];
                    this.set(n[0], n[1])
                }
            }

            Zr.prototype.clear = Mr, Zr.prototype.delete = Ku, Zr.prototype.get = Ys, Zr.prototype.has = Ac, Zr.prototype.set = nl;
            const Br = Zr, Io = function () {
                this.__data__ = new Br, this.size = 0
            }, Cc = function (r) {
                var e = this.__data__, t = e.delete(r);
                return this.size = e.size, t
            }, Ai = function (r) {
                return this.__data__.get(r)
            }, Zu = function (r) {
                return this.__data__.has(r)
            }, ni = function (r) {
                if (!Oe(r)) return !1;
                var e = Gt(r);
                return e == "[object Function]" || e == "[object GeneratorFunction]" || e == "[object AsyncFunction]" || e == "[object Proxy]"
            }, Yr = Ae["__core-js_shared__"];
            var ri = function () {
                var r = /[^.]+$/.exec(Yr && Yr.keys && Yr.keys.IE_PROTO || "");
                return r ? "Symbol(src)_1." + r : ""
            }();
            const ss = function (r) {
                return !!ri && ri in r
            };
            var Qs = Function.prototype.toString;
            const ii = function (r) {
                if (r != null) {
                    try {
                        return Qs.call(r)
                    } catch {
                    }
                    try {
                        return r + ""
                    } catch {
                    }
                }
                return ""
            };
            var Mo = /^\[object .+?Constructor\]$/, Js = Function.prototype, Ri = Object.prototype, rl = Js.toString,
                Xs = Ri.hasOwnProperty,
                Tn = RegExp("^" + rl.call(Xs).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            const dt = function (r) {
                return !(!Oe(r) || ss(r)) && (ni(r) ? Tn : Mo).test(ii(r))
            }, uo = function (r, e) {
                return r == null ? void 0 : r[e]
            }, Ci = function (r, e) {
                var t = uo(r, e);
                return dt(t) ? t : void 0
            }, mr = Ci(Ae, "Map"), W = Ci(Object, "create"), re = function () {
                this.__data__ = W ? W(null) : {}, this.size = 0
            }, Te = function (r) {
                var e = this.has(r) && delete this.__data__[r];
                return this.size -= e ? 1 : 0, e
            };
            var je = Object.prototype.hasOwnProperty;
            const _e = function (r) {
                var e = this.__data__;
                if (W) {
                    var t = e[r];
                    return t === "__lodash_hash_undefined__" ? void 0 : t
                }
                return je.call(e, r) ? e[r] : void 0
            };
            var Qe = Object.prototype.hasOwnProperty;
            const Qt = function (r) {
                var e = this.__data__;
                return W ? e[r] !== void 0 : Qe.call(e, r)
            }, tr = function (r, e) {
                var t = this.__data__;
                return this.size += this.has(r) ? 0 : 1, t[r] = W && e === void 0 ? "__lodash_hash_undefined__" : e, this
            };

            function Hn(r) {
                var e = -1, t = r == null ? 0 : r.length;
                for (this.clear(); ++e < t;) {
                    var n = r[e];
                    this.set(n[0], n[1])
                }
            }

            Hn.prototype.clear = re, Hn.prototype.delete = Te, Hn.prototype.get = _e, Hn.prototype.has = Qt, Hn.prototype.set = tr;
            const as = Hn, lf = function () {
                this.size = 0, this.__data__ = {hash: new as, map: new (mr || Br), string: new as}
            }, Et = function (r) {
                var e = typeof r;
                return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? r !== "__proto__" : r === null
            }, _c = function (r, e) {
                var t = r.__data__;
                return Et(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map
            }, cf = function (r) {
                var e = _c(this, r).delete(r);
                return this.size -= e ? 1 : 0, e
            }, yc = function (r) {
                return _c(this, r).get(r)
            }, zi = function (r) {
                return _c(this, r).has(r)
            }, uf = function (r, e) {
                var t = _c(this, r), n = t.size;
                return t.set(r, e), this.size += t.size == n ? 0 : 1, this
            };

            function ls(r) {
                var e = -1, t = r == null ? 0 : r.length;
                for (this.clear(); ++e < t;) {
                    var n = r[e];
                    this.set(n[0], n[1])
                }
            }

            ls.prototype.clear = lf, ls.prototype.delete = cf, ls.prototype.get = yc, ls.prototype.has = zi, ls.prototype.set = uf;
            const Bo = ls, Yu = function (r, e) {
                var t = this.__data__;
                if (t instanceof Br) {
                    var n = t.__data__;
                    if (!mr || n.length < 199) return n.push([r, e]), this.size = ++t.size, this;
                    t = this.__data__ = new Bo(n)
                }
                return t.set(r, e), this.size = t.size, this
            };

            function cs(r) {
                var e = this.__data__ = new Br(r);
                this.size = e.size
            }

            cs.prototype.clear = Io, cs.prototype.delete = Cc, cs.prototype.get = Ai, cs.prototype.has = Zu, cs.prototype.set = Yu;
            const us = cs, df = function (r, e) {
                for (var t = -1, n = r == null ? 0 : r.length; ++t < n && e(r[t], t, r) !== !1;) ;
                return r
            }, il = function () {
                try {
                    var r = Ci(Object, "defineProperty");
                    return r({}, "", {}), r
                } catch {
                }
            }(), Dc = function (r, e, t) {
                e == "__proto__" && il ? il(r, e, {configurable: !0, enumerable: !0, value: t, writable: !0}) : r[e] = t
            };
            var hf = Object.prototype.hasOwnProperty;
            const Qu = function (r, e, t) {
                var n = r[e];
                hf.call(r, e) && ti(n, t) && (t !== void 0 || e in r) || Dc(r, e, t)
            }, ea = function (r, e, t, n) {
                var i = !t;
                t || (t = {});
                for (var s = -1, l = e.length; ++s < l;) {
                    var d = e[s], g = n ? n(t[d], r[d], d, t, r) : void 0;
                    g === void 0 && (g = r[d]), i ? Dc(t, d, g) : Qu(t, d, g)
                }
                return t
            }, ff = function (r, e) {
                for (var t = -1, n = Array(r); ++t < r;) n[t] = e(t);
                return n
            }, ji = function (r) {
                return lr(r) && Gt(r) == "[object Arguments]"
            };
            var gf = Object.prototype, Dm = gf.hasOwnProperty, xc = gf.propertyIsEnumerable;
            const ds = ji(function () {
                return arguments
            }()) ? ji : function (r) {
                return lr(r) && Dm.call(r, "callee") && !xc.call(r, "callee")
            }, xm = function () {
                return !1
            };
            var pf = c && !c.nodeType && c, mf = pf && !0 && a && !a.nodeType && a,
                bf = mf && mf.exports === pf ? Ae.Buffer : void 0;
            const hs = (bf ? bf.isBuffer : void 0) || xm;
            var kf = /^(?:0|[1-9]\d*)$/;
            const Ju = function (r, e) {
                var t = typeof r;
                return !!(e = e ?? 9007199254740991) && (t == "number" || t != "symbol" && kf.test(r)) && r > -1 && r % 1 == 0 && r < e
            }, Xu = function (r) {
                return typeof r == "number" && r > -1 && r % 1 == 0 && r <= 9007199254740991
            };
            var wn = {};
            wn["[object Float32Array]"] = wn["[object Float64Array]"] = wn["[object Int8Array]"] = wn["[object Int16Array]"] = wn["[object Int32Array]"] = wn["[object Uint8Array]"] = wn["[object Uint8ClampedArray]"] = wn["[object Uint16Array]"] = wn["[object Uint32Array]"] = !0, wn["[object Arguments]"] = wn["[object Array]"] = wn["[object ArrayBuffer]"] = wn["[object Boolean]"] = wn["[object DataView]"] = wn["[object Date]"] = wn["[object Error]"] = wn["[object Function]"] = wn["[object Map]"] = wn["[object Number]"] = wn["[object Object]"] = wn["[object RegExp]"] = wn["[object Set]"] = wn["[object String]"] = wn["[object WeakMap]"] = !1;
            const Ec = function (r) {
                return lr(r) && Xu(r.length) && !!wn[Gt(r)]
            }, ta = function (r) {
                return function (e) {
                    return r(e)
                }
            };
            var Sc = c && !c.nodeType && c, na = Sc && !0 && a && !a.nodeType && a,
                Tc = na && na.exports === Sc && de.process;
            const ho = function () {
                try {
                    var r = na && na.require && na.require("util").types;
                    return r || Tc && Tc.binding && Tc.binding("util")
                } catch {
                }
            }();
            var vf = ho && ho.isTypedArray;
            const Ic = vf ? ta(vf) : Ec;
            var _i = Object.prototype.hasOwnProperty;
            const wf = function (r, e) {
                var t = ot(r), n = !t && ds(r), i = !t && !n && hs(r), s = !t && !n && !i && Ic(r),
                    l = t || n || i || s, d = l ? ff(r.length, String) : [], g = d.length;
                for (var v in r) !e && !_i.call(r, v) || l && (v == "length" || i && (v == "offset" || v == "parent") || s && (v == "buffer" || v == "byteLength" || v == "byteOffset") || Ju(v, g)) || d.push(v);
                return d
            };
            var Em = Object.prototype;
            const ol = function (r) {
                var e = r && r.constructor;
                return r === (typeof e == "function" && e.prototype || Em)
            }, Af = Rn(Object.keys, Object);
            var No = Object.prototype.hasOwnProperty;
            const ed = function (r) {
                if (!ol(r)) return Af(r);
                var e = [];
                for (var t in Object(r)) No.call(r, t) && t != "constructor" && e.push(t);
                return e
            }, oi = function (r) {
                return r != null && Xu(r.length) && !ni(r)
            }, ra = function (r) {
                return oi(r) ? wf(r) : ed(r)
            }, td = function (r, e) {
                return r && ea(e, ra(e), r)
            }, ia = function (r) {
                var e = [];
                if (r != null) for (var t in Object(r)) e.push(t);
                return e
            };
            var Sm = Object.prototype.hasOwnProperty;
            const Tm = function (r) {
                if (!Oe(r)) return ia(r);
                var e = ol(r), t = [];
                for (var n in r) (n != "constructor" || !e && Sm.call(r, n)) && t.push(n);
                return t
            }, oa = function (r) {
                return oi(r) ? wf(r, !0) : Tm(r)
            }, Im = function (r, e) {
                return r && ea(e, oa(e), r)
            };
            var nd = c && !c.nodeType && c, rd = nd && !0 && a && !a.nodeType && a,
                Cf = rd && rd.exports === nd ? Ae.Buffer : void 0, _f = Cf ? Cf.allocUnsafe : void 0;
            const yf = function (r, e) {
                if (e) return r.slice();
                var t = r.length, n = _f ? _f(t) : new r.constructor(t);
                return r.copy(n), n
            }, Df = function (r, e) {
                var t = -1, n = r.length;
                for (e || (e = Array(n)); ++t < n;) e[t] = r[t];
                return e
            }, xf = function (r, e) {
                for (var t = -1, n = r == null ? 0 : r.length, i = 0, s = []; ++t < n;) {
                    var l = r[t];
                    e(l, t, r) && (s[i++] = l)
                }
                return s
            }, Ef = function () {
                return []
            };
            var Sf = Object.prototype.propertyIsEnumerable, sl = Object.getOwnPropertySymbols;
            const Lo = sl ? function (r) {
                return r == null ? [] : (r = Object(r), xf(sl(r), function (e) {
                    return Sf.call(r, e)
                }))
            } : Ef, Mm = function (r, e) {
                return ea(r, Lo(r), e)
            }, Tf = function (r, e) {
                for (var t = -1, n = e.length, i = r.length; ++t < n;) r[i + t] = e[t];
                return r
            }, If = Object.getOwnPropertySymbols ? function (r) {
                for (var e = []; r;) Tf(e, Lo(r)), r = cn(r);
                return e
            } : Ef, al = function (r, e) {
                return ea(r, If(r), e)
            }, Un = function (r, e, t) {
                var n = e(r);
                return ot(r) ? n : Tf(n, t(r))
            }, id = function (r) {
                return Un(r, ra, Lo)
            }, Mf = function (r) {
                return Un(r, oa, If)
            }, fs = Ci(Ae, "DataView"), od = Ci(Ae, "Promise"), Mc = Ci(Ae, "Set"), sd = Ci(Ae, "WeakMap");
            var Bc = "[object Map]", ad = "[object Promise]", Bf = "[object Set]", Nf = "[object WeakMap]",
                ld = "[object DataView]", Lf = ii(fs), Bm = ii(mr), ll = ii(od), fo = ii(Mc), Nc = ii(sd), go = Gt;
            (fs && go(new fs(new ArrayBuffer(1))) != ld || mr && go(new mr) != Bc || od && go(od.resolve()) != ad || Mc && go(new Mc) != Bf || sd && go(new sd) != Nf) && (go = function (r) {
                var e = Gt(r), t = e == "[object Object]" ? r.constructor : void 0, n = t ? ii(t) : "";
                if (n) switch (n) {
                    case Lf:
                        return ld;
                    case Bm:
                        return Bc;
                    case ll:
                        return ad;
                    case fo:
                        return Bf;
                    case Nc:
                        return Nf
                }
                return e
            });
            const sa = go;
            var Vi = Object.prototype.hasOwnProperty;
            const gs = function (r) {
                var e = r.length, t = new r.constructor(e);
                return e && typeof r[0] == "string" && Vi.call(r, "index") && (t.index = r.index, t.input = r.input), t
            }, aa = Ae.Uint8Array, cd = function (r) {
                var e = new r.constructor(r.byteLength);
                return new aa(e).set(new aa(r)), e
            }, Pf = function (r, e) {
                var t = e ? cd(r.buffer) : r.buffer;
                return new r.constructor(t, r.byteOffset, r.byteLength)
            };
            var Nm = /\w*$/;
            const Of = function (r) {
                var e = new r.constructor(r.source, Nm.exec(r));
                return e.lastIndex = r.lastIndex, e
            };
            var Lc = De ? De.prototype : void 0, ps = Lc ? Lc.valueOf : void 0;
            const Hi = function (r) {
                return ps ? Object(ps.call(r)) : {}
            }, ud = function (r, e) {
                var t = e ? cd(r.buffer) : r.buffer;
                return new r.constructor(t, r.byteOffset, r.length)
            }, Ff = function (r, e, t) {
                var n = r.constructor;
                switch (e) {
                    case"[object ArrayBuffer]":
                        return cd(r);
                    case"[object Boolean]":
                    case"[object Date]":
                        return new n(+r);
                    case"[object DataView]":
                        return Pf(r, t);
                    case"[object Float32Array]":
                    case"[object Float64Array]":
                    case"[object Int8Array]":
                    case"[object Int16Array]":
                    case"[object Int32Array]":
                    case"[object Uint8Array]":
                    case"[object Uint8ClampedArray]":
                    case"[object Uint16Array]":
                    case"[object Uint32Array]":
                        return ud(r, t);
                    case"[object Map]":
                    case"[object Set]":
                        return new n;
                    case"[object Number]":
                    case"[object String]":
                        return new n(r);
                    case"[object RegExp]":
                        return Of(r);
                    case"[object Symbol]":
                        return Hi(r)
                }
            };
            var Rf = Object.create;
            const Lm = function () {
                function r() {
                }

                return function (e) {
                    if (!Oe(e)) return {};
                    if (Rf) return Rf(e);
                    r.prototype = e;
                    var t = new r;
                    return r.prototype = void 0, t
                }
            }(), zf = function (r) {
                return typeof r.constructor != "function" || ol(r) ? {} : Lm(cn(r))
            }, jf = function (r) {
                return lr(r) && sa(r) == "[object Map]"
            };
            var dd = ho && ho.isMap;
            const cl = dd ? ta(dd) : jf, Vf = function (r) {
                return lr(r) && sa(r) == "[object Set]"
            };
            var hd = ho && ho.isSet;
            const fd = hd ? ta(hd) : Vf;
            var ul = "[object Arguments]", gd = "[object Function]", dl = "[object Object]", Ht = {};
            Ht[ul] = Ht["[object Array]"] = Ht["[object ArrayBuffer]"] = Ht["[object DataView]"] = Ht["[object Boolean]"] = Ht["[object Date]"] = Ht["[object Float32Array]"] = Ht["[object Float64Array]"] = Ht["[object Int8Array]"] = Ht["[object Int16Array]"] = Ht["[object Int32Array]"] = Ht["[object Map]"] = Ht["[object Number]"] = Ht[dl] = Ht["[object RegExp]"] = Ht["[object Set]"] = Ht["[object String]"] = Ht["[object Symbol]"] = Ht["[object Uint8Array]"] = Ht["[object Uint8ClampedArray]"] = Ht["[object Uint16Array]"] = Ht["[object Uint32Array]"] = !0, Ht["[object Error]"] = Ht[gd] = Ht["[object WeakMap]"] = !1;
            const Pc = function r(e, t, n, i, s, l) {
                var d, g = 1 & t, v = 2 & t, _ = 4 & t;
                if (n && (d = s ? n(e, i, s, l) : n(e)), d !== void 0) return d;
                if (!Oe(e)) return e;
                var x = ot(e);
                if (x) {
                    if (d = gs(e), !g) return Df(e, d)
                } else {
                    var M = sa(e), O = M == gd || M == "[object GeneratorFunction]";
                    if (hs(e)) return yf(e, g);
                    if (M == dl || M == ul || O && !s) {
                        if (d = v || O ? {} : zf(e), !g) return v ? al(e, Im(d, e)) : Mm(e, td(d, e))
                    } else {
                        if (!Ht[M]) return s ? e : {};
                        d = Ff(e, M, g)
                    }
                }
                l || (l = new us);
                var j = l.get(e);
                if (j) return j;
                l.set(e, d), fd(e) ? e.forEach(function (K) {
                    d.add(r(K, t, n, K, e, l))
                }) : cl(e) && e.forEach(function (K, ne) {
                    d.set(ne, r(K, t, n, ne, e, l))
                });
                var U = x ? void 0 : (_ ? v ? Mf : id : v ? oa : ra)(e);
                return df(U || e, function (K, ne) {
                    U && (K = e[ne = K]), Qu(d, ne, r(K, t, n, ne, e, l))
                }), d
            }, hl = function (r, e) {
                return Pc(r, 5, e = typeof e == "function" ? e : void 0)
            }, po = function (r) {
                return lr(r) && r.nodeType === 1 && !ur(r)
            };

            class pd {
                constructor(e, t) {
                    this._config = {}, t && this.define(md(t)), e && this._setObjectToTarget(this._config, e)
                }

                set(e, t) {
                    this._setToTarget(this._config, e, t)
                }

                define(e, t) {
                    this._setToTarget(this._config, e, t, !0)
                }

                get(e) {
                    return this._getFromSource(this._config, e)
                }

                * names() {
                    for (const e of Object.keys(this._config)) yield e
                }

                _setToTarget(e, t, n, i = !1) {
                    if (ur(t)) return void this._setObjectToTarget(e, t, i);
                    const s = t.split(".");
                    t = s.pop();
                    for (const l of s) ur(e[l]) || (e[l] = {}), e = e[l];
                    if (ur(n)) return ur(e[t]) || (e[t] = {}), e = e[t], void this._setObjectToTarget(e, n, i);
                    i && e[t] !== void 0 || (e[t] = n)
                }

                _getFromSource(e, t) {
                    const n = t.split(".");
                    t = n.pop();
                    for (const i of n) {
                        if (!ur(e[i])) {
                            e = null;
                            break
                        }
                        e = e[i]
                    }
                    return e ? md(e[t]) : void 0
                }

                _setObjectToTarget(e, t, n) {
                    Object.keys(t).forEach(i => {
                        this._setToTarget(e, i, t[i], n)
                    })
                }
            }

            function md(r) {
                return hl(r, bd)
            }

            function bd(r) {
                return po(r) || typeof r == "function" ? r : void 0
            }

            function Po(r) {
                if (r) {
                    if (r.defaultView) return r instanceof r.defaultView.Document;
                    if (r.ownerDocument && r.ownerDocument.defaultView) return r instanceof r.ownerDocument.defaultView.Node
                }
                return !1
            }

            function Oc(r) {
                const e = Object.prototype.toString.apply(r);
                return e == "[object Window]" || e == "[object global]"
            }

            const Hf = dr(Le());

            function dr(r) {
                return r ? class extends r {
                    listenTo(e, t, n, i = {}) {
                        if (Po(e) || Oc(e)) {
                            const s = {capture: !!i.useCapture, passive: !!i.usePassive},
                                l = this._getProxyEmitter(e, s) || new la(e, s);
                            this.listenTo(l, t, n, i)
                        } else super.listenTo(e, t, n, i)
                    }

                    stopListening(e, t, n) {
                        if (Po(e) || Oc(e)) {
                            const i = this._getAllProxyEmitters(e);
                            for (const s of i) this.stopListening(s, t, n)
                        } else super.stopListening(e, t, n)
                    }

                    _getProxyEmitter(e, t) {
                        return function (n, i) {
                            const s = n[ee];
                            return s && s[i] ? s[i].emitter : null
                        }(this, ms(e, t))
                    }

                    _getAllProxyEmitters(e) {
                        return [{capture: !1, passive: !1}, {capture: !1, passive: !0}, {
                            capture: !0,
                            passive: !1
                        }, {capture: !0, passive: !0}].map(t => this._getProxyEmitter(e, t)).filter(t => !!t)
                    }
                } : Hf
            }

            ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(r => {
                dr[r] = Hf.prototype[r]
            });

            class la extends Le() {
                constructor(e, t) {
                    super(), it(this, ms(e, t)), this._domNode = e, this._options = t
                }

                attach(e) {
                    if (this._domListeners && this._domListeners[e]) return;
                    const t = this._createDomListener(e);
                    this._domNode.addEventListener(e, t, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[e] = t
                }

                detach(e) {
                    let t;
                    !this._domListeners[e] || (t = this._events[e]) && t.callbacks.length || this._domListeners[e].removeListener()
                }

                _addEventListener(e, t, n) {
                    this.attach(e), Le().prototype._addEventListener.call(this, e, t, n)
                }

                _removeEventListener(e, t) {
                    Le().prototype._removeEventListener.call(this, e, t), this.detach(e)
                }

                _createDomListener(e) {
                    const t = n => {
                        this.fire(e, n)
                    };
                    return t.removeListener = () => {
                        this._domNode.removeEventListener(e, t, this._options), delete this._domListeners[e]
                    }, t
                }
            }

            function ms(r, e) {
                let t = function (n) {
                    return n["data-ck-expando"] || (n["data-ck-expando"] = Y())
                }(r);
                for (const n of Object.keys(e).sort()) e[n] && (t += "-" + n);
                return t
            }

            let fl;
            try {
                fl = {window, document}
            } catch {
                fl = {window: {}, document: {}}
            }
            const bt = fl;

            function jn(r) {
                return Object.prototype.toString.call(r) == "[object Text]"
            }

            function ca(r) {
                return Object.prototype.toString.apply(r) == "[object Range]"
            }

            function Oo(r) {
                const e = r.ownerDocument.defaultView.getComputedStyle(r);
                return {
                    top: parseInt(e.borderTopWidth, 10),
                    right: parseInt(e.borderRightWidth, 10),
                    bottom: parseInt(e.borderBottomWidth, 10),
                    left: parseInt(e.borderLeftWidth, 10)
                }
            }

            function Fo(r) {
                return r && r.parentNode ? r.offsetParent === bt.document.body ? null : r.offsetParent : null
            }

            const Cr = ["top", "right", "bottom", "left", "width", "height"];

            class Lt {
                constructor(e) {
                    const t = ca(e);
                    if (Object.defineProperty(this, "_source", {
                        value: e._source || e,
                        writable: !0,
                        enumerable: !1
                    }), kd(e) || t) if (t) {
                        const n = Lt.getDomRangeRects(e);
                        yi(this, Lt.getBoundingRect(n))
                    } else yi(this, e.getBoundingClientRect()); else if (Oc(e)) {
                        const {innerWidth: n, innerHeight: i} = e;
                        yi(this, {top: 0, right: n, bottom: i, left: 0, width: n, height: i})
                    } else yi(this, e)
                }

                clone() {
                    return new Lt(this)
                }

                moveTo(e, t) {
                    return this.top = t, this.right = e + this.width, this.bottom = t + this.height, this.left = e, this
                }

                moveBy(e, t) {
                    return this.top += t, this.right += e, this.left += e, this.bottom += t, this
                }

                getIntersection(e) {
                    const t = {
                        top: Math.max(this.top, e.top),
                        right: Math.min(this.right, e.right),
                        bottom: Math.min(this.bottom, e.bottom),
                        left: Math.max(this.left, e.left),
                        width: 0,
                        height: 0
                    };
                    if (t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0) return null;
                    {
                        const n = new Lt(t);
                        return n._source = this._source, n
                    }
                }

                getIntersectionArea(e) {
                    const t = this.getIntersection(e);
                    return t ? t.getArea() : 0
                }

                getArea() {
                    return this.width * this.height
                }

                getVisible() {
                    const e = this._source;
                    let t = this.clone();
                    if (gl(e)) return t;
                    let n, i = e, s = e.parentNode || e.commonAncestorContainer;
                    for (; s && !gl(s);) {
                        const d = ((l = s) instanceof HTMLElement ? l.ownerDocument.defaultView.getComputedStyle(l).overflow : "visible") === "visible";
                        i instanceof HTMLElement && vd(i) === "absolute" && (n = i);
                        const g = vd(s);
                        if (d || n && (g === "relative" && d || g !== "relative")) {
                            i = s, s = s.parentNode;
                            continue
                        }
                        const v = new Lt(s), _ = t.getIntersection(v);
                        if (!_) return null;
                        _.getArea() < t.getArea() && (t = _), i = s, s = s.parentNode
                    }
                    var l;
                    return t
                }

                isEqual(e) {
                    for (const t of Cr) if (this[t] !== e[t]) return !1;
                    return !0
                }

                contains(e) {
                    const t = this.getIntersection(e);
                    return !(!t || !t.isEqual(e))
                }

                toAbsoluteRect() {
                    const {scrollX: e, scrollY: t} = bt.window, n = this.clone().moveBy(e, t);
                    if (kd(n._source)) {
                        const i = Fo(n._source);
                        i && function (s, l) {
                            const d = new Lt(l), g = Oo(l);
                            let v = 0, _ = 0;
                            v -= d.left, _ -= d.top, v += l.scrollLeft, _ += l.scrollTop, v -= g.left, _ -= g.top, s.moveBy(v, _)
                        }(n, i)
                    }
                    return n
                }

                excludeScrollbarsAndBorders() {
                    const e = this._source;
                    let t, n, i;
                    if (Oc(e)) t = e.innerWidth - e.document.documentElement.clientWidth, n = e.innerHeight - e.document.documentElement.clientHeight, i = e.getComputedStyle(e.document.documentElement).direction; else {
                        const s = Oo(e);
                        t = e.offsetWidth - e.clientWidth - s.left - s.right, n = e.offsetHeight - e.clientHeight - s.top - s.bottom, i = e.ownerDocument.defaultView.getComputedStyle(e).direction, this.left += s.left, this.top += s.top, this.right -= s.right, this.bottom -= s.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top
                    }
                    return this.width -= t, i === "ltr" ? this.right -= t : this.left += t, this.height -= n, this.bottom -= n, this
                }

                static getDomRangeRects(e) {
                    const t = [], n = Array.from(e.getClientRects());
                    if (n.length) for (const i of n) t.push(new Lt(i)); else {
                        let i = e.startContainer;
                        jn(i) && (i = i.parentNode);
                        const s = new Lt(i.getBoundingClientRect());
                        s.right = s.left, s.width = 0, t.push(s)
                    }
                    return t
                }

                static getBoundingRect(e) {
                    const t = {
                        left: Number.POSITIVE_INFINITY,
                        top: Number.POSITIVE_INFINITY,
                        right: Number.NEGATIVE_INFINITY,
                        bottom: Number.NEGATIVE_INFINITY,
                        width: 0,
                        height: 0
                    };
                    let n = 0;
                    for (const i of e) n++, t.left = Math.min(t.left, i.left), t.top = Math.min(t.top, i.top), t.right = Math.max(t.right, i.right), t.bottom = Math.max(t.bottom, i.bottom);
                    return n == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new Lt(t))
                }
            }

            function yi(r, e) {
                for (const t of Cr) r[t] = e[t]
            }

            function gl(r) {
                return !!kd(r) && r === r.ownerDocument.body
            }

            function kd(r) {
                return r !== null && typeof r == "object" && r.nodeType === 1 && typeof r.getBoundingClientRect == "function"
            }

            function vd(r) {
                return r instanceof HTMLElement ? r.ownerDocument.defaultView.getComputedStyle(r).position : "static"
            }

            const _n = class {
                constructor(r, e) {
                    _n._observerInstance || _n._createObserver(), this._element = r, this._callback = e, _n._addElementCallback(r, e), _n._observerInstance.observe(r)
                }

                get element() {
                    return this._element
                }

                destroy() {
                    _n._deleteElementCallback(this._element, this._callback)
                }

                static _addElementCallback(r, e) {
                    _n._elementCallbacks || (_n._elementCallbacks = new Map);
                    let t = _n._elementCallbacks.get(r);
                    t || (t = new Set, _n._elementCallbacks.set(r, t)), t.add(e)
                }

                static _deleteElementCallback(r, e) {
                    const t = _n._getElementCallbacks(r);
                    t && (t.delete(e), t.size || (_n._elementCallbacks.delete(r), _n._observerInstance.unobserve(r))), _n._elementCallbacks && !_n._elementCallbacks.size && (_n._observerInstance = null, _n._elementCallbacks = null)
                }

                static _getElementCallbacks(r) {
                    return _n._elementCallbacks ? _n._elementCallbacks.get(r) : null
                }

                static _createObserver() {
                    _n._observerInstance = new bt.window.ResizeObserver(r => {
                        for (const e of r) {
                            const t = _n._getElementCallbacks(e.target);
                            if (t) for (const n of t) n(e)
                        }
                    })
                }
            };
            let ua = _n;

            function Fc(r, e) {
                r instanceof HTMLTextAreaElement && (r.value = e), r.innerHTML = e
            }

            function Ro(r) {
                return e => e + r
            }

            function Rc(r) {
                let e = 0;
                for (; r.previousSibling;) r = r.previousSibling, e++;
                return e
            }

            function zc(r, e, t) {
                r.insertBefore(t, r.childNodes[e] || null)
            }

            function da(r) {
                return r && r.nodeType === Node.COMMENT_NODE
            }

            function mo(r) {
                return !!(r && r.getClientRects && r.getClientRects().length)
            }

            ua._observerInstance = null, ua._elementCallbacks = null;
            var jc = Math.pow;

            function zo({element: r, target: e, positions: t, limiter: n, fitInViewport: i, viewportOffsetConfig: s}) {
                ni(e) && (e = e()), ni(n) && (n = n());
                const l = Fo(r), d = function (M) {
                    M = Object.assign({top: 0, bottom: 0, left: 0, right: 0}, M);
                    const O = new Lt(bt.window);
                    return O.top += M.top, O.height -= M.top, O.bottom -= M.bottom, O.height -= M.bottom, O
                }(s), g = new Lt(r), v = pl(e, d);
                let _;
                if (!v || !d.getIntersection(v)) return null;
                const x = {targetRect: v, elementRect: g, positionedElementAncestor: l, viewportRect: d};
                if (n || i) {
                    if (n) {
                        const M = pl(n, d);
                        M && (x.limiterRect = M)
                    }
                    _ = function (M, O) {
                        const {elementRect: j} = O, U = j.getArea(),
                            K = M.map(Se => new wd(Se, O)).filter(Se => !!Se.name);
                        let ne = 0, pe = null;
                        for (const Se of K) {
                            const {limiterIntersectionArea: Je, viewportIntersectionArea: wt} = Se;
                            if (Je === U) return Se;
                            const qt = jc(wt, 2) + jc(Je, 2);
                            qt > ne && (ne = qt, pe = Se)
                        }
                        return pe
                    }(t, x)
                } else _ = new wd(t[0], x);
                return _
            }

            function pl(r, e) {
                const t = new Lt(r).getVisible();
                return t ? t.getIntersection(e) : null
            }

            class wd {
                constructor(e, t) {
                    const n = e(t.targetRect, t.elementRect, t.viewportRect, t.limiterRect);
                    if (!n) return;
                    const {left: i, top: s, name: l, config: d} = n;
                    this.name = l, this.config = d, this._positioningFunctionCoordinates = {
                        left: i,
                        top: s
                    }, this._options = t
                }

                get left() {
                    return this._absoluteRect.left
                }

                get top() {
                    return this._absoluteRect.top
                }

                get limiterIntersectionArea() {
                    const e = this._options.limiterRect;
                    return e ? e.getIntersectionArea(this._rect) : 0
                }

                get viewportIntersectionArea() {
                    return this._options.viewportRect.getIntersectionArea(this._rect)
                }

                get _rect() {
                    return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top)), this._cachedRect
                }

                get _absoluteRect() {
                    return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = this._rect.toAbsoluteRect()), this._cachedAbsoluteRect
                }
            }

            function ml(r) {
                const e = r.parentNode;
                e && e.removeChild(r)
            }

            function Pm({window: r, rect: e, alignToTop: t, forceScroll: n, viewportOffset: i}) {
                const s = e.clone().moveBy(0, i.bottom), l = e.clone().moveBy(0, -i.top),
                    d = new Lt(r).excludeScrollbarsAndBorders(), g = t && n, v = [l, s].every(j => d.contains(j));
                let {scrollX: _, scrollY: x} = r;
                const M = _, O = x;
                g ? x -= d.top - e.top + i.top : v || (Vc(l, d) ? x -= d.top - e.top + i.top : Uf(s, d) && (x += t ? e.top - d.top - i.top : e.bottom - d.bottom + i.bottom)), v || (Hc(e, d) ? _ -= d.left - e.left + i.left : bs(e, d) && (_ += e.right - d.right + i.right)), _ == M && x === O || r.scrollTo(_, x)
            }

            function Om({
                            parent: r,
                            getRect: e,
                            alignToTop: t,
                            forceScroll: n,
                            ancestorOffset: i = 0,
                            limiterElement: s
                        }) {
                const l = ks(r), d = t && n;
                let g, v, _;
                const x = s || l.document.body;
                for (; r != x;) v = e(), g = new Lt(r).excludeScrollbarsAndBorders(), _ = g.contains(v), d ? r.scrollTop -= g.top - v.top + i : _ || (Vc(v, g) ? r.scrollTop -= g.top - v.top + i : Uf(v, g) && (r.scrollTop += t ? v.top - g.top - i : v.bottom - g.bottom + i)), _ || (Hc(v, g) ? r.scrollLeft -= g.left - v.left + i : bs(v, g) && (r.scrollLeft += v.right - g.right + i)), r = r.parentNode
            }

            function Uf(r, e) {
                return r.bottom > e.bottom
            }

            function Vc(r, e) {
                return r.top < e.top
            }

            function Hc(r, e) {
                return r.left < e.left
            }

            function bs(r, e) {
                return r.right > e.right
            }

            function ks(r) {
                return ca(r) ? r.startContainer.ownerDocument.defaultView : r.ownerDocument.defaultView
            }

            function Fm(r) {
                if (ca(r)) {
                    let e = r.commonAncestorContainer;
                    return jn(e) && (e = e.parentNode), e
                }
                return r.parentNode
            }

            function bl(r, e) {
                const t = ks(r), n = new Lt(r);
                if (t === e) return n;
                {
                    let i = t;
                    for (; i != e;) {
                        const s = i.frameElement, l = new Lt(s).excludeScrollbarsAndBorders();
                        n.moveBy(l.left, l.top), i = i.parent
                    }
                }
                return n
            }

            const qf = {ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧"}, kl = {ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+"},
                Ut = function () {
                    const r = {
                        arrowleft: 37,
                        arrowup: 38,
                        arrowright: 39,
                        arrowdown: 40,
                        backspace: 8,
                        delete: 46,
                        enter: 13,
                        space: 32,
                        esc: 27,
                        tab: 9,
                        ctrl: 1114112,
                        shift: 2228224,
                        alt: 4456448,
                        cmd: 8912896
                    };
                    for (let e = 65; e <= 90; e++) r[String.fromCharCode(e).toLowerCase()] = e;
                    for (let e = 48; e <= 57; e++) r[e - 48] = e;
                    for (let e = 112; e <= 123; e++) r["f" + (e - 111)] = e;
                    for (const e of "`-=[];',./\\") r[e] = e.charCodeAt(0);
                    return r
                }(),
                vs = Object.fromEntries(Object.entries(Ut).map(([r, e]) => [e, r.charAt(0).toUpperCase() + r.slice(1)]));

            function Ui(r) {
                let e;
                if (typeof r == "string") {
                    if (e = Ut[r.toLowerCase()], !e) throw new R("keyboard-unknown-key", null, {key: r})
                } else e = r.keyCode + (r.altKey ? Ut.alt : 0) + (r.ctrlKey ? Ut.ctrl : 0) + (r.shiftKey ? Ut.shift : 0) + (r.metaKey ? Ut.cmd : 0);
                return e
            }

            function Di(r) {
                return typeof r == "string" && (r = function (e) {
                    return e.split("+").map(t => t.trim())
                }(r)), r.map(e => typeof e == "string" ? function (t) {
                    if (t.endsWith("!")) return Ui(t.slice(0, -1));
                    const n = Ui(t);
                    return (T.isMac || T.isiOS) && n == Ut.ctrl ? Ut.cmd : n
                }(e) : e).reduce((e, t) => t + e, 0)
            }

            function ha(r) {
                let e = Di(r);
                return Object.entries(T.isMac || T.isiOS ? qf : kl).reduce((t, [n, i]) => (e & Ut[n] && (e &= ~Ut[n], t += i), t), "") + (e ? vs[e] : "")
            }

            function jo(r, e) {
                const t = e === "ltr";
                switch (r) {
                    case Ut.arrowleft:
                        return t ? "left" : "right";
                    case Ut.arrowright:
                        return t ? "right" : "left";
                    case Ut.arrowup:
                        return "up";
                    case Ut.arrowdown:
                        return "down"
                }
            }

            function qn(r) {
                return Array.isArray(r) ? r : [r]
            }

            function Wf(r, e, t = 1) {
                if (typeof t != "number") throw new R("translation-service-quantity-not-a-number", null, {quantity: t});
                const n = Object.keys(bt.window.CKEDITOR_TRANSLATIONS).length;
                n === 1 && (r = Object.keys(bt.window.CKEDITOR_TRANSLATIONS)[0]);
                const i = e.id || e.string;
                if (n === 0 || !function (g, v) {
                    return !!bt.window.CKEDITOR_TRANSLATIONS[g] && !!bt.window.CKEDITOR_TRANSLATIONS[g].dictionary[v]
                }(r, i)) return t !== 1 ? e.plural : e.string;
                const s = bt.window.CKEDITOR_TRANSLATIONS[r].dictionary,
                    l = bt.window.CKEDITOR_TRANSLATIONS[r].getPluralForm || (g => g === 1 ? 0 : 1), d = s[i];
                return typeof d == "string" ? d : d[Number(l(t))]
            }

            bt.window.CKEDITOR_TRANSLATIONS || (bt.window.CKEDITOR_TRANSLATIONS = {});
            const $f = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];

            function Gf(r) {
                return $f.includes(r) ? "rtl" : "ltr"
            }

            class ws {
                constructor({uiLanguage: e = "en", contentLanguage: t} = {}) {
                    this.uiLanguage = e, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = Gf(this.uiLanguage), this.contentLanguageDirection = Gf(this.contentLanguage), this.t = (n, i) => this._t(n, i)
                }

                get language() {
                    return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage
                }

                _t(e, t = []) {
                    t = qn(t), typeof e == "string" && (e = {string: e});
                    const n = e.plural ? t[0] : 1;
                    return function (i, s) {
                        return i.replace(/%(\d+)/g, (l, d) => d < s.length ? s[d] : l)
                    }(Wf(this.uiLanguage, e, n), t)
                }
            }

            class br extends Le() {
                constructor(e = {}, t = {}) {
                    super();
                    const n = oe(e);
                    if (n || (t = e), this._items = [], this._itemMap = new Map, this._idProperty = t.idProperty || "id", this._bindToExternalToInternalMap = new WeakMap, this._bindToInternalToExternalMap = new WeakMap, this._skippedIndexesFromExternal = [], n) for (const i of e) this._items.push(i), this._itemMap.set(this._getItemIdBeforeAdding(i), i)
                }

                get length() {
                    return this._items.length
                }

                get first() {
                    return this._items[0] || null
                }

                get last() {
                    return this._items[this.length - 1] || null
                }

                add(e, t) {
                    return this.addMany([e], t)
                }

                addMany(e, t) {
                    if (t === void 0) t = this._items.length; else if (t > this._items.length || t < 0) throw new R("collection-add-item-invalid-index", this);
                    let n = 0;
                    for (const i of e) {
                        const s = this._getItemIdBeforeAdding(i), l = t + n;
                        this._items.splice(l, 0, i), this._itemMap.set(s, i), this.fire("add", i, l), n++
                    }
                    return this.fire("change", {added: e, removed: [], index: t}), this
                }

                get(e) {
                    let t;
                    if (typeof e == "string") t = this._itemMap.get(e); else {
                        if (typeof e != "number") throw new R("collection-get-invalid-arg", this);
                        t = this._items[e]
                    }
                    return t || null
                }

                has(e) {
                    if (typeof e == "string") return this._itemMap.has(e);
                    {
                        const t = e[this._idProperty];
                        return t && this._itemMap.has(t)
                    }
                }

                getIndex(e) {
                    let t;
                    return t = typeof e == "string" ? this._itemMap.get(e) : e, t ? this._items.indexOf(t) : -1
                }

                remove(e) {
                    const [t, n] = this._remove(e);
                    return this.fire("change", {added: [], removed: [t], index: n}), t
                }

                map(e, t) {
                    return this._items.map(e, t)
                }

                forEach(e, t) {
                    this._items.forEach(e, t)
                }

                find(e, t) {
                    return this._items.find(e, t)
                }

                filter(e, t) {
                    return this._items.filter(e, t)
                }

                clear() {
                    this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
                    const e = Array.from(this._items);
                    for (; this.length;) this._remove(0);
                    this.fire("change", {added: [], removed: e, index: 0})
                }

                bindTo(e) {
                    if (this._bindToCollection) throw new R("collection-bind-to-rebind", this);
                    return this._bindToCollection = e, {
                        as: t => {
                            this._setUpBindToBinding(n => new t(n))
                        }, using: t => {
                            typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding(n => n[t])
                        }
                    }
                }

                _setUpBindToBinding(e) {
                    const t = this._bindToCollection, n = (i, s, l) => {
                        const d = t._bindToCollection == this, g = t._bindToInternalToExternalMap.get(s);
                        if (d && g) this._bindToExternalToInternalMap.set(s, g), this._bindToInternalToExternalMap.set(g, s); else {
                            const v = e(s);
                            if (!v) return void this._skippedIndexesFromExternal.push(l);
                            let _ = l;
                            for (const x of this._skippedIndexesFromExternal) l > x && _--;
                            for (const x of t._skippedIndexesFromExternal) _ >= x && _++;
                            this._bindToExternalToInternalMap.set(s, v), this._bindToInternalToExternalMap.set(v, s), this.add(v, _);
                            for (let x = 0; x < t._skippedIndexesFromExternal.length; x++) _ <= t._skippedIndexesFromExternal[x] && t._skippedIndexesFromExternal[x]++
                        }
                    };
                    for (const i of t) n(0, i, t.getIndex(i));
                    this.listenTo(t, "add", n), this.listenTo(t, "remove", (i, s, l) => {
                        const d = this._bindToExternalToInternalMap.get(s);
                        d && this.remove(d), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((g, v) => (l < v && g.push(v - 1), l > v && g.push(v), g), [])
                    })
                }

                _getItemIdBeforeAdding(e) {
                    const t = this._idProperty;
                    let n;
                    if (t in e) {
                        if (n = e[t], typeof n != "string") throw new R("collection-add-invalid-id", this);
                        if (this.get(n)) throw new R("collection-add-item-already-exists", this)
                    } else e[t] = n = Y();
                    return n
                }

                _remove(e) {
                    let t, n, i, s = !1;
                    const l = this._idProperty;
                    if (typeof e == "string" ? (n = e, i = this._itemMap.get(n), s = !i, i && (t = this._items.indexOf(i))) : typeof e == "number" ? (t = e, i = this._items[t], s = !i, i && (n = i[l])) : (i = e, n = i[l], t = this._items.indexOf(i), s = t == -1 || !this._itemMap.get(n)), s) throw new R("collection-remove-404", this);
                    this._items.splice(t, 1), this._itemMap.delete(n);
                    const d = this._bindToInternalToExternalMap.get(i);
                    return this._bindToInternalToExternalMap.delete(i), this._bindToExternalToInternalMap.delete(d), this.fire("remove", i, t), [i, t]
                }

                [Symbol.iterator]() {
                    return this._items[Symbol.iterator]()
                }
            }

            function Wn(r) {
                const e = r.next();
                return e.done ? null : e.value
            }

            class Nr extends dr(we()) {
                constructor() {
                    super(), this._elements = new Set, this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null)
                }

                add(e) {
                    if (this._elements.has(e)) throw new R("focustracker-add-element-already-exist", this);
                    this.listenTo(e, "focus", () => this._focus(e), {useCapture: !0}), this.listenTo(e, "blur", () => this._blur(), {useCapture: !0}), this._elements.add(e)
                }

                remove(e) {
                    e === this.focusedElement && this._blur(), this._elements.has(e) && (this.stopListening(e), this._elements.delete(e))
                }

                destroy() {
                    this.stopListening()
                }

                _focus(e) {
                    clearTimeout(this._nextEventLoopTimeout), this.focusedElement = e, this.isFocused = !0
                }

                _blur() {
                    clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
                        this.focusedElement = null, this.isFocused = !1
                    }, 0)
                }
            }

            class si {
                constructor() {
                    this._listener = new (dr())
                }

                listenTo(e) {
                    this._listener.listenTo(e, "keydown", (t, n) => {
                        this._listener.fire("_keydown:" + Ui(n), n)
                    })
                }

                set(e, t, n = {}) {
                    const i = Di(e), s = n.priority;
                    this._listener.listenTo(this._listener, "_keydown:" + i, (l, d) => {
                        t(d, () => {
                            d.preventDefault(), d.stopPropagation(), l.stop()
                        }), l.return = !0
                    }, {priority: s})
                }

                press(e) {
                    return !!this._listener.fire("_keydown:" + Ui(e), e)
                }

                stopListening(e) {
                    this._listener.stopListening(e)
                }

                destroy() {
                    this.stopListening()
                }
            }

            function qi(r) {
                return oe(r) ? new Map(r) : function (e) {
                    const t = new Map;
                    for (const n in e) t.set(n, e[n]);
                    return t
                }(r)
            }

            function Ad(r, e) {
                let t;

                function n(...i) {
                    n.cancel(), t = setTimeout(() => r(...i), e)
                }

                return n.cancel = () => {
                    clearTimeout(t)
                }, n
            }

            function Cd(r, e) {
                return !!(t = r.charAt(e - 1)) && t.length == 1 && /[\ud800-\udbff]/.test(t) && function (n) {
                    return !!n && n.length == 1 && /[\udc00-\udfff]/.test(n)
                }(r.charAt(e));
                var t
            }

            function _r(r, e) {
                return !!(t = r.charAt(e)) && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t);
                var t
            }

            const nr = function () {
                const r = [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}", "u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")],
                    e = new RegExp("\\p{Regional_Indicator}{2}", "u").source,
                    t = "(?:" + r.map(n => n.source).join("|") + ")";
                return new RegExp(`${e}|${t}(?:‍${t})*`, "ug")
            }();

            function kr(r, e) {
                const t = String(r).matchAll(nr);
                return Array.from(t).some(n => n.index < e && e < n.index + n[0].length)
            }

            class un extends br {
                constructor(e = []) {
                    super(e, {idProperty: "viewUid"}), this.on("add", (t, n, i) => {
                        this._renderViewIntoCollectionParent(n, i)
                    }), this.on("remove", (t, n) => {
                        n.element && this._parentElement && n.element.remove()
                    }), this._parentElement = null
                }

                destroy() {
                    this.map(e => e.destroy())
                }

                setParent(e) {
                    this._parentElement = e;
                    for (const t of this) this._renderViewIntoCollectionParent(t)
                }

                delegate(...e) {
                    if (!e.length || !e.every(t => typeof t == "string")) throw new R("ui-viewcollection-delegate-wrong-events", this);
                    return {
                        to: t => {
                            for (const n of this) for (const i of e) n.delegate(i).to(t);
                            this.on("add", (n, i) => {
                                for (const s of e) i.delegate(s).to(t)
                            }), this.on("remove", (n, i) => {
                                for (const s of e) i.stopDelegating(s, t)
                            })
                        }
                    }
                }

                _renderViewIntoCollectionParent(e, t) {
                    e.isRendered || e.render(), e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t])
                }

                remove(e) {
                    return super.remove(e)
                }
            }

            var vl = C(6062), rt = C.n(vl), wl = C(4793),
                Rm = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(wl.Z, Rm), wl.Z.locals;

            class It extends dr(we()) {
                constructor(e) {
                    super(), this.element = null, this.isRendered = !1, this.locale = e, this.t = e && e.t, this._viewCollections = new br, this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t, n) => {
                        n.locale = e, n.t = e && e.t
                    }), this.decorate("render")
                }

                get bindTemplate() {
                    return this._bindTemplate ? this._bindTemplate : this._bindTemplate = xi.bind(this, this)
                }

                createCollection(e) {
                    const t = new un(e);
                    return this._viewCollections.add(t), t
                }

                registerChild(e) {
                    oe(e) || (e = [e]);
                    for (const t of e) this._unboundChildren.add(t)
                }

                deregisterChild(e) {
                    oe(e) || (e = [e]);
                    for (const t of e) this._unboundChildren.remove(t)
                }

                setTemplate(e) {
                    this.template = new xi(e)
                }

                extendTemplate(e) {
                    xi.extend(this.template, e)
                }

                render() {
                    if (this.isRendered) throw new R("ui-view-render-already-rendered", this);
                    this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0
                }

                destroy() {
                    this.stopListening(), this._viewCollections.map(e => e.destroy()), this.template && this.template._revertData && this.template.revert(this.element)
                }
            }

            class xi extends Le() {
                constructor(e) {
                    super(), Object.assign(this, yd($c(e))), this._isRendered = !1, this._revertData = null
                }

                render() {
                    const e = this._renderNode({intoFragment: !0});
                    return this._isRendered = !0, e
                }

                apply(e) {
                    return this._revertData = {children: [], bindings: [], attributes: {}}, this._renderNode({
                        node: e,
                        intoFragment: !1,
                        isApplying: !0,
                        revertData: this._revertData
                    }), e
                }

                revert(e) {
                    if (!this._revertData) throw new R("ui-template-revert-not-applied", [this, e]);
                    this._revertTemplateFromNode(e, this._revertData)
                }

                * getViews() {
                    yield* function* e(t) {
                        if (t.children) for (const n of t.children) Gc(n) ? yield n : Kc(n) && (yield* e(n))
                    }(this)
                }

                static bind(e, t) {
                    return {
                        to: (n, i) => new Kf({
                            eventNameOrFunction: n,
                            attribute: n,
                            observable: e,
                            emitter: t,
                            callback: i
                        }),
                        if: (n, i, s) => new Uc({observable: e, emitter: t, attribute: n, valueIfTrue: i, callback: s})
                    }
                }

                static extend(e, t) {
                    if (e._isRendered) throw new R("template-extend-render", [this, e]);
                    Wi(e, yd($c(t)))
                }

                _renderNode(e) {
                    let t;
                    if (t = e.node ? this.tag && this.text : this.tag ? this.text : !this.text, t) throw new R("ui-template-wrong-syntax", this);
                    return this.text ? this._renderText(e) : this._renderElement(e)
                }

                _renderElement(e) {
                    let t = e.node;
                    return t || (t = e.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(e), this._renderElementChildren(e), this._setUpListeners(e), t
                }

                _renderText(e) {
                    let t = e.node;
                    return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""), qc(this.text) ? this._bindToObservable({
                        schema: this.text,
                        updater: _d(t),
                        data: e
                    }) : t.textContent = this.text.join(""), t
                }

                _renderAttributes(e) {
                    if (!this.attributes) return;
                    const t = e.node, n = e.revertData;
                    for (const i in this.attributes) {
                        const s = t.getAttribute(i), l = this.attributes[i];
                        n && (n.attributes[i] = s);
                        const d = Kt(l) ? l[0].ns : null;
                        if (qc(l)) {
                            const g = Kt(l) ? l[0].value : l;
                            n && ai(i) && g.unshift(s), this._bindToObservable({
                                schema: g,
                                updater: Zf(t, i, d),
                                data: e
                            })
                        } else if (i == "style" && typeof l[0] != "string") this._renderStyleAttribute(l[0], e); else {
                            n && s && ai(i) && l.unshift(s);
                            const g = l.map(v => v && v.value || v).reduce((v, _) => v.concat(_), []).reduce(Qf, "");
                            Cs(g) || t.setAttributeNS(d, i, g)
                        }
                    }
                }

                _renderStyleAttribute(e, t) {
                    const n = t.node;
                    for (const i in e) {
                        const s = e[i];
                        qc(s) ? this._bindToObservable({schema: [s], updater: Yf(n, i), data: t}) : n.style[i] = s
                    }
                }

                _renderElementChildren(e) {
                    const t = e.node, n = e.intoFragment ? document.createDocumentFragment() : t, i = e.isApplying;
                    let s = 0;
                    for (const l of this.children) if (Lr(l)) {
                        if (!i) {
                            l.setParent(t);
                            for (const d of l) n.appendChild(d.element)
                        }
                    } else if (Gc(l)) i || (l.isRendered || l.render(), n.appendChild(l.element)); else if (Po(l)) n.appendChild(l); else if (i) {
                        const d = {children: [], bindings: [], attributes: {}};
                        e.revertData.children.push(d), l._renderNode({
                            intoFragment: !1,
                            node: n.childNodes[s++],
                            isApplying: !0,
                            revertData: d
                        })
                    } else n.appendChild(l.render());
                    e.intoFragment && t.appendChild(n)
                }

                _setUpListeners(e) {
                    if (this.eventListeners) for (const t in this.eventListeners) {
                        const n = this.eventListeners[t].map(i => {
                            const [s, l] = t.split("@");
                            return i.activateDomEventListener(s, l, e)
                        });
                        e.revertData && e.revertData.bindings.push(n)
                    }
                }

                _bindToObservable({schema: e, updater: t, data: n}) {
                    const i = n.revertData;
                    Wc(e, t, n);
                    const s = e.filter(l => !Cs(l)).filter(l => l.observable).map(l => l.activateAttributeListener(e, t, n));
                    i && i.bindings.push(s)
                }

                _revertTemplateFromNode(e, t) {
                    for (const i of t.bindings) for (const s of i) s();
                    if (t.text) return void (e.textContent = t.text);
                    const n = e;
                    for (const i in t.attributes) {
                        const s = t.attributes[i];
                        s === null ? n.removeAttribute(i) : n.setAttribute(i, s)
                    }
                    for (let i = 0; i < t.children.length; ++i) this._revertTemplateFromNode(n.childNodes[i], t.children[i])
                }
            }

            class As {
                constructor(e) {
                    this.attribute = e.attribute, this.observable = e.observable, this.emitter = e.emitter, this.callback = e.callback
                }

                getValue(e) {
                    const t = this.observable[this.attribute];
                    return this.callback ? this.callback(t, e) : t
                }

                activateAttributeListener(e, t, n) {
                    const i = () => Wc(e, t, n);
                    return this.emitter.listenTo(this.observable, `change:${this.attribute}`, i), () => {
                        this.emitter.stopListening(this.observable, `change:${this.attribute}`, i)
                    }
                }
            }

            class Kf extends As {
                constructor(e) {
                    super(e), this.eventNameOrFunction = e.eventNameOrFunction
                }

                activateDomEventListener(e, t, n) {
                    const i = (s, l) => {
                        t && !l.target.matches(t) || (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(l) : this.observable.fire(this.eventNameOrFunction, l))
                    };
                    return this.emitter.listenTo(n.node, e, i), () => {
                        this.emitter.stopListening(n.node, e, i)
                    }
                }
            }

            class Uc extends As {
                constructor(e) {
                    super(e), this.valueIfTrue = e.valueIfTrue
                }

                getValue(e) {
                    return !Cs(super.getValue(e)) && (this.valueIfTrue || !0)
                }
            }

            function qc(r) {
                return !!r && (r.value && (r = r.value), Array.isArray(r) ? r.some(qc) : r instanceof As)
            }

            function Wc(r, e, {node: t}) {
                const n = function (s, l) {
                    return s.map(d => d instanceof As ? d.getValue(l) : d)
                }(r, t);
                let i;
                i = r.length == 1 && r[0] instanceof Uc ? n[0] : n.reduce(Qf, ""), Cs(i) ? e.remove() : e.set(i)
            }

            function _d(r) {
                return {
                    set(e) {
                        r.textContent = e
                    }, remove() {
                        r.textContent = ""
                    }
                }
            }

            function Zf(r, e, t) {
                return {
                    set(n) {
                        r.setAttributeNS(t, e, n)
                    }, remove() {
                        r.removeAttributeNS(t, e)
                    }
                }
            }

            function Yf(r, e) {
                return {
                    set(t) {
                        r.style[e] = t
                    }, remove() {
                        r.style[e] = null
                    }
                }
            }

            function $c(r) {
                return hl(r, e => {
                    if (e && (e instanceof As || Kc(e) || Gc(e) || Lr(e))) return e
                })
            }

            function yd(r) {
                if (typeof r == "string" ? r = function (e) {
                    return {text: [e]}
                }(r) : r.text && function (e) {
                    e.text = qn(e.text)
                }(r), r.on && (r.eventListeners = function (e) {
                    for (const t in e) fa(e, t);
                    return e
                }(r.on), delete r.on), !r.text) {
                    r.attributes && function (t) {
                        for (const n in t) t[n].value && (t[n].value = qn(t[n].value)), fa(t, n)
                    }(r.attributes);
                    const e = [];
                    if (r.children) if (Lr(r.children)) e.push(r.children); else for (const t of r.children) Kc(t) || Gc(t) || Po(t) ? e.push(t) : e.push(new xi(t));
                    r.children = e
                }
                return r
            }

            function fa(r, e) {
                r[e] = qn(r[e])
            }

            function Qf(r, e) {
                return Cs(e) ? r : Cs(r) ? e : `${r} ${e}`
            }

            function Al(r, e) {
                for (const t in e) r[t] ? r[t].push(...e[t]) : r[t] = e[t]
            }

            function Wi(r, e) {
                if (e.attributes && (r.attributes || (r.attributes = {}), Al(r.attributes, e.attributes)), e.eventListeners && (r.eventListeners || (r.eventListeners = {}), Al(r.eventListeners, e.eventListeners)), e.text && r.text.push(...e.text), e.children && e.children.length) {
                    if (r.children.length != e.children.length) throw new R("ui-template-extend-children-mismatch", r);
                    let t = 0;
                    for (const n of e.children) Wi(r.children[t++], n)
                }
            }

            function Cs(r) {
                return !r && r !== 0
            }

            function Gc(r) {
                return r instanceof It
            }

            function Kc(r) {
                return r instanceof xi
            }

            function Lr(r) {
                return r instanceof un
            }

            function Kt(r) {
                return Oe(r[0]) && r[0].ns
            }

            function ai(r) {
                return r == "class" || r == "style"
            }

            class Vo extends un {
                constructor(e, t = []) {
                    super(t), this.locale = e
                }

                get bodyCollectionContainer() {
                    return this._bodyCollectionContainer
                }

                attachToDom() {
                    this._bodyCollectionContainer = new xi({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                            dir: this.locale.uiLanguageDirection
                        },
                        children: this
                    }).render();
                    let e = document.querySelector(".ck-body-wrapper");
                    e || (e = Ir(document, "div", {class: "ck-body-wrapper"}), document.body.appendChild(e)), e.appendChild(this._bodyCollectionContainer)
                }

                detachFromDom() {
                    super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
                    const e = document.querySelector(".ck-body-wrapper");
                    e && e.childElementCount == 0 && e.remove()
                }
            }

            var bo = C(6574),
                Jf = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(bo.Z, Jf), bo.Z.locals;
            const Zc = class extends It {
                constructor() {
                    super();
                    const r = this.bindTemplate;
                    this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.set("isVisible", !0), this.setTemplate({
                        tag: "svg",
                        ns: "http://www.w3.org/2000/svg",
                        attributes: {
                            class: ["ck", "ck-icon", r.if("isVisible", "ck-hidden", e => !e), "ck-reset_all-excluded", r.if("isColorInherited", "ck-icon_inherit-color")],
                            viewBox: r.to("viewBox")
                        }
                    })
                }

                render() {
                    super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
                        this._updateXMLContent(), this._colorFillPaths()
                    }), this.on("change:fillColor", () => {
                        this._colorFillPaths()
                    })
                }

                _updateXMLContent() {
                    if (this.content) {
                        const r = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"),
                            e = r.getAttribute("viewBox");
                        e && (this.viewBox = e);
                        for (const {
                            name: t,
                            value: n
                        } of Array.from(r.attributes)) Zc.presentationalAttributeNames.includes(t) && this.element.setAttribute(t, n);
                        for (; this.element.firstChild;) this.element.removeChild(this.element.firstChild);
                        for (; r.childNodes.length > 0;) this.element.appendChild(r.childNodes[0])
                    }
                }

                _colorFillPaths() {
                    this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach(r => {
                        r.style.fill = this.fillColor
                    })
                }
            };
            let Ho = Zc;
            Ho.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];

            class zm extends It {
                constructor() {
                    super(), this.set({style: void 0, text: void 0, id: void 0});
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "span",
                        attributes: {class: ["ck", "ck-button__label"], style: e.to("style"), id: e.to("id")},
                        children: [{text: e.to("text")}]
                    })
                }
            }

            var Yc = C(4906),
                Cl = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Yc.Z, Cl), Yc.Z.locals;

            class sn extends It {
                constructor(e, t = new zm) {
                    super(e), this._focusDelayed = null;
                    const n = this.bindTemplate, i = Y();
                    this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${i}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._setupLabelView(t), this.iconView = new Ho, this.iconView.extendTemplate({attributes: {class: "ck-button__icon"}}), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
                    const s = {
                        tag: "button",
                        attributes: {
                            class: ["ck", "ck-button", n.to("class"), n.if("isEnabled", "ck-disabled", l => !l), n.if("isVisible", "ck-hidden", l => !l), n.to("isOn", l => l ? "ck-on" : "ck-off"), n.if("withText", "ck-button_with-text"), n.if("withKeystroke", "ck-button_with-keystroke")],
                            role: n.to("role"),
                            type: n.to("type", l => l || "button"),
                            tabindex: n.to("tabindex"),
                            "aria-label": n.to("ariaLabel"),
                            "aria-labelledby": n.to("ariaLabelledBy"),
                            "aria-disabled": n.if("isEnabled", !0, l => !l),
                            "aria-pressed": n.to("isOn", l => !!this.isToggleable && String(!!l)),
                            "data-cke-tooltip-text": n.to("_tooltipString"),
                            "data-cke-tooltip-position": n.to("tooltipPosition")
                        },
                        children: this.children,
                        on: {
                            click: n.to(l => {
                                this.isEnabled ? this.fire("execute") : l.preventDefault()
                            })
                        }
                    };
                    T.isSafari && (this._focusDelayed || (this._focusDelayed = Ad(() => this.focus(), 0)), s.on.mousedown = n.to(() => {
                        this._focusDelayed()
                    }), s.on.mouseup = n.to(() => {
                        this._focusDelayed.cancel()
                    })), this.setTemplate(s)
                }

                render() {
                    super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView)
                }

                focus() {
                    this.element.focus()
                }

                destroy() {
                    this._focusDelayed && this._focusDelayed.cancel(), super.destroy()
                }

                _setupLabelView(e) {
                    return e.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy"), e
                }

                _createKeystrokeView() {
                    const e = new It;
                    return e.setTemplate({
                        tag: "span",
                        attributes: {class: ["ck", "ck-button__keystroke"]},
                        children: [{text: this.bindTemplate.to("keystroke", t => ha(t))}]
                    }), e
                }

                _getTooltipString(e, t, n) {
                    return e ? typeof e == "string" ? e : (n && (n = ha(n)), e instanceof Function ? e(t, n) : `${t}${n ? ` (${n})` : ""}`) : ""
                }
            }

            var Qc = C(5332),
                Uo = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Qc.Z, Uo), Qc.Z.locals;

            class _l extends sn {
                constructor(e) {
                    super(e), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({attributes: {class: "ck-switchbutton"}})
                }

                render() {
                    super.render(), this.children.add(this.toggleSwitchView)
                }

                _createToggleView() {
                    const e = new It;
                    return e.setTemplate({
                        tag: "span",
                        attributes: {class: ["ck", "ck-button__toggle"]},
                        children: [{tag: "span", attributes: {class: ["ck", "ck-button__toggle__inner"]}}]
                    }), e
                }
            }

            var Dd = C(6781),
                jm = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Dd.Z, jm), Dd.Z.locals, C(1103), C(841);
            var yl = C(3662),
                xd = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(yl.Z, xd), yl.Z.locals;

            class Jc extends It {
                constructor(e) {
                    super(e), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${Y()}`;
                    const t = this.bindTemplate;
                    this.setTemplate({
                        tag: "label",
                        attributes: {class: ["ck", "ck-label"], id: this.id, for: t.to("for")},
                        children: [{text: t.to("text")}]
                    })
                }
            }

            var Xf = C(2577),
                eg = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Xf.Z, eg), Xf.Z.locals;

            class Xc extends It {
                constructor(e, t) {
                    super(e);
                    const n = `ck-labeled-field-view-${Y()}`, i = `ck-labeled-field-view-status-${Y()}`;
                    this.fieldView = t(this, n, i), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n), this.statusView = this._createStatusView(i), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (l, d) => l || d);
                    const s = this.bindTemplate;
                    this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-labeled-field-view", s.to("class"), s.if("isEnabled", "ck-disabled", l => !l), s.if("isEmpty", "ck-labeled-field-view_empty"), s.if("isFocused", "ck-labeled-field-view_focused"), s.if("placeholder", "ck-labeled-field-view_placeholder"), s.if("errorText", "ck-error")]},
                        children: [{
                            tag: "div",
                            attributes: {class: ["ck", "ck-labeled-field-view__input-wrapper"]},
                            children: this.fieldWrapperChildren
                        }, this.statusView]
                    })
                }

                _createLabelView(e) {
                    const t = new Jc(this.locale);
                    return t.for = e, t.bind("text").to(this, "label"), t
                }

                _createStatusView(e) {
                    const t = new It(this.locale), n = this.bindTemplate;
                    return t.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", i => !i)],
                            id: e,
                            role: n.if("errorText", "alert")
                        },
                        children: [{text: n.to("_statusText")}]
                    }), t
                }

                focus(e) {
                    this.fieldView.focus(e)
                }
            }

            class Vm extends It {
                constructor(e) {
                    super(e), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.focusTracker = new Nr, this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0);
                    const t = this.bindTemplate;
                    this.setTemplate({
                        tag: "input",
                        attributes: {
                            class: ["ck", "ck-input", t.if("isFocused", "ck-input_focused"), t.if("isEmpty", "ck-input-text_empty"), t.if("hasError", "ck-error")],
                            id: t.to("id"),
                            placeholder: t.to("placeholder"),
                            readonly: t.to("isReadOnly"),
                            "aria-invalid": t.if("hasError", !0),
                            "aria-describedby": t.to("ariaDescribedById")
                        },
                        on: {
                            input: t.to((...n) => {
                                this.fire("input", ...n), this._updateIsEmpty()
                            }), change: t.to(this._updateIsEmpty.bind(this))
                        }
                    })
                }

                render() {
                    super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e, t, n) => {
                        this._setDomElementValue(n), this._updateIsEmpty()
                    })
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy()
                }

                select() {
                    this.element.select()
                }

                focus() {
                    this.element.focus()
                }

                reset() {
                    this.value = this.element.value = "", this._updateIsEmpty()
                }

                _updateIsEmpty() {
                    this.isEmpty = !this.element.value
                }

                _setDomElementValue(e) {
                    this.element.value = e || e === 0 ? e : ""
                }
            }

            var Dl = C(4879),
                tg = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Dl.Z, tg), Dl.Z.locals;

            class Hm extends Vm {
                constructor(e) {
                    super(e), this.set("inputMode", "text");
                    const t = this.bindTemplate;
                    this.extendTemplate({attributes: {inputmode: t.to("inputMode")}})
                }
            }

            class Um extends Hm {
                constructor(e) {
                    super(e), this.extendTemplate({attributes: {type: "text", class: ["ck-input-text"]}})
                }
            }

            var Ed = C(8182),
                ga = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Ed.Z, ga), Ed.Z.locals;

            class Sd extends It {
                constructor(e) {
                    super(e);
                    const t = this.bindTemplate;
                    this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-dropdown__panel", t.to("position", n => `ck-dropdown__panel_${n}`), t.if("isVisible", "ck-dropdown__panel-visible")],
                            tabindex: "-1"
                        },
                        children: this.children,
                        on: {
                            selectstart: t.to(n => {
                                n.target.tagName.toLocaleLowerCase() !== "input" && n.preventDefault()
                            })
                        }
                    })
                }

                focus() {
                    if (this.children.length) {
                        const e = this.children.first;
                        typeof e.focus == "function" ? e.focus() : ae("ui-dropdown-panel-focus-child-missing-focus", {
                            childView: this.children.first,
                            dropdownPanel: this
                        })
                    }
                }

                focusLast() {
                    if (this.children.length) {
                        const e = this.children.last;
                        typeof e.focusLast == "function" ? e.focusLast() : e.focus()
                    }
                }
            }

            var xl = C(5485),
                ng = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(xl.Z, ng), xl.Z.locals;
            const El = class extends It {
                constructor(r, e, t) {
                    super(r);
                    const n = this.bindTemplate;
                    this.buttonView = e, this.panelView = t, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new si, this.focusTracker = new Nr, this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-dropdown", n.to("class"), n.if("isEnabled", "ck-disabled", i => !i)],
                            id: n.to("id"),
                            "aria-describedby": n.to("ariaDescribedById")
                        },
                        children: [e, t]
                    }), e.extendTemplate({
                        attributes: {
                            class: ["ck-dropdown__button"],
                            "data-cke-tooltip-disabled": n.to("isOpen")
                        }
                    })
                }

                render() {
                    super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
                        this.isOpen = !this.isOpen
                    }), this.on("change:isOpen", (e, t, n) => {
                        if (n) if (this.panelPosition === "auto") {
                            const i = El._getOptimalPosition({
                                element: this.panelView.element,
                                target: this.buttonView.element,
                                fitInViewport: !0,
                                positions: this._panelPositions
                            });
                            this.panelView.position = i ? i.name : this._panelPositions[0].name
                        } else this.panelView.position = this.panelPosition
                    }), this.keystrokes.listenTo(this.element);
                    const r = (e, t) => {
                        this.isOpen && (this.isOpen = !1, t())
                    };
                    this.keystrokes.set("arrowdown", (e, t) => {
                        this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, t())
                    }), this.keystrokes.set("arrowright", (e, t) => {
                        this.isOpen && t()
                    }), this.keystrokes.set("arrowleft", r), this.keystrokes.set("esc", r)
                }

                focus() {
                    this.buttonView.focus()
                }

                get _panelPositions() {
                    const {
                        south: r,
                        north: e,
                        southEast: t,
                        southWest: n,
                        northEast: i,
                        northWest: s,
                        southMiddleEast: l,
                        southMiddleWest: d,
                        northMiddleEast: g,
                        northMiddleWest: v
                    } = El.defaultPanelPositions;
                    return this.locale.uiLanguageDirection !== "rtl" ? [t, n, l, d, r, i, s, g, v, e] : [n, t, d, l, r, s, i, v, g, e]
                }
            };
            let eu = El;
            eu.defaultPanelPositions = {
                south: (r, e) => ({
                    top: r.bottom,
                    left: r.left - (e.width - r.width) / 2,
                    name: "s"
                }),
                southEast: r => ({top: r.bottom, left: r.left, name: "se"}),
                southWest: (r, e) => ({top: r.bottom, left: r.left - e.width + r.width, name: "sw"}),
                southMiddleEast: (r, e) => ({top: r.bottom, left: r.left - (e.width - r.width) / 4, name: "sme"}),
                southMiddleWest: (r, e) => ({top: r.bottom, left: r.left - 3 * (e.width - r.width) / 4, name: "smw"}),
                north: (r, e) => ({top: r.top - e.height, left: r.left - (e.width - r.width) / 2, name: "n"}),
                northEast: (r, e) => ({top: r.top - e.height, left: r.left, name: "ne"}),
                northWest: (r, e) => ({top: r.top - e.height, left: r.left - e.width + r.width, name: "nw"}),
                northMiddleEast: (r, e) => ({
                    top: r.top - e.height,
                    left: r.left - (e.width - r.width) / 4,
                    name: "nme"
                }),
                northMiddleWest: (r, e) => ({
                    top: r.top - e.height,
                    left: r.left - 3 * (e.width - r.width) / 4,
                    name: "nmw"
                })
            }, eu._getOptimalPosition = zo;
            const Td = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';

            class rg extends sn {
                constructor(e) {
                    super(e), this.arrowView = this._createArrowView(), this.extendTemplate({
                        attributes: {
                            "aria-haspopup": !0,
                            "aria-expanded": this.bindTemplate.to("isOn", t => String(t))
                        }
                    }), this.delegate("execute").to(this, "open")
                }

                render() {
                    super.render(), this.children.add(this.arrowView)
                }

                _createArrowView() {
                    const e = new Ho;
                    return e.content = Td, e.extendTemplate({attributes: {class: "ck-dropdown__arrow"}}), e
                }
            }

            class yn extends Le() {
                constructor(e) {
                    if (super(), this.focusables = e.focusables, this.focusTracker = e.focusTracker, this.keystrokeHandler = e.keystrokeHandler, this.actions = e.actions, e.actions && e.keystrokeHandler) for (const t in e.actions) {
                        let n = e.actions[t];
                        typeof n == "string" && (n = [n]);
                        for (const i of n) e.keystrokeHandler.set(i, (s, l) => {
                            this[t](), l()
                        })
                    }
                    this.on("forwardCycle", () => this.focusFirst(), {priority: "low"}), this.on("backwardCycle", () => this.focusLast(), {priority: "low"})
                }

                get first() {
                    return this.focusables.find(pa) || null
                }

                get last() {
                    return this.focusables.filter(pa).slice(-1)[0] || null
                }

                get next() {
                    return this._getFocusableItem(1)
                }

                get previous() {
                    return this._getFocusableItem(-1)
                }

                get current() {
                    let e = null;
                    return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t, n) => {
                        const i = t.element === this.focusTracker.focusedElement;
                        return i && (e = n), i
                    }), e)
                }

                focusFirst() {
                    this._focus(this.first, 1)
                }

                focusLast() {
                    this._focus(this.last, -1)
                }

                focusNext() {
                    const e = this.next;
                    e && this.focusables.getIndex(e) === this.current || (e === this.first ? this.fire("forwardCycle") : this._focus(e, 1))
                }

                focusPrevious() {
                    const e = this.previous;
                    e && this.focusables.getIndex(e) === this.current || (e === this.last ? this.fire("backwardCycle") : this._focus(e, -1))
                }

                _focus(e, t) {
                    e && e.focus(t)
                }

                _getFocusableItem(e) {
                    const t = this.current, n = this.focusables.length;
                    if (!n) return null;
                    if (t === null) return this[e === 1 ? "first" : "last"];
                    let i = (t + n + e) % n;
                    do {
                        const s = this.focusables.get(i);
                        if (pa(s)) return s;
                        i = (i + n + e) % n
                    } while (i !== t);
                    return null
                }
            }

            function pa(r) {
                return !(!("focus" in r) || !mo(r.element))
            }

            class Id extends It {
                constructor(e) {
                    super(e), this.setTemplate({tag: "span", attributes: {class: ["ck", "ck-toolbar__separator"]}})
                }
            }

            class ig extends It {
                constructor(e) {
                    super(e), this.setTemplate({tag: "span", attributes: {class: ["ck", "ck-toolbar__line-break"]}})
                }
            }

            var og = Object.defineProperty, _s = Object.getOwnPropertySymbols, tu = Object.prototype.hasOwnProperty,
                sg = Object.prototype.propertyIsEnumerable, Md = (r, e, t) => e in r ? og(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, Bd = (r, e) => {
                    for (var t in e || (e = {})) tu.call(e, t) && Md(r, t, e[t]);
                    if (_s) for (var t of _s(e)) sg.call(e, t) && Md(r, t, e[t]);
                    return r
                };

            function ys(r) {
                if (Array.isArray(r)) return {items: r, removeItems: []};
                const e = {items: [], removeItems: []};
                return r ? Bd(Bd({}, e), r) : e
            }

            class Re extends we() {
                constructor(e) {
                    super(), this._disableStack = new Set, this.editor = e, this.set("isEnabled", !0)
                }

                forceDisabled(e) {
                    this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", Sl, {priority: "highest"}), this.isEnabled = !1)
                }

                clearForceDisabled(e) {
                    this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", Sl), this.isEnabled = !0)
                }

                destroy() {
                    this.stopListening()
                }

                static get isContextPlugin() {
                    return !1
                }
            }

            function Sl(r) {
                r.return = !1, r.stop()
            }

            class Ft extends we() {
                constructor(e) {
                    super(), this.editor = e, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = new Set, this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
                        this.refresh()
                    }), this.listenTo(e, "change:isReadOnly", () => {
                        this.refresh()
                    }), this.on("set:isEnabled", t => {
                        if (!this.affectsData) return;
                        const n = e.model.document.selection,
                            i = n.getFirstPosition().root.rootName != "$graveyard" && e.model.canEditAt(n);
                        (e.isReadOnly || this._isEnabledBasedOnSelection && !i) && (t.return = !1, t.stop())
                    }, {priority: "highest"}), this.on("execute", t => {
                        this.isEnabled || t.stop()
                    }, {priority: "high"})
                }

                get affectsData() {
                    return this._affectsData
                }

                set affectsData(e) {
                    this._affectsData = e
                }

                refresh() {
                    this.isEnabled = !0
                }

                forceDisabled(e) {
                    this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", ma, {priority: "highest"}), this.isEnabled = !1)
                }

                clearForceDisabled(e) {
                    this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", ma), this.refresh())
                }

                execute(...e) {
                }

                destroy() {
                    this.stopListening()
                }
            }

            function ma(r) {
                r.return = !1, r.stop()
            }

            class ag extends Ft {
                constructor() {
                    super(...arguments), this._childCommandsDefinitions = []
                }

                refresh() {
                }

                execute(...e) {
                    const t = this._getFirstEnabledCommand();
                    return !!t && t.execute(e)
                }

                registerChildCommand(e, t = {}) {
                    Ce(this._childCommandsDefinitions, {
                        command: e,
                        priority: t.priority || "normal"
                    }), e.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled()
                }

                _checkEnabled() {
                    this.isEnabled = !!this._getFirstEnabledCommand()
                }

                _getFirstEnabledCommand() {
                    const e = this._childCommandsDefinitions.find(({command: t}) => t.isEnabled);
                    return e && e.command
                }
            }

            class Ds extends Le() {
                constructor(e, t = [], n = []) {
                    super(), this._plugins = new Map, this._context = e, this._availablePlugins = new Map;
                    for (const i of t) i.pluginName && this._availablePlugins.set(i.pluginName, i);
                    this._contextPlugins = new Map;
                    for (const [i, s] of n) this._contextPlugins.set(i, s), this._contextPlugins.set(s, i), i.pluginName && this._availablePlugins.set(i.pluginName, i)
                }

                * [Symbol.iterator]() {
                    for (const e of this._plugins) typeof e[0] == "function" && (yield e)
                }

                get(e) {
                    const t = this._plugins.get(e);
                    if (!t) {
                        let n = e;
                        throw typeof e == "function" && (n = e.pluginName || e.name), new R("plugincollection-plugin-not-loaded", this._context, {plugin: n})
                    }
                    return t
                }

                has(e) {
                    return this._plugins.has(e)
                }

                init(e, t = [], n = []) {
                    const i = this, s = this._context;
                    (function j(U, K = new Set) {
                        U.forEach(ne => {
                            g(ne) && (K.has(ne) || (K.add(ne), ne.pluginName && !i._availablePlugins.has(ne.pluginName) && i._availablePlugins.set(ne.pluginName, ne), ne.requires && j(ne.requires, K)))
                        })
                    })(e), M(e);
                    const l = [...function j(U, K = new Set) {
                        return U.map(ne => g(ne) ? ne : i._availablePlugins.get(ne)).reduce((ne, pe) => K.has(pe) ? ne : (K.add(pe), pe.requires && (M(pe.requires, pe), j(pe.requires, K).forEach(Se => ne.add(Se))), ne.add(pe)), new Set)
                    }(e.filter(j => !_(j, t)))];
                    (function (j, U) {
                        for (const K of U) {
                            if (typeof K != "function") throw new R("plugincollection-replace-plugin-invalid-type", null, {pluginItem: K});
                            const ne = K.pluginName;
                            if (!ne) throw new R("plugincollection-replace-plugin-missing-name", null, {pluginItem: K});
                            if (K.requires && K.requires.length) throw new R("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {pluginName: ne});
                            const pe = i._availablePlugins.get(ne);
                            if (!pe) throw new R("plugincollection-plugin-for-replacing-not-exist", null, {pluginName: ne});
                            const Se = j.indexOf(pe);
                            if (Se === -1) {
                                if (i._contextPlugins.has(pe)) return;
                                throw new R("plugincollection-plugin-for-replacing-not-loaded", null, {pluginName: ne})
                            }
                            if (pe.requires && pe.requires.length) throw new R("plugincollection-replaced-plugin-cannot-have-dependencies", null, {pluginName: ne});
                            j.splice(Se, 1, K), i._availablePlugins.set(ne, K)
                        }
                    })(l, n);
                    const d = l.map(j => {
                        let U = i._contextPlugins.get(j);
                        return U = U || new j(s), i._add(j, U), U
                    });
                    return O(d, "init").then(() => O(d, "afterInit")).then(() => d);

                    function g(j) {
                        return typeof j == "function"
                    }

                    function v(j) {
                        return g(j) && !!j.isContextPlugin
                    }

                    function _(j, U) {
                        return U.some(K => K === j || x(j) === K || x(K) === j)
                    }

                    function x(j) {
                        return g(j) ? j.pluginName || j.name : j
                    }

                    function M(j, U = null) {
                        j.map(K => g(K) ? K : i._availablePlugins.get(K) || K).forEach(K => {
                            (function (ne, pe) {
                                if (!g(ne)) throw pe ? new R("plugincollection-soft-required", s, {
                                    missingPlugin: ne,
                                    requiredBy: x(pe)
                                }) : new R("plugincollection-plugin-not-found", s, {plugin: ne})
                            })(K, U), function (ne, pe) {
                                if (v(pe) && !v(ne)) throw new R("plugincollection-context-required", s, {
                                    plugin: x(ne),
                                    requiredBy: x(pe)
                                })
                            }(K, U), function (ne, pe) {
                                if (pe && _(ne, t)) throw new R("plugincollection-required", s, {
                                    plugin: x(ne),
                                    requiredBy: x(pe)
                                })
                            }(K, U)
                        })
                    }

                    function O(j, U) {
                        return j.reduce((K, ne) => ne[U] ? i._contextPlugins.has(ne) ? K : K.then(ne[U].bind(ne)) : K, Promise.resolve())
                    }
                }

                destroy() {
                    const e = [];
                    for (const [, t] of this) typeof t.destroy != "function" || this._contextPlugins.has(t) || e.push(t.destroy());
                    return Promise.all(e)
                }

                _add(e, t) {
                    this._plugins.set(e, t);
                    const n = e.pluginName;
                    if (n) {
                        if (this._plugins.has(n)) throw new R("plugincollection-plugin-name-conflict", null, {
                            pluginName: n,
                            plugin1: this._plugins.get(n).constructor,
                            plugin2: e
                        });
                        this._plugins.set(n, t)
                    }
                }
            }

            class Nd {
                constructor(e) {
                    this._contextOwner = null, this.config = new pd(e, this.constructor.defaultConfig);
                    const t = this.constructor.builtinPlugins;
                    this.config.define("plugins", t), this.plugins = new Ds(this, t);
                    const n = this.config.get("language") || {};
                    this.locale = new ws({
                        uiLanguage: typeof n == "string" ? n : n.ui,
                        contentLanguage: this.config.get("language.content")
                    }), this.t = this.locale.t, this.editors = new br
                }

                initPlugins() {
                    const e = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
                    for (const n of e.concat(t)) {
                        if (typeof n != "function") throw new R("context-initplugins-constructor-only", null, {Plugin: n});
                        if (n.isContextPlugin !== !0) throw new R("context-initplugins-invalid-plugin", null, {Plugin: n})
                    }
                    return this.plugins.init(e, [], t)
                }

                destroy() {
                    return Promise.all(Array.from(this.editors, e => e.destroy())).then(() => this.plugins.destroy())
                }

                _addEditor(e, t) {
                    if (this._contextOwner) throw new R("context-addeditor-private-context");
                    this.editors.add(e), t && (this._contextOwner = e)
                }

                _removeEditor(e) {
                    return this.editors.has(e) && this.editors.remove(e), this._contextOwner === e ? this.destroy() : Promise.resolve()
                }

                _getEditorConfig() {
                    const e = {};
                    for (const t of this.config.names()) ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
                    return e
                }

                static create(e) {
                    return new Promise(t => {
                        const n = new this(e);
                        t(n.initPlugins().then(() => n))
                    })
                }
            }

            class Tl extends we() {
                constructor(e) {
                    super(), this.context = e
                }

                destroy() {
                    this.stopListening()
                }

                static get isContextPlugin() {
                    return !0
                }
            }

            class lg extends si {
                constructor(e) {
                    super(), this.editor = e
                }

                set(e, t, n = {}) {
                    if (typeof t == "string") {
                        const i = t;
                        t = (s, l) => {
                            this.editor.execute(i), l()
                        }
                    }
                    super.set(e, t, n)
                }
            }

            var ba = C(4717),
                Il = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(ba.Z, Il), ba.Z.locals;
            const qo = new WeakMap;
            let ka = !1;

            function Ld({view: r, element: e, text: t, isDirectHost: n = !0, keepOnFocus: i = !1}) {
                const s = r.document;

                function l(d) {
                    qo.get(s).set(e, {
                        text: d,
                        isDirectHost: n,
                        keepOnFocus: i,
                        hostElement: n ? e : null
                    }), r.change(g => nu(s, g))
                }

                qo.has(s) || (qo.set(s, new Map), s.registerPostFixer(d => nu(s, d)), s.on("change:isComposing", () => {
                    r.change(d => nu(s, d))
                }, {priority: "high"})), e.is("editableElement") && e.on("change:placeholder", (d, g, v) => {
                    l(v)
                }), e.placeholder ? l(e.placeholder) : t && l(t), t && function () {
                    ka || ae("enableplaceholder-deprecated-text-option"), ka = !0
                }()
            }

            function qm(r, e) {
                return !!e.hasClass("ck-placeholder") && (r.removeClass("ck-placeholder", e), !0)
            }

            function nu(r, e) {
                const t = qo.get(r), n = [];
                let i = !1;
                for (const [s, l] of t) l.isDirectHost && (n.push(s), ko(e, s, l) && (i = !0));
                for (const [s, l] of t) {
                    if (l.isDirectHost) continue;
                    const d = va(s);
                    d && (n.includes(d) || (l.hostElement = d, ko(e, s, l) && (i = !0)))
                }
                return i
            }

            function ko(r, e, t) {
                const {text: n, isDirectHost: i, hostElement: s} = t;
                let l = !1;
                return s.getAttribute("data-placeholder") !== n && (r.setAttribute("data-placeholder", n, s), l = !0), (i || e.childCount == 1) && function (d, g) {
                    if (!d.isAttached() || Array.from(d.getChildren()).some(x => !x.is("uiElement"))) return !1;
                    const v = d.document, _ = v.selection.anchor;
                    return !(v.isComposing && _ && _.parent === d || !g && v.isFocused && (!_ || _.parent === d))
                }(s, t.keepOnFocus) ? function (d, g) {
                    return !g.hasClass("ck-placeholder") && (d.addClass("ck-placeholder", g), !0)
                }(r, s) && (l = !0) : qm(r, s) && (l = !0), l
            }

            function va(r) {
                if (r.childCount) {
                    const e = r.getChild(0);
                    if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) return e
                }
                return null
            }

            class Ei {
                is() {
                    throw new Error("is() method is abstract")
                }
            }

            const cg = function (r) {
                return Pc(r, 4)
            };

            class Wo extends Le(Ei) {
                constructor(e) {
                    super(), this.document = e, this.parent = null
                }

                get index() {
                    let e;
                    if (!this.parent) return null;
                    if ((e = this.parent.getChildIndex(this)) == -1) throw new R("view-node-not-found-in-parent", this);
                    return e
                }

                get nextSibling() {
                    const e = this.index;
                    return e !== null && this.parent.getChild(e + 1) || null
                }

                get previousSibling() {
                    const e = this.index;
                    return e !== null && this.parent.getChild(e - 1) || null
                }

                get root() {
                    let e = this;
                    for (; e.parent;) e = e.parent;
                    return e
                }

                isAttached() {
                    return this.root.is("rootElement")
                }

                getPath() {
                    const e = [];
                    let t = this;
                    for (; t.parent;) e.unshift(t.index), t = t.parent;
                    return e
                }

                getAncestors(e = {}) {
                    const t = [];
                    let n = e.includeSelf ? this : this.parent;
                    for (; n;) t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
                    return t
                }

                getCommonAncestor(e, t = {}) {
                    const n = this.getAncestors(t), i = e.getAncestors(t);
                    let s = 0;
                    for (; n[s] == i[s] && n[s];) s++;
                    return s === 0 ? null : n[s - 1]
                }

                isBefore(e) {
                    if (this == e || this.root !== e.root) return !1;
                    const t = this.getPath(), n = e.getPath(), i = te(t, n);
                    switch (i) {
                        case"prefix":
                            return !0;
                        case"extension":
                            return !1;
                        default:
                            return t[i] < n[i]
                    }
                }

                isAfter(e) {
                    return this != e && this.root === e.root && !this.isBefore(e)
                }

                _remove() {
                    this.parent._removeChildren(this.index)
                }

                _fireChange(e, t) {
                    this.fire(`change:${e}`, t), this.parent && this.parent._fireChange(e, t)
                }

                toJSON() {
                    const e = cg(this);
                    return delete e.parent, e
                }
            }

            Wo.prototype.is = function (r) {
                return r === "node" || r === "view:node"
            };

            class dn extends Wo {
                constructor(e, t) {
                    super(e), this._textData = t
                }

                get data() {
                    return this._textData
                }

                get _data() {
                    return this.data
                }

                set _data(e) {
                    this._fireChange("text", this), this._textData = e
                }

                isSimilar(e) {
                    return e instanceof dn && (this === e || this.data === e.data)
                }

                _clone() {
                    return new dn(this.document, this.data)
                }
            }

            dn.prototype.is = function (r) {
                return r === "$text" || r === "view:$text" || r === "text" || r === "view:text" || r === "node" || r === "view:node"
            };

            class $i extends Ei {
                constructor(e, t, n) {
                    if (super(), this.textNode = e, t < 0 || t > e.data.length) throw new R("view-textproxy-wrong-offsetintext", this);
                    if (n < 0 || t + n > e.data.length) throw new R("view-textproxy-wrong-length", this);
                    this.data = e.data.substring(t, t + n), this.offsetInText = t
                }

                get offsetSize() {
                    return this.data.length
                }

                get isPartial() {
                    return this.data.length !== this.textNode.data.length
                }

                get parent() {
                    return this.textNode.parent
                }

                get root() {
                    return this.textNode.root
                }

                get document() {
                    return this.textNode.document
                }

                getAncestors(e = {}) {
                    const t = [];
                    let n = e.includeSelf ? this.textNode : this.parent;
                    for (; n !== null;) t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
                    return t
                }
            }

            $i.prototype.is = function (r) {
                return r === "$textProxy" || r === "view:$textProxy" || r === "textProxy" || r === "view:textProxy"
            };

            class Si {
                constructor(...e) {
                    this._patterns = [], this.add(...e)
                }

                add(...e) {
                    for (let t of e) (typeof t == "string" || t instanceof RegExp) && (t = {name: t}), this._patterns.push(t)
                }

                match(...e) {
                    for (const t of e) for (const n of this._patterns) {
                        const i = yr(t, n);
                        if (i) return {element: t, pattern: n, match: i}
                    }
                    return null
                }

                matchAll(...e) {
                    const t = [];
                    for (const n of e) for (const i of this._patterns) {
                        const s = yr(n, i);
                        s && t.push({element: n, pattern: i, match: s})
                    }
                    return t.length > 0 ? t : null
                }

                getElementName() {
                    if (this._patterns.length !== 1) return null;
                    const e = this._patterns[0], t = e.name;
                    return typeof e == "function" || !t || t instanceof RegExp ? null : t
                }
            }

            function yr(r, e) {
                if (typeof e == "function") return e(r);
                const t = {};
                return e.name && (t.name = function (n, i) {
                    return n instanceof RegExp ? !!i.match(n) : n === i
                }(e.name, r.name), !t.name) || e.attributes && (t.attributes = function (n, i) {
                    const s = new Set(i.getAttributeKeys());
                    return ur(n) ? (n.style !== void 0 && ae("matcher-pattern-deprecated-attributes-style-key", n), n.class !== void 0 && ae("matcher-pattern-deprecated-attributes-class-key", n)) : (s.delete("style"), s.delete("class")), ru(n, s, l => i.getAttribute(l))
                }(e.attributes, r), !t.attributes) || e.classes && (t.classes = function (n, i) {
                    return ru(n, i.getClassNames(), () => {
                    })
                }(e.classes, r), !t.classes) || e.styles && (t.styles = function (n, i) {
                    return ru(n, i.getStyleNames(!0), s => i.getStyle(s))
                }(e.styles, r), !t.styles) ? null : t
            }

            function ru(r, e, t) {
                const n = function (l) {
                    return Array.isArray(l) ? l.map(d => ur(d) ? (d.key !== void 0 && d.value !== void 0 || ae("matcher-pattern-missing-key-or-value", d), [d.key, d.value]) : [d, !0]) : ur(l) ? Object.entries(l) : [[l, !0]]
                }(r), i = Array.from(e), s = [];
                if (n.forEach(([l, d]) => {
                    i.forEach(g => {
                        (function (v, _) {
                            return v === !0 || v === _ || v instanceof RegExp && _.match(v)
                        })(l, g) && function (v, _, x) {
                            if (v === !0) return !0;
                            const M = x(_);
                            return v === M || v instanceof RegExp && !!String(M).match(v)
                        }(d, g, t) && s.push(g)
                    })
                }), n.length && !(s.length < n.length)) return s
            }

            const iu = function (r) {
                return typeof r == "symbol" || lr(r) && Gt(r) == "[object Symbol]"
            };
            var Wm = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, $m = /^\w*$/;
            const ug = function (r, e) {
                if (ot(r)) return !1;
                var t = typeof r;
                return !(t != "number" && t != "symbol" && t != "boolean" && r != null && !iu(r)) || $m.test(r) || !Wm.test(r) || e != null && r in Object(e)
            };

            function ou(r, e) {
                if (typeof r != "function" || e != null && typeof e != "function") throw new TypeError("Expected a function");
                var t = function () {
                    var n = arguments, i = e ? e.apply(this, n) : n[0], s = t.cache;
                    if (s.has(i)) return s.get(i);
                    var l = r.apply(this, n);
                    return t.cache = s.set(i, l) || s, l
                };
                return t.cache = new (ou.Cache || Bo), t
            }

            ou.Cache = Bo;
            const dg = ou, Gm = function (r) {
                var e = dg(r, function (n) {
                    return t.size === 500 && t.clear(), n
                }), t = e.cache;
                return e
            };
            var Km = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                Zm = /\\(\\)?/g, $o = Gm(function (r) {
                    var e = [];
                    return r.charCodeAt(0) === 46 && e.push(""), r.replace(Km, function (t, n, i, s) {
                        e.push(i ? s.replace(Zm, "$1") : n || t)
                    }), e
                });
            const Ml = $o, su = function (r, e) {
                for (var t = -1, n = r == null ? 0 : r.length, i = Array(n); ++t < n;) i[t] = e(r[t], t, r);
                return i
            };
            var wa = De ? De.prototype : void 0, Gi = wa ? wa.toString : void 0;
            const Ym = function r(e) {
                if (typeof e == "string") return e;
                if (ot(e)) return su(e, r) + "";
                if (iu(e)) return Gi ? Gi.call(e) : "";
                var t = e + "";
                return t == "0" && 1 / e == -1 / 0 ? "-0" : t
            }, Pd = function (r) {
                return r == null ? "" : Ym(r)
            }, Go = function (r, e) {
                return ot(r) ? r : ug(r, e) ? [r] : Ml(Pd(r))
            }, hg = function (r) {
                var e = r == null ? 0 : r.length;
                return e ? r[e - 1] : void 0
            }, au = function (r) {
                if (typeof r == "string" || iu(r)) return r;
                var e = r + "";
                return e == "0" && 1 / r == -1 / 0 ? "-0" : e
            }, Od = function (r, e) {
                for (var t = 0, n = (e = Go(e, r)).length; r != null && t < n;) r = r[au(e[t++])];
                return t && t == n ? r : void 0
            }, Bl = function (r, e, t) {
                var n = -1, i = r.length;
                e < 0 && (e = -e > i ? 0 : i + e), (t = t > i ? i : t) < 0 && (t += i), i = e > t ? 0 : t - e >>> 0, e >>>= 0;
                for (var s = Array(i); ++n < i;) s[n] = r[n + e];
                return s
            }, Aa = function (r, e) {
                return e.length < 2 ? r : Od(r, Bl(e, 0, -1))
            }, Fd = function (r, e) {
                return e = Go(e, r), (r = Aa(r, e)) == null || delete r[au(hg(e))]
            }, Rd = function (r, e) {
                return r == null || Fd(r, e)
            }, Ca = function (r, e, t) {
                var n = r == null ? void 0 : Od(r, e);
                return n === void 0 ? t : n
            }, zd = function (r, e, t) {
                (t !== void 0 && !ti(r[e], t) || t === void 0 && !(e in r)) && Dc(r, e, t)
            }, Nl = function (r) {
                return function (e, t, n) {
                    for (var i = -1, s = Object(e), l = n(e), d = l.length; d--;) {
                        var g = l[r ? d : ++i];
                        if (t(s[g], g, s) === !1) break
                    }
                    return e
                }
            }(), fg = function (r) {
                return lr(r) && oi(r)
            }, jd = function (r, e) {
                if ((e !== "constructor" || typeof r[e] != "function") && e != "__proto__") return r[e]
            }, gg = function (r) {
                return ea(r, oa(r))
            }, lu = function (r, e, t, n, i, s, l) {
                var d = jd(r, t), g = jd(e, t), v = l.get(g);
                if (v) zd(r, t, v); else {
                    var _ = s ? s(d, g, t + "", r, e, l) : void 0, x = _ === void 0;
                    if (x) {
                        var M = ot(g), O = !M && hs(g), j = !M && !O && Ic(g);
                        _ = g, M || O || j ? ot(d) ? _ = d : fg(d) ? _ = Df(d) : O ? (x = !1, _ = yf(g, !0)) : j ? (x = !1, _ = ud(g, !0)) : _ = [] : ur(g) || ds(g) ? (_ = d, ds(d) ? _ = gg(d) : Oe(d) && !ni(d) || (_ = zf(g))) : x = !1
                    }
                    x && (l.set(g, _), i(_, g, n, s, l), l.delete(g)), zd(r, t, _)
                }
            }, Qm = function r(e, t, n, i, s) {
                e !== t && Nl(t, function (l, d) {
                    if (s || (s = new us), Oe(l)) lu(e, t, d, n, r, i, s); else {
                        var g = i ? i(jd(e, d), l, d + "", e, t, s) : void 0;
                        g === void 0 && (g = l), zd(e, d, g)
                    }
                }, oa)
            }, xs = function (r) {
                return r
            }, Ll = function (r, e, t) {
                switch (t.length) {
                    case 0:
                        return r.call(e);
                    case 1:
                        return r.call(e, t[0]);
                    case 2:
                        return r.call(e, t[0], t[1]);
                    case 3:
                        return r.call(e, t[0], t[1], t[2])
                }
                return r.apply(e, t)
            };
            var Vd = Math.max;
            const pg = function (r, e, t) {
                return e = Vd(e === void 0 ? r.length - 1 : e, 0), function () {
                    for (var n = arguments, i = -1, s = Vd(n.length - e, 0), l = Array(s); ++i < s;) l[i] = n[e + i];
                    i = -1;
                    for (var d = Array(e + 1); ++i < e;) d[i] = n[i];
                    return d[e] = t(l), Ll(r, this, d)
                }
            }, Jm = function (r) {
                return function () {
                    return r
                }
            }, Hd = il ? function (r, e) {
                return il(r, "toString", {configurable: !0, enumerable: !1, value: Jm(e), writable: !0})
            } : xs;
            var mg = Date.now;
            const bg = function (r) {
                var e = 0, t = 0;
                return function () {
                    var n = mg(), i = 16 - (n - t);
                    if (t = n, i > 0) {
                        if (++e >= 800) return arguments[0]
                    } else e = 0;
                    return r.apply(void 0, arguments)
                }
            }(Hd), kg = function (r, e) {
                return bg(pg(r, e, xs), r + "")
            }, Xm = function (r, e, t) {
                if (!Oe(t)) return !1;
                var n = typeof e;
                return !!(n == "number" ? oi(t) && Ju(e, t.length) : n == "string" && e in t) && ti(t[e], r)
            }, cu = function (r) {
                return kg(function (e, t) {
                    var n = -1, i = t.length, s = i > 1 ? t[i - 1] : void 0, l = i > 2 ? t[2] : void 0;
                    for (s = r.length > 3 && typeof s == "function" ? (i--, s) : void 0, l && Xm(t[0], t[1], l) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++n < i;) {
                        var d = t[n];
                        d && r(e, d, n, s)
                    }
                    return e
                })
            }, _a = cu(function (r, e, t) {
                Qm(r, e, t)
            }), Pl = function (r, e, t, n) {
                if (!Oe(r)) return r;
                for (var i = -1, s = (e = Go(e, r)).length, l = s - 1, d = r; d != null && ++i < s;) {
                    var g = au(e[i]), v = t;
                    if (g === "__proto__" || g === "constructor" || g === "prototype") return r;
                    if (i != l) {
                        var _ = d[g];
                        (v = n ? n(_, g, d) : void 0) === void 0 && (v = Oe(_) ? _ : Ju(e[i + 1]) ? [] : {})
                    }
                    Qu(d, g, v), d = d[g]
                }
                return r
            }, eb = function (r, e, t) {
                return r == null ? r : Pl(r, e, t)
            };

            class vg {
                constructor(e) {
                    this._styles = {}, this._styleProcessor = e
                }

                get isEmpty() {
                    return !Object.entries(this._styles).length
                }

                get size() {
                    return this.isEmpty ? 0 : this.getStyleNames().length
                }

                setTo(e) {
                    this.clear();
                    const t = function (n) {
                        let i = null, s = 0, l = 0, d = null;
                        const g = new Map;
                        if (n === "") return g;
                        n.charAt(n.length - 1) != ";" && (n += ";");
                        for (let v = 0; v < n.length; v++) {
                            const _ = n.charAt(v);
                            if (i === null) switch (_) {
                                case":":
                                    d || (d = n.substr(s, v - s), l = v + 1);
                                    break;
                                case'"':
                                case"'":
                                    i = _;
                                    break;
                                case";": {
                                    const x = n.substr(l, v - l);
                                    d && g.set(d.trim(), x.trim()), d = null, s = v + 1;
                                    break
                                }
                            } else _ === i && (i = null)
                        }
                        return g
                    }(e);
                    for (const [n, i] of t) this._styleProcessor.toNormalizedForm(n, i, this._styles)
                }

                has(e) {
                    if (this.isEmpty) return !1;
                    const t = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
                    return Array.isArray(t)
                }

                set(e, t) {
                    if (Oe(e)) for (const [n, i] of Object.entries(e)) this._styleProcessor.toNormalizedForm(n, i, this._styles); else this._styleProcessor.toNormalizedForm(e, t, this._styles)
                }

                remove(e) {
                    const t = Ud(e);
                    Rd(this._styles, t), delete this._styles[e], this._cleanEmptyObjectsOnPath(t)
                }

                getNormalized(e) {
                    return this._styleProcessor.getNormalized(e, this._styles)
                }

                toString() {
                    return this.isEmpty ? "" : this._getStylesEntries().map(e => e.join(":")).sort().join(";") + ";"
                }

                getAsString(e) {
                    if (this.isEmpty) return;
                    if (this._styles[e] && !Oe(this._styles[e])) return this._styles[e];
                    const t = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
                    return Array.isArray(t) ? t[1] : void 0
                }

                getStyleNames(e = !1) {
                    return this.isEmpty ? [] : e ? this._styleProcessor.getStyleNames(this._styles) : this._getStylesEntries().map(([t]) => t)
                }

                clear() {
                    this._styles = {}
                }

                _getStylesEntries() {
                    const e = [], t = Object.keys(this._styles);
                    for (const n of t) e.push(...this._styleProcessor.getReducedForm(n, this._styles));
                    return e
                }

                _cleanEmptyObjectsOnPath(e) {
                    const t = e.split(".");
                    if (!(t.length > 1)) return;
                    const n = t.splice(0, t.length - 1).join("."), i = Ca(this._styles, n);
                    i && !Object.keys(i).length && this.remove(n)
                }
            }

            class tb {
                constructor() {
                    this._normalizers = new Map, this._extractors = new Map, this._reducers = new Map, this._consumables = new Map
                }

                toNormalizedForm(e, t, n) {
                    if (Oe(t)) qd(n, Ud(e), t); else if (this._normalizers.has(e)) {
                        const i = this._normalizers.get(e), {path: s, value: l} = i(t);
                        qd(n, s, l)
                    } else qd(n, e, t)
                }

                getNormalized(e, t) {
                    if (!e) return _a({}, t);
                    if (t[e] !== void 0) return t[e];
                    if (this._extractors.has(e)) {
                        const n = this._extractors.get(e);
                        if (typeof n == "string") return Ca(t, n);
                        const i = n(e, t);
                        if (i) return i
                    }
                    return Ca(t, Ud(e))
                }

                getReducedForm(e, t) {
                    const n = this.getNormalized(e, t);
                    return n === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(n) : [[e, n]]
                }

                getStyleNames(e) {
                    const t = Array.from(this._consumables.keys()).filter(i => {
                        const s = this.getNormalized(i, e);
                        return s && typeof s == "object" ? Object.keys(s).length : s
                    }), n = new Set([...t, ...Object.keys(e)]);
                    return Array.from(n)
                }

                getRelatedStyles(e) {
                    return this._consumables.get(e) || []
                }

                setNormalizer(e, t) {
                    this._normalizers.set(e, t)
                }

                setExtractor(e, t) {
                    this._extractors.set(e, t)
                }

                setReducer(e, t) {
                    this._reducers.set(e, t)
                }

                setStyleRelation(e, t) {
                    this._mapStyleNames(e, t);
                    for (const n of t) this._mapStyleNames(n, [e])
                }

                _mapStyleNames(e, t) {
                    this._consumables.has(e) || this._consumables.set(e, []), this._consumables.get(e).push(...t)
                }
            }

            function Ud(r) {
                return r.replace("-", ".")
            }

            function qd(r, e, t) {
                let n = t;
                Oe(t) && (n = _a({}, Ca(r, e), t)), eb(r, e, n)
            }

            class Qr extends Wo {
                constructor(e, t, n, i) {
                    if (super(e), this._unsafeAttributesToRender = [], this._customProperties = new Map, this.name = t, this._attrs = function (s) {
                        const l = qi(s);
                        for (const [d, g] of l) g === null ? l.delete(d) : typeof g != "string" && l.set(d, String(g));
                        return l
                    }(n), this._children = [], i && this._insertChild(0, i), this._classes = new Set, this._attrs.has("class")) {
                        const s = this._attrs.get("class");
                        Wd(this._classes, s), this._attrs.delete("class")
                    }
                    this._styles = new vg(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"))
                }

                get childCount() {
                    return this._children.length
                }

                get isEmpty() {
                    return this._children.length === 0
                }

                getChild(e) {
                    return this._children[e]
                }

                getChildIndex(e) {
                    return this._children.indexOf(e)
                }

                getChildren() {
                    return this._children[Symbol.iterator]()
                }

                * getAttributeKeys() {
                    this._classes.size > 0 && (yield"class"), this._styles.isEmpty || (yield"style"), yield* this._attrs.keys()
                }

                * getAttributes() {
                    yield* this._attrs.entries(), this._classes.size > 0 && (yield["class", this.getAttribute("class")]), this._styles.isEmpty || (yield["style", this.getAttribute("style")])
                }

                getAttribute(e) {
                    if (e == "class") return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
                    if (e == "style") {
                        const t = this._styles.toString();
                        return t == "" ? void 0 : t
                    }
                    return this._attrs.get(e)
                }

                hasAttribute(e) {
                    return e == "class" ? this._classes.size > 0 : e == "style" ? !this._styles.isEmpty : this._attrs.has(e)
                }

                isSimilar(e) {
                    if (!(e instanceof Qr)) return !1;
                    if (this === e) return !0;
                    if (this.name != e.name || this._attrs.size !== e._attrs.size || this._classes.size !== e._classes.size || this._styles.size !== e._styles.size) return !1;
                    for (const [t, n] of this._attrs) if (!e._attrs.has(t) || e._attrs.get(t) !== n) return !1;
                    for (const t of this._classes) if (!e._classes.has(t)) return !1;
                    for (const t of this._styles.getStyleNames()) if (!e._styles.has(t) || e._styles.getAsString(t) !== this._styles.getAsString(t)) return !1;
                    return !0
                }

                hasClass(...e) {
                    for (const t of e) if (!this._classes.has(t)) return !1;
                    return !0
                }

                getClassNames() {
                    return this._classes.keys()
                }

                getStyle(e) {
                    return this._styles.getAsString(e)
                }

                getNormalizedStyle(e) {
                    return this._styles.getNormalized(e)
                }

                getStyleNames(e) {
                    return this._styles.getStyleNames(e)
                }

                hasStyle(...e) {
                    for (const t of e) if (!this._styles.has(t)) return !1;
                    return !0
                }

                findAncestor(...e) {
                    const t = new Si(...e);
                    let n = this.parent;
                    for (; n && !n.is("documentFragment");) {
                        if (t.match(n)) return n;
                        n = n.parent
                    }
                    return null
                }

                getCustomProperty(e) {
                    return this._customProperties.get(e)
                }

                * getCustomProperties() {
                    yield* this._customProperties.entries()
                }

                getIdentity() {
                    const e = Array.from(this._classes).sort().join(","), t = this._styles.toString(),
                        n = Array.from(this._attrs).map(i => `${i[0]}="${i[1]}"`).sort().join(" ");
                    return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (n == "" ? "" : ` ${n}`)
                }

                shouldRenderUnsafeAttribute(e) {
                    return this._unsafeAttributesToRender.includes(e)
                }

                _clone(e = !1) {
                    const t = [];
                    if (e) for (const i of this.getChildren()) t.push(i._clone(e));
                    const n = new this.constructor(this.document, this.name, this._attrs, t);
                    return n._classes = new Set(this._classes), n._styles.set(this._styles.getNormalized()), n._customProperties = new Map(this._customProperties), n.getFillerOffset = this.getFillerOffset, n._unsafeAttributesToRender = this._unsafeAttributesToRender, n
                }

                _appendChild(e) {
                    return this._insertChild(this.childCount, e)
                }

                _insertChild(e, t) {
                    this._fireChange("children", this);
                    let n = 0;
                    const i = function (s, l) {
                        return typeof l == "string" ? [new dn(s, l)] : (oe(l) || (l = [l]), Array.from(l).map(d => typeof d == "string" ? new dn(s, d) : d instanceof $i ? new dn(s, d.data) : d))
                    }(this.document, t);
                    for (const s of i) s.parent !== null && s._remove(), s.parent = this, s.document = this.document, this._children.splice(e, 0, s), e++, n++;
                    return n
                }

                _removeChildren(e, t = 1) {
                    this._fireChange("children", this);
                    for (let n = e; n < e + t; n++) this._children[n].parent = null;
                    return this._children.splice(e, t)
                }

                _setAttribute(e, t) {
                    const n = String(t);
                    this._fireChange("attributes", this), e == "class" ? Wd(this._classes, n) : e == "style" ? this._styles.setTo(n) : this._attrs.set(e, n)
                }

                _removeAttribute(e) {
                    return this._fireChange("attributes", this), e == "class" ? this._classes.size > 0 && (this._classes.clear(), !0) : e == "style" ? !this._styles.isEmpty && (this._styles.clear(), !0) : this._attrs.delete(e)
                }

                _addClass(e) {
                    this._fireChange("attributes", this);
                    for (const t of qn(e)) this._classes.add(t)
                }

                _removeClass(e) {
                    this._fireChange("attributes", this);
                    for (const t of qn(e)) this._classes.delete(t)
                }

                _setStyle(e, t) {
                    this._fireChange("attributes", this), typeof e != "string" ? this._styles.set(e) : this._styles.set(e, t)
                }

                _removeStyle(e) {
                    this._fireChange("attributes", this);
                    for (const t of qn(e)) this._styles.remove(t)
                }

                _setCustomProperty(e, t) {
                    this._customProperties.set(e, t)
                }

                _removeCustomProperty(e) {
                    return this._customProperties.delete(e)
                }
            }

            function Wd(r, e) {
                const t = e.split(/\s+/);
                r.clear(), t.forEach(n => r.add(n))
            }

            Qr.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "element" || r === "view:element") : r === "element" || r === "view:element" || r === "node" || r === "view:node"
            };

            class Ol extends Qr {
                constructor(e, t, n, i) {
                    super(e, t, n, i), this.getFillerOffset = wg
                }
            }

            function wg() {
                const r = [...this.getChildren()], e = r[this.childCount - 1];
                if (e && e.is("element", "br")) return this.childCount;
                for (const t of r) if (!t.is("uiElement")) return null;
                return this.childCount
            }

            Ol.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "containerElement" || r === "view:containerElement" || r === "element" || r === "view:element") : r === "containerElement" || r === "view:containerElement" || r === "element" || r === "view:element" || r === "node" || r === "view:node"
            };

            class Fl extends we(Ol) {
                constructor(e, t, n, i) {
                    super(e, t, n, i), this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("placeholder", void 0), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", s => s && e.selection.editableElement == this), this.listenTo(e.selection, "change", () => {
                        this.isFocused = e.isFocused && e.selection.editableElement == this
                    })
                }

                destroy() {
                    this.stopListening()
                }
            }

            Fl.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "editableElement" || r === "view:editableElement" || r === "containerElement" || r === "view:containerElement" || r === "element" || r === "view:element") : r === "editableElement" || r === "view:editableElement" || r === "containerElement" || r === "view:containerElement" || r === "element" || r === "view:element" || r === "node" || r === "view:node"
            };
            const uu = Symbol("rootName");

            class $d extends Fl {
                constructor(e, t) {
                    super(e, t), this.rootName = "main"
                }

                get rootName() {
                    return this.getCustomProperty(uu)
                }

                set rootName(e) {
                    this._setCustomProperty(uu, e)
                }

                set _name(e) {
                    this.name = e
                }
            }

            $d.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "rootElement" || r === "view:rootElement" || r === "editableElement" || r === "view:editableElement" || r === "containerElement" || r === "view:containerElement" || r === "element" || r === "view:element") : r === "rootElement" || r === "view:rootElement" || r === "editableElement" || r === "view:editableElement" || r === "containerElement" || r === "view:containerElement" || r === "element" || r === "view:element" || r === "node" || r === "view:node"
            };

            class Es {
                constructor(e = {}) {
                    if (!e.boundaries && !e.startPosition) throw new R("view-tree-walker-no-start-position", null);
                    if (e.direction && e.direction != "forward" && e.direction != "backward") throw new R("view-tree-walker-unknown-direction", e.startPosition, {direction: e.direction});
                    this.boundaries = e.boundaries || null, e.startPosition ? this._position = We._createAt(e.startPosition) : this._position = We._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]), this.direction = e.direction || "forward", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
                }

                [Symbol.iterator]() {
                    return this
                }

                get position() {
                    return this._position
                }

                skip(e) {
                    let t, n;
                    do n = this.position, t = this.next(); while (!t.done && e(t.value));
                    t.done || (this._position = n)
                }

                next() {
                    return this.direction == "forward" ? this._next() : this._previous()
                }

                _next() {
                    let e = this.position.clone();
                    const t = this.position, n = e.parent;
                    if (n.parent === null && e.offset === n.childCount) return {done: !0, value: void 0};
                    if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) return {
                        done: !0,
                        value: void 0
                    };
                    let i;
                    if (n instanceof dn) {
                        if (e.isAtEnd) return this._position = We._createAfter(n), this._next();
                        i = n.data[e.offset]
                    } else i = n.getChild(e.offset);
                    if (i instanceof Qr) {
                        if (this.shallow) {
                            if (this.boundaries && this.boundaries.end.isBefore(e)) return {done: !0, value: void 0};
                            e.offset++
                        } else e = new We(i, 0);
                        return this._position = e, this._formatReturnValue("elementStart", i, t, e, 1)
                    }
                    if (i instanceof dn) {
                        if (this.singleCharacters) return e = new We(i, 0), this._position = e, this._next();
                        let s, l = i.data.length;
                        return i == this._boundaryEndParent ? (l = this.boundaries.end.offset, s = new $i(i, 0, l), e = We._createAfter(s)) : (s = new $i(i, 0, i.data.length), e.offset++), this._position = e, this._formatReturnValue("text", s, t, e, l)
                    }
                    if (typeof i == "string") {
                        let s;
                        this.singleCharacters ? s = 1 : s = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - e.offset;
                        const l = new $i(n, e.offset, s);
                        return e.offset += s, this._position = e, this._formatReturnValue("text", l, t, e, s)
                    }
                    return e = We._createAfter(n), this._position = e, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n, t, e)
                }

                _previous() {
                    let e = this.position.clone();
                    const t = this.position, n = e.parent;
                    if (n.parent === null && e.offset === 0) return {done: !0, value: void 0};
                    if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) return {
                        done: !0,
                        value: void 0
                    };
                    let i;
                    if (n instanceof dn) {
                        if (e.isAtStart) return this._position = We._createBefore(n), this._previous();
                        i = n.data[e.offset - 1]
                    } else i = n.getChild(e.offset - 1);
                    if (i instanceof Qr) return this.shallow ? (e.offset--, this._position = e, this._formatReturnValue("elementStart", i, t, e, 1)) : (e = new We(i, i.childCount), this._position = e, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", i, t, e));
                    if (i instanceof dn) {
                        if (this.singleCharacters) return e = new We(i, i.data.length), this._position = e, this._previous();
                        let s, l = i.data.length;
                        if (i == this._boundaryStartParent) {
                            const d = this.boundaries.start.offset;
                            s = new $i(i, d, i.data.length - d), l = s.data.length, e = We._createBefore(s)
                        } else s = new $i(i, 0, i.data.length), e.offset--;
                        return this._position = e, this._formatReturnValue("text", s, t, e, l)
                    }
                    if (typeof i == "string") {
                        let s;
                        if (this.singleCharacters) s = 1; else {
                            const d = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                            s = e.offset - d
                        }
                        e.offset -= s;
                        const l = new $i(n, e.offset, s);
                        return this._position = e, this._formatReturnValue("text", l, t, e, s)
                    }
                    return e = We._createBefore(n), this._position = e, this._formatReturnValue("elementStart", n, t, e, 1)
                }

                _formatReturnValue(e, t, n, i, s) {
                    return t instanceof $i && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction != "forward" || this.boundaries && this.boundaries.end.isEqual(this.position) ? n = We._createAfter(t.textNode) : (i = We._createAfter(t.textNode), this._position = i)), t.offsetInText === 0 && (this.direction != "backward" || this.boundaries && this.boundaries.start.isEqual(this.position) ? n = We._createBefore(t.textNode) : (i = We._createBefore(t.textNode), this._position = i))), {
                        done: !1,
                        value: {type: e, item: t, previousPosition: n, nextPosition: i, length: s}
                    }
                }
            }

            class We extends Ei {
                constructor(e, t) {
                    super(), this.parent = e, this.offset = t
                }

                get nodeAfter() {
                    return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null
                }

                get nodeBefore() {
                    return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null
                }

                get isAtStart() {
                    return this.offset === 0
                }

                get isAtEnd() {
                    const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
                    return this.offset === e
                }

                get root() {
                    return this.parent.root
                }

                get editableElement() {
                    let e = this.parent;
                    for (; !(e instanceof Fl);) {
                        if (!e.parent) return null;
                        e = e.parent
                    }
                    return e
                }

                getShiftedBy(e) {
                    const t = We._createAt(this), n = t.offset + e;
                    return t.offset = n < 0 ? 0 : n, t
                }

                getLastMatchingPosition(e, t = {}) {
                    t.startPosition = this;
                    const n = new Es(t);
                    return n.skip(e), n.position
                }

                getAncestors() {
                    return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({includeSelf: !0})
                }

                getCommonAncestor(e) {
                    const t = this.getAncestors(), n = e.getAncestors();
                    let i = 0;
                    for (; t[i] == n[i] && t[i];) i++;
                    return i === 0 ? null : t[i - 1]
                }

                isEqual(e) {
                    return this.parent == e.parent && this.offset == e.offset
                }

                isBefore(e) {
                    return this.compareWith(e) == "before"
                }

                isAfter(e) {
                    return this.compareWith(e) == "after"
                }

                compareWith(e) {
                    if (this.root !== e.root) return "different";
                    if (this.isEqual(e)) return "same";
                    const t = this.parent.is("node") ? this.parent.getPath() : [],
                        n = e.parent.is("node") ? e.parent.getPath() : [];
                    t.push(this.offset), n.push(e.offset);
                    const i = te(t, n);
                    switch (i) {
                        case"prefix":
                            return "before";
                        case"extension":
                            return "after";
                        default:
                            return t[i] < n[i] ? "before" : "after"
                    }
                }

                getWalker(e = {}) {
                    return e.startPosition = this, new Es(e)
                }

                clone() {
                    return new We(this.parent, this.offset)
                }

                static _createAt(e, t) {
                    if (e instanceof We) return new this(e.parent, e.offset);
                    {
                        const n = e;
                        if (t == "end") t = n.is("$text") ? n.data.length : n.childCount; else {
                            if (t == "before") return this._createBefore(n);
                            if (t == "after") return this._createAfter(n);
                            if (t !== 0 && !t) throw new R("view-createpositionat-offset-required", n)
                        }
                        return new We(n, t)
                    }
                }

                static _createAfter(e) {
                    if (e.is("$textProxy")) return new We(e.textNode, e.offsetInText + e.data.length);
                    if (!e.parent) throw new R("view-position-after-root", e, {root: e});
                    return new We(e.parent, e.index + 1)
                }

                static _createBefore(e) {
                    if (e.is("$textProxy")) return new We(e.textNode, e.offsetInText);
                    if (!e.parent) throw new R("view-position-before-root", e, {root: e});
                    return new We(e.parent, e.index)
                }
            }

            We.prototype.is = function (r) {
                return r === "position" || r === "view:position"
            };

            class Ct extends Ei {
                constructor(e, t = null) {
                    super(), this.start = e.clone(), this.end = t ? t.clone() : e.clone()
                }

                * [Symbol.iterator]() {
                    yield* new Es({boundaries: this, ignoreElementEnd: !0})
                }

                get isCollapsed() {
                    return this.start.isEqual(this.end)
                }

                get isFlat() {
                    return this.start.parent === this.end.parent
                }

                get root() {
                    return this.start.root
                }

                getEnlarged() {
                    let e = this.start.getLastMatchingPosition(Rl, {direction: "backward"}),
                        t = this.end.getLastMatchingPosition(Rl);
                    return e.parent.is("$text") && e.isAtStart && (e = We._createBefore(e.parent)), t.parent.is("$text") && t.isAtEnd && (t = We._createAfter(t.parent)), new Ct(e, t)
                }

                getTrimmed() {
                    let e = this.start.getLastMatchingPosition(Rl);
                    if (e.isAfter(this.end) || e.isEqual(this.end)) return new Ct(e, e);
                    let t = this.end.getLastMatchingPosition(Rl, {direction: "backward"});
                    const n = e.nodeAfter, i = t.nodeBefore;
                    return n && n.is("$text") && (e = new We(n, 0)), i && i.is("$text") && (t = new We(i, i.data.length)), new Ct(e, t)
                }

                isEqual(e) {
                    return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end)
                }

                containsPosition(e) {
                    return e.isAfter(this.start) && e.isBefore(this.end)
                }

                containsRange(e, t = !1) {
                    e.isCollapsed && (t = !1);
                    const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start),
                        i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
                    return n && i
                }

                getDifference(e) {
                    const t = [];
                    return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new Ct(this.start, e.start)), this.containsPosition(e.end) && t.push(new Ct(e.end, this.end))) : t.push(this.clone()), t
                }

                getIntersection(e) {
                    if (this.isIntersecting(e)) {
                        let t = this.start, n = this.end;
                        return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new Ct(t, n)
                    }
                    return null
                }

                getWalker(e = {}) {
                    return e.boundaries = this, new Es(e)
                }

                getCommonAncestor() {
                    return this.start.getCommonAncestor(this.end)
                }

                getContainedElement() {
                    if (this.isCollapsed) return null;
                    let e = this.start.nodeAfter, t = this.end.nodeBefore;
                    return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling), e && e.is("element") && e === t ? e : null
                }

                clone() {
                    return new Ct(this.start, this.end)
                }

                * getItems(e = {}) {
                    e.boundaries = this, e.ignoreElementEnd = !0;
                    const t = new Es(e);
                    for (const n of t) yield n.item
                }

                * getPositions(e = {}) {
                    e.boundaries = this;
                    const t = new Es(e);
                    yield t.position;
                    for (const n of t) yield n.nextPosition
                }

                isIntersecting(e) {
                    return this.start.isBefore(e.end) && this.end.isAfter(e.start)
                }

                static _createFromParentsAndOffsets(e, t, n, i) {
                    return new this(new We(e, t), new We(n, i))
                }

                static _createFromPositionAndShift(e, t) {
                    const n = e, i = e.getShiftedBy(t);
                    return t > 0 ? new this(n, i) : new this(i, n)
                }

                static _createIn(e) {
                    return this._createFromParentsAndOffsets(e, 0, e, e.childCount)
                }

                static _createOn(e) {
                    const t = e.is("$textProxy") ? e.offsetSize : 1;
                    return this._createFromPositionAndShift(We._createBefore(e), t)
                }
            }

            function Rl(r) {
                return !(!r.item.is("attributeElement") && !r.item.is("uiElement"))
            }

            Ct.prototype.is = function (r) {
                return r === "range" || r === "view:range"
            };

            class Ur extends Le(Ei) {
                constructor(...e) {
                    super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", e.length && this.setTo(...e)
                }

                get isFake() {
                    return this._isFake
                }

                get fakeSelectionLabel() {
                    return this._fakeSelectionLabel
                }

                get anchor() {
                    if (!this._ranges.length) return null;
                    const e = this._ranges[this._ranges.length - 1];
                    return (this._lastRangeBackward ? e.end : e.start).clone()
                }

                get focus() {
                    if (!this._ranges.length) return null;
                    const e = this._ranges[this._ranges.length - 1];
                    return (this._lastRangeBackward ? e.start : e.end).clone()
                }

                get isCollapsed() {
                    return this.rangeCount === 1 && this._ranges[0].isCollapsed
                }

                get rangeCount() {
                    return this._ranges.length
                }

                get isBackward() {
                    return !this.isCollapsed && this._lastRangeBackward
                }

                get editableElement() {
                    return this.anchor ? this.anchor.editableElement : null
                }

                * getRanges() {
                    for (const e of this._ranges) yield e.clone()
                }

                getFirstRange() {
                    let e = null;
                    for (const t of this._ranges) e && !t.start.isBefore(e.start) || (e = t);
                    return e ? e.clone() : null
                }

                getLastRange() {
                    let e = null;
                    for (const t of this._ranges) e && !t.end.isAfter(e.end) || (e = t);
                    return e ? e.clone() : null
                }

                getFirstPosition() {
                    const e = this.getFirstRange();
                    return e ? e.start.clone() : null
                }

                getLastPosition() {
                    const e = this.getLastRange();
                    return e ? e.end.clone() : null
                }

                isEqual(e) {
                    if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount) return !1;
                    if (this.rangeCount === 0) return !0;
                    if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus)) return !1;
                    for (const t of this._ranges) {
                        let n = !1;
                        for (const i of e._ranges) if (t.isEqual(i)) {
                            n = !0;
                            break
                        }
                        if (!n) return !1
                    }
                    return !0
                }

                isSimilar(e) {
                    if (this.isBackward != e.isBackward) return !1;
                    const t = $(this.getRanges());
                    if (t != $(e.getRanges())) return !1;
                    if (t == 0) return !0;
                    for (let n of this.getRanges()) {
                        n = n.getTrimmed();
                        let i = !1;
                        for (let s of e.getRanges()) if (s = s.getTrimmed(), n.start.isEqual(s.start) && n.end.isEqual(s.end)) {
                            i = !0;
                            break
                        }
                        if (!i) return !1
                    }
                    return !0
                }

                getSelectedElement() {
                    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement()
                }

                setTo(...e) {
                    let [t, n, i] = e;
                    if (typeof n == "object" && (i = n, n = void 0), t === null) this._setRanges([]), this._setFakeOptions(i); else if (t instanceof Ur || t instanceof Gd) this._setRanges(t.getRanges(), t.isBackward), this._setFakeOptions({
                        fake: t.isFake,
                        label: t.fakeSelectionLabel
                    }); else if (t instanceof Ct) this._setRanges([t], i && i.backward), this._setFakeOptions(i); else if (t instanceof We) this._setRanges([new Ct(t)]), this._setFakeOptions(i); else if (t instanceof Wo) {
                        const s = !!i && !!i.backward;
                        let l;
                        if (n === void 0) throw new R("view-selection-setto-required-second-parameter", this);
                        l = n == "in" ? Ct._createIn(t) : n == "on" ? Ct._createOn(t) : new Ct(We._createAt(t, n)), this._setRanges([l], s), this._setFakeOptions(i)
                    } else {
                        if (!oe(t)) throw new R("view-selection-setto-not-selectable", this);
                        this._setRanges(t, i && i.backward), this._setFakeOptions(i)
                    }
                    this.fire("change")
                }

                setFocus(e, t) {
                    if (this.anchor === null) throw new R("view-selection-setfocus-no-ranges", this);
                    const n = We._createAt(e, t);
                    if (n.compareWith(this.focus) == "same") return;
                    const i = this.anchor;
                    this._ranges.pop(), n.compareWith(i) == "before" ? this._addRange(new Ct(n, i), !0) : this._addRange(new Ct(i, n)), this.fire("change")
                }

                _setRanges(e, t = !1) {
                    e = Array.from(e), this._ranges = [];
                    for (const n of e) this._addRange(n);
                    this._lastRangeBackward = !!t
                }

                _setFakeOptions(e = {}) {
                    this._isFake = !!e.fake, this._fakeSelectionLabel = e.fake && e.label || ""
                }

                _addRange(e, t = !1) {
                    if (!(e instanceof Ct)) throw new R("view-selection-add-range-not-range", this);
                    this._pushRange(e), this._lastRangeBackward = !!t
                }

                _pushRange(e) {
                    for (const t of this._ranges) if (e.isIntersecting(t)) throw new R("view-selection-range-intersects", this, {
                        addedRange: e,
                        intersectingRange: t
                    });
                    this._ranges.push(new Ct(e.start, e.end))
                }
            }

            Ur.prototype.is = function (r) {
                return r === "selection" || r === "view:selection"
            };

            class Gd extends Le(Ei) {
                constructor(...e) {
                    super(), this._selection = new Ur, this._selection.delegate("change").to(this), e.length && this._selection.setTo(...e)
                }

                get isFake() {
                    return this._selection.isFake
                }

                get fakeSelectionLabel() {
                    return this._selection.fakeSelectionLabel
                }

                get anchor() {
                    return this._selection.anchor
                }

                get focus() {
                    return this._selection.focus
                }

                get isCollapsed() {
                    return this._selection.isCollapsed
                }

                get rangeCount() {
                    return this._selection.rangeCount
                }

                get isBackward() {
                    return this._selection.isBackward
                }

                get editableElement() {
                    return this._selection.editableElement
                }

                get _ranges() {
                    return this._selection._ranges
                }

                * getRanges() {
                    yield* this._selection.getRanges()
                }

                getFirstRange() {
                    return this._selection.getFirstRange()
                }

                getLastRange() {
                    return this._selection.getLastRange()
                }

                getFirstPosition() {
                    return this._selection.getFirstPosition()
                }

                getLastPosition() {
                    return this._selection.getLastPosition()
                }

                getSelectedElement() {
                    return this._selection.getSelectedElement()
                }

                isEqual(e) {
                    return this._selection.isEqual(e)
                }

                isSimilar(e) {
                    return this._selection.isSimilar(e)
                }

                _setTo(...e) {
                    this._selection.setTo(...e)
                }

                _setFocus(e, t) {
                    this._selection.setFocus(e, t)
                }
            }

            Gd.prototype.is = function (r) {
                return r === "selection" || r == "documentSelection" || r == "view:selection" || r == "view:documentSelection"
            };

            class ya extends G {
                constructor(e, t, n) {
                    super(e, t), this.startRange = n, this._eventPhase = "none", this._currentTarget = null
                }

                get eventPhase() {
                    return this._eventPhase
                }

                get currentTarget() {
                    return this._currentTarget
                }
            }

            const Kd = Symbol("bubbling contexts");

            function gn(r) {
                return class extends r {
                    fire(e, ...t) {
                        try {
                            const n = e instanceof G ? e : new G(this, e), i = Jr(this);
                            if (!i.size) return;
                            if (zl(n, "capturing", this), Ko(i, "$capture", n, ...t)) return n.return;
                            const s = n.startRange || this.selection.getFirstRange(),
                                l = s ? s.getContainedElement() : null, d = !!l && !!Da(i, l);
                            let g = l || function (v) {
                                if (!v) return null;
                                const _ = v.start.parent, x = v.end.parent, M = _.getPath(), O = x.getPath();
                                return M.length > O.length ? _ : x
                            }(s);
                            if (zl(n, "atTarget", g), !d) {
                                if (Ko(i, "$text", n, ...t)) return n.return;
                                zl(n, "bubbling", g)
                            }
                            for (; g;) {
                                if (g.is("rootElement")) {
                                    if (Ko(i, "$root", n, ...t)) return n.return
                                } else if (g.is("element") && Ko(i, g.name, n, ...t)) return n.return;
                                if (Ko(i, g, n, ...t)) return n.return;
                                g = g.parent, zl(n, "bubbling", g)
                            }
                            return zl(n, "bubbling", this), Ko(i, "$document", n, ...t), n.return
                        } catch (n) {
                            R.rethrowUnexpectedError(n, this)
                        }
                    }

                    _addEventListener(e, t, n) {
                        const i = qn(n.context || "$document"), s = Jr(this);
                        for (const l of i) {
                            let d = s.get(l);
                            d || (d = new (Le()), s.set(l, d)), this.listenTo(d, e, t, n)
                        }
                    }

                    _removeEventListener(e, t) {
                        const n = Jr(this);
                        for (const i of n.values()) this.stopListening(i, e, t)
                    }
                }
            }

            {
                const r = gn(Object);
                ["fire", "_addEventListener", "_removeEventListener"].forEach(e => {
                    gn[e] = r.prototype[e]
                })
            }

            function zl(r, e, t) {
                r instanceof ya && (r._eventPhase = e, r._currentTarget = t)
            }

            function Ko(r, e, t, ...n) {
                const i = typeof e == "string" ? r.get(e) : Da(r, e);
                return !!i && (i.fire(t, ...n), t.stop.called)
            }

            function Da(r, e) {
                for (const [t, n] of r) if (typeof t == "function" && t(e)) return n;
                return null
            }

            function Jr(r) {
                return r[Kd] || (r[Kd] = new Map), r[Kd]
            }

            class Ss extends gn(we()) {
                constructor(e) {
                    super(), this._postFixers = new Set, this.selection = new Gd, this.roots = new br({idProperty: "rootName"}), this.stylesProcessor = e, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1)
                }

                getRoot(e = "main") {
                    return this.roots.get(e)
                }

                registerPostFixer(e) {
                    this._postFixers.add(e)
                }

                destroy() {
                    this.roots.forEach(e => e.destroy()), this.stopListening()
                }

                _callPostFixers(e) {
                    let t = !1;
                    do for (const n of this._postFixers) if (t = n(e), t) break; while (t)
                }
            }

            class vo extends Qr {
                constructor(e, t, n, i) {
                    super(e, t, n, i), this._priority = 10, this._id = null, this._clonesGroup = null, this.getFillerOffset = Ag
                }

                get priority() {
                    return this._priority
                }

                get id() {
                    return this._id
                }

                getElementsWithSameId() {
                    if (this.id === null) throw new R("attribute-element-get-elements-with-same-id-no-id", this);
                    return new Set(this._clonesGroup)
                }

                isSimilar(e) {
                    return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority
                }

                _clone(e = !1) {
                    const t = super._clone(e);
                    return t._priority = this._priority, t._id = this._id, t
                }
            }

            function Ag() {
                if (du(this)) return null;
                let r = this.parent;
                for (; r && r.is("attributeElement");) {
                    if (du(r) > 1) return null;
                    r = r.parent
                }
                return !r || du(r) > 1 ? null : this.childCount
            }

            function du(r) {
                return Array.from(r.getChildren()).filter(e => !e.is("uiElement")).length
            }

            vo.DEFAULT_PRIORITY = 10, vo.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "attributeElement" || r === "view:attributeElement" || r === "element" || r === "view:element") : r === "attributeElement" || r === "view:attributeElement" || r === "element" || r === "view:element" || r === "node" || r === "view:node"
            };

            class hu extends Qr {
                constructor(e, t, n, i) {
                    super(e, t, n, i), this.getFillerOffset = Zd
                }

                _insertChild(e, t) {
                    if (t && (t instanceof Wo || Array.from(t).length > 0)) throw new R("view-emptyelement-cannot-add", [this, t]);
                    return 0
                }
            }

            function Zd() {
                return null
            }

            hu.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "emptyElement" || r === "view:emptyElement" || r === "element" || r === "view:element") : r === "emptyElement" || r === "view:emptyElement" || r === "element" || r === "view:element" || r === "node" || r === "view:node"
            };

            class jl extends Qr {
                constructor(e, t, n, i) {
                    super(e, t, n, i), this.getFillerOffset = Yd
                }

                _insertChild(e, t) {
                    if (t && (t instanceof Wo || Array.from(t).length > 0)) throw new R("view-uielement-cannot-add", [this, t]);
                    return 0
                }

                render(e, t) {
                    return this.toDomElement(e)
                }

                toDomElement(e) {
                    const t = e.createElement(this.name);
                    for (const n of this.getAttributeKeys()) t.setAttribute(n, this.getAttribute(n));
                    return t
                }
            }

            function nb(r) {
                r.document.on("arrowKey", (e, t) => function (n, i, s) {
                    if (i.keyCode == Ut.arrowright) {
                        const l = i.domTarget.ownerDocument.defaultView.getSelection(),
                            d = l.rangeCount == 1 && l.getRangeAt(0).collapsed;
                        if (d || i.shiftKey) {
                            const g = l.focusNode, v = l.focusOffset, _ = s.domPositionToView(g, v);
                            if (_ === null) return;
                            let x = !1;
                            const M = _.getLastMatchingPosition(O => (O.item.is("uiElement") && (x = !0), !(!O.item.is("uiElement") && !O.item.is("attributeElement"))));
                            if (x) {
                                const O = s.viewPositionToDom(M);
                                d ? l.collapse(O.parent, O.offset) : l.extend(O.parent, O.offset)
                            }
                        }
                    }
                }(0, t, r.domConverter), {priority: "low"})
            }

            function Yd() {
                return null
            }

            jl.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "uiElement" || r === "view:uiElement" || r === "element" || r === "view:element") : r === "uiElement" || r === "view:uiElement" || r === "element" || r === "view:element" || r === "node" || r === "view:node"
            };

            class fu extends Qr {
                constructor(e, t, n, i) {
                    super(e, t, n, i), this.getFillerOffset = rn
                }

                _insertChild(e, t) {
                    if (t && (t instanceof Wo || Array.from(t).length > 0)) throw new R("view-rawelement-cannot-add", [this, t]);
                    return 0
                }

                render(e, t) {
                }
            }

            function rn() {
                return null
            }

            fu.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "rawElement" || r === "view:rawElement" || r === "element" || r === "view:element") : r === "rawElement" || r === "view:rawElement" || r === this.name || r === "view:" + this.name || r === "element" || r === "view:element" || r === "node" || r === "view:node"
            };

            class Zo extends Le(Ei) {
                constructor(e, t) {
                    super(), this._children = [], this._customProperties = new Map, this.document = e, t && this._insertChild(0, t)
                }

                [Symbol.iterator]() {
                    return this._children[Symbol.iterator]()
                }

                get childCount() {
                    return this._children.length
                }

                get isEmpty() {
                    return this.childCount === 0
                }

                get root() {
                    return this
                }

                get parent() {
                    return null
                }

                get name() {
                }

                get getFillerOffset() {
                }

                getCustomProperty(e) {
                    return this._customProperties.get(e)
                }

                * getCustomProperties() {
                    yield* this._customProperties.entries()
                }

                _appendChild(e) {
                    return this._insertChild(this.childCount, e)
                }

                getChild(e) {
                    return this._children[e]
                }

                getChildIndex(e) {
                    return this._children.indexOf(e)
                }

                getChildren() {
                    return this._children[Symbol.iterator]()
                }

                _insertChild(e, t) {
                    this._fireChange("children", this);
                    let n = 0;
                    const i = function (s, l) {
                        return typeof l == "string" ? [new dn(s, l)] : (oe(l) || (l = [l]), Array.from(l).map(d => typeof d == "string" ? new dn(s, d) : d instanceof $i ? new dn(s, d.data) : d))
                    }(this.document, t);
                    for (const s of i) s.parent !== null && s._remove(), s.parent = this, this._children.splice(e, 0, s), e++, n++;
                    return n
                }

                _removeChildren(e, t = 1) {
                    this._fireChange("children", this);
                    for (let n = e; n < e + t; n++) this._children[n].parent = null;
                    return this._children.splice(e, t)
                }

                _fireChange(e, t) {
                    this.fire("change:" + e, t)
                }

                _setCustomProperty(e, t) {
                    this._customProperties.set(e, t)
                }

                _removeCustomProperty(e) {
                    return this._customProperties.delete(e)
                }
            }

            Zo.prototype.is = function (r) {
                return r === "documentFragment" || r === "view:documentFragment"
            };

            class Cg {
                constructor(e) {
                    this._cloneGroups = new Map, this._slotFactory = null, this.document = e
                }

                setSelection(...e) {
                    this.document.selection._setTo(...e)
                }

                setSelectionFocus(e, t) {
                    this.document.selection._setFocus(e, t)
                }

                createDocumentFragment(e) {
                    return new Zo(this.document, e)
                }

                createText(e) {
                    return new dn(this.document, e)
                }

                createAttributeElement(e, t, n = {}) {
                    const i = new vo(this.document, e, t);
                    return typeof n.priority == "number" && (i._priority = n.priority), n.id && (i._id = n.id), n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i
                }

                createContainerElement(e, t, n = {}, i = {}) {
                    let s = null;
                    ur(n) ? i = n : s = n;
                    const l = new Ol(this.document, e, t, s);
                    return i.renderUnsafeAttributes && l._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), l
                }

                createEditableElement(e, t, n = {}) {
                    const i = new Fl(this.document, e, t);
                    return n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i
                }

                createEmptyElement(e, t, n = {}) {
                    const i = new hu(this.document, e, t);
                    return n.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), i
                }

                createUIElement(e, t, n) {
                    const i = new jl(this.document, e, t);
                    return n && (i.render = n), i
                }

                createRawElement(e, t, n, i = {}) {
                    const s = new fu(this.document, e, t);
                    return n && (s.render = n), i.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), s
                }

                setAttribute(e, t, n) {
                    n._setAttribute(e, t)
                }

                removeAttribute(e, t) {
                    t._removeAttribute(e)
                }

                addClass(e, t) {
                    t._addClass(e)
                }

                removeClass(e, t) {
                    t._removeClass(e)
                }

                setStyle(e, t, n) {
                    ur(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t)
                }

                removeStyle(e, t) {
                    t._removeStyle(e)
                }

                setCustomProperty(e, t, n) {
                    n._setCustomProperty(e, t)
                }

                removeCustomProperty(e, t) {
                    return t._removeCustomProperty(e)
                }

                breakAttributes(e) {
                    return e instanceof We ? this._breakAttributes(e) : this._breakAttributesRange(e)
                }

                breakContainer(e) {
                    const t = e.parent;
                    if (!t.is("containerElement")) throw new R("view-writer-break-non-container-element", this.document);
                    if (!t.parent) throw new R("view-writer-break-root", this.document);
                    if (e.isAtStart) return We._createBefore(t);
                    if (!e.isAtEnd) {
                        const n = t._clone(!1);
                        this.insert(We._createAfter(t), n);
                        const i = new Ct(e, We._createAt(t, "end")), s = new We(n, 0);
                        this.move(i, s)
                    }
                    return We._createAfter(t)
                }

                mergeAttributes(e) {
                    const t = e.offset, n = e.parent;
                    if (n.is("$text")) return e;
                    if (n.is("attributeElement") && n.childCount === 0) {
                        const l = n.parent, d = n.index;
                        return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new We(l, d))
                    }
                    const i = n.getChild(t - 1), s = n.getChild(t);
                    if (!i || !s) return e;
                    if (i.is("$text") && s.is("$text")) return In(i, s);
                    if (i.is("attributeElement") && s.is("attributeElement") && i.isSimilar(s)) {
                        const l = i.childCount;
                        return i._appendChild(s.getChildren()), s._remove(), this._removeFromClonedElementsGroup(s), this.mergeAttributes(new We(i, l))
                    }
                    return e
                }

                mergeContainers(e) {
                    const t = e.nodeBefore, n = e.nodeAfter;
                    if (!(t && n && t.is("containerElement") && n.is("containerElement"))) throw new R("view-writer-merge-containers-invalid-position", this.document);
                    const i = t.getChild(t.childCount - 1),
                        s = i instanceof dn ? We._createAt(i, "end") : We._createAt(t, "end");
                    return this.move(Ct._createIn(n), We._createAt(t, "end")), this.remove(Ct._createOn(n)), s
                }

                insert(e, t) {
                    _g(t = oe(t) ? [...t] : [t], this.document);
                    const n = t.reduce((l, d) => {
                        const g = l[l.length - 1], v = !d.is("uiElement");
                        return g && g.breakAttributes == v ? g.nodes.push(d) : l.push({
                            breakAttributes: v,
                            nodes: [d]
                        }), l
                    }, []);
                    let i = null, s = e;
                    for (const {nodes: l, breakAttributes: d} of n) {
                        const g = this._insertNodes(s, l, d);
                        i || (i = g.start), s = g.end
                    }
                    return i ? new Ct(i, s) : new Ct(e)
                }

                remove(e) {
                    const t = e instanceof Ct ? e : Ct._createOn(e);
                    if (Qo(t, this.document), t.isCollapsed) return new Zo(this.document);
                    const {start: n, end: i} = this._breakAttributesRange(t, !0), s = n.parent, l = i.offset - n.offset,
                        d = s._removeChildren(n.offset, l);
                    for (const v of d) this._removeFromClonedElementsGroup(v);
                    const g = this.mergeAttributes(n);
                    return t.start = g, t.end = g.clone(), new Zo(this.document, d)
                }

                clear(e, t) {
                    Qo(e, this.document);
                    const n = e.getWalker({direction: "backward", ignoreElementEnd: !0});
                    for (const i of n) {
                        const s = i.item;
                        let l;
                        if (s.is("element") && t.isSimilar(s)) l = Ct._createOn(s); else if (!i.nextPosition.isAfter(e.start) && s.is("$textProxy")) {
                            const d = s.getAncestors().find(g => g.is("element") && t.isSimilar(g));
                            d && (l = Ct._createIn(d))
                        }
                        l && (l.end.isAfter(e.end) && (l.end = e.end), l.start.isBefore(e.start) && (l.start = e.start), this.remove(l))
                    }
                }

                move(e, t) {
                    let n;
                    if (t.isAfter(e.end)) {
                        const i = (t = this._breakAttributes(t, !0)).parent, s = i.childCount;
                        e = this._breakAttributesRange(e, !0), n = this.remove(e), t.offset += i.childCount - s
                    } else n = this.remove(e);
                    return this.insert(t, n)
                }

                wrap(e, t) {
                    if (!(t instanceof vo)) throw new R("view-writer-wrap-invalid-attribute", this.document);
                    if (Qo(e, this.document), e.isCollapsed) {
                        let i = e.start;
                        i.parent.is("element") && (n = i.parent, !Array.from(n.getChildren()).some(l => !l.is("uiElement"))) && (i = i.getLastMatchingPosition(l => l.item.is("uiElement"))), i = this._wrapPosition(i, t);
                        const s = this.document.selection;
                        return s.isCollapsed && s.getFirstPosition().isEqual(e.start) && this.setSelection(i), new Ct(i)
                    }
                    return this._wrapRange(e, t);
                    var n
                }

                unwrap(e, t) {
                    if (!(t instanceof vo)) throw new R("view-writer-unwrap-invalid-attribute", this.document);
                    if (Qo(e, this.document), e.isCollapsed) return e;
                    const {start: n, end: i} = this._breakAttributesRange(e, !0), s = n.parent,
                        l = this._unwrapChildren(s, n.offset, i.offset, t), d = this.mergeAttributes(l.start);
                    d.isEqual(l.start) || l.end.offset--;
                    const g = this.mergeAttributes(l.end);
                    return new Ct(d, g)
                }

                rename(e, t) {
                    const n = new Ol(this.document, e, t.getAttributes());
                    return this.insert(We._createAfter(t), n), this.move(Ct._createIn(t), We._createAt(n, 0)), this.remove(Ct._createOn(t)), n
                }

                clearClonedElementsGroup(e) {
                    this._cloneGroups.delete(e)
                }

                createPositionAt(e, t) {
                    return We._createAt(e, t)
                }

                createPositionAfter(e) {
                    return We._createAfter(e)
                }

                createPositionBefore(e) {
                    return We._createBefore(e)
                }

                createRange(e, t) {
                    return new Ct(e, t)
                }

                createRangeOn(e) {
                    return Ct._createOn(e)
                }

                createRangeIn(e) {
                    return Ct._createIn(e)
                }

                createSelection(...e) {
                    return new Ur(...e)
                }

                createSlot(e = "children") {
                    if (!this._slotFactory) throw new R("view-writer-invalid-create-slot-context", this.document);
                    return this._slotFactory(this, e)
                }

                _registerSlotFactory(e) {
                    this._slotFactory = e
                }

                _clearSlotFactory() {
                    this._slotFactory = null
                }

                _insertNodes(e, t, n) {
                    let i, s;
                    if (i = n ? Yo(e) : e.parent.is("$text") ? e.parent.parent : e.parent, !i) throw new R("view-writer-invalid-position-container", this.document);
                    s = n ? this._breakAttributes(e, !0) : e.parent.is("$text") ? Qd(e) : e;
                    const l = i._insertChild(s.offset, t);
                    for (const _ of t) this._addToClonedElementsGroup(_);
                    const d = s.getShiftedBy(l), g = this.mergeAttributes(s);
                    g.isEqual(s) || d.offset--;
                    const v = this.mergeAttributes(d);
                    return new Ct(g, v)
                }

                _wrapChildren(e, t, n, i) {
                    let s = t;
                    const l = [];
                    for (; s < n;) {
                        const g = e.getChild(s), v = g.is("$text"), _ = g.is("attributeElement");
                        if (_ && this._wrapAttributeElement(i, g)) l.push(new We(e, s)); else if (v || !_ || rb(i, g)) {
                            const x = i._clone();
                            g._remove(), x._appendChild(g), e._insertChild(s, x), this._addToClonedElementsGroup(x), l.push(new We(e, s))
                        } else this._wrapChildren(g, 0, g.childCount, i);
                        s++
                    }
                    let d = 0;
                    for (const g of l) g.offset -= d, g.offset != t && (this.mergeAttributes(g).isEqual(g) || (d++, n--));
                    return Ct._createFromParentsAndOffsets(e, t, e, n)
                }

                _unwrapChildren(e, t, n, i) {
                    let s = t;
                    const l = [];
                    for (; s < n;) {
                        const g = e.getChild(s);
                        if (g.is("attributeElement")) if (g.isSimilar(i)) {
                            const v = g.getChildren(), _ = g.childCount;
                            g._remove(), e._insertChild(s, v), this._removeFromClonedElementsGroup(g), l.push(new We(e, s), new We(e, s + _)), s += _, n += _ - 1
                        } else this._unwrapAttributeElement(i, g) ? (l.push(new We(e, s), new We(e, s + 1)), s++) : (this._unwrapChildren(g, 0, g.childCount, i), s++); else s++
                    }
                    let d = 0;
                    for (const g of l) g.offset -= d, !(g.offset == t || g.offset == n) && (this.mergeAttributes(g).isEqual(g) || (d++, n--));
                    return Ct._createFromParentsAndOffsets(e, t, e, n)
                }

                _wrapRange(e, t) {
                    const {start: n, end: i} = this._breakAttributesRange(e, !0), s = n.parent,
                        l = this._wrapChildren(s, n.offset, i.offset, t), d = this.mergeAttributes(l.start);
                    d.isEqual(l.start) || l.end.offset--;
                    const g = this.mergeAttributes(l.end);
                    return new Ct(d, g)
                }

                _wrapPosition(e, t) {
                    if (t.isSimilar(e.parent)) return Vl(e.clone());
                    e.parent.is("$text") && (e = Qd(e));
                    const n = this.createAttributeElement("_wrapPosition-fake-element");
                    n._priority = Number.POSITIVE_INFINITY, n.isSimilar = () => !1, e.parent._insertChild(e.offset, n);
                    const i = new Ct(e, e.getShiftedBy(1));
                    this.wrap(i, t);
                    const s = new We(n.parent, n.index);
                    n._remove();
                    const l = s.nodeBefore, d = s.nodeAfter;
                    return l instanceof dn && d instanceof dn ? In(l, d) : Vl(s)
                }

                _wrapAttributeElement(e, t) {
                    if (!o(e, t) || e.name !== t.name || e.priority !== t.priority) return !1;
                    for (const n of e.getAttributeKeys()) if (n !== "class" && n !== "style" && t.hasAttribute(n) && t.getAttribute(n) !== e.getAttribute(n)) return !1;
                    for (const n of e.getStyleNames()) if (t.hasStyle(n) && t.getStyle(n) !== e.getStyle(n)) return !1;
                    for (const n of e.getAttributeKeys()) n !== "class" && n !== "style" && (t.hasAttribute(n) || this.setAttribute(n, e.getAttribute(n), t));
                    for (const n of e.getStyleNames()) t.hasStyle(n) || this.setStyle(n, e.getStyle(n), t);
                    for (const n of e.getClassNames()) t.hasClass(n) || this.addClass(n, t);
                    return !0
                }

                _unwrapAttributeElement(e, t) {
                    if (!o(e, t) || e.name !== t.name || e.priority !== t.priority) return !1;
                    for (const n of e.getAttributeKeys()) if (n !== "class" && n !== "style" && (!t.hasAttribute(n) || t.getAttribute(n) !== e.getAttribute(n))) return !1;
                    if (!t.hasClass(...e.getClassNames())) return !1;
                    for (const n of e.getStyleNames()) if (!t.hasStyle(n) || t.getStyle(n) !== e.getStyle(n)) return !1;
                    for (const n of e.getAttributeKeys()) n !== "class" && n !== "style" && this.removeAttribute(n, t);
                    return this.removeClass(Array.from(e.getClassNames()), t), this.removeStyle(Array.from(e.getStyleNames()), t), !0
                }

                _breakAttributesRange(e, t = !1) {
                    const n = e.start, i = e.end;
                    if (Qo(e, this.document), e.isCollapsed) {
                        const g = this._breakAttributes(e.start, t);
                        return new Ct(g, g)
                    }
                    const s = this._breakAttributes(i, t), l = s.parent.childCount, d = this._breakAttributes(n, t);
                    return s.offset += s.parent.childCount - l, new Ct(d, s)
                }

                _breakAttributes(e, t = !1) {
                    const n = e.offset, i = e.parent;
                    if (e.parent.is("emptyElement")) throw new R("view-writer-cannot-break-empty-element", this.document);
                    if (e.parent.is("uiElement")) throw new R("view-writer-cannot-break-ui-element", this.document);
                    if (e.parent.is("rawElement")) throw new R("view-writer-cannot-break-raw-element", this.document);
                    if (!t && i.is("$text") && Jd(i.parent) || Jd(i)) return e.clone();
                    if (i.is("$text")) return this._breakAttributes(Qd(e), t);
                    if (n == i.childCount) {
                        const s = new We(i.parent, i.index + 1);
                        return this._breakAttributes(s, t)
                    }
                    if (n === 0) {
                        const s = new We(i.parent, i.index);
                        return this._breakAttributes(s, t)
                    }
                    {
                        const s = i.index + 1, l = i._clone();
                        i.parent._insertChild(s, l), this._addToClonedElementsGroup(l);
                        const d = i.childCount - n, g = i._removeChildren(n, d);
                        l._appendChild(g);
                        const v = new We(i.parent, s);
                        return this._breakAttributes(v, t)
                    }
                }

                _addToClonedElementsGroup(e) {
                    if (!e.root.is("rootElement")) return;
                    if (e.is("element")) for (const i of e.getChildren()) this._addToClonedElementsGroup(i);
                    const t = e.id;
                    if (!t) return;
                    let n = this._cloneGroups.get(t);
                    n || (n = new Set, this._cloneGroups.set(t, n)), n.add(e), e._clonesGroup = n
                }

                _removeFromClonedElementsGroup(e) {
                    if (e.is("element")) for (const i of e.getChildren()) this._removeFromClonedElementsGroup(i);
                    const t = e.id;
                    if (!t) return;
                    const n = this._cloneGroups.get(t);
                    n && n.delete(e)
                }
            }

            function Yo(r) {
                let e = r.parent;
                for (; !Jd(e);) {
                    if (!e) return;
                    e = e.parent
                }
                return e
            }

            function rb(r, e) {
                return r.priority < e.priority || !(r.priority > e.priority) && r.getIdentity() < e.getIdentity()
            }

            function Vl(r) {
                const e = r.nodeBefore;
                if (e && e.is("$text")) return new We(e, e.data.length);
                const t = r.nodeAfter;
                return t && t.is("$text") ? new We(t, 0) : r
            }

            function Qd(r) {
                if (r.offset == r.parent.data.length) return new We(r.parent.parent, r.parent.index + 1);
                if (r.offset === 0) return new We(r.parent.parent, r.parent.index);
                const e = r.parent.data.slice(r.offset);
                return r.parent._data = r.parent.data.slice(0, r.offset), r.parent.parent._insertChild(r.parent.index + 1, new dn(r.root.document, e)), new We(r.parent.parent, r.parent.index + 1)
            }

            function In(r, e) {
                const t = r.data.length;
                return r._data += e.data, e._remove(), new We(r, t)
            }

            const ib = [dn, vo, Ol, hu, fu, jl];

            function _g(r, e) {
                for (const t of r) {
                    if (!ib.some(n => t instanceof n)) throw new R("view-writer-insert-invalid-node-type", e);
                    t.is("$text") || _g(t.getChildren(), e)
                }
            }

            function Jd(r) {
                return r && (r.is("containerElement") || r.is("documentFragment"))
            }

            function Qo(r, e) {
                const t = Yo(r.start), n = Yo(r.end);
                if (!t || !n || t !== n) throw new R("view-writer-invalid-range-container", e)
            }

            function o(r, e) {
                return r.id === null && e.id === null
            }

            const u = r => r.createTextNode(" "), p = r => {
                const e = r.createElement("span");
                return e.dataset.ckeFiller = "true", e.innerText = " ", e
            }, f = r => {
                const e = r.createElement("br");
                return e.dataset.ckeFiller = "true", e
            }, m = 7, E = "⁠".repeat(m);

            function N(r) {
                return typeof r == "string" ? r.substr(0, m) === E : jn(r) && r.data.substr(0, m) === E
            }

            function P(r) {
                return r.data.length == m && N(r)
            }

            function F(r) {
                const e = typeof r == "string" ? r : r.data;
                return N(r) ? e.slice(m) : e
            }

            function H(r, e) {
                if (e.keyCode == Ut.arrowleft) {
                    const t = e.domTarget.ownerDocument.defaultView.getSelection();
                    if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
                        const n = t.getRangeAt(0).startContainer, i = t.getRangeAt(0).startOffset;
                        N(n) && i <= m && t.collapse(n, 0)
                    }
                }
            }

            var X = C(9315),
                ie = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(X.Z, ie), X.Z.locals;

            class be extends we() {
                constructor(e, t) {
                    super(), this.domDocuments = new Set, this.markedAttributes = new Set, this.markedChildren = new Set, this.markedTexts = new Set, this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = e, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), T.isBlink && !T.isAndroid && this.on("change:isSelecting", () => {
                        this.isSelecting || this.render()
                    }), this.set("isComposing", !1), this.on("change:isComposing", () => {
                        this.isComposing || this.render()
                    })
                }

                markToSync(e, t) {
                    if (e === "text") this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t); else {
                        if (!this.domConverter.mapViewToDom(t)) return;
                        if (e === "attributes") this.markedAttributes.add(t); else {
                            if (e !== "children") throw new R("view-renderer-unknown-type", this);
                            this.markedChildren.add(t)
                        }
                    }
                }

                render() {
                    if (this.isComposing && !T.isAndroid) return;
                    let e = null;
                    const t = !(T.isBlink && !T.isAndroid) || !this.isSelecting;
                    for (const n of this.markedChildren) this._updateChildrenMappings(n);
                    t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(), this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller), e && e.parent.is("$text") && (e = We._createBefore(e.parent)));
                    for (const n of this.markedAttributes) this._updateAttrs(n);
                    for (const n of this.markedChildren) this._updateChildren(n, {inlineFillerPosition: e});
                    for (const n of this.markedTexts) !this.markedChildren.has(n.parent) && this.domConverter.mapViewToDom(n.parent) && this._updateText(n, {inlineFillerPosition: e});
                    if (t) if (e) {
                        const n = this.domConverter.viewPositionToDom(e), i = n.parent.ownerDocument;
                        N(n.parent) ? this._inlineFiller = n.parent : this._inlineFiller = fe(i, n.parent, n.offset)
                    } else this._inlineFiller = null;
                    this._updateFocus(), this._updateSelection(), this.domConverter._clearTemporaryCustomProperties(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear()
                }

                _updateChildrenMappings(e) {
                    const t = this.domConverter.mapViewToDom(e);
                    if (!t) return;
                    const n = Array.from(t.childNodes),
                        i = Array.from(this.domConverter.viewChildrenToDom(e, {withChildren: !1})),
                        s = this._diffNodeLists(n, i), l = this._findUpdateActions(s, n, i, xe);
                    if (l.indexOf("update") !== -1) {
                        const d = {equal: 0, insert: 0, delete: 0};
                        for (const g of l) if (g === "update") {
                            const v = d.equal + d.insert, _ = d.equal + d.delete, x = e.getChild(v);
                            !x || x.is("uiElement") || x.is("rawElement") || this._updateElementMappings(x, n[_]), ml(i[v]), d.equal++
                        } else d[g]++
                    }
                }

                _updateElementMappings(e, t) {
                    this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, e), this.markedChildren.add(e), this.markedAttributes.add(e)
                }

                _getInlineFillerPosition() {
                    const e = this.selection.getFirstPosition();
                    return e.parent.is("$text") ? We._createBefore(e.parent) : e
                }

                _isSelectionInInlineFiller() {
                    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) return !1;
                    const e = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(e);
                    return !!(t && jn(t.parent) && N(t.parent))
                }

                _removeInlineFiller() {
                    const e = this._inlineFiller;
                    if (!N(e)) throw new R("view-renderer-filler-was-lost", this);
                    P(e) ? e.remove() : e.data = e.data.substr(m), this._inlineFiller = null
                }

                _needsInlineFillerAtSelection() {
                    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) return !1;
                    const e = this.selection.getFirstPosition(), t = e.parent, n = e.offset;
                    if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !function (l) {
                        if (l.getAttribute("contenteditable") == "false") return !1;
                        const d = l.findAncestor(g => g.hasAttribute("contenteditable"));
                        return !d || d.getAttribute("contenteditable") == "true"
                    }(t) || n === t.getFillerOffset()) return !1;
                    const i = e.nodeBefore, s = e.nodeAfter;
                    return !(i instanceof dn || s instanceof dn) && (!T.isAndroid || !i && !s)
                }

                _updateText(e, t) {
                    const n = this.domConverter.findCorrespondingDomText(e);
                    let i = this.domConverter.viewToDom(e).data;
                    const s = t.inlineFillerPosition;
                    s && s.parent == e.parent && s.offset == e.index && (i = E + i), $e(n, i)
                }

                _updateAttrs(e) {
                    const t = this.domConverter.mapViewToDom(e);
                    if (!t) return;
                    const n = Array.from(t.attributes).map(s => s.name), i = e.getAttributeKeys();
                    for (const s of i) this.domConverter.setDomElementAttribute(t, s, e.getAttribute(s), e);
                    for (const s of n) e.hasAttribute(s) || this.domConverter.removeDomElementAttribute(t, s)
                }

                _updateChildren(e, t) {
                    const n = this.domConverter.mapViewToDom(e);
                    if (!n) return;
                    if (T.isAndroid) {
                        let x = null;
                        for (const M of Array.from(n.childNodes)) {
                            if (x && jn(x) && jn(M)) {
                                n.normalize();
                                break
                            }
                            x = M
                        }
                    }
                    const i = t.inlineFillerPosition, s = n.childNodes,
                        l = Array.from(this.domConverter.viewChildrenToDom(e, {bind: !0}));
                    i && i.parent === e && fe(n.ownerDocument, l, i.offset);
                    const d = this._diffNodeLists(s, l), g = this._findUpdateActions(d, s, l, Ne);
                    let v = 0;
                    const _ = new Set;
                    for (const x of g) x === "delete" ? (_.add(s[v]), ml(s[v])) : x !== "equal" && x !== "update" || v++;
                    v = 0;
                    for (const x of g) x === "insert" ? (zc(n, v, l[v]), v++) : x === "update" ? ($e(s[v], l[v].data), v++) : x === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(l[v])), v++);
                    for (const x of _) x.parentNode || this.domConverter.unbindDomElement(x)
                }

                _diffNodeLists(e, t) {
                    return e = function (n, i) {
                        const s = Array.from(n);
                        return s.length == 0 || !i || s[s.length - 1] == i && s.pop(), s
                    }(e, this._fakeSelectionContainer), q(e, t, Ve.bind(null, this.domConverter))
                }

                _findUpdateActions(e, t, n, i) {
                    if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1) return e;
                    let s = [], l = [], d = [];
                    const g = {equal: 0, insert: 0, delete: 0};
                    for (const v of e) v === "insert" ? d.push(n[g.equal + g.insert]) : v === "delete" ? l.push(t[g.equal + g.delete]) : (s = s.concat(q(l, d, i).map(_ => _ === "equal" ? "update" : _)), s.push("equal"), l = [], d = []), g[v]++;
                    return s.concat(q(l, d, i).map(v => v === "equal" ? "update" : v))
                }

                _markDescendantTextToSync(e) {
                    if (e) {
                        if (e.is("$text")) this.markedTexts.add(e); else if (e.is("element")) for (const t of e.getChildren()) this._markDescendantTextToSync(t)
                    }
                }

                _updateSelection() {
                    if (T.isBlink && !T.isAndroid && this.isSelecting && !this.markedChildren.size) return;
                    if (this.selection.rangeCount === 0) return this._removeDomSelection(), void this._removeFakeSelection();
                    const e = this.domConverter.mapViewToDom(this.selection.editableElement);
                    this.isFocused && e && (this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(e)) : this.isComposing && T.isAndroid || this._updateDomSelection(e))
                }

                _updateFakeSelection(e) {
                    const t = e.ownerDocument;
                    this._fakeSelectionContainer || (this._fakeSelectionContainer = function (l) {
                        const d = l.createElement("div");
                        return d.className = "ck-fake-selection-container", Object.assign(d.style, {
                            position: "fixed",
                            top: 0,
                            left: "-9999px",
                            width: "42px"
                        }), d.textContent = " ", d
                    }(t));
                    const n = this._fakeSelectionContainer;
                    if (this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(e)) return;
                    n.parentElement && n.parentElement == e || e.appendChild(n), n.textContent = this.selection.fakeSelectionLabel || " ";
                    const i = t.getSelection(), s = t.createRange();
                    i.removeAllRanges(), s.selectNodeContents(n), i.addRange(s)
                }

                _updateDomSelection(e) {
                    const t = e.ownerDocument.defaultView.getSelection();
                    if (!this._domSelectionNeedsUpdate(t)) return;
                    const n = this.domConverter.viewPositionToDom(this.selection.anchor),
                        i = this.domConverter.viewPositionToDom(this.selection.focus);
                    t.setBaseAndExtent(n.parent, n.offset, i.parent, i.offset), T.isGecko && function (s, l) {
                        const d = s.parent;
                        if (d.nodeType != Node.ELEMENT_NODE || s.offset != d.childNodes.length - 1) return;
                        const g = d.childNodes[s.offset];
                        g && g.tagName == "BR" && l.addRange(l.getRangeAt(0))
                    }(i, t)
                }

                _domSelectionNeedsUpdate(e) {
                    if (!this.domConverter.isDomSelectionCorrect(e)) return !0;
                    const t = e && this.domConverter.domSelectionToView(e);
                    return (!t || !this.selection.isEqual(t)) && !(!this.selection.isCollapsed && this.selection.isSimilar(t))
                }

                _fakeSelectionNeedsUpdate(e) {
                    const t = this._fakeSelectionContainer, n = e.ownerDocument.getSelection();
                    return !t || t.parentElement !== e || n.anchorNode !== t && !t.contains(n.anchorNode) || t.textContent !== this.selection.fakeSelectionLabel
                }

                _removeDomSelection() {
                    for (const e of this.domDocuments) {
                        const t = e.getSelection();
                        if (t.rangeCount) {
                            const n = e.activeElement, i = this.domConverter.mapDomToView(n);
                            n && i && t.removeAllRanges()
                        }
                    }
                }

                _removeFakeSelection() {
                    const e = this._fakeSelectionContainer;
                    e && e.remove()
                }

                _updateFocus() {
                    if (this.isFocused) {
                        const e = this.selection.editableElement;
                        e && this.domConverter.focus(e)
                    }
                }
            }

            function fe(r, e, t) {
                const n = e instanceof Array ? e : e.childNodes, i = n[t];
                if (jn(i)) return i.data = E + i.data, i;
                {
                    const s = r.createTextNode(E);
                    return Array.isArray(e) ? n.splice(t, 0, s) : zc(e, t, s), s
                }
            }

            function xe(r, e) {
                return Po(r) && Po(e) && !jn(r) && !jn(e) && !da(r) && !da(e) && r.tagName.toLowerCase() === e.tagName.toLowerCase()
            }

            function Ne(r, e) {
                return Po(r) && Po(e) && jn(r) && jn(e)
            }

            function Ve(r, e, t) {
                return e === t || (jn(e) && jn(t) ? e.data === t.data : !(!r.isBlockFiller(e) || !r.isBlockFiller(t)))
            }

            function $e(r, e) {
                const t = r.data;
                if (t == e) return;
                const n = B(t, e);
                for (const i of n) i.type === "insert" ? r.insertData(i.index, i.values.join("")) : r.deleteData(i.index, i.howMany)
            }

            const et = f(bt.document), Ke = u(bt.document), at = p(bt.document), pt = "data-ck-unsafe-attribute-",
                gt = "data-ck-unsafe-element";

            class Mt {
                constructor(e, {blockFillerMode: t, renderingMode: n = "editing"} = {}) {
                    this._domToViewMapping = new WeakMap, this._viewToDomMapping = new WeakMap, this._fakeSelectionMapping = new WeakMap, this._rawContentElementMatcher = new Si, this._inlineObjectElementMatcher = new Si, this._elementsWithTemporaryCustomProperties = new Set, this.document = e, this.renderingMode = n, this.blockFillerMode = t || (n === "editing" ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? bt.document : bt.document.implementation.createHTMLDocument("")
                }

                bindFakeSelection(e, t) {
                    this._fakeSelectionMapping.set(e, new Ur(t))
                }

                fakeSelectionToView(e) {
                    return this._fakeSelectionMapping.get(e)
                }

                bindElements(e, t) {
                    this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e)
                }

                unbindDomElement(e) {
                    const t = this._domToViewMapping.get(e);
                    if (t) {
                        this._domToViewMapping.delete(e), this._viewToDomMapping.delete(t);
                        for (const n of Array.from(e.children)) this.unbindDomElement(n)
                    }
                }

                bindDocumentFragments(e, t) {
                    this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e)
                }

                shouldRenderAttribute(e, t, n) {
                    return this.renderingMode === "data" || !(e = e.toLowerCase()).startsWith("on") && (e !== "srcdoc" || !t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && (n === "img" && (e === "src" || e === "srcset") || n === "source" && e === "srcset" || !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))
                }

                setContentOf(e, t) {
                    if (this.renderingMode === "data") return void (e.innerHTML = t);
                    const n = new DOMParser().parseFromString(t, "text/html"), i = n.createDocumentFragment(),
                        s = n.body.childNodes;
                    for (; s.length > 0;) i.appendChild(s[0]);
                    const l = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT), d = [];
                    let g;
                    for (; g = l.nextNode();) d.push(g);
                    for (const v of d) {
                        for (const x of v.getAttributeNames()) this.setDomElementAttribute(v, x, v.getAttribute(x));
                        const _ = v.tagName.toLowerCase();
                        this._shouldRenameElement(_) && (Pr(_), v.replaceWith(this._createReplacementDomElement(_, v)))
                    }
                    for (; e.firstChild;) e.firstChild.remove();
                    e.append(i)
                }

                viewToDom(e, t = {}) {
                    if (e.is("$text")) {
                        const n = this._processDataFromViewText(e);
                        return this._domDocument.createTextNode(n)
                    }
                    {
                        const n = e;
                        if (this.mapViewToDom(n)) {
                            if (!n.getCustomProperty("editingPipeline:doNotReuseOnce")) return this.mapViewToDom(n);
                            this._elementsWithTemporaryCustomProperties.add(n)
                        }
                        let i;
                        if (n.is("documentFragment")) i = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(i, n); else {
                            if (n.is("uiElement")) return i = n.name === "$comment" ? this._domDocument.createComment(n.getCustomProperty("$rawContent")) : n.render(this._domDocument, this), t.bind && this.bindElements(i, n), i;
                            this._shouldRenameElement(n.name) ? (Pr(n.name), i = this._createReplacementDomElement(n.name)) : i = n.hasAttribute("xmlns") ? this._domDocument.createElementNS(n.getAttribute("xmlns"), n.name) : this._domDocument.createElement(n.name), n.is("rawElement") && n.render(i, this), t.bind && this.bindElements(i, n);
                            for (const s of n.getAttributeKeys()) this.setDomElementAttribute(i, s, n.getAttribute(s), n)
                        }
                        if (t.withChildren !== !1) for (const s of this.viewChildrenToDom(n, t)) i.appendChild(s);
                        return i
                    }
                }

                setDomElementAttribute(e, t, n, i) {
                    const s = this.shouldRenderAttribute(t, n, e.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(t);
                    s || ae("domconverter-unsafe-attribute-detected", {domElement: e, key: t, value: n}), function (l) {
                        try {
                            bt.document.createAttribute(l)
                        } catch {
                            return !1
                        }
                        return !0
                    }(t) ? (e.hasAttribute(t) && !s ? e.removeAttribute(t) : e.hasAttribute(pt + t) && s && e.removeAttribute(pt + t), e.setAttribute(s ? t : pt + t, n)) : ae("domconverter-invalid-attribute-detected", {
                        domElement: e,
                        key: t,
                        value: n
                    })
                }

                removeDomElementAttribute(e, t) {
                    t != gt && (e.removeAttribute(t), e.removeAttribute(pt + t))
                }

                * viewChildrenToDom(e, t = {}) {
                    const n = e.getFillerOffset && e.getFillerOffset();
                    let i = 0;
                    for (const s of e.getChildren()) {
                        n === i && (yield this._getBlockFiller());
                        const l = s.is("element") && !!s.getCustomProperty("dataPipeline:transparentRendering") && !Wn(s.getAttributes());
                        l && this.renderingMode == "data" ? yield* this.viewChildrenToDom(s, t) : (l && ae("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {viewElement: s}), yield this.viewToDom(s, t)), i++
                    }
                    n === i && (yield this._getBlockFiller())
                }

                viewRangeToDom(e) {
                    const t = this.viewPositionToDom(e.start), n = this.viewPositionToDom(e.end),
                        i = this._domDocument.createRange();
                    return i.setStart(t.parent, t.offset), i.setEnd(n.parent, n.offset), i
                }

                viewPositionToDom(e) {
                    const t = e.parent;
                    if (t.is("$text")) {
                        const n = this.findCorrespondingDomText(t);
                        if (!n) return null;
                        let i = e.offset;
                        return N(n) && (i += m), {parent: n, offset: i}
                    }
                    {
                        let n, i, s;
                        if (e.offset === 0) {
                            if (n = this.mapViewToDom(t), !n) return null;
                            s = n.childNodes[0]
                        } else {
                            const l = e.nodeBefore;
                            if (i = l.is("$text") ? this.findCorrespondingDomText(l) : this.mapViewToDom(l), !i) return null;
                            n = i.parentNode, s = i.nextSibling
                        }
                        return jn(s) && N(s) ? {parent: s, offset: m} : {parent: n, offset: i ? Rc(i) + 1 : 0}
                    }
                }

                domToView(e, t = {}) {
                    const n = [], i = this._domToView(e, t, n), s = i.next().value;
                    return s ? (i.next(), this._processDomInlineNodes(null, n, t), s.is("$text") && s.data.length == 0 ? null : s) : null
                }

                * domChildrenToView(e, t = {}, n = []) {
                    for (let i = 0; i < e.childNodes.length; i++) {
                        const s = e.childNodes[i], l = this._domToView(s, t, n), d = l.next().value;
                        d !== null && (this._isBlockViewElement(d) && this._processDomInlineNodes(e, n, t), yield d, l.next())
                    }
                    this._processDomInlineNodes(e, n, t)
                }

                domSelectionToView(e) {
                    if (function (i) {
                        if (!T.isGecko || !i.rangeCount) return !1;
                        const s = i.getRangeAt(0).startContainer;
                        try {
                            Object.prototype.toString.call(s)
                        } catch {
                            return !0
                        }
                        return !1
                    }(e)) return new Ur([]);
                    if (e.rangeCount === 1) {
                        let i = e.getRangeAt(0).startContainer;
                        jn(i) && (i = i.parentNode);
                        const s = this.fakeSelectionToView(i);
                        if (s) return s
                    }
                    const t = this.isDomSelectionBackward(e), n = [];
                    for (let i = 0; i < e.rangeCount; i++) {
                        const s = e.getRangeAt(i), l = this.domRangeToView(s);
                        l && n.push(l)
                    }
                    return new Ur(n, {backward: t})
                }

                domRangeToView(e) {
                    const t = this.domPositionToView(e.startContainer, e.startOffset),
                        n = this.domPositionToView(e.endContainer, e.endOffset);
                    return t && n ? new Ct(t, n) : null
                }

                domPositionToView(e, t = 0) {
                    if (this.isBlockFiller(e)) return this.domPositionToView(e.parentNode, Rc(e));
                    const n = this.mapDomToView(e);
                    if (n && (n.is("uiElement") || n.is("rawElement"))) return We._createBefore(n);
                    if (jn(e)) {
                        if (P(e)) return this.domPositionToView(e.parentNode, Rc(e));
                        const i = this.findCorrespondingViewText(e);
                        let s = t;
                        return i ? (N(e) && (s -= m, s = s < 0 ? 0 : s), new We(i, s)) : null
                    }
                    if (t === 0) {
                        const i = this.mapDomToView(e);
                        if (i) return new We(i, 0)
                    } else {
                        const i = e.childNodes[t - 1];
                        if (jn(i) && P(i) || i && this.isBlockFiller(i)) return this.domPositionToView(i.parentNode, Rc(i));
                        const s = jn(i) ? this.findCorrespondingViewText(i) : this.mapDomToView(i);
                        if (s && s.parent) return new We(s.parent, s.index + 1)
                    }
                    return null
                }

                mapDomToView(e) {
                    return this.getHostViewElement(e) || this._domToViewMapping.get(e)
                }

                findCorrespondingViewText(e) {
                    if (P(e)) return null;
                    const t = this.getHostViewElement(e);
                    if (t) return t;
                    const n = e.previousSibling;
                    if (n) {
                        if (!this.isElement(n)) return null;
                        const i = this.mapDomToView(n);
                        if (i) {
                            const s = i.nextSibling;
                            return s instanceof dn ? s : null
                        }
                    } else {
                        const i = this.mapDomToView(e.parentNode);
                        if (i) {
                            const s = i.getChild(0);
                            return s instanceof dn ? s : null
                        }
                    }
                    return null
                }

                mapViewToDom(e) {
                    return this._viewToDomMapping.get(e)
                }

                findCorrespondingDomText(e) {
                    const t = e.previousSibling;
                    return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null
                }

                focus(e) {
                    const t = this.mapViewToDom(e);
                    if (t && t.ownerDocument.activeElement !== t) {
                        const {scrollX: n, scrollY: i} = bt.window, s = [];
                        $n(t, l => {
                            const {scrollLeft: d, scrollTop: g} = l;
                            s.push([d, g])
                        }), t.focus(), $n(t, l => {
                            const [d, g] = s.shift();
                            l.scrollLeft = d, l.scrollTop = g
                        }), bt.window.scrollTo(n, i)
                    }
                }

                _clearDomSelection() {
                    const e = this.mapViewToDom(this.document.selection.editableElement);
                    if (!e) return;
                    const t = e.ownerDocument.defaultView.getSelection(), n = this.domSelectionToView(t);
                    n && n.rangeCount > 0 && t.removeAllRanges()
                }

                isElement(e) {
                    return e && e.nodeType == Node.ELEMENT_NODE
                }

                isDocumentFragment(e) {
                    return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE
                }

                isBlockFiller(e) {
                    return this.blockFillerMode == "br" ? e.isEqualNode(et) : !(e.tagName !== "BR" || !Dn(e, this.blockElements) || e.parentNode.childNodes.length !== 1) || e.isEqualNode(at) || function (t, n) {
                        return t.isEqualNode(Ke) && Dn(t, n) && t.parentNode.childNodes.length === 1
                    }(e, this.blockElements)
                }

                isDomSelectionBackward(e) {
                    if (e.isCollapsed) return !1;
                    const t = this._domDocument.createRange();
                    try {
                        t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset)
                    } catch {
                        return !1
                    }
                    const n = t.collapsed;
                    return t.detach(), n
                }

                getHostViewElement(e) {
                    const t = function (n) {
                        const i = [];
                        let s = n;
                        for (; s && s.nodeType != Node.DOCUMENT_NODE;) i.unshift(s), s = s.parentNode;
                        return i
                    }(e);
                    for (t.pop(); t.length;) {
                        const n = t.pop(), i = this._domToViewMapping.get(n);
                        if (i && (i.is("uiElement") || i.is("rawElement"))) return i
                    }
                    return null
                }

                isDomSelectionCorrect(e) {
                    return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset)
                }

                registerRawContentMatcher(e) {
                    this._rawContentElementMatcher.add(e)
                }

                registerInlineObjectMatcher(e) {
                    this._inlineObjectElementMatcher.add(e)
                }

                _clearTemporaryCustomProperties() {
                    for (const e of this._elementsWithTemporaryCustomProperties) e._removeCustomProperty("editingPipeline:doNotReuseOnce");
                    this._elementsWithTemporaryCustomProperties.clear()
                }

                _getBlockFiller() {
                    switch (this.blockFillerMode) {
                        case"nbsp":
                            return u(this._domDocument);
                        case"markedNbsp":
                            return p(this._domDocument);
                        case"br":
                            return f(this._domDocument)
                    }
                }

                _isDomSelectionPositionCorrect(e, t) {
                    if (jn(e) && N(e) && t < m || this.isElement(e) && N(e.childNodes[t])) return !1;
                    const n = this.mapDomToView(e);
                    return !n || !n.is("uiElement") && !n.is("rawElement")
                }

                * _domToView(e, t, n) {
                    if (this.isBlockFiller(e)) return null;
                    const i = this.getHostViewElement(e);
                    if (i) return i;
                    if (da(e) && t.skipComments) return null;
                    if (jn(e)) {
                        if (P(e)) return null;
                        {
                            const s = e.data;
                            if (s === "") return null;
                            const l = new dn(this.document, s);
                            return n.push(l), l
                        }
                    }
                    {
                        let s = this.mapDomToView(e);
                        if (s) return this._isInlineObjectElement(s) && n.push(s), s;
                        if (this.isDocumentFragment(e)) s = new Zo(this.document), t.bind && this.bindDocumentFragments(e, s); else {
                            s = this._createViewElement(e, t), t.bind && this.bindElements(e, s);
                            const d = e.attributes;
                            if (d) for (let g = d.length, v = 0; v < g; v++) s._setAttribute(d[v].name, d[v].value);
                            if (this._isViewElementWithRawContent(s, t)) return s._setCustomProperty("$rawContent", e.innerHTML), this._isBlockViewElement(s) || n.push(s), s;
                            if (da(e)) return s._setCustomProperty("$rawContent", e.data), s
                        }
                        yield s;
                        const l = [];
                        if (t.withChildren !== !1) for (const d of this.domChildrenToView(e, t, l)) s._appendChild(d);
                        if (this._isInlineObjectElement(s)) n.push(s); else for (const d of l) n.push(d)
                    }
                }

                _processDomInlineNodes(e, t, n) {
                    if (!t.length || e && !this.isDocumentFragment(e) && !this._isBlockDomElement(e)) return;
                    let i = !1;
                    for (let s = 0; s < t.length; s++) {
                        const l = t[s];
                        if (!l.is("$text")) {
                            i = !1;
                            continue
                        }
                        let d, g = !1;
                        if (hn(l, this.preElements)) d = F(l.data); else {
                            d = l.data.replace(/[ \n\t\r]{1,}/g, " "), g = /[^\S\u00A0]/.test(d.charAt(d.length - 1));
                            const v = s > 0 ? t[s - 1] : null, _ = s + 1 < t.length ? t[s + 1] : null,
                                x = !v || v.is("element") && v.name == "br" || i, M = !_ && !N(l.data);
                            n.withChildren !== !1 && (x && (d = d.replace(/^ /, "")), M && (d = d.replace(/ $/, ""))), d = F(d), d = d.replace(/ \u00A0/g, "  ");
                            const O = _ && _.is("element") && _.name != "br",
                                j = _ && _.is("$text") && _.data.charAt(0) == " ";
                            (/[ \u00A0]\u00A0$/.test(d) || !_ || O || j) && (d = d.replace(/\u00A0$/, " ")), (x || v && v.is("element") && v.name != "br") && (d = d.replace(/^\u00A0/, " "))
                        }
                        d.length == 0 && l.parent ? (l._remove(), t.splice(s, 1), s--) : (l._data = d, i = g)
                    }
                    t.length = 0
                }

                _processDataFromViewText(e) {
                    let t = e.data;
                    if (e.getAncestors().some(n => this.preElements.includes(n.name))) return t;
                    if (t.charAt(0) == " ") {
                        const n = this._getTouchingInlineViewNode(e, !1);
                        !(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) && n || (t = " " + t.substr(1))
                    }
                    if (t.charAt(t.length - 1) == " ") {
                        const n = this._getTouchingInlineViewNode(e, !0),
                            i = n && n.is("$textProxy") && n.data.charAt(0) == " ";
                        t.charAt(t.length - 2) != " " && n && !i || (t = t.substr(0, t.length - 1) + " ")
                    }
                    return t.replace(/ {2}/g, "  ")
                }

                _nodeEndsWithSpace(e) {
                    if (e.getAncestors().some(n => this.preElements.includes(n.name))) return !1;
                    const t = this._processDataFromViewText(e);
                    return t.charAt(t.length - 1) == " "
                }

                _getTouchingInlineViewNode(e, t) {
                    const n = new Es({
                        startPosition: t ? We._createAfter(e) : We._createBefore(e),
                        direction: t ? "forward" : "backward"
                    });
                    for (const i of n) {
                        if (i.item.is("element", "br")) return null;
                        if (this._isInlineObjectElement(i.item)) return i.item;
                        if (i.item.is("containerElement")) return null;
                        if (i.item.is("$textProxy")) return i.item
                    }
                    return null
                }

                _isBlockDomElement(e) {
                    return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase())
                }

                _isBlockViewElement(e) {
                    return e.is("element") && this.blockElements.includes(e.name)
                }

                _isInlineObjectElement(e) {
                    return !!e.is("element") && (e.name == "br" || this.inlineObjectElements.includes(e.name) || !!this._inlineObjectElementMatcher.match(e))
                }

                _createViewElement(e, t) {
                    if (da(e)) return new jl(this.document, "$comment");
                    const n = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
                    return new Qr(this.document, n)
                }

                _isViewElementWithRawContent(e, t) {
                    return t.withChildren !== !1 && e.is("element") && !!this._rawContentElementMatcher.match(e)
                }

                _shouldRenameElement(e) {
                    const t = e.toLowerCase();
                    return this.renderingMode === "editing" && this.unsafeElements.includes(t)
                }

                _createReplacementDomElement(e, t) {
                    const n = this._domDocument.createElement("span");
                    if (n.setAttribute(gt, e), t) {
                        for (; t.firstChild;) n.appendChild(t.firstChild);
                        for (const i of t.getAttributeNames()) n.setAttribute(i, t.getAttribute(i))
                    }
                    return n
                }
            }

            function hn(r, e) {
                return r.getAncestors().some(t => t.is("element") && e.includes(t.name))
            }

            function $n(r, e) {
                let t = r;
                for (; t;) e(t), t = t.parentElement
            }

            function Dn(r, e) {
                const t = r.parentNode;
                return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase())
            }

            function Pr(r) {
                r === "script" && ae("domconverter-unsafe-script-element-detected"), r === "style" && ae("domconverter-unsafe-style-element-detected")
            }

            class En extends dr() {
                constructor(e) {
                    super(), this._isEnabled = !1, this.view = e, this.document = e.document
                }

                get isEnabled() {
                    return this._isEnabled
                }

                enable() {
                    this._isEnabled = !0
                }

                disable() {
                    this._isEnabled = !1
                }

                destroy() {
                    this.disable(), this.stopListening()
                }

                checkShouldIgnoreEventFromTarget(e) {
                    return e && e.nodeType === 3 && (e = e.parentNode), !(!e || e.nodeType !== 1) && e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
                }
            }

            const Ln = cu(function (r, e) {
                ea(e, oa(e), r)
            });

            class Gn {
                constructor(e, t, n) {
                    this.view = e, this.document = e.document, this.domEvent = t, this.domTarget = t.target, Ln(this, n)
                }

                get target() {
                    return this.view.domConverter.mapDomToView(this.domTarget)
                }

                preventDefault() {
                    this.domEvent.preventDefault()
                }

                stopPropagation() {
                    this.domEvent.stopPropagation()
                }
            }

            class xn extends En {
                constructor() {
                    super(...arguments), this.useCapture = !1
                }

                observe(e) {
                    (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach(t => {
                        this.listenTo(e, t, (n, i) => {
                            this.isEnabled && !this.checkShouldIgnoreEventFromTarget(i.target) && this.onDomEvent(i)
                        }, {useCapture: this.useCapture})
                    })
                }

                stopObserving(e) {
                    this.stopListening(e)
                }

                fire(e, t, n) {
                    this.isEnabled && this.document.fire(e, new Gn(this.view, t, n))
                }
            }

            class Kn extends xn {
                constructor() {
                    super(...arguments), this.domEventType = ["keydown", "keyup"]
                }

                onDomEvent(e) {
                    const t = {
                        keyCode: e.keyCode,
                        altKey: e.altKey,
                        ctrlKey: e.ctrlKey,
                        shiftKey: e.shiftKey,
                        metaKey: e.metaKey,
                        get keystroke() {
                            return Ui(this)
                        }
                    };
                    this.fire(e.type, e, t)
                }
            }

            const Mn = function () {
                return Ae.Date.now()
            };
            var Bn = /\s/;
            const Or = function (r) {
                for (var e = r.length; e-- && Bn.test(r.charAt(e));) ;
                return e
            };
            var xa = /^\s+/;
            const Jo = function (r) {
                return r && r.slice(0, Or(r) + 1).replace(xa, "")
            };
            var vr = /^[-+]0x[0-9a-f]+$/i, Ki = /^0b[01]+$/i, rr = /^0o[0-7]+$/i, Xd = parseInt;
            const Zi = function (r) {
                if (typeof r == "number") return r;
                if (iu(r)) return NaN;
                if (Oe(r)) {
                    var e = typeof r.valueOf == "function" ? r.valueOf() : r;
                    r = Oe(e) ? e + "" : e
                }
                if (typeof r != "string") return r === 0 ? r : +r;
                r = Jo(r);
                var t = Ki.test(r);
                return t || rr.test(r) ? Xd(r.slice(2), t ? 2 : 8) : vr.test(r) ? NaN : +r
            };
            var Ts = Math.max, Is = Math.min;
            const Zn = function (r, e, t) {
                var n, i, s, l, d, g, v = 0, _ = !1, x = !1, M = !0;
                if (typeof r != "function") throw new TypeError("Expected a function");

                function O(pe) {
                    var Se = n, Je = i;
                    return n = i = void 0, v = pe, l = r.apply(Je, Se)
                }

                function j(pe) {
                    var Se = pe - g;
                    return g === void 0 || Se >= e || Se < 0 || x && pe - v >= s
                }

                function U() {
                    var pe = Mn();
                    if (j(pe)) return K(pe);
                    d = setTimeout(U, function (Se) {
                        var Je = e - (Se - g);
                        return x ? Is(Je, s - (Se - v)) : Je
                    }(pe))
                }

                function K(pe) {
                    return d = void 0, M && n ? O(pe) : (n = i = void 0, l)
                }

                function ne() {
                    var pe = Mn(), Se = j(pe);
                    if (n = arguments, i = this, g = pe, Se) {
                        if (d === void 0) return function (Je) {
                            return v = Je, d = setTimeout(U, e), _ ? O(Je) : l
                        }(g);
                        if (x) return clearTimeout(d), d = setTimeout(U, e), O(g)
                    }
                    return d === void 0 && (d = setTimeout(U, e)), l
                }

                return e = Zi(e) || 0, Oe(t) && (_ = !!t.leading, s = (x = "maxWait" in t) ? Ts(Zi(t.maxWait) || 0, e) : s, M = "trailing" in t ? !!t.trailing : M), ne.cancel = function () {
                    d !== void 0 && clearTimeout(d), v = 0, n = g = i = d = void 0
                }, ne.flush = function () {
                    return d === void 0 ? l : K(Mn())
                }, ne
            };

            class Ea extends En {
                constructor(e) {
                    super(e), this._fireSelectionChangeDoneDebounced = Zn(t => {
                        this.document.fire("selectionChangeDone", t)
                    }, 200)
                }

                observe() {
                    const e = this.document;
                    e.on("arrowKey", (t, n) => {
                        e.selection.isFake && this.isEnabled && n.preventDefault()
                    }, {context: "$capture"}), e.on("arrowKey", (t, n) => {
                        e.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode)
                    }, {priority: "lowest"})
                }

                stopObserving() {
                }

                destroy() {
                    super.destroy(), this._fireSelectionChangeDoneDebounced.cancel()
                }

                _handleSelectionMove(e) {
                    const t = this.document.selection, n = new Ur(t.getRanges(), {backward: t.isBackward, fake: !1});
                    e != Ut.arrowleft && e != Ut.arrowup || n.setTo(n.getFirstPosition()), e != Ut.arrowright && e != Ut.arrowdown || n.setTo(n.getLastPosition());
                    const i = {oldSelection: t, newSelection: n, domSelection: null};
                    this.document.fire("selectionChange", i), this._fireSelectionChangeDoneDebounced(i)
                }
            }

            const eh = function (r) {
                return this.__data__.set(r, "__lodash_hash_undefined__"), this
            }, j5 = function (r) {
                return this.__data__.has(r)
            };

            function yg(r) {
                var e = -1, t = r == null ? 0 : r.length;
                for (this.__data__ = new Bo; ++e < t;) this.add(r[e])
            }

            yg.prototype.add = yg.prototype.push = eh, yg.prototype.has = j5;
            const V5 = yg, H5 = function (r, e) {
                for (var t = -1, n = r == null ? 0 : r.length; ++t < n;) if (e(r[t], t, r)) return !0;
                return !1
            }, U5 = function (r, e) {
                return r.has(e)
            }, Dv = function (r, e, t, n, i, s) {
                var l = 1 & t, d = r.length, g = e.length;
                if (d != g && !(l && g > d)) return !1;
                var v = s.get(r), _ = s.get(e);
                if (v && _) return v == e && _ == r;
                var x = -1, M = !0, O = 2 & t ? new V5 : void 0;
                for (s.set(r, e), s.set(e, r); ++x < d;) {
                    var j = r[x], U = e[x];
                    if (n) var K = l ? n(U, j, x, e, r, s) : n(j, U, x, r, e, s);
                    if (K !== void 0) {
                        if (K) continue;
                        M = !1;
                        break
                    }
                    if (O) {
                        if (!H5(e, function (ne, pe) {
                            if (!U5(O, pe) && (j === ne || i(j, ne, t, n, s))) return O.push(pe)
                        })) {
                            M = !1;
                            break
                        }
                    } else if (j !== U && !i(j, U, t, n, s)) {
                        M = !1;
                        break
                    }
                }
                return s.delete(r), s.delete(e), M
            }, q5 = function (r) {
                var e = -1, t = Array(r.size);
                return r.forEach(function (n, i) {
                    t[++e] = [i, n]
                }), t
            }, W5 = function (r) {
                var e = -1, t = Array(r.size);
                return r.forEach(function (n) {
                    t[++e] = n
                }), t
            };
            var xv = De ? De.prototype : void 0, ob = xv ? xv.valueOf : void 0;
            const $5 = function (r, e, t, n, i, s, l) {
                switch (t) {
                    case"[object DataView]":
                        if (r.byteLength != e.byteLength || r.byteOffset != e.byteOffset) return !1;
                        r = r.buffer, e = e.buffer;
                    case"[object ArrayBuffer]":
                        return !(r.byteLength != e.byteLength || !s(new aa(r), new aa(e)));
                    case"[object Boolean]":
                    case"[object Date]":
                    case"[object Number]":
                        return ti(+r, +e);
                    case"[object Error]":
                        return r.name == e.name && r.message == e.message;
                    case"[object RegExp]":
                    case"[object String]":
                        return r == e + "";
                    case"[object Map]":
                        var d = q5;
                    case"[object Set]":
                        var g = 1 & n;
                        if (d || (d = W5), r.size != e.size && !g) return !1;
                        var v = l.get(r);
                        if (v) return v == e;
                        n |= 2, l.set(r, e);
                        var _ = Dv(d(r), d(e), n, i, s, l);
                        return l.delete(r), _;
                    case"[object Symbol]":
                        if (ob) return ob.call(r) == ob.call(e)
                }
                return !1
            };
            var G5 = Object.prototype.hasOwnProperty;
            const K5 = function (r, e, t, n, i, s) {
                var l = 1 & t, d = id(r), g = d.length;
                if (g != id(e).length && !l) return !1;
                for (var v = g; v--;) {
                    var _ = d[v];
                    if (!(l ? _ in e : G5.call(e, _))) return !1
                }
                var x = s.get(r), M = s.get(e);
                if (x && M) return x == e && M == r;
                var O = !0;
                s.set(r, e), s.set(e, r);
                for (var j = l; ++v < g;) {
                    var U = r[_ = d[v]], K = e[_];
                    if (n) var ne = l ? n(K, U, _, e, r, s) : n(U, K, _, r, e, s);
                    if (!(ne === void 0 ? U === K || i(U, K, t, n, s) : ne)) {
                        O = !1;
                        break
                    }
                    j || (j = _ == "constructor")
                }
                if (O && !j) {
                    var pe = r.constructor, Se = e.constructor;
                    pe == Se || !("constructor" in r) || !("constructor" in e) || typeof pe == "function" && pe instanceof pe && typeof Se == "function" && Se instanceof Se || (O = !1)
                }
                return s.delete(r), s.delete(e), O
            };
            var Ev = "[object Arguments]", Sv = "[object Array]", Dg = "[object Object]",
                Tv = Object.prototype.hasOwnProperty;
            const Z5 = function (r, e, t, n, i, s) {
                var l = ot(r), d = ot(e), g = l ? Sv : sa(r), v = d ? Sv : sa(e), _ = (g = g == Ev ? Dg : g) == Dg,
                    x = (v = v == Ev ? Dg : v) == Dg, M = g == v;
                if (M && hs(r)) {
                    if (!hs(e)) return !1;
                    l = !0, _ = !1
                }
                if (M && !_) return s || (s = new us), l || Ic(r) ? Dv(r, e, t, n, i, s) : $5(r, e, g, t, n, i, s);
                if (!(1 & t)) {
                    var O = _ && Tv.call(r, "__wrapped__"), j = x && Tv.call(e, "__wrapped__");
                    if (O || j) {
                        var U = O ? r.value() : r, K = j ? e.value() : e;
                        return s || (s = new us), i(U, K, t, n, s)
                    }
                }
                return !!M && (s || (s = new us), K5(r, e, t, n, i, s))
            }, Iv = function r(e, t, n, i, s) {
                return e === t || (e == null || t == null || !lr(e) && !lr(t) ? e != e && t != t : Z5(e, t, n, i, r, s))
            }, Y5 = function (r, e, t) {
                var n = (t = typeof t == "function" ? t : void 0) ? t(r, e) : void 0;
                return n === void 0 ? Iv(r, e, void 0, t) : !!n
            };

            class Mv extends En {
                constructor(e) {
                    super(e), this._config = {
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    }, this.domConverter = e.domConverter, this.renderer = e._renderer, this._domElements = new Set, this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
                }

                flush() {
                    this._onMutations(this._mutationObserver.takeRecords())
                }

                observe(e) {
                    this._domElements.add(e), this.isEnabled && this._mutationObserver.observe(e, this._config)
                }

                stopObserving(e) {
                    if (this._domElements.delete(e), this.isEnabled) {
                        this._mutationObserver.disconnect();
                        for (const t of this._domElements) this._mutationObserver.observe(t, this._config)
                    }
                }

                enable() {
                    super.enable();
                    for (const e of this._domElements) this._mutationObserver.observe(e, this._config)
                }

                disable() {
                    super.disable(), this._mutationObserver.disconnect()
                }

                destroy() {
                    super.destroy(), this._mutationObserver.disconnect()
                }

                _onMutations(e) {
                    if (e.length === 0) return;
                    const t = this.domConverter, n = new Set, i = new Set;
                    for (const l of e) {
                        const d = t.mapDomToView(l.target);
                        d && (d.is("uiElement") || d.is("rawElement") || l.type !== "childList" || this._isBogusBrMutation(l) || i.add(d))
                    }
                    for (const l of e) {
                        const d = t.mapDomToView(l.target);
                        if ((!d || !d.is("uiElement") && !d.is("rawElement")) && l.type === "characterData") {
                            const g = t.findCorrespondingViewText(l.target);
                            g && !i.has(g.parent) ? n.add(g) : !g && N(l.target) && i.add(t.mapDomToView(l.target.parentNode))
                        }
                    }
                    let s = !1;
                    for (const l of n) s = !0, this.renderer.markToSync("text", l);
                    for (const l of i) {
                        const d = t.mapViewToDom(l), g = Array.from(l.getChildren()),
                            v = Array.from(t.domChildrenToView(d, {withChildren: !1}));
                        Y5(g, v, Q5) || (s = !0, this.renderer.markToSync("children", l))
                    }
                    s && this.view.forceRender()
                }

                _isBogusBrMutation(e) {
                    let t = null;
                    return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], {withChildren: !1})), t && t.is("element", "br")
                }
            }

            function Q5(r, e) {
                if (!Array.isArray(r)) return r === e || !(!r.is("$text") || !e.is("$text")) && r.data === e.data
            }

            class xg extends xn {
                constructor(e) {
                    super(e), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
                    const t = this.document;
                    t.on("focus", () => {
                        this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
                            this.flush(), e.change(() => {
                            })
                        }, 50)
                    }), t.on("blur", (n, i) => {
                        const s = t.selection.editableElement;
                        s !== null && s !== i.target || (t.isFocused = !1, this._isFocusChanging = !1, e.change(() => {
                        }))
                    })
                }

                flush() {
                    this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0)
                }

                onDomEvent(e) {
                    this.fire(e.type, e)
                }

                destroy() {
                    this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy()
                }
            }

            class J5 extends En {
                constructor(e) {
                    super(e), this.mutationObserver = e.getObserver(Mv), this.focusObserver = e.getObserver(xg), this.selection = this.document.selection, this.domConverter = e.domConverter, this._documents = new WeakSet, this._fireSelectionChangeDoneDebounced = Zn(t => {
                        this.document.fire("selectionChangeDone", t)
                    }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = Zn(() => this.document.isSelecting = !1, 5e3), this._loopbackCounter = 0
                }

                observe(e) {
                    const t = e.ownerDocument, n = () => {
                        this.document.isSelecting && (this._handleSelectionChange(null, t), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel())
                    };
                    this.listenTo(e, "selectstart", () => {
                        this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced()
                    }, {priority: "highest"}), this.listenTo(e, "keydown", n, {
                        priority: "highest",
                        useCapture: !0
                    }), this.listenTo(e, "keyup", n, {
                        priority: "highest",
                        useCapture: !0
                    }), this._documents.has(t) || (this.listenTo(t, "mouseup", n, {
                        priority: "highest",
                        useCapture: !0
                    }), this.listenTo(t, "selectionchange", (i, s) => {
                        this.document.isComposing && !T.isAndroid || (this._handleSelectionChange(s, t), this._documentIsSelectingInactivityTimeoutDebounced())
                    }), this._documents.add(t))
                }

                stopObserving(e) {
                    this.stopListening(e)
                }

                destroy() {
                    super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel()
                }

                _reportInfiniteLoop() {
                }

                _handleSelectionChange(e, t) {
                    if (!this.isEnabled) return;
                    const n = t.defaultView.getSelection();
                    if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) return;
                    this.mutationObserver.flush();
                    const i = this.domConverter.domSelectionToView(n);
                    if (i.rangeCount != 0) {
                        if (this.view.hasDomSelection = !0, this.focusObserver.flush(), !this.selection.isEqual(i) || !this.domConverter.isDomSelectionCorrect(n)) if (++this._loopbackCounter > 60) this._reportInfiniteLoop(); else if (this.selection.isSimilar(i)) this.view.forceRender(); else {
                            const s = {oldSelection: this.selection, newSelection: i, domSelection: n};
                            this.document.fire("selectionChange", s), this._fireSelectionChangeDoneDebounced(s)
                        }
                    } else this.view.hasDomSelection = !1
                }

                _clearInfiniteLoop() {
                    this._loopbackCounter = 0
                }
            }

            class X5 extends xn {
                constructor(e) {
                    super(e), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
                    const t = this.document;
                    t.on("compositionstart", () => {
                        t.isComposing = !0
                    }, {priority: "low"}), t.on("compositionend", () => {
                        t.isComposing = !1
                    }, {priority: "low"})
                }

                onDomEvent(e) {
                    this.fire(e.type, e, {data: e.data})
                }
            }

            class Bv {
                constructor(e, t = {}) {
                    this._files = t.cacheFiles ? Nv(e) : null, this._native = e
                }

                get files() {
                    return this._files || (this._files = Nv(this._native)), this._files
                }

                get types() {
                    return this._native.types
                }

                getData(e) {
                    return this._native.getData(e)
                }

                setData(e, t) {
                    this._native.setData(e, t)
                }

                set effectAllowed(e) {
                    this._native.effectAllowed = e
                }

                get effectAllowed() {
                    return this._native.effectAllowed
                }

                set dropEffect(e) {
                    this._native.dropEffect = e
                }

                get dropEffect() {
                    return this._native.dropEffect
                }

                setDragImage(e, t, n) {
                    this._native.setDragImage(e, t, n)
                }

                get isCanceled() {
                    return this._native.dropEffect == "none" || !!this._native.mozUserCancelled
                }
            }

            function Nv(r) {
                const e = Array.from(r.files || []), t = Array.from(r.items || []);
                return e.length ? e : t.filter(n => n.kind === "file").map(n => n.getAsFile())
            }

            class eS extends xn {
                constructor() {
                    super(...arguments), this.domEventType = "beforeinput"
                }

                onDomEvent(e) {
                    const t = e.getTargetRanges(), n = this.view, i = n.document;
                    let s = null, l = null, d = [];
                    if (e.dataTransfer && (s = new Bv(e.dataTransfer)), e.data !== null ? l = e.data : s && (l = s.getData("text/plain")), i.selection.isFake) d = Array.from(i.selection.getRanges()); else if (t.length) d = t.map(g => {
                        const v = n.domConverter.domPositionToView(g.startContainer, g.startOffset),
                            _ = n.domConverter.domPositionToView(g.endContainer, g.endOffset);
                        return v ? n.createRange(v, _) : _ ? n.createRange(_) : void 0
                    }).filter(g => !!g); else if (T.isAndroid) {
                        const g = e.target.ownerDocument.defaultView.getSelection();
                        d = Array.from(n.domConverter.domSelectionToView(g).getRanges())
                    }
                    if (T.isAndroid && e.inputType == "insertCompositionText" && l && l.endsWith(`
`)) this.fire(e.type, e, {
                        inputType: "insertParagraph",
                        targetRanges: [n.createRange(d[0].end)]
                    }); else if (e.inputType == "insertText" && l && l.includes(`
`)) {
                        const g = l.split(/\n{1,2}/g);
                        let v = d;
                        for (let _ = 0; _ < g.length; _++) {
                            const x = g[_];
                            x != "" && (this.fire(e.type, e, {
                                data: x,
                                dataTransfer: s,
                                targetRanges: v,
                                inputType: e.inputType,
                                isComposing: e.isComposing
                            }), v = [i.selection.getFirstRange()]), _ + 1 < g.length && (this.fire(e.type, e, {
                                inputType: "insertParagraph",
                                targetRanges: v
                            }), v = [i.selection.getFirstRange()])
                        }
                    } else this.fire(e.type, e, {
                        data: l,
                        dataTransfer: s,
                        targetRanges: d,
                        inputType: e.inputType,
                        isComposing: e.isComposing
                    })
                }
            }

            class tS extends En {
                constructor(e) {
                    super(e), this.document.on("keydown", (t, n) => {
                        if (this.isEnabled && ((i = n.keyCode) == Ut.arrowright || i == Ut.arrowleft || i == Ut.arrowup || i == Ut.arrowdown)) {
                            const s = new ya(this.document, "arrowKey", this.document.selection.getFirstRange());
                            this.document.fire(s, n), s.stop.called && t.stop()
                        }
                        var i
                    })
                }

                observe() {
                }

                stopObserving() {
                }
            }

            class nS extends En {
                constructor(e) {
                    super(e);
                    const t = this.document;
                    t.on("keydown", (n, i) => {
                        if (!this.isEnabled || i.keyCode != Ut.tab || i.ctrlKey) return;
                        const s = new ya(t, "tab", t.selection.getFirstRange());
                        t.fire(s, i), s.stop.called && n.stop()
                    })
                }

                observe() {
                }

                stopObserving() {
                }
            }

            const Sa = function (r) {
                return Pc(r, 5)
            };

            class rS extends we() {
                constructor(e) {
                    super(), this.domRoots = new Map, this._initialDomRootAttributes = new WeakMap, this._observers = new Map, this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this.document = new Ss(e), this.domConverter = new Mt(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new be(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new Cg(this.document), this.addObserver(Mv), this.addObserver(xg), this.addObserver(J5), this.addObserver(Kn), this.addObserver(Ea), this.addObserver(X5), this.addObserver(tS), this.addObserver(eS), this.addObserver(nS), this.document.on("arrowKey", H, {priority: "low"}), nb(this), this.on("render", () => {
                        this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1
                    }), this.listenTo(this.document.selection, "change", () => {
                        this._hasChangedSinceTheLastRendering = !0
                    }), this.listenTo(this.document, "change:isFocused", () => {
                        this._hasChangedSinceTheLastRendering = !0
                    }), T.isiOS && this.listenTo(this.document, "blur", (t, n) => {
                        this.domConverter.mapDomToView(n.domEvent.relatedTarget) || this.domConverter._clearDomSelection()
                    })
                }

                attachDomRoot(e, t = "main") {
                    const n = this.document.getRoot(t);
                    n._name = e.tagName.toLowerCase();
                    const i = {};
                    for (const {
                        name: l,
                        value: d
                    } of Array.from(e.attributes)) i[l] = d, l === "class" ? this._writer.addClass(d.split(" "), n) : this._writer.setAttribute(l, d, n);
                    this._initialDomRootAttributes.set(e, i);
                    const s = () => {
                        this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n), n.isReadOnly ? this._writer.addClass("ck-read-only", n) : this._writer.removeClass("ck-read-only", n)
                    };
                    s(), this.domRoots.set(t, e), this.domConverter.bindElements(e, n), this._renderer.markToSync("children", n), this._renderer.markToSync("attributes", n), this._renderer.domDocuments.add(e.ownerDocument), n.on("change:children", (l, d) => this._renderer.markToSync("children", d)), n.on("change:attributes", (l, d) => this._renderer.markToSync("attributes", d)), n.on("change:text", (l, d) => this._renderer.markToSync("text", d)), n.on("change:isReadOnly", () => this.change(s)), n.on("change", () => {
                        this._hasChangedSinceTheLastRendering = !0
                    });
                    for (const l of this._observers.values()) l.observe(e, t)
                }

                detachDomRoot(e) {
                    const t = this.domRoots.get(e);
                    Array.from(t.attributes).forEach(({name: i}) => t.removeAttribute(i));
                    const n = this._initialDomRootAttributes.get(t);
                    for (const i in n) t.setAttribute(i, n[i]);
                    this.domRoots.delete(e), this.domConverter.unbindDomElement(t);
                    for (const i of this._observers.values()) i.stopObserving(t)
                }

                getDomRoot(e = "main") {
                    return this.domRoots.get(e)
                }

                addObserver(e) {
                    let t = this._observers.get(e);
                    if (t) return t;
                    t = new e(this), this._observers.set(e, t);
                    for (const [n, i] of this.domRoots) t.observe(i, n);
                    return t.enable(), t
                }

                getObserver(e) {
                    return this._observers.get(e)
                }

                disableObservers() {
                    for (const e of this._observers.values()) e.disable()
                }

                enableObservers() {
                    for (const e of this._observers.values()) e.enable()
                }

                scrollToTheSelection({
                                         alignToTop: e,
                                         forceScroll: t,
                                         viewportOffset: n = 20,
                                         ancestorOffset: i = 20
                                     } = {}) {
                    const s = this.document.selection.getFirstRange();
                    if (!s) return;
                    const l = Sa({alignToTop: e, forceScroll: t, viewportOffset: n, ancestorOffset: i});
                    typeof n == "number" && (n = {top: n, bottom: n, left: n, right: n});
                    const d = {
                        target: this.domConverter.viewRangeToDom(s),
                        viewportOffset: n,
                        ancestorOffset: i,
                        alignToTop: e,
                        forceScroll: t
                    };
                    this.fire("scrollToTheSelection", d, l), function ({
                                                                           target: g,
                                                                           viewportOffset: v = 0,
                                                                           ancestorOffset: _ = 0,
                                                                           alignToTop: x,
                                                                           forceScroll: M
                                                                       }) {
                        const O = ks(g);
                        let j = O, U = null;
                        for (v = function (K) {
                            return typeof K == "number" ? {top: K, bottom: K, left: K, right: K} : K
                        }(v); j;) {
                            let K;
                            K = Fm(j == O ? g : U), Om({
                                parent: K,
                                getRect: () => bl(g, j),
                                alignToTop: x,
                                ancestorOffset: _,
                                forceScroll: M
                            });
                            const ne = bl(g, j);
                            if (Pm({
                                window: j,
                                rect: ne,
                                viewportOffset: v,
                                alignToTop: x,
                                forceScroll: M
                            }), j.parent != j) {
                                if (U = j.frameElement, j = j.parent, !U) return
                            } else j = null
                        }
                    }(d)
                }

                focus() {
                    if (!this.document.isFocused) {
                        const e = this.document.selection.editableElement;
                        e && (this.domConverter.focus(e), this.forceRender())
                    }
                }

                change(e) {
                    if (this.isRenderingInProgress || this._postFixersInProgress) throw new R("cannot-change-view-tree", this);
                    try {
                        if (this._ongoingChange) return e(this._writer);
                        this._ongoingChange = !0;
                        const t = e(this._writer);
                        return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t
                    } catch (t) {
                        R.rethrowUnexpectedError(t, this)
                    }
                }

                forceRender() {
                    this._hasChangedSinceTheLastRendering = !0, this.getObserver(xg).flush(), this.change(() => {
                    })
                }

                destroy() {
                    for (const e of this._observers.values()) e.destroy();
                    this.document.destroy(), this.stopListening()
                }

                createPositionAt(e, t) {
                    return We._createAt(e, t)
                }

                createPositionAfter(e) {
                    return We._createAfter(e)
                }

                createPositionBefore(e) {
                    return We._createBefore(e)
                }

                createRange(e, t) {
                    return new Ct(e, t)
                }

                createRangeOn(e) {
                    return Ct._createOn(e)
                }

                createRangeIn(e) {
                    return Ct._createIn(e)
                }

                createSelection(...e) {
                    return new Ur(...e)
                }

                _disableRendering(e) {
                    this._renderingDisabled = e, e == 0 && this.change(() => {
                    })
                }

                _render() {
                    this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1
                }
            }

            class Ta {
                is() {
                    throw new Error("is() method is abstract")
                }
            }

            class Hl extends Ta {
                constructor(e) {
                    super(), this.parent = null, this._attrs = qi(e)
                }

                get document() {
                    return null
                }

                get index() {
                    let e;
                    if (!this.parent) return null;
                    if ((e = this.parent.getChildIndex(this)) === null) throw new R("model-node-not-found-in-parent", this);
                    return e
                }

                get startOffset() {
                    let e;
                    if (!this.parent) return null;
                    if ((e = this.parent.getChildStartOffset(this)) === null) throw new R("model-node-not-found-in-parent", this);
                    return e
                }

                get offsetSize() {
                    return 1
                }

                get endOffset() {
                    return this.parent ? this.startOffset + this.offsetSize : null
                }

                get nextSibling() {
                    const e = this.index;
                    return e !== null && this.parent.getChild(e + 1) || null
                }

                get previousSibling() {
                    const e = this.index;
                    return e !== null && this.parent.getChild(e - 1) || null
                }

                get root() {
                    let e = this;
                    for (; e.parent;) e = e.parent;
                    return e
                }

                isAttached() {
                    return this.parent !== null && this.root.isAttached()
                }

                getPath() {
                    const e = [];
                    let t = this;
                    for (; t.parent;) e.unshift(t.startOffset), t = t.parent;
                    return e
                }

                getAncestors(e = {}) {
                    const t = [];
                    let n = e.includeSelf ? this : this.parent;
                    for (; n;) t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
                    return t
                }

                getCommonAncestor(e, t = {}) {
                    const n = this.getAncestors(t), i = e.getAncestors(t);
                    let s = 0;
                    for (; n[s] == i[s] && n[s];) s++;
                    return s === 0 ? null : n[s - 1]
                }

                isBefore(e) {
                    if (this == e || this.root !== e.root) return !1;
                    const t = this.getPath(), n = e.getPath(), i = te(t, n);
                    switch (i) {
                        case"prefix":
                            return !0;
                        case"extension":
                            return !1;
                        default:
                            return t[i] < n[i]
                    }
                }

                isAfter(e) {
                    return this != e && this.root === e.root && !this.isBefore(e)
                }

                hasAttribute(e) {
                    return this._attrs.has(e)
                }

                getAttribute(e) {
                    return this._attrs.get(e)
                }

                getAttributes() {
                    return this._attrs.entries()
                }

                getAttributeKeys() {
                    return this._attrs.keys()
                }

                toJSON() {
                    const e = {};
                    return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce((t, n) => (t[n[0]] = n[1], t), {})), e
                }

                _clone(e) {
                    return new this.constructor(this._attrs)
                }

                _remove() {
                    this.parent._removeChildren(this.index)
                }

                _setAttribute(e, t) {
                    this._attrs.set(e, t)
                }

                _setAttributesTo(e) {
                    this._attrs = qi(e)
                }

                _removeAttribute(e) {
                    return this._attrs.delete(e)
                }

                _clearAttributes() {
                    this._attrs.clear()
                }
            }

            Hl.prototype.is = function (r) {
                return r === "node" || r === "model:node"
            };

            class th {
                constructor(e) {
                    this._nodes = [], e && this._insertNodes(0, e)
                }

                [Symbol.iterator]() {
                    return this._nodes[Symbol.iterator]()
                }

                get length() {
                    return this._nodes.length
                }

                get maxOffset() {
                    return this._nodes.reduce((e, t) => e + t.offsetSize, 0)
                }

                getNode(e) {
                    return this._nodes[e] || null
                }

                getNodeIndex(e) {
                    const t = this._nodes.indexOf(e);
                    return t == -1 ? null : t
                }

                getNodeStartOffset(e) {
                    const t = this.getNodeIndex(e);
                    return t === null ? null : this._nodes.slice(0, t).reduce((n, i) => n + i.offsetSize, 0)
                }

                indexToOffset(e) {
                    if (e == this._nodes.length) return this.maxOffset;
                    const t = this._nodes[e];
                    if (!t) throw new R("model-nodelist-index-out-of-bounds", this);
                    return this.getNodeStartOffset(t)
                }

                offsetToIndex(e) {
                    let t = 0;
                    for (const n of this._nodes) {
                        if (e >= t && e < t + n.offsetSize) return this.getNodeIndex(n);
                        t += n.offsetSize
                    }
                    if (t != e) throw new R("model-nodelist-offset-out-of-bounds", this, {offset: e, nodeList: this});
                    return this.length
                }

                _insertNodes(e, t) {
                    for (const n of t) if (!(n instanceof Hl)) throw new R("model-nodelist-insertnodes-not-node", this);
                    this._nodes = function (n, i, s, l) {
                        if (Math.max(i.length, n.length) > 1e4) return n.slice(0, s).concat(i).concat(n.slice(s + l, n.length));
                        {
                            const d = Array.from(n);
                            return d.splice(s, l, ...i), d
                        }
                    }(this._nodes, Array.from(t), e, 0)
                }

                _removeNodes(e, t = 1) {
                    return this._nodes.splice(e, t)
                }

                toJSON() {
                    return this._nodes.map(e => e.toJSON())
                }
            }

            class An extends Hl {
                constructor(e, t) {
                    super(t), this._data = e || ""
                }

                get offsetSize() {
                    return this.data.length
                }

                get data() {
                    return this._data
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.data = this.data, e
                }

                _clone() {
                    return new An(this.data, this.getAttributes())
                }

                static fromJSON(e) {
                    return new An(e.data, e.attributes)
                }
            }

            An.prototype.is = function (r) {
                return r === "$text" || r === "model:$text" || r === "text" || r === "model:text" || r === "node" || r === "model:node"
            };

            class wo extends Ta {
                constructor(e, t, n) {
                    if (super(), this.textNode = e, t < 0 || t > e.offsetSize) throw new R("model-textproxy-wrong-offsetintext", this);
                    if (n < 0 || t + n > e.offsetSize) throw new R("model-textproxy-wrong-length", this);
                    this.data = e.data.substring(t, t + n), this.offsetInText = t
                }

                get startOffset() {
                    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null
                }

                get offsetSize() {
                    return this.data.length
                }

                get endOffset() {
                    return this.startOffset !== null ? this.startOffset + this.offsetSize : null
                }

                get isPartial() {
                    return this.offsetSize !== this.textNode.offsetSize
                }

                get parent() {
                    return this.textNode.parent
                }

                get root() {
                    return this.textNode.root
                }

                getPath() {
                    const e = this.textNode.getPath();
                    return e.length > 0 && (e[e.length - 1] += this.offsetInText), e
                }

                getAncestors(e = {}) {
                    const t = [];
                    let n = e.includeSelf ? this : this.parent;
                    for (; n;) t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
                    return t
                }

                hasAttribute(e) {
                    return this.textNode.hasAttribute(e)
                }

                getAttribute(e) {
                    return this.textNode.getAttribute(e)
                }

                getAttributes() {
                    return this.textNode.getAttributes()
                }

                getAttributeKeys() {
                    return this.textNode.getAttributeKeys()
                }
            }

            wo.prototype.is = function (r) {
                return r === "$textProxy" || r === "model:$textProxy" || r === "textProxy" || r === "model:textProxy"
            };

            class pn extends Hl {
                constructor(e, t, n) {
                    super(t), this._children = new th, this.name = e, n && this._insertChild(0, n)
                }

                get childCount() {
                    return this._children.length
                }

                get maxOffset() {
                    return this._children.maxOffset
                }

                get isEmpty() {
                    return this.childCount === 0
                }

                getChild(e) {
                    return this._children.getNode(e)
                }

                getChildren() {
                    return this._children[Symbol.iterator]()
                }

                getChildIndex(e) {
                    return this._children.getNodeIndex(e)
                }

                getChildStartOffset(e) {
                    return this._children.getNodeStartOffset(e)
                }

                offsetToIndex(e) {
                    return this._children.offsetToIndex(e)
                }

                getNodeByPath(e) {
                    let t = this;
                    for (const n of e) t = t.getChild(t.offsetToIndex(n));
                    return t
                }

                findAncestor(e, t = {}) {
                    let n = t.includeSelf ? this : this.parent;
                    for (; n;) {
                        if (n.name === e) return n;
                        n = n.parent
                    }
                    return null
                }

                toJSON() {
                    const e = super.toJSON();
                    if (e.name = this.name, this._children.length > 0) {
                        e.children = [];
                        for (const t of this._children) e.children.push(t.toJSON())
                    }
                    return e
                }

                _clone(e = !1) {
                    const t = e ? Array.from(this._children).map(n => n._clone(!0)) : void 0;
                    return new pn(this.name, this.getAttributes(), t)
                }

                _appendChild(e) {
                    this._insertChild(this.childCount, e)
                }

                _insertChild(e, t) {
                    const n = function (i) {
                        return typeof i == "string" ? [new An(i)] : (oe(i) || (i = [i]), Array.from(i).map(s => typeof s == "string" ? new An(s) : s instanceof wo ? new An(s.data, s.getAttributes()) : s))
                    }(t);
                    for (const i of n) i.parent !== null && i._remove(), i.parent = this;
                    this._children._insertNodes(e, n)
                }

                _removeChildren(e, t = 1) {
                    const n = this._children._removeNodes(e, t);
                    for (const i of n) i.parent = null;
                    return n
                }

                static fromJSON(e) {
                    let t;
                    if (e.children) {
                        t = [];
                        for (const n of e.children) n.name ? t.push(pn.fromJSON(n)) : t.push(An.fromJSON(n))
                    }
                    return new pn(e.name, e.attributes, t)
                }
            }

            pn.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "element" || r === "model:element") : r === "element" || r === "model:element" || r === "node" || r === "model:node"
            };

            class Ao {
                constructor(e) {
                    if (!e || !e.boundaries && !e.startPosition) throw new R("model-tree-walker-no-start-position", null);
                    const t = e.direction || "forward";
                    if (t != "forward" && t != "backward") throw new R("model-tree-walker-unknown-direction", e, {direction: t});
                    this.direction = t, this.boundaries = e.boundaries || null, e.startPosition ? this._position = e.startPosition.clone() : this._position = Fe._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent
                }

                [Symbol.iterator]() {
                    return this
                }

                get position() {
                    return this._position
                }

                skip(e) {
                    let t, n, i, s;
                    do i = this.position, s = this._visitedParent, {
                        done: t,
                        value: n
                    } = this.next(); while (!t && e(n));
                    t || (this._position = i, this._visitedParent = s)
                }

                next() {
                    return this.direction == "forward" ? this._next() : this._previous()
                }

                _next() {
                    const e = this.position, t = this.position.clone(), n = this._visitedParent;
                    if (n.parent === null && t.offset === n.maxOffset) return {done: !0, value: void 0};
                    if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) return {
                        done: !0,
                        value: void 0
                    };
                    const i = nh(t, n), s = i || Lv(t, n, i);
                    if (s instanceof pn) {
                        if (this.shallow) {
                            if (this.boundaries && this.boundaries.end.isBefore(t)) return {done: !0, value: void 0};
                            t.offset++
                        } else t.path.push(0), this._visitedParent = s;
                        return this._position = t, Ul("elementStart", s, e, t, 1)
                    }
                    if (s instanceof An) {
                        let l;
                        if (this.singleCharacters) l = 1; else {
                            let v = s.endOffset;
                            this._boundaryEndParent == n && this.boundaries.end.offset < v && (v = this.boundaries.end.offset), l = v - t.offset
                        }
                        const d = t.offset - s.startOffset, g = new wo(s, d, l);
                        return t.offset += l, this._position = t, Ul("text", g, e, t, l)
                    }
                    return t.path.pop(), t.offset++, this._position = t, this._visitedParent = n.parent, this.ignoreElementEnd ? this._next() : Ul("elementEnd", n, e, t)
                }

                _previous() {
                    const e = this.position, t = this.position.clone(), n = this._visitedParent;
                    if (n.parent === null && t.offset === 0) return {done: !0, value: void 0};
                    if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) return {
                        done: !0,
                        value: void 0
                    };
                    const i = t.parent, s = nh(t, i), l = s || Pv(t, i, s);
                    if (l instanceof pn) return t.offset--, this.shallow ? (this._position = t, Ul("elementStart", l, e, t, 1)) : (t.path.push(l.maxOffset), this._position = t, this._visitedParent = l, this.ignoreElementEnd ? this._previous() : Ul("elementEnd", l, e, t));
                    if (l instanceof An) {
                        let d;
                        if (this.singleCharacters) d = 1; else {
                            let _ = l.startOffset;
                            this._boundaryStartParent == n && this.boundaries.start.offset > _ && (_ = this.boundaries.start.offset), d = t.offset - _
                        }
                        const g = t.offset - l.startOffset, v = new wo(l, g - d, d);
                        return t.offset -= d, this._position = t, Ul("text", v, e, t, d)
                    }
                    return t.path.pop(), this._position = t, this._visitedParent = n.parent, Ul("elementStart", n, e, t, 1)
                }
            }

            function Ul(r, e, t, n, i) {
                return {done: !1, value: {type: r, item: e, previousPosition: t, nextPosition: n, length: i}}
            }

            class Fe extends Ta {
                constructor(e, t, n = "toNone") {
                    if (super(), !e.is("element") && !e.is("documentFragment")) throw new R("model-position-root-invalid", e);
                    if (!(t instanceof Array) || t.length === 0) throw new R("model-position-path-incorrect-format", e, {path: t});
                    e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t], e = e.root), this.root = e, this.path = t, this.stickiness = n
                }

                get offset() {
                    return this.path[this.path.length - 1]
                }

                set offset(e) {
                    this.path[this.path.length - 1] = e
                }

                get parent() {
                    let e = this.root;
                    for (let t = 0; t < this.path.length - 1; t++) if (e = e.getChild(e.offsetToIndex(this.path[t])), !e) throw new R("model-position-path-incorrect", this, {position: this});
                    if (e.is("$text")) throw new R("model-position-path-incorrect", this, {position: this});
                    return e
                }

                get index() {
                    return this.parent.offsetToIndex(this.offset)
                }

                get textNode() {
                    return nh(this, this.parent)
                }

                get nodeAfter() {
                    const e = this.parent;
                    return Lv(this, e, nh(this, e))
                }

                get nodeBefore() {
                    const e = this.parent;
                    return Pv(this, e, nh(this, e))
                }

                get isAtStart() {
                    return this.offset === 0
                }

                get isAtEnd() {
                    return this.offset == this.parent.maxOffset
                }

                compareWith(e) {
                    if (this.root != e.root) return "different";
                    const t = te(this.path, e.path);
                    switch (t) {
                        case"same":
                            return "same";
                        case"prefix":
                            return "before";
                        case"extension":
                            return "after";
                        default:
                            return this.path[t] < e.path[t] ? "before" : "after"
                    }
                }

                getLastMatchingPosition(e, t = {}) {
                    t.startPosition = this;
                    const n = new Ao(t);
                    return n.skip(e), n.position
                }

                getParentPath() {
                    return this.path.slice(0, -1)
                }

                getAncestors() {
                    const e = this.parent;
                    return e.is("documentFragment") ? [e] : e.getAncestors({includeSelf: !0})
                }

                findAncestor(e) {
                    const t = this.parent;
                    return t.is("element") ? t.findAncestor(e, {includeSelf: !0}) : null
                }

                getCommonPath(e) {
                    if (this.root != e.root) return [];
                    const t = te(this.path, e.path),
                        n = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
                    return this.path.slice(0, n)
                }

                getCommonAncestor(e) {
                    const t = this.getAncestors(), n = e.getAncestors();
                    let i = 0;
                    for (; t[i] == n[i] && t[i];) i++;
                    return i === 0 ? null : t[i - 1]
                }

                getShiftedBy(e) {
                    const t = this.clone(), n = t.offset + e;
                    return t.offset = n < 0 ? 0 : n, t
                }

                isAfter(e) {
                    return this.compareWith(e) == "after"
                }

                isBefore(e) {
                    return this.compareWith(e) == "before"
                }

                isEqual(e) {
                    return this.compareWith(e) == "same"
                }

                isTouching(e) {
                    if (this.root !== e.root) return !1;
                    const t = Math.min(this.path.length, e.path.length);
                    for (let n = 0; n < t; n++) {
                        const i = this.path[n] - e.path[n];
                        if (i < -1 || i > 1) return !1;
                        if (i === 1) return Ov(e, this, n);
                        if (i === -1) return Ov(this, e, n)
                    }
                    return this.path.length === e.path.length || (this.path.length > e.path.length ? sb(this.path, t) : sb(e.path, t))
                }

                hasSameParentAs(e) {
                    return this.root !== e.root ? !1 : te(this.getParentPath(), e.getParentPath()) == "same"
                }

                getTransformedByOperation(e) {
                    let t;
                    switch (e.type) {
                        case"insert":
                            t = this._getTransformedByInsertOperation(e);
                            break;
                        case"move":
                        case"remove":
                        case"reinsert":
                            t = this._getTransformedByMoveOperation(e);
                            break;
                        case"split":
                            t = this._getTransformedBySplitOperation(e);
                            break;
                        case"merge":
                            t = this._getTransformedByMergeOperation(e);
                            break;
                        default:
                            t = Fe._createAt(this)
                    }
                    return t
                }

                _getTransformedByInsertOperation(e) {
                    return this._getTransformedByInsertion(e.position, e.howMany)
                }

                _getTransformedByMoveOperation(e) {
                    return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
                }

                _getTransformedBySplitOperation(e) {
                    const t = e.movedRange;
                    return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1)
                }

                _getTransformedByMergeOperation(e) {
                    const t = e.movedRange;
                    let n;
                    return t.containsPosition(this) || t.start.isEqual(this) ? (n = this._getCombined(e.sourcePosition, e.targetPosition), e.sourcePosition.isBefore(e.targetPosition) && (n = n._getTransformedByDeletion(e.deletionPosition, 1))) : n = this.isEqual(e.deletionPosition) ? Fe._createAt(e.deletionPosition) : this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1), n
                }

                _getTransformedByDeletion(e, t) {
                    const n = Fe._createAt(this);
                    if (this.root != e.root) return n;
                    if (te(e.getParentPath(), this.getParentPath()) == "same") {
                        if (e.offset < this.offset) {
                            if (e.offset + t > this.offset) return null;
                            n.offset -= t
                        }
                    } else if (te(e.getParentPath(), this.getParentPath()) == "prefix") {
                        const i = e.path.length - 1;
                        if (e.offset <= this.path[i]) {
                            if (e.offset + t > this.path[i]) return null;
                            n.path[i] -= t
                        }
                    }
                    return n
                }

                _getTransformedByInsertion(e, t) {
                    const n = Fe._createAt(this);
                    if (this.root != e.root) return n;
                    if (te(e.getParentPath(), this.getParentPath()) == "same") (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (n.offset += t); else if (te(e.getParentPath(), this.getParentPath()) == "prefix") {
                        const i = e.path.length - 1;
                        e.offset <= this.path[i] && (n.path[i] += t)
                    }
                    return n
                }

                _getTransformedByMove(e, t, n) {
                    if (t = t._getTransformedByDeletion(e, n), e.isEqual(t)) return Fe._createAt(this);
                    const i = this._getTransformedByDeletion(e, n);
                    return i === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : i._getTransformedByInsertion(t, n)
                }

                _getCombined(e, t) {
                    const n = e.path.length - 1, i = Fe._createAt(t);
                    return i.stickiness = this.stickiness, i.offset = i.offset + this.path[n] - e.offset, i.path = [...i.path, ...this.path.slice(n + 1)], i
                }

                toJSON() {
                    return {root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness}
                }

                clone() {
                    return new this.constructor(this.root, this.path, this.stickiness)
                }

                static _createAt(e, t, n = "toNone") {
                    if (e instanceof Fe) return new Fe(e.root, e.path, e.stickiness);
                    {
                        const i = e;
                        if (t == "end") t = i.maxOffset; else {
                            if (t == "before") return this._createBefore(i, n);
                            if (t == "after") return this._createAfter(i, n);
                            if (t !== 0 && !t) throw new R("model-createpositionat-offset-required", [this, e])
                        }
                        if (!i.is("element") && !i.is("documentFragment")) throw new R("model-position-parent-incorrect", [this, e]);
                        const s = i.getPath();
                        return s.push(t), new this(i.root, s, n)
                    }
                }

                static _createAfter(e, t) {
                    if (!e.parent) throw new R("model-position-after-root", [this, e], {root: e});
                    return this._createAt(e.parent, e.endOffset, t)
                }

                static _createBefore(e, t) {
                    if (!e.parent) throw new R("model-position-before-root", e, {root: e});
                    return this._createAt(e.parent, e.startOffset, t)
                }

                static fromJSON(e, t) {
                    if (e.root === "$graveyard") {
                        const n = new Fe(t.graveyard, e.path);
                        return n.stickiness = e.stickiness, n
                    }
                    if (!t.getRoot(e.root)) throw new R("model-position-fromjson-no-root", t, {rootName: e.root});
                    return new Fe(t.getRoot(e.root), e.path, e.stickiness)
                }
            }

            function nh(r, e) {
                const t = e.getChild(e.offsetToIndex(r.offset));
                return t && t.is("$text") && t.startOffset < r.offset ? t : null
            }

            function Lv(r, e, t) {
                return t !== null ? null : e.getChild(e.offsetToIndex(r.offset))
            }

            function Pv(r, e, t) {
                return t !== null ? null : e.getChild(e.offsetToIndex(r.offset) - 1)
            }

            function Ov(r, e, t) {
                return t + 1 !== r.path.length && !!sb(e.path, t + 1) && !!function (n, i) {
                    let s = n.parent, l = n.path.length - 1, d = 0;
                    for (; l >= i;) {
                        if (n.path[l] + d !== s.maxOffset) return !1;
                        d = 1, l--, s = s.parent
                    }
                    return !0
                }(r, t + 1)
            }

            function sb(r, e) {
                for (; e < r.length;) {
                    if (r[e] !== 0) return !1;
                    e++
                }
                return !0
            }

            Fe.prototype.is = function (r) {
                return r === "position" || r === "model:position"
            };

            class Ee extends Ta {
                constructor(e, t) {
                    super(), this.start = Fe._createAt(e), this.end = t ? Fe._createAt(t) : Fe._createAt(e), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
                }

                * [Symbol.iterator]() {
                    yield* new Ao({boundaries: this, ignoreElementEnd: !0})
                }

                get isCollapsed() {
                    return this.start.isEqual(this.end)
                }

                get isFlat() {
                    return te(this.start.getParentPath(), this.end.getParentPath()) == "same"
                }

                get root() {
                    return this.start.root
                }

                containsPosition(e) {
                    return e.isAfter(this.start) && e.isBefore(this.end)
                }

                containsRange(e, t = !1) {
                    e.isCollapsed && (t = !1);
                    const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start),
                        i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
                    return n && i
                }

                containsItem(e) {
                    const t = Fe._createBefore(e);
                    return this.containsPosition(t) || this.start.isEqual(t)
                }

                isEqual(e) {
                    return this.start.isEqual(e.start) && this.end.isEqual(e.end)
                }

                isIntersecting(e) {
                    return this.start.isBefore(e.end) && this.end.isAfter(e.start)
                }

                getDifference(e) {
                    const t = [];
                    return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new Ee(this.start, e.start)), this.containsPosition(e.end) && t.push(new Ee(e.end, this.end))) : t.push(new Ee(this.start, this.end)), t
                }

                getIntersection(e) {
                    if (this.isIntersecting(e)) {
                        let t = this.start, n = this.end;
                        return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new Ee(t, n)
                    }
                    return null
                }

                getJoined(e, t = !1) {
                    let n = this.isIntersecting(e);
                    if (n || (n = this.start.isBefore(e.start) ? t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)), !n) return null;
                    let i = this.start, s = this.end;
                    return e.start.isBefore(i) && (i = e.start), e.end.isAfter(s) && (s = e.end), new Ee(i, s)
                }

                getMinimalFlatRanges() {
                    const e = [], t = this.start.getCommonPath(this.end).length, n = Fe._createAt(this.start);
                    let i = n.parent;
                    for (; n.path.length > t + 1;) {
                        const s = i.maxOffset - n.offset;
                        s !== 0 && e.push(new Ee(n, n.getShiftedBy(s))), n.path = n.path.slice(0, -1), n.offset++, i = i.parent
                    }
                    for (; n.path.length <= this.end.path.length;) {
                        const s = this.end.path[n.path.length - 1], l = s - n.offset;
                        l !== 0 && e.push(new Ee(n, n.getShiftedBy(l))), n.offset = s, n.path.push(0)
                    }
                    return e
                }

                getWalker(e = {}) {
                    return e.boundaries = this, new Ao(e)
                }

                * getItems(e = {}) {
                    e.boundaries = this, e.ignoreElementEnd = !0;
                    const t = new Ao(e);
                    for (const n of t) yield n.item
                }

                * getPositions(e = {}) {
                    e.boundaries = this;
                    const t = new Ao(e);
                    yield t.position;
                    for (const n of t) yield n.nextPosition
                }

                getTransformedByOperation(e) {
                    switch (e.type) {
                        case"insert":
                            return this._getTransformedByInsertOperation(e);
                        case"move":
                        case"remove":
                        case"reinsert":
                            return this._getTransformedByMoveOperation(e);
                        case"split":
                            return [this._getTransformedBySplitOperation(e)];
                        case"merge":
                            return [this._getTransformedByMergeOperation(e)]
                    }
                    return [new Ee(this.start, this.end)]
                }

                getTransformedByOperations(e) {
                    const t = [new Ee(this.start, this.end)];
                    for (const n of e) for (let i = 0; i < t.length; i++) {
                        const s = t[i].getTransformedByOperation(n);
                        t.splice(i, 1, ...s), i += s.length - 1
                    }
                    for (let n = 0; n < t.length; n++) {
                        const i = t[n];
                        for (let s = n + 1; s < t.length; s++) {
                            const l = t[s];
                            (i.containsRange(l) || l.containsRange(i) || i.isEqual(l)) && t.splice(s, 1)
                        }
                    }
                    return t
                }

                getCommonAncestor() {
                    return this.start.getCommonAncestor(this.end)
                }

                getContainedElement() {
                    if (this.isCollapsed) return null;
                    const e = this.start.nodeAfter, t = this.end.nodeBefore;
                    return e && e.is("element") && e === t ? e : null
                }

                toJSON() {
                    return {start: this.start.toJSON(), end: this.end.toJSON()}
                }

                clone() {
                    return new this.constructor(this.start, this.end)
                }

                _getTransformedByInsertOperation(e, t = !1) {
                    return this._getTransformedByInsertion(e.position, e.howMany, t)
                }

                _getTransformedByMoveOperation(e, t = !1) {
                    const n = e.sourcePosition, i = e.howMany, s = e.targetPosition;
                    return this._getTransformedByMove(n, s, i, t)
                }

                _getTransformedBySplitOperation(e) {
                    const t = this.start._getTransformedBySplitOperation(e);
                    let n = this.end._getTransformedBySplitOperation(e);
                    return this.end.isEqual(e.insertionPosition) && (n = this.end.getShiftedBy(1)), t.root != n.root && (n = this.end.getShiftedBy(-1)), new Ee(t, n)
                }

                _getTransformedByMergeOperation(e) {
                    if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition)) return new Ee(this.start);
                    let t = this.start._getTransformedByMergeOperation(e),
                        n = this.end._getTransformedByMergeOperation(e);
                    return t.root != n.root && (n = this.end.getShiftedBy(-1)), t.isAfter(n) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = Fe._createAt(n), t.offset = 0) : (e.deletionPosition.isEqual(t) || (n = e.deletionPosition), t = e.targetPosition), new Ee(t, n)) : new Ee(t, n)
                }

                _getTransformedByInsertion(e, t, n = !1) {
                    if (n && this.containsPosition(e)) return [new Ee(this.start, e), new Ee(e.getShiftedBy(t), this.end._getTransformedByInsertion(e, t))];
                    {
                        const i = new Ee(this.start, this.end);
                        return i.start = i.start._getTransformedByInsertion(e, t), i.end = i.end._getTransformedByInsertion(e, t), [i]
                    }
                }

                _getTransformedByMove(e, t, n, i = !1) {
                    if (this.isCollapsed) {
                        const x = this.start._getTransformedByMove(e, t, n);
                        return [new Ee(x)]
                    }
                    const s = Ee._createFromPositionAndShift(e, n), l = t._getTransformedByDeletion(e, n);
                    if (this.containsPosition(t) && !i && (s.containsPosition(this.start) || s.containsPosition(this.end))) {
                        const x = this.start._getTransformedByMove(e, t, n),
                            M = this.end._getTransformedByMove(e, t, n);
                        return [new Ee(x, M)]
                    }
                    let d;
                    const g = this.getDifference(s);
                    let v = null;
                    const _ = this.getIntersection(s);
                    if (g.length == 1 ? v = new Ee(g[0].start._getTransformedByDeletion(e, n), g[0].end._getTransformedByDeletion(e, n)) : g.length == 2 && (v = new Ee(this.start, this.end._getTransformedByDeletion(e, n))), d = v ? v._getTransformedByInsertion(l, n, _ !== null || i) : [], _) {
                        const x = new Ee(_.start._getCombined(s.start, l), _.end._getCombined(s.start, l));
                        d.length == 2 ? d.splice(1, 0, x) : d.push(x)
                    }
                    return d
                }

                _getTransformedByDeletion(e, t) {
                    let n = this.start._getTransformedByDeletion(e, t), i = this.end._getTransformedByDeletion(e, t);
                    return n == null && i == null ? null : (n == null && (n = e), i == null && (i = e), new Ee(n, i))
                }

                static _createFromPositionAndShift(e, t) {
                    const n = e, i = e.getShiftedBy(t);
                    return t > 0 ? new this(n, i) : new this(i, n)
                }

                static _createIn(e) {
                    return new this(Fe._createAt(e, 0), Fe._createAt(e, e.maxOffset))
                }

                static _createOn(e) {
                    return this._createFromPositionAndShift(Fe._createBefore(e), e.offsetSize)
                }

                static _createFromRanges(e) {
                    if (e.length === 0) throw new R("range-create-from-ranges-empty-array", null);
                    if (e.length == 1) return e[0].clone();
                    const t = e[0];
                    e.sort((s, l) => s.start.isAfter(l.start) ? 1 : -1);
                    const n = e.indexOf(t), i = new this(t.start, t.end);
                    if (n > 0) for (let s = n - 1; e[s].end.isEqual(i.start); s++) i.start = Fe._createAt(e[s].start);
                    for (let s = n + 1; s < e.length && e[s].start.isEqual(i.end); s++) i.end = Fe._createAt(e[s].end);
                    return i
                }

                static fromJSON(e, t) {
                    return new this(Fe.fromJSON(e.start, t), Fe.fromJSON(e.end, t))
                }
            }

            Ee.prototype.is = function (r) {
                return r === "range" || r === "model:range"
            };

            class Fv extends Le() {
                constructor() {
                    super(), this._modelToViewMapping = new WeakMap, this._viewToModelMapping = new WeakMap, this._viewToModelLengthCallbacks = new Map, this._markerNameToElements = new Map, this._elementToMarkerNames = new Map, this._deferredBindingRemovals = new Map, this._unboundMarkerNames = new Set, this.on("modelToViewPosition", (e, t) => {
                        if (t.viewPosition) return;
                        const n = this._modelToViewMapping.get(t.modelPosition.parent);
                        if (!n) throw new R("mapping-model-position-view-parent-not-found", this, {modelPosition: t.modelPosition});
                        t.viewPosition = this.findPositionIn(n, t.modelPosition.offset)
                    }, {priority: "low"}), this.on("viewToModelPosition", (e, t) => {
                        if (t.modelPosition) return;
                        const n = this.findMappedViewAncestor(t.viewPosition), i = this._viewToModelMapping.get(n),
                            s = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, n);
                        t.modelPosition = Fe._createAt(i, s)
                    }, {priority: "low"})
                }

                bindElements(e, t) {
                    this._modelToViewMapping.set(e, t), this._viewToModelMapping.set(t, e)
                }

                unbindViewElement(e, t = {}) {
                    const n = this.toModelElement(e);
                    if (this._elementToMarkerNames.has(e)) for (const i of this._elementToMarkerNames.get(e)) this._unboundMarkerNames.add(i);
                    t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e), this._modelToViewMapping.get(n) == e && this._modelToViewMapping.delete(n))
                }

                unbindModelElement(e) {
                    const t = this.toViewElement(e);
                    this._modelToViewMapping.delete(e), this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t)
                }

                bindElementToMarker(e, t) {
                    const n = this._markerNameToElements.get(t) || new Set;
                    n.add(e);
                    const i = this._elementToMarkerNames.get(e) || new Set;
                    i.add(t), this._markerNameToElements.set(t, n), this._elementToMarkerNames.set(e, i)
                }

                unbindElementFromMarkerName(e, t) {
                    const n = this._markerNameToElements.get(t);
                    n && (n.delete(e), n.size == 0 && this._markerNameToElements.delete(t));
                    const i = this._elementToMarkerNames.get(e);
                    i && (i.delete(t), i.size == 0 && this._elementToMarkerNames.delete(e))
                }

                flushUnboundMarkerNames() {
                    const e = Array.from(this._unboundMarkerNames);
                    return this._unboundMarkerNames.clear(), e
                }

                flushDeferredBindings() {
                    for (const [e, t] of this._deferredBindingRemovals) e.root == t && this.unbindViewElement(e);
                    this._deferredBindingRemovals = new Map
                }

                clearBindings() {
                    this._modelToViewMapping = new WeakMap, this._viewToModelMapping = new WeakMap, this._markerNameToElements = new Map, this._elementToMarkerNames = new Map, this._unboundMarkerNames = new Set, this._deferredBindingRemovals = new Map
                }

                toModelElement(e) {
                    return this._viewToModelMapping.get(e)
                }

                toViewElement(e) {
                    return this._modelToViewMapping.get(e)
                }

                toModelRange(e) {
                    return new Ee(this.toModelPosition(e.start), this.toModelPosition(e.end))
                }

                toViewRange(e) {
                    return new Ct(this.toViewPosition(e.start), this.toViewPosition(e.end))
                }

                toModelPosition(e) {
                    const t = {viewPosition: e, mapper: this};
                    return this.fire("viewToModelPosition", t), t.modelPosition
                }

                toViewPosition(e, t = {}) {
                    const n = {modelPosition: e, mapper: this, isPhantom: t.isPhantom};
                    return this.fire("modelToViewPosition", n), n.viewPosition
                }

                markerNameToElements(e) {
                    const t = this._markerNameToElements.get(e);
                    if (!t) return null;
                    const n = new Set;
                    for (const i of t) if (i.is("attributeElement")) for (const s of i.getElementsWithSameId()) n.add(s); else n.add(i);
                    return n
                }

                registerViewToModelLength(e, t) {
                    this._viewToModelLengthCallbacks.set(e, t)
                }

                findMappedViewAncestor(e) {
                    let t = e.parent;
                    for (; !this._viewToModelMapping.has(t);) t = t.parent;
                    return t
                }

                _toModelOffset(e, t, n) {
                    if (n != e) return this._toModelOffset(e.parent, e.index, n) + this._toModelOffset(e, t, e);
                    if (e.is("$text")) return t;
                    let i = 0;
                    for (let s = 0; s < t; s++) i += this.getModelLength(e.getChild(s));
                    return i
                }

                getModelLength(e) {
                    if (this._viewToModelLengthCallbacks.get(e.name)) return this._viewToModelLengthCallbacks.get(e.name)(e);
                    if (this._viewToModelMapping.has(e)) return 1;
                    if (e.is("$text")) return e.data.length;
                    if (e.is("uiElement")) return 0;
                    {
                        let t = 0;
                        for (const n of e.getChildren()) t += this.getModelLength(n);
                        return t
                    }
                }

                findPositionIn(e, t) {
                    let n, i = 0, s = 0, l = 0;
                    if (e.is("$text")) return new We(e, t);
                    for (; s < t;) n = e.getChild(l), i = this.getModelLength(n), s += i, l++;
                    return s == t ? this._moveViewPositionToTextNode(new We(e, l)) : this.findPositionIn(n, t - (s - i))
                }

                _moveViewPositionToTextNode(e) {
                    const t = e.nodeBefore, n = e.nodeAfter;
                    return t instanceof dn ? new We(t, t.data.length) : n instanceof dn ? new We(n, 0) : e
                }
            }

            class iS {
                constructor() {
                    this._consumable = new Map, this._textProxyRegistry = new Map
                }

                add(e, t) {
                    t = Eg(t), e instanceof wo && (e = this._getSymbolForTextProxy(e)), this._consumable.has(e) || this._consumable.set(e, new Map), this._consumable.get(e).set(t, !0)
                }

                consume(e, t) {
                    return t = Eg(t), e instanceof wo && (e = this._getSymbolForTextProxy(e)), !!this.test(e, t) && (this._consumable.get(e).set(t, !1), !0)
                }

                test(e, t) {
                    t = Eg(t), e instanceof wo && (e = this._getSymbolForTextProxy(e));
                    const n = this._consumable.get(e);
                    if (n === void 0) return null;
                    const i = n.get(t);
                    return i === void 0 ? null : i
                }

                revert(e, t) {
                    t = Eg(t), e instanceof wo && (e = this._getSymbolForTextProxy(e));
                    const n = this.test(e, t);
                    return n === !1 ? (this._consumable.get(e).set(t, !0), !0) : n !== !0 && null
                }

                verifyAllConsumed(e) {
                    const t = [];
                    for (const [n, i] of this._consumable) for (const [s, l] of i) {
                        const d = s.split(":")[0];
                        l && e == d && t.push({event: s, item: n.name || n.description})
                    }
                    if (t.length) throw new R("conversion-model-consumable-not-consumed", null, {items: t})
                }

                _getSymbolForTextProxy(e) {
                    let t = null;
                    const n = this._textProxyRegistry.get(e.startOffset);
                    if (n) {
                        const i = n.get(e.endOffset);
                        i && (t = i.get(e.parent))
                    }
                    return t || (t = this._addSymbolForTextProxy(e)), t
                }

                _addSymbolForTextProxy(e) {
                    const t = e.startOffset, n = e.endOffset, i = e.parent, s = Symbol("$textProxy:" + e.data);
                    let l, d;
                    return l = this._textProxyRegistry.get(t), l || (l = new Map, this._textProxyRegistry.set(t, l)), d = l.get(n), d || (d = new Map, l.set(n, d)), d.set(i, s), s
                }
            }

            function Eg(r) {
                const e = r.split(":");
                return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? r : e.length > 1 ? e[0] + ":" + e[1] : e[0]
            }

            var oS = Object.defineProperty, sS = Object.defineProperties, aS = Object.getOwnPropertyDescriptors,
                Rv = Object.getOwnPropertySymbols, lS = Object.prototype.hasOwnProperty,
                cS = Object.prototype.propertyIsEnumerable, zv = (r, e, t) => e in r ? oS(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, ab = (r, e) => {
                    for (var t in e || (e = {})) lS.call(e, t) && zv(r, t, e[t]);
                    if (Rv) for (var t of Rv(e)) cS.call(e, t) && zv(r, t, e[t]);
                    return r
                }, jv = (r, e) => sS(r, aS(e));

            class Vv extends Le() {
                constructor(e) {
                    super(), this._conversionApi = ab({dispatcher: this}, e), this._firedEventsMap = new WeakMap
                }

                convertChanges(e, t, n) {
                    const i = this._createConversionApi(n, e.getRefreshedItems());
                    for (const l of e.getMarkersToRemove()) this._convertMarkerRemove(l.name, l.range, i);
                    const s = this._reduceChanges(e.getChanges());
                    for (const l of s) l.type === "insert" ? this._convertInsert(Ee._createFromPositionAndShift(l.position, l.length), i) : l.type === "reinsert" ? this._convertReinsert(Ee._createFromPositionAndShift(l.position, l.length), i) : l.type === "remove" ? this._convertRemove(l.position, l.length, l.name, i) : this._convertAttribute(l.range, l.attributeKey, l.attributeOldValue, l.attributeNewValue, i);
                    i.mapper.flushDeferredBindings();
                    for (const l of i.mapper.flushUnboundMarkerNames()) {
                        const d = t.get(l).getRange();
                        this._convertMarkerRemove(l, d, i), this._convertMarkerAdd(l, d, i)
                    }
                    for (const l of e.getMarkersToAdd()) this._convertMarkerAdd(l.name, l.range, i);
                    i.consumable.verifyAllConsumed("insert")
                }

                convert(e, t, n, i = {}) {
                    const s = this._createConversionApi(n, void 0, i);
                    this._convertInsert(e, s);
                    for (const [l, d] of t) this._convertMarkerAdd(l, d, s);
                    s.consumable.verifyAllConsumed("insert")
                }

                convertSelection(e, t, n) {
                    const i = this._createConversionApi(n);
                    this.fire("cleanSelection", {selection: e}, i);
                    const s = e.getFirstPosition().root;
                    if (!i.mapper.toViewElement(s)) return;
                    const l = Array.from(t.getMarkersAtPosition(e.getFirstPosition()));
                    if (this._addConsumablesForSelection(i.consumable, e, l), this.fire("selection", {selection: e}, i), e.isCollapsed) {
                        for (const d of l) if (i.consumable.test(e, "addMarker:" + d.name)) {
                            const g = d.getRange();
                            if (!uS(e.getFirstPosition(), d, i.mapper)) continue;
                            const v = {item: e, markerName: d.name, markerRange: g};
                            this.fire(`addMarker:${d.name}`, v, i)
                        }
                        for (const d of e.getAttributeKeys()) if (i.consumable.test(e, "attribute:" + d)) {
                            const g = {
                                item: e,
                                range: e.getFirstRange(),
                                attributeKey: d,
                                attributeOldValue: null,
                                attributeNewValue: e.getAttribute(d)
                            };
                            this.fire(`attribute:${d}:$text`, g, i)
                        }
                    }
                }

                _convertInsert(e, t, n = {}) {
                    n.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, e);
                    for (const i of Array.from(e.getWalker({shallow: !0})).map(Hv)) this._testAndFire("insert", i, t)
                }

                _convertRemove(e, t, n, i) {
                    this.fire(`remove:${n}`, {position: e, length: t}, i)
                }

                _convertAttribute(e, t, n, i, s) {
                    this._addConsumablesForRange(s.consumable, e, `attribute:${t}`);
                    for (const l of e) {
                        const d = {
                            item: l.item,
                            range: Ee._createFromPositionAndShift(l.previousPosition, l.length),
                            attributeKey: t,
                            attributeOldValue: n,
                            attributeNewValue: i
                        };
                        this._testAndFire(`attribute:${t}`, d, s)
                    }
                }

                _convertReinsert(e, t) {
                    const n = Array.from(e.getWalker({shallow: !0}));
                    this._addConsumablesForInsert(t.consumable, n);
                    for (const i of n.map(Hv)) this._testAndFire("insert", jv(ab({}, i), {reconversion: !0}), t)
                }

                _convertMarkerAdd(e, t, n) {
                    if (t.root.rootName == "$graveyard") return;
                    const i = `addMarker:${e}`;
                    if (n.consumable.add(t, i), this.fire(i, {
                        markerName: e,
                        markerRange: t
                    }, n), n.consumable.consume(t, i)) {
                        this._addConsumablesForRange(n.consumable, t, i);
                        for (const s of t.getItems()) {
                            if (!n.consumable.test(s, i)) continue;
                            const l = {item: s, range: Ee._createOn(s), markerName: e, markerRange: t};
                            this.fire(i, l, n)
                        }
                    }
                }

                _convertMarkerRemove(e, t, n) {
                    t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, {
                        markerName: e,
                        markerRange: t
                    }, n)
                }

                _reduceChanges(e) {
                    const t = {changes: e};
                    return this.fire("reduceChanges", t), t.changes
                }

                _addConsumablesForInsert(e, t) {
                    for (const n of t) {
                        const i = n.item;
                        if (e.test(i, "insert") === null) {
                            e.add(i, "insert");
                            for (const s of i.getAttributeKeys()) e.add(i, "attribute:" + s)
                        }
                    }
                    return e
                }

                _addConsumablesForRange(e, t, n) {
                    for (const i of t.getItems()) e.add(i, n);
                    return e
                }

                _addConsumablesForSelection(e, t, n) {
                    e.add(t, "selection");
                    for (const i of n) e.add(t, "addMarker:" + i.name);
                    for (const i of t.getAttributeKeys()) e.add(t, "attribute:" + i);
                    return e
                }

                _testAndFire(e, t, n) {
                    const i = function (g, v) {
                            const _ = v.item.is("element") ? v.item.name : "$text";
                            return `${g}:${_}`
                        }(e, t), s = t.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(t.item) : t.item,
                        l = this._firedEventsMap.get(n), d = l.get(s);
                    if (d) {
                        if (d.has(i)) return;
                        d.add(i)
                    } else l.set(s, new Set([i]));
                    this.fire(i, t, n)
                }

                _testAndFireAddAttributes(e, t) {
                    const n = {item: e, range: Ee._createOn(e)};
                    for (const i of n.item.getAttributeKeys()) n.attributeKey = i, n.attributeOldValue = null, n.attributeNewValue = n.item.getAttribute(i), this._testAndFire(`attribute:${i}`, n, t)
                }

                _createConversionApi(e, t = new Set, n = {}) {
                    const i = jv(ab({}, this._conversionApi), {
                        consumable: new iS,
                        writer: e,
                        options: n,
                        convertItem: s => this._convertInsert(Ee._createOn(s), i),
                        convertChildren: s => this._convertInsert(Ee._createIn(s), i, {doNotAddConsumables: !0}),
                        convertAttributes: s => this._testAndFireAddAttributes(s, i),
                        canReuseView: s => !t.has(i.mapper.toModelElement(s))
                    });
                    return this._firedEventsMap.set(i, new Map), i
                }
            }

            function uS(r, e, t) {
                const n = e.getRange(), i = Array.from(r.getAncestors());
                return i.shift(), i.reverse(), !i.some(s => {
                    if (n.containsItem(s)) return !!t.toViewElement(s).getCustomProperty("addHighlight")
                })
            }

            function Hv(r) {
                return {item: r.item, range: Ee._createFromPositionAndShift(r.previousPosition, r.length)}
            }

            class Ti extends Le(Ta) {
                constructor(...e) {
                    super(), this._lastRangeBackward = !1, this._attrs = new Map, this._ranges = [], e.length && this.setTo(...e)
                }

                get anchor() {
                    if (this._ranges.length > 0) {
                        const e = this._ranges[this._ranges.length - 1];
                        return this._lastRangeBackward ? e.end : e.start
                    }
                    return null
                }

                get focus() {
                    if (this._ranges.length > 0) {
                        const e = this._ranges[this._ranges.length - 1];
                        return this._lastRangeBackward ? e.start : e.end
                    }
                    return null
                }

                get isCollapsed() {
                    return this._ranges.length === 1 && this._ranges[0].isCollapsed
                }

                get rangeCount() {
                    return this._ranges.length
                }

                get isBackward() {
                    return !this.isCollapsed && this._lastRangeBackward
                }

                isEqual(e) {
                    if (this.rangeCount != e.rangeCount) return !1;
                    if (this.rangeCount === 0) return !0;
                    if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus)) return !1;
                    for (const t of this._ranges) {
                        let n = !1;
                        for (const i of e._ranges) if (t.isEqual(i)) {
                            n = !0;
                            break
                        }
                        if (!n) return !1
                    }
                    return !0
                }

                * getRanges() {
                    for (const e of this._ranges) yield new Ee(e.start, e.end)
                }

                getFirstRange() {
                    let e = null;
                    for (const t of this._ranges) e && !t.start.isBefore(e.start) || (e = t);
                    return e ? new Ee(e.start, e.end) : null
                }

                getLastRange() {
                    let e = null;
                    for (const t of this._ranges) e && !t.end.isAfter(e.end) || (e = t);
                    return e ? new Ee(e.start, e.end) : null
                }

                getFirstPosition() {
                    const e = this.getFirstRange();
                    return e ? e.start.clone() : null
                }

                getLastPosition() {
                    const e = this.getLastRange();
                    return e ? e.end.clone() : null
                }

                setTo(...e) {
                    let [t, n, i] = e;
                    if (typeof n == "object" && (i = n, n = void 0), t === null) this._setRanges([]); else if (t instanceof Ti) this._setRanges(t.getRanges(), t.isBackward); else if (t && typeof t.getRanges == "function") this._setRanges(t.getRanges(), t.isBackward); else if (t instanceof Ee) this._setRanges([t], !!i && !!i.backward); else if (t instanceof Fe) this._setRanges([new Ee(t)]); else if (t instanceof Hl) {
                        const s = !!i && !!i.backward;
                        let l;
                        if (n == "in") l = Ee._createIn(t); else if (n == "on") l = Ee._createOn(t); else {
                            if (n === void 0) throw new R("model-selection-setto-required-second-parameter", [this, t]);
                            l = new Ee(Fe._createAt(t, n))
                        }
                        this._setRanges([l], s)
                    } else {
                        if (!oe(t)) throw new R("model-selection-setto-not-selectable", [this, t]);
                        this._setRanges(t, i && !!i.backward)
                    }
                }

                _setRanges(e, t = !1) {
                    const n = Array.from(e), i = n.some(s => {
                        if (!(s instanceof Ee)) throw new R("model-selection-set-ranges-not-range", [this, e]);
                        return this._ranges.every(l => !l.isEqual(s))
                    });
                    (n.length !== this._ranges.length || i) && (this._replaceAllRanges(n), this._lastRangeBackward = !!t, this.fire("change:range", {directChange: !0}))
                }

                setFocus(e, t) {
                    if (this.anchor === null) throw new R("model-selection-setfocus-no-ranges", [this, e]);
                    const n = Fe._createAt(e, t);
                    if (n.compareWith(this.focus) == "same") return;
                    const i = this.anchor;
                    this._ranges.length && this._popRange(), n.compareWith(i) == "before" ? (this._pushRange(new Ee(n, i)), this._lastRangeBackward = !0) : (this._pushRange(new Ee(i, n)), this._lastRangeBackward = !1), this.fire("change:range", {directChange: !0})
                }

                getAttribute(e) {
                    return this._attrs.get(e)
                }

                getAttributes() {
                    return this._attrs.entries()
                }

                getAttributeKeys() {
                    return this._attrs.keys()
                }

                hasAttribute(e) {
                    return this._attrs.has(e)
                }

                removeAttribute(e) {
                    this.hasAttribute(e) && (this._attrs.delete(e), this.fire("change:attribute", {
                        attributeKeys: [e],
                        directChange: !0
                    }))
                }

                setAttribute(e, t) {
                    this.getAttribute(e) !== t && (this._attrs.set(e, t), this.fire("change:attribute", {
                        attributeKeys: [e],
                        directChange: !0
                    }))
                }

                getSelectedElement() {
                    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement()
                }

                * getSelectedBlocks() {
                    const e = new WeakSet;
                    for (const t of this.getRanges()) {
                        const n = qv(t.start, e);
                        hS(n, t) && (yield n);
                        for (const s of t.getWalker()) {
                            const l = s.item;
                            s.type == "elementEnd" && dS(l, e, t) && (yield l)
                        }
                        const i = qv(t.end, e);
                        fS(i, t) && (yield i)
                    }
                }

                containsEntireContent(e = this.anchor.root) {
                    const t = Fe._createAt(e, 0), n = Fe._createAt(e, "end");
                    return t.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
                }

                _pushRange(e) {
                    this._checkRange(e), this._ranges.push(new Ee(e.start, e.end))
                }

                _checkRange(e) {
                    for (let t = 0; t < this._ranges.length; t++) if (e.isIntersecting(this._ranges[t])) throw new R("model-selection-range-intersects", [this, e], {
                        addedRange: e,
                        intersectingRange: this._ranges[t]
                    })
                }

                _replaceAllRanges(e) {
                    this._removeAllRanges();
                    for (const t of e) this._pushRange(t)
                }

                _removeAllRanges() {
                    for (; this._ranges.length > 0;) this._popRange()
                }

                _popRange() {
                    this._ranges.pop()
                }
            }

            function Uv(r, e) {
                return !e.has(r) && (e.add(r), r.root.document.model.schema.isBlock(r) && !!r.parent)
            }

            function dS(r, e, t) {
                return Uv(r, e) && lb(r, t)
            }

            function qv(r, e) {
                const t = r.parent.root.document.model.schema,
                    n = r.parent.getAncestors({parentFirst: !0, includeSelf: !0});
                let i = !1;
                const s = n.find(l => !i && (i = t.isLimit(l), !i && Uv(l, e)));
                return n.forEach(l => e.add(l)), s
            }

            function lb(r, e) {
                const t = function (n) {
                    const i = n.root.document.model.schema;
                    let s = n.parent;
                    for (; s;) {
                        if (i.isBlock(s)) return s;
                        s = s.parent
                    }
                }(r);
                return t ? !e.containsRange(Ee._createOn(t), !0) : !0
            }

            function hS(r, e) {
                return !!r && (!(!e.isCollapsed && !r.isEmpty) || !e.start.isTouching(Fe._createAt(r, r.maxOffset)) && lb(r, e))
            }

            function fS(r, e) {
                return !!r && (!(!e.isCollapsed && !r.isEmpty) || !e.end.isTouching(Fe._createAt(r, 0)) && lb(r, e))
            }

            Ti.prototype.is = function (r) {
                return r === "selection" || r === "model:selection"
            };

            class Ii extends Le(Ee) {
                constructor(e, t) {
                    super(e, t), gS.call(this)
                }

                detach() {
                    this.stopListening()
                }

                toRange() {
                    return new Ee(this.start, this.end)
                }

                static fromRange(e) {
                    return new Ii(e.start, e.end)
                }
            }

            function gS() {
                this.listenTo(this.root.document.model, "applyOperation", (r, e) => {
                    const t = e[0];
                    t.isDocumentOperation && pS.call(this, t)
                }, {priority: "low"})
            }

            function pS(r) {
                const e = this.getTransformedByOperation(r), t = Ee._createFromRanges(e), n = !t.isEqual(this),
                    i = function (l, d) {
                        switch (d.type) {
                            case"insert":
                                return l.containsPosition(d.position);
                            case"move":
                            case"remove":
                            case"reinsert":
                            case"merge":
                                return l.containsPosition(d.sourcePosition) || l.start.isEqual(d.sourcePosition) || l.containsPosition(d.targetPosition);
                            case"split":
                                return l.containsPosition(d.splitPosition) || l.containsPosition(d.insertionPosition)
                        }
                        return !1
                    }(this, r);
                let s = null;
                if (n) {
                    t.root.rootName == "$graveyard" && (s = r.type == "remove" ? r.sourcePosition : r.deletionPosition);
                    const l = this.toRange();
                    this.start = t.start, this.end = t.end, this.fire("change:range", l, {deletionPosition: s})
                } else i && this.fire("change:content", this.toRange(), {deletionPosition: s})
            }

            Ii.prototype.is = function (r) {
                return r === "liveRange" || r === "model:liveRange" || r == "range" || r === "model:range"
            };
            const Sg = "selection:";

            class Co extends Le(Ta) {
                constructor(e) {
                    super(), this._selection = new mS(e), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this)
                }

                get isCollapsed() {
                    return this._selection.isCollapsed
                }

                get anchor() {
                    return this._selection.anchor
                }

                get focus() {
                    return this._selection.focus
                }

                get rangeCount() {
                    return this._selection.rangeCount
                }

                get hasOwnRange() {
                    return this._selection.hasOwnRange
                }

                get isBackward() {
                    return this._selection.isBackward
                }

                get isGravityOverridden() {
                    return this._selection.isGravityOverridden
                }

                get markers() {
                    return this._selection.markers
                }

                get _ranges() {
                    return this._selection._ranges
                }

                getRanges() {
                    return this._selection.getRanges()
                }

                getFirstPosition() {
                    return this._selection.getFirstPosition()
                }

                getLastPosition() {
                    return this._selection.getLastPosition()
                }

                getFirstRange() {
                    return this._selection.getFirstRange()
                }

                getLastRange() {
                    return this._selection.getLastRange()
                }

                getSelectedBlocks() {
                    return this._selection.getSelectedBlocks()
                }

                getSelectedElement() {
                    return this._selection.getSelectedElement()
                }

                containsEntireContent(e) {
                    return this._selection.containsEntireContent(e)
                }

                destroy() {
                    this._selection.destroy()
                }

                getAttributeKeys() {
                    return this._selection.getAttributeKeys()
                }

                getAttributes() {
                    return this._selection.getAttributes()
                }

                getAttribute(e) {
                    return this._selection.getAttribute(e)
                }

                hasAttribute(e) {
                    return this._selection.hasAttribute(e)
                }

                refresh() {
                    this._selection.updateMarkers(), this._selection._updateAttributes(!1)
                }

                observeMarkers(e) {
                    this._selection.observeMarkers(e)
                }

                _setFocus(e, t) {
                    this._selection.setFocus(e, t)
                }

                _setTo(...e) {
                    this._selection.setTo(...e)
                }

                _setAttribute(e, t) {
                    this._selection.setAttribute(e, t)
                }

                _removeAttribute(e) {
                    this._selection.removeAttribute(e)
                }

                _getStoredAttributes() {
                    return this._selection.getStoredAttributes()
                }

                _overrideGravity() {
                    return this._selection.overrideGravity()
                }

                _restoreGravity(e) {
                    this._selection.restoreGravity(e)
                }

                static _getStoreAttributeKey(e) {
                    return Sg + e
                }

                static _isStoreAttributeKey(e) {
                    return e.startsWith(Sg)
                }
            }

            Co.prototype.is = function (r) {
                return r === "selection" || r == "model:selection" || r == "documentSelection" || r == "model:documentSelection"
            };

            class mS extends Ti {
                constructor(e) {
                    super(), this.markers = new br({idProperty: "name"}), this._attributePriority = new Map, this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = new Set, this._observedMarkers = new Set, this._model = e.model, this._document = e, this.listenTo(this._model, "applyOperation", (t, n) => {
                        const i = n[0];
                        i.isDocumentOperation && i.type != "marker" && i.type != "rename" && i.type != "noop" && (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", {directChange: !1})))
                    }, {priority: "lowest"}), this.on("change:range", () => {
                        this._validateSelectionRanges(this.getRanges())
                    }), this.listenTo(this._model.markers, "update", (t, n, i, s) => {
                        this._updateMarker(n, s)
                    }), this.listenTo(this._document, "change", (t, n) => {
                        (function (i, s) {
                            const l = i.document.differ;
                            for (const d of l.getChanges()) {
                                if (d.type != "insert") continue;
                                const g = d.position.parent;
                                d.length === g.maxOffset && i.enqueueChange(s, v => {
                                    const _ = Array.from(g.getAttributeKeys()).filter(x => x.startsWith(Sg));
                                    for (const x of _) v.removeAttribute(x, g)
                                })
                            }
                        })(this._model, n)
                    })
                }

                get isCollapsed() {
                    return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
                }

                get anchor() {
                    return super.anchor || this._document._getDefaultRange().start
                }

                get focus() {
                    return super.focus || this._document._getDefaultRange().end
                }

                get rangeCount() {
                    return this._ranges.length ? this._ranges.length : 1
                }

                get hasOwnRange() {
                    return this._ranges.length > 0
                }

                get isGravityOverridden() {
                    return !!this._overriddenGravityRegister.size
                }

                destroy() {
                    for (let e = 0; e < this._ranges.length; e++) this._ranges[e].detach();
                    this.stopListening()
                }

                * getRanges() {
                    this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange()
                }

                getFirstRange() {
                    return super.getFirstRange() || this._document._getDefaultRange()
                }

                getLastRange() {
                    return super.getLastRange() || this._document._getDefaultRange()
                }

                setTo(...e) {
                    super.setTo(...e), this._updateAttributes(!0), this.updateMarkers()
                }

                setFocus(e, t) {
                    super.setFocus(e, t), this._updateAttributes(!0), this.updateMarkers()
                }

                setAttribute(e, t) {
                    if (this._setAttribute(e, t)) {
                        const n = [e];
                        this.fire("change:attribute", {attributeKeys: n, directChange: !0})
                    }
                }

                removeAttribute(e) {
                    if (this._removeAttribute(e)) {
                        const t = [e];
                        this.fire("change:attribute", {attributeKeys: t, directChange: !0})
                    }
                }

                overrideGravity() {
                    const e = Y();
                    return this._overriddenGravityRegister.add(e), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), e
                }

                restoreGravity(e) {
                    if (!this._overriddenGravityRegister.has(e)) throw new R("document-selection-gravity-wrong-restore", this, {uid: e});
                    this._overriddenGravityRegister.delete(e), this.isGravityOverridden || this._updateAttributes(!0)
                }

                observeMarkers(e) {
                    this._observedMarkers.add(e), this.updateMarkers()
                }

                _replaceAllRanges(e) {
                    this._validateSelectionRanges(e), super._replaceAllRanges(e)
                }

                _popRange() {
                    this._ranges.pop().detach()
                }

                _pushRange(e) {
                    const t = this._prepareRange(e);
                    t && this._ranges.push(t)
                }

                _validateSelectionRanges(e) {
                    for (const t of e) if (!this._document._validateSelectionRange(t)) throw new R("document-selection-wrong-position", this, {range: t})
                }

                _prepareRange(e) {
                    if (this._checkRange(e), e.root == this._document.graveyard) return;
                    const t = Ii.fromRange(e);
                    return t.on("change:range", (n, i, s) => {
                        if (this._hasChangedRange = !0, t.root == this._document.graveyard) {
                            this._selectionRestorePosition = s.deletionPosition;
                            const l = this._ranges.indexOf(t);
                            this._ranges.splice(l, 1), t.detach()
                        }
                    }), t
                }

                updateMarkers() {
                    if (!this._observedMarkers.size) return;
                    const e = [];
                    let t = !1;
                    for (const i of this._model.markers) {
                        const s = i.name.split(":", 1)[0];
                        if (!this._observedMarkers.has(s)) continue;
                        const l = i.getRange();
                        for (const d of this.getRanges()) l.containsRange(d, !d.isCollapsed) && e.push(i)
                    }
                    const n = Array.from(this.markers);
                    for (const i of e) this.markers.has(i) || (this.markers.add(i), t = !0);
                    for (const i of Array.from(this.markers)) e.includes(i) || (this.markers.remove(i), t = !0);
                    t && this.fire("change:marker", {oldMarkers: n, directChange: !1})
                }

                _updateMarker(e, t) {
                    const n = e.name.split(":", 1)[0];
                    if (!this._observedMarkers.has(n)) return;
                    let i = !1;
                    const s = Array.from(this.markers), l = this.markers.has(e);
                    if (t) {
                        let d = !1;
                        for (const g of this.getRanges()) if (t.containsRange(g, !g.isCollapsed)) {
                            d = !0;
                            break
                        }
                        d && !l ? (this.markers.add(e), i = !0) : !d && l && (this.markers.remove(e), i = !0)
                    } else l && (this.markers.remove(e), i = !0);
                    i && this.fire("change:marker", {oldMarkers: s, directChange: !1})
                }

                _updateAttributes(e) {
                    const t = qi(this._getSurroundingAttributes()), n = qi(this.getAttributes());
                    if (e) this._attributePriority = new Map, this._attrs = new Map; else for (const [s, l] of this._attributePriority) l == "low" && (this._attrs.delete(s), this._attributePriority.delete(s));
                    this._setAttributesTo(t);
                    const i = [];
                    for (const [s, l] of this.getAttributes()) n.has(s) && n.get(s) === l || i.push(s);
                    for (const [s] of n) this.hasAttribute(s) || i.push(s);
                    i.length > 0 && this.fire("change:attribute", {attributeKeys: i, directChange: !1})
                }

                _setAttribute(e, t, n = !0) {
                    const i = n ? "normal" : "low";
                    return i == "low" && this._attributePriority.get(e) == "normal" ? !1 : super.getAttribute(e) !== t && (this._attrs.set(e, t), this._attributePriority.set(e, i), !0)
                }

                _removeAttribute(e, t = !0) {
                    const n = t ? "normal" : "low";
                    return (n != "low" || this._attributePriority.get(e) != "normal") && (this._attributePriority.set(e, n), !!super.hasAttribute(e) && (this._attrs.delete(e), !0))
                }

                _setAttributesTo(e) {
                    const t = new Set;
                    for (const [n, i] of this.getAttributes()) e.get(n) !== i && this._removeAttribute(n, !1);
                    for (const [n, i] of e) this._setAttribute(n, i, !1) && t.add(n);
                    return t
                }

                * getStoredAttributes() {
                    const e = this.getFirstPosition().parent;
                    if (this.isCollapsed && e.isEmpty) for (const t of e.getAttributeKeys()) t.startsWith(Sg) && (yield[t.substr(10), e.getAttribute(t)])
                }

                _getSurroundingAttributes() {
                    const e = this.getFirstPosition(), t = this._model.schema;
                    if (e.root.rootName == "$graveyard") return null;
                    let n = null;
                    if (this.isCollapsed) {
                        const i = e.textNode ? e.textNode : e.nodeBefore, s = e.textNode ? e.textNode : e.nodeAfter;
                        if (this.isGravityOverridden || (n = rh(i, t)), n || (n = rh(s, t)), !this.isGravityOverridden && !n) {
                            let l = i;
                            for (; l && !n;) l = l.previousSibling, n = rh(l, t)
                        }
                        if (!n) {
                            let l = s;
                            for (; l && !n;) l = l.nextSibling, n = rh(l, t)
                        }
                        n || (n = this.getStoredAttributes())
                    } else {
                        const i = this.getFirstRange();
                        for (const s of i) {
                            if (s.item.is("element") && t.isObject(s.item)) {
                                n = rh(s.item, t);
                                break
                            }
                            if (s.type == "text") {
                                n = s.item.getAttributes();
                                break
                            }
                        }
                    }
                    return n
                }

                _fixGraveyardSelection(e) {
                    const t = this._model.schema.getNearestSelectionRange(e);
                    t && this._pushRange(t)
                }
            }

            function rh(r, e) {
                if (!r) return null;
                if (r instanceof wo || r instanceof An) return r.getAttributes();
                if (!e.isInline(r)) return null;
                if (!e.isObject(r)) return [];
                const t = [];
                for (const [n, i] of r.getAttributes()) e.checkAttribute("$text", n) && e.getAttributeProperties(n).copyFromObject !== !1 && t.push([n, i]);
                return t
            }

            class Wv {
                constructor(e) {
                    this._dispatchers = e
                }

                add(e) {
                    for (const t of this._dispatchers) e(t);
                    return this
                }
            }

            class bS extends Wv {
                elementToElement(e) {
                    return this.add(function (t) {
                        const n = Kv(t.model), i = ih(t.view, "container");
                        return n.attributes.length && (n.children = !0), s => {
                            s.on(`insert:${n.name}`, function (l, d = vS) {
                                return (g, v, _) => {
                                    if (!d(v.item, _.consumable, {preflight: !0})) return;
                                    const x = l(v.item, _, v);
                                    if (!x) return;
                                    d(v.item, _.consumable);
                                    const M = _.mapper.toViewPosition(v.range.start);
                                    _.mapper.bindElements(v.item, x), _.writer.insert(M, x), _.convertAttributes(v.item), Xv(x, v.item.getChildren(), _, {reconversion: v.reconversion})
                                }
                            }(i, Jv(n)), {priority: t.converterPriority || "normal"}), (n.children || n.attributes.length) && s.on("reduceChanges", Qv(n), {priority: "low"})
                        }
                    }(e))
                }

                elementToStructure(e) {
                    return this.add(function (t) {
                        const n = Kv(t.model), i = ih(t.view, "container");
                        return n.children = !0, s => {
                            if (s._conversionApi.schema.checkChild(n.name, "$text")) throw new R("conversion-element-to-structure-disallowed-text", s, {elementName: n.name});
                            var l, d;
                            s.on(`insert:${n.name}`, (l = i, d = Jv(n), (g, v, _) => {
                                if (!d(v.item, _.consumable, {preflight: !0})) return;
                                const x = new Map;
                                _.writer._registerSlotFactory(function (j, U, K) {
                                    return (ne, pe) => {
                                        const Se = ne.createContainerElement("$slot");
                                        let Je = null;
                                        if (pe === "children") Je = Array.from(j.getChildren()); else {
                                            if (typeof pe != "function") throw new R("conversion-slot-mode-unknown", K.dispatcher, {modeOrFilter: pe});
                                            Je = Array.from(j.getChildren()).filter(wt => pe(wt))
                                        }
                                        return U.set(Se, Je), Se
                                    }
                                }(v.item, x, _));
                                const M = l(v.item, _, v);
                                if (_.writer._clearSlotFactory(), !M) return;
                                (function (j, U, K) {
                                    const ne = Array.from(U.values()).flat(), pe = new Set(ne);
                                    if (pe.size != ne.length) throw new R("conversion-slot-filter-overlap", K.dispatcher, {element: j});
                                    if (pe.size != j.childCount) throw new R("conversion-slot-filter-incomplete", K.dispatcher, {element: j})
                                })(v.item, x, _), d(v.item, _.consumable);
                                const O = _.mapper.toViewPosition(v.range.start);
                                _.mapper.bindElements(v.item, M), _.writer.insert(O, M), _.convertAttributes(v.item), function (j, U, K, ne) {
                                    K.mapper.on("modelToViewPosition", Je, {priority: "highest"});
                                    let pe = null, Se = null;
                                    for ([pe, Se] of U) Xv(j, Se, K, ne), K.writer.move(K.writer.createRangeIn(pe), K.writer.createPositionBefore(pe)), K.writer.remove(pe);

                                    function Je(wt, qt) {
                                        const Zt = qt.modelPosition.nodeAfter, Jn = Se.indexOf(Zt);
                                        Jn < 0 || (qt.viewPosition = qt.mapper.findPositionIn(pe, Jn))
                                    }

                                    K.mapper.off("modelToViewPosition", Je)
                                }(M, x, _, {reconversion: v.reconversion})
                            }), {priority: t.converterPriority || "normal"}), s.on("reduceChanges", Qv(n), {priority: "low"})
                        }
                    }(e))
                }

                attributeToElement(e) {
                    return this.add(function (t) {
                        t = Sa(t);
                        let n = t.model;
                        typeof n == "string" && (n = {key: n});
                        let i = `attribute:${n.key}`;
                        if (n.name && (i += ":" + n.name), n.values) for (const l of n.values) t.view[l] = ih(t.view[l], "attribute"); else t.view = ih(t.view, "attribute");
                        const s = Zv(t);
                        return l => {
                            l.on(i, function (d) {
                                return (g, v, _) => {
                                    if (!_.consumable.test(v.item, g.name)) return;
                                    const x = d(v.attributeOldValue, _, v), M = d(v.attributeNewValue, _, v);
                                    if (!x && !M) return;
                                    _.consumable.consume(v.item, g.name);
                                    const O = _.writer, j = O.document.selection;
                                    if (v.item instanceof Ti || v.item instanceof Co) O.wrap(j.getFirstRange(), M); else {
                                        let U = _.mapper.toViewRange(v.range);
                                        v.attributeOldValue !== null && x && (U = O.unwrap(U, x)), v.attributeNewValue !== null && M && O.wrap(U, M)
                                    }
                                }
                            }(s), {priority: t.converterPriority || "normal"})
                        }
                    }(e))
                }

                attributeToAttribute(e) {
                    return this.add(function (t) {
                        t = Sa(t);
                        let n = t.model;
                        typeof n == "string" && (n = {key: n});
                        let i = `attribute:${n.key}`;
                        if (n.name && (i += ":" + n.name), n.values) for (const l of n.values) t.view[l] = Yv(t.view[l]); else t.view = Yv(t.view);
                        const s = Zv(t);
                        return l => {
                            var d;
                            l.on(i, (d = s, (g, v, _) => {
                                if (!_.consumable.test(v.item, g.name)) return;
                                const x = d(v.attributeOldValue, _, v), M = d(v.attributeNewValue, _, v);
                                if (!x && !M) return;
                                _.consumable.consume(v.item, g.name);
                                const O = _.mapper.toViewElement(v.item), j = _.writer;
                                if (!O) throw new R("conversion-attribute-to-attribute-on-text", _.dispatcher, v);
                                if (v.attributeOldValue !== null && x) if (x.key == "class") {
                                    const U = qn(x.value);
                                    for (const K of U) j.removeClass(K, O)
                                } else if (x.key == "style") {
                                    const U = Object.keys(x.value);
                                    for (const K of U) j.removeStyle(K, O)
                                } else j.removeAttribute(x.key, O);
                                if (v.attributeNewValue !== null && M) if (M.key == "class") {
                                    const U = qn(M.value);
                                    for (const K of U) j.addClass(K, O)
                                } else if (M.key == "style") {
                                    const U = Object.keys(M.value);
                                    for (const K of U) j.setStyle(K, M.value[K], O)
                                } else j.setAttribute(M.key, M.value, O)
                            }), {priority: t.converterPriority || "normal"})
                        }
                    }(e))
                }

                markerToElement(e) {
                    return this.add(function (t) {
                        const n = ih(t.view, "ui");
                        return i => {
                            var s;
                            i.on(`addMarker:${t.model}`, (s = n, (l, d, g) => {
                                d.isOpening = !0;
                                const v = s(d, g);
                                d.isOpening = !1;
                                const _ = s(d, g);
                                if (!v || !_) return;
                                const x = d.markerRange;
                                if (x.isCollapsed && !g.consumable.consume(x, l.name)) return;
                                for (const j of x) if (!g.consumable.consume(j.item, l.name)) return;
                                const M = g.mapper, O = g.writer;
                                O.insert(M.toViewPosition(x.start), v), g.mapper.bindElementToMarker(v, d.markerName), x.isCollapsed || (O.insert(M.toViewPosition(x.end), _), g.mapper.bindElementToMarker(_, d.markerName)), l.stop()
                            }), {priority: t.converterPriority || "normal"}), i.on(`removeMarker:${t.model}`, (l, d, g) => {
                                const v = g.mapper.markerNameToElements(d.markerName);
                                if (v) {
                                    for (const _ of v) g.mapper.unbindElementFromMarkerName(_, d.markerName), g.writer.clear(g.writer.createRangeOn(_), _);
                                    g.writer.clearClonedElementsGroup(d.markerName), l.stop()
                                }
                            }, {priority: t.converterPriority || "normal"})
                        }
                    }(e))
                }

                markerToHighlight(e) {
                    return this.add(function (t) {
                        return n => {
                            var i;
                            n.on(`addMarker:${t.model}`, (i = t.view, (s, l, d) => {
                                if (!l.item || !(l.item instanceof Ti || l.item instanceof Co || l.item.is("$textProxy"))) return;
                                const g = cb(i, l, d);
                                if (!g || !d.consumable.consume(l.item, s.name)) return;
                                const v = d.writer, _ = $v(v, g), x = v.document.selection;
                                if (l.item instanceof Ti || l.item instanceof Co) v.wrap(x.getFirstRange(), _); else {
                                    const M = d.mapper.toViewRange(l.range), O = v.wrap(M, _);
                                    for (const j of O.getItems()) if (j.is("attributeElement") && j.isSimilar(_)) {
                                        d.mapper.bindElementToMarker(j, l.markerName);
                                        break
                                    }
                                }
                            }), {priority: t.converterPriority || "normal"}), n.on(`addMarker:${t.model}`, function (s) {
                                return (l, d, g) => {
                                    if (!d.item || !(d.item instanceof pn)) return;
                                    const v = cb(s, d, g);
                                    if (!v || !g.consumable.test(d.item, l.name)) return;
                                    const _ = g.mapper.toViewElement(d.item);
                                    if (_ && _.getCustomProperty("addHighlight")) {
                                        g.consumable.consume(d.item, l.name);
                                        for (const x of Ee._createIn(d.item)) g.consumable.consume(x.item, l.name);
                                        _.getCustomProperty("addHighlight")(_, v, g.writer), g.mapper.bindElementToMarker(_, d.markerName)
                                    }
                                }
                            }(t.view), {priority: t.converterPriority || "normal"}), n.on(`removeMarker:${t.model}`, function (s) {
                                return (l, d, g) => {
                                    if (d.markerRange.isCollapsed) return;
                                    const v = cb(s, d, g);
                                    if (!v) return;
                                    const _ = $v(g.writer, v), x = g.mapper.markerNameToElements(d.markerName);
                                    if (x) {
                                        for (const M of x) g.mapper.unbindElementFromMarkerName(M, d.markerName), M.is("attributeElement") ? g.writer.unwrap(g.writer.createRangeOn(M), _) : M.getCustomProperty("removeHighlight")(M, v.id, g.writer);
                                        g.writer.clearClonedElementsGroup(d.markerName), l.stop()
                                    }
                                }
                            }(t.view), {priority: t.converterPriority || "normal"})
                        }
                    }(e))
                }

                markerToData(e) {
                    return this.add(function (t) {
                        t = Sa(t);
                        const n = t.model;
                        let i = t.view;
                        return i || (i = s => ({group: n, name: s.substr(t.model.length + 1)})), s => {
                            var l;
                            s.on(`addMarker:${n}`, (l = i, (d, g, v) => {
                                const _ = l(g.markerName, v);
                                if (!_) return;
                                const x = g.markerRange;
                                v.consumable.consume(x, d.name) && (Gv(x, !1, v, g, _), Gv(x, !0, v, g, _), d.stop())
                            }), {priority: t.converterPriority || "normal"}), s.on(`removeMarker:${n}`, function (d) {
                                return (g, v, _) => {
                                    const x = d(v.markerName, _);
                                    if (!x) return;
                                    const M = _.mapper.markerNameToElements(v.markerName);
                                    if (M) {
                                        for (const j of M) _.mapper.unbindElementFromMarkerName(j, v.markerName), j.is("containerElement") ? (O(`data-${x.group}-start-before`, j), O(`data-${x.group}-start-after`, j), O(`data-${x.group}-end-before`, j), O(`data-${x.group}-end-after`, j)) : _.writer.clear(_.writer.createRangeOn(j), j);
                                        _.writer.clearClonedElementsGroup(v.markerName), g.stop()
                                    }

                                    function O(j, U) {
                                        if (U.hasAttribute(j)) {
                                            const K = new Set(U.getAttribute(j).split(","));
                                            K.delete(x.name), K.size == 0 ? _.writer.removeAttribute(j, U) : _.writer.setAttribute(j, Array.from(K).join(","), U)
                                        }
                                    }
                                }
                            }(i), {priority: t.converterPriority || "normal"})
                        }
                    }(e))
                }
            }

            function $v(r, e) {
                const t = r.createAttributeElement("span", e.attributes);
                return e.classes && t._addClass(e.classes), typeof e.priority == "number" && (t._priority = e.priority), t._id = e.id, t
            }

            function Gv(r, e, t, n, i) {
                const s = e ? r.start : r.end, l = s.nodeAfter && s.nodeAfter.is("element") ? s.nodeAfter : null,
                    d = s.nodeBefore && s.nodeBefore.is("element") ? s.nodeBefore : null;
                if (l || d) {
                    let g, v;
                    e && l || !e && !d ? (g = l, v = !0) : (g = d, v = !1);
                    const _ = t.mapper.toViewElement(g);
                    if (_) return void function (x, M, O, j, U, K) {
                        const ne = `data-${K.group}-${M ? "start" : "end"}-${O ? "before" : "after"}`,
                            pe = x.hasAttribute(ne) ? x.getAttribute(ne).split(",") : [];
                        pe.unshift(K.name), j.writer.setAttribute(ne, pe.join(","), x), j.mapper.bindElementToMarker(x, U.markerName)
                    }(_, e, v, t, n, i)
                }
                (function (g, v, _, x, M) {
                    const O = `${M.group}-${v ? "start" : "end"}`, j = M.name ? {name: M.name} : null,
                        U = _.writer.createUIElement(O, j);
                    _.writer.insert(g, U), _.mapper.bindElementToMarker(U, x.markerName)
                })(t.mapper.toViewPosition(s), e, t, n, i)
            }

            function Kv(r) {
                return typeof r == "string" && (r = {name: r}), {
                    name: r.name,
                    attributes: r.attributes ? qn(r.attributes) : [],
                    children: !!r.children
                }
            }

            function ih(r, e) {
                return typeof r == "function" ? r : (t, n) => function (i, s, l) {
                    typeof i == "string" && (i = {name: i});
                    let d;
                    const g = s.writer, v = Object.assign({}, i.attributes);
                    if (l == "container") d = g.createContainerElement(i.name, v); else if (l == "attribute") {
                        const _ = {priority: i.priority || vo.DEFAULT_PRIORITY};
                        d = g.createAttributeElement(i.name, v, _)
                    } else d = g.createUIElement(i.name, v);
                    if (i.styles) {
                        const _ = Object.keys(i.styles);
                        for (const x of _) g.setStyle(x, i.styles[x], d)
                    }
                    if (i.classes) {
                        const _ = i.classes;
                        if (typeof _ == "string") g.addClass(_, d); else for (const x of _) g.addClass(x, d)
                    }
                    return d
                }(r, n, e)
            }

            function Zv(r) {
                return r.model.values ? (e, t, n) => {
                    const i = r.view[e];
                    return i ? i(e, t, n) : null
                } : r.view
            }

            function Yv(r) {
                return typeof r == "string" ? e => ({
                    key: r,
                    value: e
                }) : typeof r == "object" ? r.value ? () => r : e => ({key: r.key, value: e}) : r
            }

            function cb(r, e, t) {
                const n = typeof r == "function" ? r(e, t) : r;
                return n ? (n.priority || (n.priority = 10), n.id || (n.id = e.markerName), n) : null
            }

            function Qv(r) {
                const e = function (t) {
                    return (n, i) => {
                        if (!n.is("element", t.name)) return !1;
                        if (i.type == "attribute") {
                            if (t.attributes.includes(i.attributeKey)) return !0
                        } else if (t.children) return !0;
                        return !1
                    }
                }(r);
                return (t, n) => {
                    const i = [];
                    n.reconvertedElements || (n.reconvertedElements = new Set);
                    for (const s of n.changes) {
                        const l = s.type == "attribute" ? s.range.start.nodeAfter : s.position.parent;
                        if (l && e(l, s)) {
                            if (!n.reconvertedElements.has(l)) {
                                n.reconvertedElements.add(l);
                                const d = Fe._createBefore(l);
                                let g = i.length;
                                for (let v = i.length - 1; v >= 0; v--) {
                                    const _ = i[v],
                                        x = (_.type == "attribute" ? _.range.start : _.position).compareWith(d);
                                    if (x == "before" || _.type == "remove" && x == "same") break;
                                    g = v
                                }
                                i.splice(g, 0, {
                                    type: "remove",
                                    name: l.name,
                                    position: d,
                                    length: 1
                                }, {type: "reinsert", name: l.name, position: d, length: 1})
                            }
                        } else i.push(s)
                    }
                    n.changes = i
                }
            }

            function Jv(r) {
                return (e, t, n = {}) => {
                    const i = ["insert"];
                    for (const s of r.attributes) e.hasAttribute(s) && i.push(`attribute:${s}`);
                    return !!i.every(s => t.test(e, s)) && (n.preflight || i.forEach(s => t.consume(e, s)), !0)
                }
            }

            function Xv(r, e, t, n) {
                for (const i of e) kS(r.root, i, t, n) || t.convertItem(i)
            }

            function kS(r, e, t, n) {
                const {writer: i, mapper: s} = t;
                if (!n.reconversion) return !1;
                const l = s.toViewElement(e);
                return !(!l || l.root == r) && !!t.canReuseView(l) && (i.move(i.createRangeOn(l), s.toViewPosition(Fe._createBefore(e))), !0)
            }

            function vS(r, e, {preflight: t} = {}) {
                return t ? e.test(r, "insert") : e.consume(r, "insert")
            }

            function ew(r) {
                const {schema: e, document: t} = r.model;
                for (const n of t.getRoots()) if (n.isEmpty && !e.checkChild(n, "$text") && e.checkChild(n, "paragraph")) return r.insertElement("paragraph", n), !0;
                return !1
            }

            function tw(r, e, t) {
                const n = t.createContext(r);
                return !!t.checkChild(n, "paragraph") && !!t.checkChild(n.push("paragraph"), e)
            }

            function nw(r, e) {
                const t = e.createElement("paragraph");
                return e.insert(t, r), e.createPositionAt(t, 0)
            }

            var wS = Object.defineProperty, AS = Object.defineProperties, CS = Object.getOwnPropertyDescriptors,
                rw = Object.getOwnPropertySymbols, _S = Object.prototype.hasOwnProperty,
                yS = Object.prototype.propertyIsEnumerable, iw = (r, e, t) => e in r ? wS(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            class DS extends Wv {
                elementToElement(e) {
                    return this.add(ow(e))
                }

                elementToAttribute(e) {
                    return this.add(function (t) {
                        t = Sa(t), sw(t);
                        const n = aw(t, !1), i = ub(t.view), s = i ? `element:${i}` : "element";
                        return l => {
                            l.on(s, n, {priority: t.converterPriority || "low"})
                        }
                    }(e))
                }

                attributeToAttribute(e) {
                    return this.add(function (t) {
                        t = Sa(t);
                        let n = null;
                        (typeof t.view == "string" || t.view.key) && (n = function (s) {
                            typeof s.view == "string" && (s.view = {key: s.view});
                            const l = s.view.key;
                            let d;
                            return l == "class" || l == "style" ? d = {[l == "class" ? "classes" : "styles"]: s.view.value} : d = {attributes: {[l]: s.view.value === void 0 ? /[\s\S]*/ : s.view.value}}, s.view.name && (d.name = s.view.name), s.view = d, l
                        }(t)), sw(t, n);
                        const i = aw(t, !0);
                        return s => {
                            s.on("element", i, {priority: t.converterPriority || "low"})
                        }
                    }(e))
                }

                elementToMarker(e) {
                    return this.add(function (t) {
                        const n = function (l) {
                            return (d, g) => {
                                const v = typeof l == "string" ? l : l(d, g);
                                return g.writer.createElement("$marker", {"data-name": v})
                            }
                        }(t.model);
                        return ow((i = ((l, d) => {
                            for (var g in d || (d = {})) _S.call(d, g) && iw(l, g, d[g]);
                            if (rw) for (var g of rw(d)) yS.call(d, g) && iw(l, g, d[g]);
                            return l
                        })({}, t), s = {model: n}, AS(i, CS(s))));
                        var i, s
                    }(e))
                }

                dataToMarker(e) {
                    return this.add(function (t) {
                        t = Sa(t), t.model || (t.model = l => l ? t.view + ":" + l : t.view);
                        const n = {view: t.view, model: t.model}, i = db(lw(n, "start")), s = db(lw(n, "end"));
                        return l => {
                            l.on(`element:${t.view}-start`, i, {priority: t.converterPriority || "normal"}), l.on(`element:${t.view}-end`, s, {priority: t.converterPriority || "normal"});
                            const d = ce.low, g = ce.highest, v = ce.get(t.converterPriority) / g;
                            l.on("element", function (_) {
                                return (x, M, O) => {
                                    const j = `data-${_.view}`;

                                    function U(K, ne) {
                                        for (const pe of ne) {
                                            const Se = _.model(pe, O),
                                                Je = O.writer.createElement("$marker", {"data-name": Se});
                                            O.writer.insert(Je, K), M.modelCursor.isEqual(K) ? M.modelCursor = M.modelCursor.getShiftedBy(1) : M.modelCursor = M.modelCursor._getTransformedByInsertion(K, 1), M.modelRange = M.modelRange._getTransformedByInsertion(K, 1)[0]
                                        }
                                    }

                                    (O.consumable.test(M.viewItem, {attributes: j + "-end-after"}) || O.consumable.test(M.viewItem, {attributes: j + "-start-after"}) || O.consumable.test(M.viewItem, {attributes: j + "-end-before"}) || O.consumable.test(M.viewItem, {attributes: j + "-start-before"})) && (M.modelRange || Object.assign(M, O.convertChildren(M.viewItem, M.modelCursor)), O.consumable.consume(M.viewItem, {attributes: j + "-end-after"}) && U(M.modelRange.end, M.viewItem.getAttribute(j + "-end-after").split(",")), O.consumable.consume(M.viewItem, {attributes: j + "-start-after"}) && U(M.modelRange.end, M.viewItem.getAttribute(j + "-start-after").split(",")), O.consumable.consume(M.viewItem, {attributes: j + "-end-before"}) && U(M.modelRange.start, M.viewItem.getAttribute(j + "-end-before").split(",")), O.consumable.consume(M.viewItem, {attributes: j + "-start-before"}) && U(M.modelRange.start, M.viewItem.getAttribute(j + "-start-before").split(",")))
                                }
                            }(n), {priority: d + v})
                        }
                    }(e))
                }
            }

            function ow(r) {
                const e = db(r = Sa(r)), t = ub(r.view), n = t ? `element:${t}` : "element";
                return i => {
                    i.on(n, e, {priority: r.converterPriority || "normal"})
                }
            }

            function ub(r) {
                return typeof r == "string" ? r : typeof r == "object" && typeof r.name == "string" ? r.name : null
            }

            function db(r) {
                const e = new Si(r.view);
                return (t, n, i) => {
                    const s = e.match(n.viewItem);
                    if (!s) return;
                    const l = s.match;
                    if (l.name = !0, !i.consumable.test(n.viewItem, l)) return;
                    const d = function (g, v, _) {
                        return g instanceof Function ? g(v, _) : _.writer.createElement(g)
                    }(r.model, n.viewItem, i);
                    d && i.safeInsert(d, n.modelCursor) && (i.consumable.consume(n.viewItem, l), i.convertChildren(n.viewItem, d), i.updateConversionResult(d, n))
                }
            }

            function sw(r, e = null) {
                const t = e === null || (s => s.getAttribute(e)),
                    n = typeof r.model != "object" ? r.model : r.model.key,
                    i = typeof r.model != "object" || r.model.value === void 0 ? t : r.model.value;
                r.model = {key: n, value: i}
            }

            function aw(r, e) {
                const t = new Si(r.view);
                return (n, i, s) => {
                    if (!i.modelRange && e) return;
                    const l = t.match(i.viewItem);
                    if (!l || (function (_, x) {
                        const M = typeof _ == "function" ? _(x) : _;
                        return typeof M == "object" && !ub(M) ? !1 : !M.classes && !M.attributes && !M.styles
                    }(r.view, i.viewItem) ? l.match.name = !0 : delete l.match.name, !s.consumable.test(i.viewItem, l.match))) return;
                    const d = r.model.key,
                        g = typeof r.model.value == "function" ? r.model.value(i.viewItem, s) : r.model.value;
                    if (g === null) return;
                    i.modelRange || Object.assign(i, s.convertChildren(i.viewItem, i.modelCursor)), function (_, x, M, O) {
                        let j = !1;
                        for (const U of Array.from(_.getItems({shallow: M}))) O.schema.checkAttribute(U, x.key) && (j = !0, U.hasAttribute(x.key) || O.writer.setAttribute(x.key, x.value, U));
                        return j
                    }(i.modelRange, {
                        key: d,
                        value: g
                    }, e, s) && (s.consumable.test(i.viewItem, {name: !0}) && (l.match.name = !0), s.consumable.consume(i.viewItem, l.match))
                }
            }

            function lw(r, e) {
                return {
                    view: `${r.view}-${e}`, model: (t, n) => {
                        const i = t.getAttribute("name"), s = r.model(i, n);
                        return n.writer.createElement("$marker", {"data-name": s})
                    }
                }
            }

            function xS(r) {
                r.document.registerPostFixer(e => function (t, n) {
                    const i = n.document.selection, s = n.schema, l = [];
                    let d = !1;
                    for (const g of i.getRanges()) {
                        const v = cw(g, s);
                        v && !v.isEqual(g) ? (l.push(v), d = !0) : l.push(g)
                    }
                    return d && t.setSelection(function (g) {
                        const v = [...g], _ = new Set;
                        let x = 1;
                        for (; x < v.length;) {
                            const M = v[x], O = v.slice(0, x);
                            for (const [j, U] of O.entries()) if (!_.has(j)) {
                                if (M.isEqual(U)) _.add(j); else if (M.isIntersecting(U)) {
                                    _.add(j), _.add(x);
                                    const K = M.getJoined(U);
                                    v.push(K)
                                }
                            }
                            x++
                        }
                        return v.filter((M, O) => !_.has(O))
                    }(l), {backward: i.isBackward}), !1
                }(e, r))
            }

            function cw(r, e) {
                return r.isCollapsed ? function (t, n) {
                    const i = t.start, s = n.getNearestSelectionRange(i);
                    if (!s) {
                        const d = i.getAncestors().reverse().find(g => n.isObject(g));
                        return d ? Ee._createOn(d) : null
                    }
                    if (!s.isCollapsed) return s;
                    const l = s.start;
                    return i.isEqual(l) ? null : new Ee(l)
                }(r, e) : function (t, n) {
                    const {start: i, end: s} = t, l = n.checkChild(i, "$text"), d = n.checkChild(s, "$text"),
                        g = n.getLimitElement(i), v = n.getLimitElement(s);
                    if (g === v) {
                        if (l && d) return null;
                        if (function (M, O, j) {
                            const U = M.nodeAfter && !j.isLimit(M.nodeAfter) || j.checkChild(M, "$text"),
                                K = O.nodeBefore && !j.isLimit(O.nodeBefore) || j.checkChild(O, "$text");
                            return U || K
                        }(i, s, n)) {
                            const M = i.nodeAfter && n.isSelectable(i.nodeAfter) ? null : n.getNearestSelectionRange(i, "forward"),
                                O = s.nodeBefore && n.isSelectable(s.nodeBefore) ? null : n.getNearestSelectionRange(s, "backward"),
                                j = M ? M.start : i, U = O ? O.end : s;
                            return new Ee(j, U)
                        }
                    }
                    const _ = g && !g.is("rootElement"), x = v && !v.is("rootElement");
                    if (_ || x) {
                        const M = i.nodeAfter && s.nodeBefore && i.nodeAfter.parent === s.nodeBefore.parent,
                            O = _ && (!M || !dw(i.nodeAfter, n)), j = x && (!M || !dw(s.nodeBefore, n));
                        let U = i, K = s;
                        return O && (U = Fe._createBefore(uw(g, n))), j && (K = Fe._createAfter(uw(v, n))), new Ee(U, K)
                    }
                    return null
                }(r, e)
            }

            function uw(r, e) {
                let t = r, n = t;
                for (; e.isLimit(n) && n.parent;) t = n, n = n.parent;
                return t
            }

            function dw(r, e) {
                return r && e.isSelectable(r)
            }

            class ES extends we() {
                constructor(e, t) {
                    super(), this.model = e, this.view = new rS(t), this.mapper = new Fv, this.downcastDispatcher = new Vv({
                        mapper: this.mapper,
                        schema: e.schema
                    });
                    const n = this.model.document, i = n.selection, s = this.model.markers;
                    var l, d, g;
                    this.listenTo(this.model, "_beforeChanges", () => {
                        this.view._disableRendering(!0)
                    }, {priority: "highest"}), this.listenTo(this.model, "_afterChanges", () => {
                        this.view._disableRendering(!1)
                    }, {priority: "lowest"}), this.listenTo(n, "change", () => {
                        this.view.change(v => {
                            this.downcastDispatcher.convertChanges(n.differ, s, v), this.downcastDispatcher.convertSelection(i, s, v)
                        })
                    }, {priority: "low"}), this.listenTo(this.view.document, "selectionChange", function (v, _) {
                        return (x, M) => {
                            const O = M.newSelection, j = [];
                            for (const K of O.getRanges()) j.push(_.toModelRange(K));
                            const U = v.createSelection(j, {backward: O.isBackward});
                            U.isEqual(v.document.selection) || v.change(K => {
                                K.setSelection(U)
                            })
                        }
                    }(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", (l = this.mapper, d = this.model.schema, g = this.view, (v, _) => {
                        if (!g.document.isComposing || T.isAndroid) for (let x = 0; x < _.targetRanges.length; x++) {
                            const M = _.targetRanges[x], O = l.toModelRange(M), j = cw(O, d);
                            j && !j.isEqual(O) && (_.targetRanges[x] = l.toViewRange(j))
                        }
                    }), {priority: "high"}), this.downcastDispatcher.on("insert:$text", (v, _, x) => {
                        if (!x.consumable.consume(_.item, v.name)) return;
                        const M = x.writer, O = x.mapper.toViewPosition(_.range.start), j = M.createText(_.item.data);
                        M.insert(O, j)
                    }, {priority: "lowest"}), this.downcastDispatcher.on("insert", (v, _, x) => {
                        x.convertAttributes(_.item), _.reconversion || !_.item.is("element") || _.item.isEmpty || x.convertChildren(_.item)
                    }, {priority: "lowest"}), this.downcastDispatcher.on("remove", (v, _, x) => {
                        const M = x.mapper.toViewPosition(_.position), O = _.position.getShiftedBy(_.length),
                            j = x.mapper.toViewPosition(O, {isPhantom: !0}), U = x.writer.createRange(M, j),
                            K = x.writer.remove(U.getTrimmed());
                        for (const ne of x.writer.createRangeIn(K).getItems()) x.mapper.unbindViewElement(ne, {defer: !0})
                    }, {priority: "low"}), this.downcastDispatcher.on("cleanSelection", (v, _, x) => {
                        const M = x.writer, O = M.document.selection;
                        for (const j of O.getRanges()) j.isCollapsed && j.end.parent.isAttached() && x.writer.mergeAttributes(j.start);
                        M.setSelection(null)
                    }), this.downcastDispatcher.on("selection", (v, _, x) => {
                        const M = _.selection;
                        if (M.isCollapsed || !x.consumable.consume(M, "selection")) return;
                        const O = [];
                        for (const j of M.getRanges()) O.push(x.mapper.toViewRange(j));
                        x.writer.setSelection(O, {backward: M.isBackward})
                    }, {priority: "low"}), this.downcastDispatcher.on("selection", (v, _, x) => {
                        const M = _.selection;
                        if (!M.isCollapsed || !x.consumable.consume(M, "selection")) return;
                        const O = x.writer, j = M.getFirstPosition(), U = x.mapper.toViewPosition(j),
                            K = O.breakAttributes(U);
                        O.setSelection(K)
                    }, {priority: "low"}), this.view.document.roots.bindTo(this.model.document.roots).using(v => {
                        if (v.rootName == "$graveyard") return null;
                        const _ = new $d(this.view.document, v.name);
                        return _.rootName = v.rootName, this.mapper.bindElements(v, _), _
                    })
                }

                destroy() {
                    this.view.destroy(), this.stopListening()
                }

                reconvertMarker(e) {
                    const t = typeof e == "string" ? e : e.name, n = this.model.markers.get(t);
                    if (!n) throw new R("editingcontroller-reconvertmarker-marker-not-exist", this, {markerName: t});
                    this.model.change(() => {
                        this.model.markers._refresh(n)
                    })
                }

                reconvertItem(e) {
                    this.model.change(() => {
                        this.model.document.differ._refreshItem(e)
                    })
                }
            }

            class oh {
                constructor() {
                    this._consumables = new Map
                }

                add(e, t) {
                    let n;
                    e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : (this._consumables.has(e) ? n = this._consumables.get(e) : (n = new SS(e), this._consumables.set(e, n)), n.add(t))
                }

                test(e, t) {
                    const n = this._consumables.get(e);
                    return n === void 0 ? null : e.is("$text") || e.is("documentFragment") ? n : n.test(t)
                }

                consume(e, t) {
                    return !!this.test(e, t) && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !1) : this._consumables.get(e).consume(t), !0)
                }

                revert(e, t) {
                    const n = this._consumables.get(e);
                    n !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : n.revert(t))
                }

                static consumablesFromElement(e) {
                    const t = {element: e, name: !0, attributes: [], classes: [], styles: []}, n = e.getAttributeKeys();
                    for (const l of n) l != "style" && l != "class" && t.attributes.push(l);
                    const i = e.getClassNames();
                    for (const l of i) t.classes.push(l);
                    const s = e.getStyleNames();
                    for (const l of s) t.styles.push(l);
                    return t
                }

                static createFrom(e, t) {
                    if (t || (t = new oh), e.is("$text")) return t.add(e), t;
                    e.is("element") && t.add(e, oh.consumablesFromElement(e)), e.is("documentFragment") && t.add(e);
                    for (const n of e.getChildren()) t = oh.createFrom(n, t);
                    return t
                }
            }

            const Tg = ["attributes", "classes", "styles"];

            class SS {
                constructor(e) {
                    this.element = e, this._canConsumeName = null, this._consumables = {
                        attributes: new Map,
                        styles: new Map,
                        classes: new Map
                    }
                }

                add(e) {
                    e.name && (this._canConsumeName = !0);
                    for (const t of Tg) t in e && this._add(t, e[t])
                }

                test(e) {
                    if (e.name && !this._canConsumeName) return this._canConsumeName;
                    for (const t of Tg) if (t in e) {
                        const n = this._test(t, e[t]);
                        if (n !== !0) return n
                    }
                    return !0
                }

                consume(e) {
                    e.name && (this._canConsumeName = !1);
                    for (const t of Tg) t in e && this._consume(t, e[t])
                }

                revert(e) {
                    e.name && (this._canConsumeName = !0);
                    for (const t of Tg) t in e && this._revert(t, e[t])
                }

                _add(e, t) {
                    const n = ot(t) ? t : [t], i = this._consumables[e];
                    for (const s of n) {
                        if (e === "attributes" && (s === "class" || s === "style")) throw new R("viewconsumable-invalid-attribute", this);
                        if (i.set(s, !0), e === "styles") for (const l of this.element.document.stylesProcessor.getRelatedStyles(s)) i.set(l, !0)
                    }
                }

                _test(e, t) {
                    const n = ot(t) ? t : [t], i = this._consumables[e];
                    for (const s of n) if (e !== "attributes" || s !== "class" && s !== "style") {
                        const l = i.get(s);
                        if (l === void 0) return null;
                        if (!l) return !1
                    } else {
                        const l = s == "class" ? "classes" : "styles",
                            d = this._test(l, [...this._consumables[l].keys()]);
                        if (d !== !0) return d
                    }
                    return !0
                }

                _consume(e, t) {
                    const n = ot(t) ? t : [t], i = this._consumables[e];
                    for (const s of n) if (e !== "attributes" || s !== "class" && s !== "style") {
                        if (i.set(s, !1), e == "styles") for (const l of this.element.document.stylesProcessor.getRelatedStyles(s)) i.set(l, !1)
                    } else {
                        const l = s == "class" ? "classes" : "styles";
                        this._consume(l, [...this._consumables[l].keys()])
                    }
                }

                _revert(e, t) {
                    const n = ot(t) ? t : [t], i = this._consumables[e];
                    for (const s of n) if (e !== "attributes" || s !== "class" && s !== "style") i.get(s) === !1 && i.set(s, !0); else {
                        const l = s == "class" ? "classes" : "styles";
                        this._revert(l, [...this._consumables[l].keys()])
                    }
                }
            }

            class TS extends we() {
                constructor() {
                    super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e, t) => {
                        t[0] = new ql(t[0])
                    }, {priority: "highest"}), this.on("checkChild", (e, t) => {
                        t[0] = new ql(t[0]), t[1] = this.getDefinition(t[1])
                    }, {priority: "highest"})
                }

                register(e, t) {
                    if (this._sourceDefinitions[e]) throw new R("schema-cannot-register-item-twice", this, {itemName: e});
                    this._sourceDefinitions[e] = [Object.assign({}, t)], this._clearCache()
                }

                extend(e, t) {
                    if (!this._sourceDefinitions[e]) throw new R("schema-cannot-extend-missing-item", this, {itemName: e});
                    this._sourceDefinitions[e].push(Object.assign({}, t)), this._clearCache()
                }

                getDefinitions() {
                    return this._compiledDefinitions || this._compile(), this._compiledDefinitions
                }

                getDefinition(e) {
                    let t;
                    return t = typeof e == "string" ? e : "is" in e && (e.is("$text") || e.is("$textProxy")) ? "$text" : e.name, this.getDefinitions()[t]
                }

                isRegistered(e) {
                    return !!this.getDefinition(e)
                }

                isBlock(e) {
                    const t = this.getDefinition(e);
                    return !(!t || !t.isBlock)
                }

                isLimit(e) {
                    const t = this.getDefinition(e);
                    return !!t && !(!t.isLimit && !t.isObject)
                }

                isObject(e) {
                    const t = this.getDefinition(e);
                    return !!t && !!(t.isObject || t.isLimit && t.isSelectable && t.isContent)
                }

                isInline(e) {
                    const t = this.getDefinition(e);
                    return !(!t || !t.isInline)
                }

                isSelectable(e) {
                    const t = this.getDefinition(e);
                    return !!t && !(!t.isSelectable && !t.isObject)
                }

                isContent(e) {
                    const t = this.getDefinition(e);
                    return !!t && !(!t.isContent && !t.isObject)
                }

                checkChild(e, t) {
                    return !!t && this._checkContextMatch(t, e)
                }

                checkAttribute(e, t) {
                    const n = this.getDefinition(e.last);
                    return !!n && n.allowAttributes.includes(t)
                }

                checkMerge(e, t) {
                    if (e instanceof Fe) {
                        const n = e.nodeBefore, i = e.nodeAfter;
                        if (!(n instanceof pn)) throw new R("schema-check-merge-no-element-before", this);
                        if (!(i instanceof pn)) throw new R("schema-check-merge-no-element-after", this);
                        return this.checkMerge(n, i)
                    }
                    for (const n of t.getChildren()) if (!this.checkChild(e, n)) return !1;
                    return !0
                }

                addChildCheck(e) {
                    this.on("checkChild", (t, [n, i]) => {
                        if (!i) return;
                        const s = e(n, i);
                        typeof s == "boolean" && (t.stop(), t.return = s)
                    }, {priority: "high"})
                }

                addAttributeCheck(e) {
                    this.on("checkAttribute", (t, [n, i]) => {
                        const s = e(n, i);
                        typeof s == "boolean" && (t.stop(), t.return = s)
                    }, {priority: "high"})
                }

                setAttributeProperties(e, t) {
                    this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t)
                }

                getAttributeProperties(e) {
                    return this._attributeProperties[e] || {}
                }

                getLimitElement(e) {
                    let t;
                    for (e instanceof Fe ? t = e.parent : t = (e instanceof Ee ? [e] : Array.from(e.getRanges())).reduce((n, i) => {
                        const s = i.getCommonAncestor();
                        return n ? n.getCommonAncestor(s, {includeSelf: !0}) : s
                    }, null); !this.isLimit(t) && t.parent;) t = t.parent;
                    return t
                }

                checkAttributeInSelection(e, t) {
                    if (e.isCollapsed) {
                        const n = [...e.getFirstPosition().getAncestors(), new An("", e.getAttributes())];
                        return this.checkAttribute(n, t)
                    }
                    {
                        const n = e.getRanges();
                        for (const i of n) for (const s of i) if (this.checkAttribute(s.item, t)) return !0
                    }
                    return !1
                }

                * getValidRanges(e, t) {
                    e = function* (n) {
                        for (const i of n) yield* i.getMinimalFlatRanges()
                    }(e);
                    for (const n of e) yield* this._getValidRangesForRange(n, t)
                }

                getNearestSelectionRange(e, t = "both") {
                    if (e.root.rootName == "$graveyard") return null;
                    if (this.checkChild(e, "$text")) return new Ee(e);
                    let n, i;
                    const s = e.getAncestors().reverse().find(l => this.isLimit(l)) || e.root;
                    t != "both" && t != "backward" || (n = new Ao({
                        boundaries: Ee._createIn(s),
                        startPosition: e,
                        direction: "backward"
                    })), t != "both" && t != "forward" || (i = new Ao({boundaries: Ee._createIn(s), startPosition: e}));
                    for (const l of function* (d, g) {
                        let v = !1;
                        for (; !v;) {
                            if (v = !0, d) {
                                const _ = d.next();
                                _.done || (v = !1, yield{walker: d, value: _.value})
                            }
                            if (g) {
                                const _ = g.next();
                                _.done || (v = !1, yield{walker: g, value: _.value})
                            }
                        }
                    }(n, i)) {
                        const d = l.walker == n ? "elementEnd" : "elementStart", g = l.value;
                        if (g.type == d && this.isObject(g.item)) return Ee._createOn(g.item);
                        if (this.checkChild(g.nextPosition, "$text")) return new Ee(g.nextPosition)
                    }
                    return null
                }

                findAllowedParent(e, t) {
                    let n = e.parent;
                    for (; n;) {
                        if (this.checkChild(n, t)) return n;
                        if (this.isLimit(n)) return null;
                        n = n.parent
                    }
                    return null
                }

                setAllowedAttributes(e, t, n) {
                    const i = n.model;
                    for (const [s, l] of Object.entries(t)) i.schema.checkAttribute(e, s) && n.setAttribute(s, l, e)
                }

                removeDisallowedAttributes(e, t) {
                    for (const n of e) if (n.is("$text")) hw(this, n, t); else {
                        const i = Ee._createIn(n).getPositions();
                        for (const s of i) hw(this, s.nodeBefore || s.parent, t)
                    }
                }

                getAttributesWithProperty(e, t, n) {
                    const i = {};
                    for (const [s, l] of e.getAttributes()) {
                        const d = this.getAttributeProperties(s);
                        d[t] !== void 0 && (n !== void 0 && n !== d[t] || (i[s] = l))
                    }
                    return i
                }

                createContext(e) {
                    return new ql(e)
                }

                _clearCache() {
                    this._compiledDefinitions = null
                }

                _compile() {
                    const e = {}, t = this._sourceDefinitions, n = Object.keys(t);
                    for (const i of n) e[i] = IS(t[i], i);
                    for (const i of n) MS(e, i);
                    for (const i of n) BS(e, i);
                    for (const i of n) NS(e, i);
                    for (const i of n) LS(e, i), PS(e, i);
                    for (const i of n) OS(e, i), FS(e, i), RS(e, i);
                    this._compiledDefinitions = e
                }

                _checkContextMatch(e, t, n = t.length - 1) {
                    const i = t.getItem(n);
                    if (e.allowIn.includes(i.name)) {
                        if (n == 0) return !0;
                        {
                            const s = this.getDefinition(i);
                            return this._checkContextMatch(s, t, n - 1)
                        }
                    }
                    return !1
                }

                * _getValidRangesForRange(e, t) {
                    let n = e.start, i = e.start;
                    for (const s of e.getItems({shallow: !0})) s.is("element") && (yield* this._getValidRangesForRange(Ee._createIn(s), t)), this.checkAttribute(s, t) || (n.isEqual(i) || (yield new Ee(n, i)), n = Fe._createAfter(s)), i = Fe._createAfter(s);
                    n.isEqual(i) || (yield new Ee(n, i))
                }
            }

            class ql {
                constructor(e) {
                    if (e instanceof ql) return e;
                    let t;
                    t = typeof e == "string" ? [e] : Array.isArray(e) ? e : e.getAncestors({includeSelf: !0}), this._items = t.map(jS)
                }

                get length() {
                    return this._items.length
                }

                get last() {
                    return this._items[this._items.length - 1]
                }

                [Symbol.iterator]() {
                    return this._items[Symbol.iterator]()
                }

                push(e) {
                    const t = new ql([e]);
                    return t._items = [...this._items, ...t._items], t
                }

                getItem(e) {
                    return this._items[e]
                }

                * getNames() {
                    yield* this._items.map(e => e.name)
                }

                endsWith(e) {
                    return Array.from(this.getNames()).join(" ").endsWith(e)
                }

                startsWith(e) {
                    return Array.from(this.getNames()).join(" ").startsWith(e)
                }
            }

            function IS(r, e) {
                const t = {
                    name: e,
                    allowIn: [],
                    allowContentOf: [],
                    allowWhere: [],
                    allowAttributes: [],
                    allowAttributesOf: [],
                    allowChildren: [],
                    inheritTypesFrom: []
                };
                return function (n, i) {
                    for (const s of n) {
                        const l = Object.keys(s).filter(d => d.startsWith("is"));
                        for (const d of l) i[d] = !!s[d]
                    }
                }(r, t), Wl(r, t, "allowIn"), Wl(r, t, "allowContentOf"), Wl(r, t, "allowWhere"), Wl(r, t, "allowAttributes"), Wl(r, t, "allowAttributesOf"), Wl(r, t, "allowChildren"), Wl(r, t, "inheritTypesFrom"), function (n, i) {
                    for (const s of n) {
                        const l = s.inheritAllFrom;
                        l && (i.allowContentOf.push(l), i.allowWhere.push(l), i.allowAttributesOf.push(l), i.inheritTypesFrom.push(l))
                    }
                }(r, t), t
            }

            function MS(r, e) {
                const t = r[e];
                for (const n of t.allowChildren) {
                    const i = r[n];
                    i && i.allowIn.push(e)
                }
                t.allowChildren.length = 0
            }

            function BS(r, e) {
                for (const t of r[e].allowContentOf) r[t] && zS(r, t).forEach(n => {
                    n.allowIn.push(e)
                });
                delete r[e].allowContentOf
            }

            function NS(r, e) {
                for (const t of r[e].allowWhere) {
                    const n = r[t];
                    if (n) {
                        const i = n.allowIn;
                        r[e].allowIn.push(...i)
                    }
                }
                delete r[e].allowWhere
            }

            function LS(r, e) {
                for (const t of r[e].allowAttributesOf) {
                    const n = r[t];
                    if (n) {
                        const i = n.allowAttributes;
                        r[e].allowAttributes.push(...i)
                    }
                }
                delete r[e].allowAttributesOf
            }

            function PS(r, e) {
                const t = r[e];
                for (const n of t.inheritTypesFrom) {
                    const i = r[n];
                    if (i) {
                        const s = Object.keys(i).filter(l => l.startsWith("is"));
                        for (const l of s) l in t || (t[l] = i[l])
                    }
                }
                delete t.inheritTypesFrom
            }

            function OS(r, e) {
                const t = r[e], n = t.allowIn.filter(i => r[i]);
                t.allowIn = Array.from(new Set(n))
            }

            function FS(r, e) {
                const t = r[e];
                for (const n of t.allowIn) r[n].allowChildren.push(e)
            }

            function RS(r, e) {
                const t = r[e];
                t.allowAttributes = Array.from(new Set(t.allowAttributes))
            }

            function Wl(r, e, t) {
                for (const n of r) {
                    const i = n[t];
                    typeof i == "string" ? e[t].push(i) : Array.isArray(i) && e[t].push(...i)
                }
            }

            function zS(r, e) {
                const t = r[e];
                return (n = r, Object.keys(n).map(i => n[i])).filter(i => i.allowIn.includes(t.name));
                var n
            }

            function jS(r) {
                return typeof r == "string" || r.is("documentFragment") ? {
                    name: typeof r == "string" ? r : "$documentFragment",
                    * getAttributeKeys() {
                    },
                    getAttribute() {
                    }
                } : {
                    name: r.is("element") ? r.name : "$text", * getAttributeKeys() {
                        yield* r.getAttributeKeys()
                    }, getAttribute: e => r.getAttribute(e)
                }
            }

            function hw(r, e, t) {
                for (const n of e.getAttributeKeys()) r.checkAttribute(e, n) || t.removeAttribute(n, e)
            }

            var VS = Object.defineProperty, HS = Object.defineProperties, US = Object.getOwnPropertyDescriptors,
                fw = Object.getOwnPropertySymbols, qS = Object.prototype.hasOwnProperty,
                WS = Object.prototype.propertyIsEnumerable, gw = (r, e, t) => e in r ? VS(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            class $S extends Le() {
                constructor(e) {
                    var t;
                    super(), this._splitParts = new Map, this._cursorParents = new Map, this._modelCursor = null, this._emptyElementsToKeep = new Set, this.conversionApi = (t = ((n, i) => {
                        for (var s in i || (i = {})) qS.call(i, s) && gw(n, s, i[s]);
                        if (fw) for (var s of fw(i)) WS.call(i, s) && gw(n, s, i[s]);
                        return n
                    })({}, e), HS(t, US({
                        consumable: null,
                        writer: null,
                        store: null,
                        convertItem: (n, i) => this._convertItem(n, i),
                        convertChildren: (n, i) => this._convertChildren(n, i),
                        safeInsert: (n, i) => this._safeInsert(n, i),
                        updateConversionResult: (n, i) => this._updateConversionResult(n, i),
                        splitToAllowedParent: (n, i) => this._splitToAllowedParent(n, i),
                        getSplitParts: n => this._getSplitParts(n),
                        keepEmptyElement: n => this._keepEmptyElement(n)
                    })))
                }

                convert(e, t, n = ["$root"]) {
                    this.fire("viewCleanup", e), this._modelCursor = function (l, d) {
                        let g;
                        for (const v of new ql(l)) {
                            const _ = {};
                            for (const M of v.getAttributeKeys()) _[M] = v.getAttribute(M);
                            const x = d.createElement(v.name, _);
                            g && d.insert(x, g), g = Fe._createAt(x, 0)
                        }
                        return g
                    }(n, t), this.conversionApi.writer = t, this.conversionApi.consumable = oh.createFrom(e), this.conversionApi.store = {};
                    const {modelRange: i} = this._convertItem(e, this._modelCursor), s = t.createDocumentFragment();
                    if (i) {
                        this._removeEmptyElements();
                        for (const l of Array.from(this._modelCursor.parent.getChildren())) t.append(l, s);
                        s.markers = function (l, d) {
                            const g = new Set, v = new Map, _ = Ee._createIn(l).getItems();
                            for (const x of _) x.is("element", "$marker") && g.add(x);
                            for (const x of g) {
                                const M = x.getAttribute("data-name"), O = d.createPositionBefore(x);
                                v.has(M) ? v.get(M).end = O.clone() : v.set(M, new Ee(O.clone())), d.remove(x)
                            }
                            return v
                        }(s, t)
                    }
                    return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, s
                }

                _convertItem(e, t) {
                    const n = {viewItem: e, modelCursor: t, modelRange: null};
                    if (e.is("element") ? this.fire(`element:${e.name}`, n, this.conversionApi) : e.is("$text") ? this.fire("text", n, this.conversionApi) : this.fire("documentFragment", n, this.conversionApi), n.modelRange && !(n.modelRange instanceof Ee)) throw new R("view-conversion-dispatcher-incorrect-result", this);
                    return {modelRange: n.modelRange, modelCursor: n.modelCursor}
                }

                _convertChildren(e, t) {
                    let n = t.is("position") ? t : Fe._createAt(t, 0);
                    const i = new Ee(n);
                    for (const s of Array.from(e.getChildren())) {
                        const l = this._convertItem(s, n);
                        l.modelRange instanceof Ee && (i.end = l.modelRange.end, n = l.modelCursor)
                    }
                    return {modelRange: i, modelCursor: n}
                }

                _safeInsert(e, t) {
                    const n = this._splitToAllowedParent(e, t);
                    return !!n && (this.conversionApi.writer.insert(e, n.position), !0)
                }

                _updateConversionResult(e, t) {
                    const n = this._getSplitParts(e), i = this.conversionApi.writer;
                    t.modelRange || (t.modelRange = i.createRange(i.createPositionBefore(e), i.createPositionAfter(n[n.length - 1])));
                    const s = this._cursorParents.get(e);
                    t.modelCursor = s ? i.createPositionAt(s, 0) : t.modelRange.end
                }

                _splitToAllowedParent(e, t) {
                    const {schema: n, writer: i} = this.conversionApi;
                    let s = n.findAllowedParent(t, e);
                    if (s) {
                        if (s === t.parent) return {position: t};
                        this._modelCursor.parent.getAncestors().includes(s) && (s = null)
                    }
                    if (!s) return tw(t, e, n) ? {position: nw(t, i)} : null;
                    const l = this.conversionApi.writer.split(t, s), d = [];
                    for (const v of l.range.getWalker()) if (v.type == "elementEnd") d.push(v.item); else {
                        const _ = d.pop(), x = v.item;
                        this._registerSplitPair(_, x)
                    }
                    const g = l.range.end.parent;
                    return this._cursorParents.set(e, g), {position: l.position, cursorParent: g}
                }

                _registerSplitPair(e, t) {
                    this._splitParts.has(e) || this._splitParts.set(e, [e]);
                    const n = this._splitParts.get(e);
                    this._splitParts.set(t, n), n.push(t)
                }

                _getSplitParts(e) {
                    let t;
                    return t = this._splitParts.has(e) ? this._splitParts.get(e) : [e], t
                }

                _keepEmptyElement(e) {
                    this._emptyElementsToKeep.add(e)
                }

                _removeEmptyElements() {
                    let e = !1;
                    for (const t of this._splitParts.keys()) t.isEmpty && !this._emptyElementsToKeep.has(t) && (this.conversionApi.writer.remove(t), this._splitParts.delete(t), e = !0);
                    e && this._removeEmptyElements()
                }
            }

            class GS {
                getHtml(e) {
                    const t = bt.document.implementation.createHTMLDocument("").createElement("div");
                    return t.appendChild(e), t.innerHTML
                }
            }

            class KS {
                constructor(e) {
                    this.skipComments = !0, this.domParser = new DOMParser, this.domConverter = new Mt(e, {renderingMode: "data"}), this.htmlWriter = new GS
                }

                toData(e) {
                    const t = this.domConverter.viewToDom(e);
                    return this.htmlWriter.getHtml(t)
                }

                toView(e) {
                    const t = this._toDom(e);
                    return this.domConverter.domToView(t, {skipComments: this.skipComments})
                }

                registerRawContentMatcher(e) {
                    this.domConverter.registerRawContentMatcher(e)
                }

                useFillerType(e) {
                    this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp"
                }

                _toDom(e) {
                    e.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (e = `<body>${e}</body>`);
                    const t = this.domParser.parseFromString(e, "text/html"), n = t.createDocumentFragment(),
                        i = t.body.childNodes;
                    for (; i.length > 0;) n.appendChild(i[0]);
                    return n
                }
            }

            class ZS extends Le() {
                constructor(e, t) {
                    super(), this.model = e, this.mapper = new Fv, this.downcastDispatcher = new Vv({
                        mapper: this.mapper,
                        schema: e.schema
                    }), this.downcastDispatcher.on("insert:$text", (n, i, s) => {
                        if (!s.consumable.consume(i.item, n.name)) return;
                        const l = s.writer, d = s.mapper.toViewPosition(i.range.start), g = l.createText(i.item.data);
                        l.insert(d, g)
                    }, {priority: "lowest"}), this.downcastDispatcher.on("insert", (n, i, s) => {
                        s.convertAttributes(i.item), i.reconversion || !i.item.is("element") || i.item.isEmpty || s.convertChildren(i.item)
                    }, {priority: "lowest"}), this.upcastDispatcher = new $S({schema: e.schema}), this.viewDocument = new Ss(t), this.stylesProcessor = t, this.htmlProcessor = new KS(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new Cg(this.viewDocument), this.upcastDispatcher.on("text", (n, i, {
                        schema: s,
                        consumable: l,
                        writer: d
                    }) => {
                        let g = i.modelCursor;
                        if (!l.test(i.viewItem)) return;
                        if (!s.checkChild(g, "$text")) {
                            if (!tw(g, "$text", s) || i.viewItem.data.trim().length == 0) return;
                            const _ = g.nodeBefore;
                            g = nw(g, d), _ && _.is("element", "$marker") && (d.move(d.createRangeOn(_), g), g = d.createPositionAfter(_))
                        }
                        l.consume(i.viewItem);
                        const v = d.createText(i.viewItem.data);
                        d.insert(v, g), i.modelRange = d.createRange(g, g.getShiftedBy(v.offsetSize)), i.modelCursor = i.modelRange.end
                    }, {priority: "lowest"}), this.upcastDispatcher.on("element", (n, i, s) => {
                        if (!i.modelRange && s.consumable.consume(i.viewItem, {name: !0})) {
                            const {modelRange: l, modelCursor: d} = s.convertChildren(i.viewItem, i.modelCursor);
                            i.modelRange = l, i.modelCursor = d
                        }
                    }, {priority: "lowest"}), this.upcastDispatcher.on("documentFragment", (n, i, s) => {
                        if (!i.modelRange && s.consumable.consume(i.viewItem, {name: !0})) {
                            const {modelRange: l, modelCursor: d} = s.convertChildren(i.viewItem, i.modelCursor);
                            i.modelRange = l, i.modelCursor = d
                        }
                    }, {priority: "lowest"}), we().prototype.decorate.call(this, "init"), we().prototype.decorate.call(this, "set"), we().prototype.decorate.call(this, "get"), we().prototype.decorate.call(this, "toView"), we().prototype.decorate.call(this, "toModel"), this.on("init", () => {
                        this.fire("ready")
                    }, {priority: "lowest"}), this.on("ready", () => {
                        this.model.enqueueChange({isUndoable: !1}, ew)
                    }, {priority: "lowest"})
                }

                get(e = {}) {
                    const {rootName: t = "main", trim: n = "empty"} = e;
                    if (!this._checkIfRootsExists([t])) throw new R("datacontroller-get-non-existent-root", this);
                    const i = this.model.document.getRoot(t);
                    return i.isAttached() || ae("datacontroller-get-detached-root", this), n !== "empty" || this.model.hasContent(i, {ignoreWhitespaces: !0}) ? this.stringify(i, e) : ""
                }

                stringify(e, t = {}) {
                    const n = this.toView(e, t);
                    return this.processor.toData(n)
                }

                toView(e, t = {}) {
                    const n = this.viewDocument, i = this._viewWriter;
                    this.mapper.clearBindings();
                    const s = Ee._createIn(e), l = new Zo(n);
                    this.mapper.bindElements(e, l);
                    const d = e.is("documentFragment") ? e.markers : function (g) {
                        const v = [], _ = g.root.document;
                        if (!_) return new Map;
                        const x = Ee._createIn(g);
                        for (const M of _.model.markers) {
                            const O = M.getRange(), j = O.isCollapsed,
                                U = O.start.isEqual(x.start) || O.end.isEqual(x.end);
                            if (j && U) v.push([M.name, O]); else {
                                const K = x.getIntersection(O);
                                K && v.push([M.name, K])
                            }
                        }
                        return v.sort(([M, O], [j, U]) => {
                            if (O.end.compareWith(U.start) !== "after") return 1;
                            if (O.start.compareWith(U.end) !== "before") return -1;
                            switch (O.start.compareWith(U.start)) {
                                case"before":
                                    return 1;
                                case"after":
                                    return -1;
                                default:
                                    switch (O.end.compareWith(U.end)) {
                                        case"before":
                                            return 1;
                                        case"after":
                                            return -1;
                                        default:
                                            return j.localeCompare(M)
                                    }
                            }
                        }), new Map(v)
                    }(e);
                    return this.downcastDispatcher.convert(s, d, i, t), l
                }

                init(e) {
                    if (this.model.document.version) throw new R("datacontroller-init-document-not-empty", this);
                    let t = {};
                    if (typeof e == "string" ? t.main = e : t = e, !this._checkIfRootsExists(Object.keys(t))) throw new R("datacontroller-init-non-existent-root", this);
                    return this.model.enqueueChange({isUndoable: !1}, n => {
                        for (const i of Object.keys(t)) {
                            const s = this.model.document.getRoot(i);
                            n.insert(this.parse(t[i], s), s, 0)
                        }
                    }), Promise.resolve()
                }

                set(e, t = {}) {
                    let n = {};
                    if (typeof e == "string" ? n.main = e : n = e, !this._checkIfRootsExists(Object.keys(n))) throw new R("datacontroller-set-non-existent-root", this);
                    this.model.enqueueChange(t.batchType || {}, i => {
                        i.setSelection(null), i.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                        for (const s of Object.keys(n)) {
                            const l = this.model.document.getRoot(s);
                            i.remove(i.createRangeIn(l)), i.insert(this.parse(n[s], l), l, 0)
                        }
                    })
                }

                parse(e, t = "$root") {
                    const n = this.processor.toView(e);
                    return this.toModel(n, t)
                }

                toModel(e, t = "$root") {
                    return this.model.change(n => this.upcastDispatcher.convert(e, n, t))
                }

                addStyleProcessorRules(e) {
                    e(this.stylesProcessor)
                }

                registerRawContentMatcher(e) {
                    this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e), this.htmlProcessor.registerRawContentMatcher(e)
                }

                destroy() {
                    this.stopListening()
                }

                _checkIfRootsExists(e) {
                    for (const t of e) if (!this.model.document.getRoot(t)) return !1;
                    return !0
                }
            }

            class YS {
                constructor(e, t) {
                    this._helpers = new Map, this._downcast = qn(e), this._createConversionHelpers({
                        name: "downcast",
                        dispatchers: this._downcast,
                        isDowncast: !0
                    }), this._upcast = qn(t), this._createConversionHelpers({
                        name: "upcast",
                        dispatchers: this._upcast,
                        isDowncast: !1
                    })
                }

                addAlias(e, t) {
                    const n = this._downcast.includes(t);
                    if (!this._upcast.includes(t) && !n) throw new R("conversion-add-alias-dispatcher-not-registered", this);
                    this._createConversionHelpers({name: e, dispatchers: [t], isDowncast: n})
                }

                for(e) {
                    if (!this._helpers.has(e)) throw new R("conversion-for-unknown-group", this);
                    return this._helpers.get(e)
                }

                elementToElement(e) {
                    this.for("downcast").elementToElement(e);
                    for (const {model: t, view: n} of hb(e)) this.for("upcast").elementToElement({
                        model: t,
                        view: n,
                        converterPriority: e.converterPriority
                    })
                }

                attributeToElement(e) {
                    this.for("downcast").attributeToElement(e);
                    for (const {model: t, view: n} of hb(e)) this.for("upcast").elementToAttribute({
                        view: n,
                        model: t,
                        converterPriority: e.converterPriority
                    })
                }

                attributeToAttribute(e) {
                    this.for("downcast").attributeToAttribute(e);
                    for (const {model: t, view: n} of hb(e)) this.for("upcast").attributeToAttribute({
                        view: n,
                        model: t
                    })
                }

                _createConversionHelpers({name: e, dispatchers: t, isDowncast: n}) {
                    if (this._helpers.has(e)) throw new R("conversion-group-exists", this);
                    const i = n ? new bS(t) : new DS(t);
                    this._helpers.set(e, i)
                }
            }

            function* hb(r) {
                if (r.model.values) for (const e of r.model.values) {
                    const t = {key: r.model.key, value: e}, n = r.view[e], i = r.upcastAlso ? r.upcastAlso[e] : void 0;
                    yield* pw(t, n, i)
                } else yield* pw(r.model, r.view, r.upcastAlso)
            }

            function* pw(r, e, t) {
                if (yield{model: r, view: e}, t) for (const n of qn(t)) yield{model: r, view: n}
            }

            class Mi {
                constructor(e) {
                    this.baseVersion = e, this.isDocumentOperation = this.baseVersion !== null, this.batch = null
                }

                _validate() {
                }

                toJSON() {
                    const e = Object.assign({}, this);
                    return e.__className = this.constructor.className, delete e.batch, delete e.isDocumentOperation, e
                }

                static get className() {
                    return "Operation"
                }

                static fromJSON(e, t) {
                    return new this(e.baseVersion)
                }
            }

            function fb(r, e) {
                const t = bw(e), n = t.reduce((l, d) => l + d.offsetSize, 0), i = r.parent;
                lh(r);
                const s = r.index;
                return i._insertChild(s, t), ah(i, s + t.length), ah(i, s), new Ee(r, r.getShiftedBy(n))
            }

            function mw(r) {
                if (!r.isFlat) throw new R("operation-utils-remove-range-not-flat", this);
                const e = r.start.parent;
                lh(r.start), lh(r.end);
                const t = e._removeChildren(r.start.index, r.end.index - r.start.index);
                return ah(e, r.start.index), t
            }

            function sh(r, e) {
                if (!r.isFlat) throw new R("operation-utils-move-range-not-flat", this);
                const t = mw(r);
                return fb(e = e._getTransformedByDeletion(r.start, r.end.offset - r.start.offset), t)
            }

            function bw(r) {
                const e = [];
                (function t(n) {
                    if (typeof n == "string") e.push(new An(n)); else if (n instanceof wo) e.push(new An(n.data, n.getAttributes())); else if (n instanceof Hl) e.push(n); else if (oe(n)) for (const i of n) t(i)
                })(r);
                for (let t = 1; t < e.length; t++) {
                    const n = e[t], i = e[t - 1];
                    n instanceof An && i instanceof An && kw(n, i) && (e.splice(t - 1, 2, new An(i.data + n.data, i.getAttributes())), t--)
                }
                return e
            }

            function ah(r, e) {
                const t = r.getChild(e - 1), n = r.getChild(e);
                if (t && n && t.is("$text") && n.is("$text") && kw(t, n)) {
                    const i = new An(t.data + n.data, t.getAttributes());
                    r._removeChildren(e - 1, 2), r._insertChild(e - 1, i)
                }
            }

            function lh(r) {
                const e = r.textNode, t = r.parent;
                if (e) {
                    const n = r.offset - e.startOffset, i = e.index;
                    t._removeChildren(i, 1);
                    const s = new An(e.data.substr(0, n), e.getAttributes()),
                        l = new An(e.data.substr(n), e.getAttributes());
                    t._insertChild(i, [s, l])
                }
            }

            function kw(r, e) {
                const t = r.getAttributes(), n = e.getAttributes();
                for (const i of t) {
                    if (i[1] !== e.getAttribute(i[0])) return !1;
                    n.next()
                }
                return n.next().done
            }

            class on extends Mi {
                constructor(e, t, n, i) {
                    super(i), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNone"
                }

                get type() {
                    return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move"
                }

                get affectedSelectable() {
                    return [Ee._createFromPositionAndShift(this.sourcePosition, this.howMany), Ee._createFromPositionAndShift(this.targetPosition, 0)]
                }

                clone() {
                    return new on(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
                }

                getMovedRangeStart() {
                    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
                }

                getReversed() {
                    const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
                    return new on(this.getMovedRangeStart(), this.howMany, e, this.baseVersion + 1)
                }

                _validate() {
                    const e = this.sourcePosition.parent, t = this.targetPosition.parent,
                        n = this.sourcePosition.offset, i = this.targetPosition.offset;
                    if (n + this.howMany > e.maxOffset) throw new R("move-operation-nodes-do-not-exist", this);
                    if (e === t && n < i && i < n + this.howMany) throw new R("move-operation-range-into-itself", this);
                    if (this.sourcePosition.root == this.targetPosition.root && te(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
                        const s = this.sourcePosition.path.length - 1;
                        if (this.targetPosition.path[s] >= n && this.targetPosition.path[s] < n + this.howMany) throw new R("move-operation-node-into-itself", this)
                    }
                }

                _execute() {
                    sh(Ee._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.sourcePosition = this.sourcePosition.toJSON(), e.targetPosition = this.targetPosition.toJSON(), e
                }

                static get className() {
                    return "MoveOperation"
                }

                static fromJSON(e, t) {
                    const n = Fe.fromJSON(e.sourcePosition, t), i = Fe.fromJSON(e.targetPosition, t);
                    return new this(n, e.howMany, i, e.baseVersion)
                }
            }

            class Dr extends Mi {
                constructor(e, t, n) {
                    super(n), this.position = e.clone(), this.position.stickiness = "toNone", this.nodes = new th(bw(t)), this.shouldReceiveAttributes = !1
                }

                get type() {
                    return "insert"
                }

                get howMany() {
                    return this.nodes.maxOffset
                }

                get affectedSelectable() {
                    return this.position.clone()
                }

                clone() {
                    const e = new th([...this.nodes].map(n => n._clone(!0))),
                        t = new Dr(this.position, e, this.baseVersion);
                    return t.shouldReceiveAttributes = this.shouldReceiveAttributes, t
                }

                getReversed() {
                    const e = this.position.root.document.graveyard, t = new Fe(e, [0]);
                    return new on(this.position, this.nodes.maxOffset, t, this.baseVersion + 1)
                }

                _validate() {
                    const e = this.position.parent;
                    if (!e || e.maxOffset < this.position.offset) throw new R("insert-operation-position-invalid", this)
                }

                _execute() {
                    const e = this.nodes;
                    this.nodes = new th([...e].map(t => t._clone(!0))), fb(this.position, e)
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.position = this.position.toJSON(), e.nodes = this.nodes.toJSON(), e
                }

                static get className() {
                    return "InsertOperation"
                }

                static fromJSON(e, t) {
                    const n = [];
                    for (const s of e.nodes) s.name ? n.push(pn.fromJSON(s)) : n.push(An.fromJSON(s));
                    const i = new Dr(Fe.fromJSON(e.position, t), n, e.baseVersion);
                    return i.shouldReceiveAttributes = e.shouldReceiveAttributes, i
                }
            }

            class Cn extends Mi {
                constructor(e, t, n, i, s) {
                    super(s), this.splitPosition = e.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t, this.insertionPosition = n, this.graveyardPosition = i ? i.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext")
                }

                get type() {
                    return "split"
                }

                get moveTargetPosition() {
                    const e = this.insertionPosition.path.slice();
                    return e.push(0), new Fe(this.insertionPosition.root, e)
                }

                get movedRange() {
                    const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
                    return new Ee(this.splitPosition, e)
                }

                get affectedSelectable() {
                    const e = [Ee._createFromPositionAndShift(this.splitPosition, 0), Ee._createFromPositionAndShift(this.insertionPosition, 0)];
                    return this.graveyardPosition && e.push(Ee._createFromPositionAndShift(this.graveyardPosition, 0)), e
                }

                clone() {
                    return new Cn(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion)
                }

                getReversed() {
                    const e = this.splitPosition.root.document.graveyard, t = new Fe(e, [0]);
                    return new Yn(this.moveTargetPosition, this.howMany, this.splitPosition, t, this.baseVersion + 1)
                }

                _validate() {
                    const e = this.splitPosition.parent, t = this.splitPosition.offset;
                    if (!e || e.maxOffset < t) throw new R("split-operation-position-invalid", this);
                    if (!e.parent) throw new R("split-operation-split-in-root", this);
                    if (this.howMany != e.maxOffset - this.splitPosition.offset) throw new R("split-operation-how-many-invalid", this);
                    if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) throw new R("split-operation-graveyard-position-invalid", this)
                }

                _execute() {
                    const e = this.splitPosition.parent;
                    if (this.graveyardPosition) sh(Ee._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition); else {
                        const t = e._clone();
                        fb(this.insertionPosition, t)
                    }
                    sh(new Ee(Fe._createAt(e, this.splitPosition.offset), Fe._createAt(e, e.maxOffset)), this.moveTargetPosition)
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.splitPosition = this.splitPosition.toJSON(), e.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()), e
                }

                static get className() {
                    return "SplitOperation"
                }

                static getInsertionPosition(e) {
                    const t = e.path.slice(0, -1);
                    return t[t.length - 1]++, new Fe(e.root, t, "toPrevious")
                }

                static fromJSON(e, t) {
                    const n = Fe.fromJSON(e.splitPosition, t), i = Fe.fromJSON(e.insertionPosition, t),
                        s = e.graveyardPosition ? Fe.fromJSON(e.graveyardPosition, t) : null;
                    return new this(n, e.howMany, i, s, e.baseVersion)
                }
            }

            class Yn extends Mi {
                constructor(e, t, n, i, s) {
                    super(s), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = i.clone()
                }

                get type() {
                    return "merge"
                }

                get deletionPosition() {
                    return new Fe(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
                }

                get movedRange() {
                    const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
                    return new Ee(this.sourcePosition, e)
                }

                get affectedSelectable() {
                    const e = this.sourcePosition.parent;
                    return [Ee._createOn(e), Ee._createFromPositionAndShift(this.targetPosition, 0), Ee._createFromPositionAndShift(this.graveyardPosition, 0)]
                }

                clone() {
                    return new Yn(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion)
                }

                getReversed() {
                    const e = this.targetPosition._getTransformedByMergeOperation(this),
                        t = this.sourcePosition.path.slice(0, -1),
                        n = new Fe(this.sourcePosition.root, t)._getTransformedByMergeOperation(this);
                    return new Cn(e, this.howMany, n, this.graveyardPosition, this.baseVersion + 1)
                }

                _validate() {
                    const e = this.sourcePosition.parent, t = this.targetPosition.parent;
                    if (!e.parent) throw new R("merge-operation-source-position-invalid", this);
                    if (!t.parent) throw new R("merge-operation-target-position-invalid", this);
                    if (this.howMany != e.maxOffset) throw new R("merge-operation-how-many-invalid", this)
                }

                _execute() {
                    const e = this.sourcePosition.parent;
                    sh(Ee._createIn(e), this.targetPosition), sh(Ee._createOn(e), this.graveyardPosition)
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.sourcePosition = e.sourcePosition.toJSON(), e.targetPosition = e.targetPosition.toJSON(), e.graveyardPosition = e.graveyardPosition.toJSON(), e
                }

                static get className() {
                    return "MergeOperation"
                }

                static fromJSON(e, t) {
                    const n = Fe.fromJSON(e.sourcePosition, t), i = Fe.fromJSON(e.targetPosition, t),
                        s = Fe.fromJSON(e.graveyardPosition, t);
                    return new this(n, e.howMany, i, s, e.baseVersion)
                }
            }

            class li extends Mi {
                constructor(e, t, n, i, s, l) {
                    super(l), this.name = e, this.oldRange = t ? t.clone() : null, this.newRange = n ? n.clone() : null, this.affectsData = s, this._markers = i
                }

                get type() {
                    return "marker"
                }

                get affectedSelectable() {
                    const e = [];
                    return this.oldRange && e.push(this.oldRange.clone()), this.newRange && (this.oldRange ? e.push(...this.newRange.getDifference(this.oldRange)) : e.push(this.newRange.clone())), e
                }

                clone() {
                    return new li(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
                }

                getReversed() {
                    return new li(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
                }

                _execute() {
                    this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name)
                }

                toJSON() {
                    const e = super.toJSON();
                    return this.oldRange && (e.oldRange = this.oldRange.toJSON()), this.newRange && (e.newRange = this.newRange.toJSON()), delete e._markers, e
                }

                static get className() {
                    return "MarkerOperation"
                }

                static fromJSON(e, t) {
                    return new li(e.name, e.oldRange ? Ee.fromJSON(e.oldRange, t) : null, e.newRange ? Ee.fromJSON(e.newRange, t) : null, t.model.markers, e.affectsData, e.baseVersion)
                }
            }

            const vw = function (r, e) {
                return Iv(r, e)
            };

            class ir extends Mi {
                constructor(e, t, n, i, s) {
                    super(s), this.range = e.clone(), this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = i === void 0 ? null : i
                }

                get type() {
                    return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute"
                }

                get affectedSelectable() {
                    return this.range.clone()
                }

                clone() {
                    return new ir(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
                }

                getReversed() {
                    return new ir(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.range = this.range.toJSON(), e
                }

                _validate() {
                    if (!this.range.isFlat) throw new R("attribute-operation-range-not-flat", this);
                    for (const e of this.range.getItems({shallow: !0})) {
                        if (this.oldValue !== null && !vw(e.getAttribute(this.key), this.oldValue)) throw new R("attribute-operation-wrong-old-value", this, {
                            item: e,
                            key: this.key,
                            value: this.oldValue
                        });
                        if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key)) throw new R("attribute-operation-attribute-exists", this, {
                            node: e,
                            key: this.key
                        })
                    }
                }

                _execute() {
                    vw(this.oldValue, this.newValue) || function (e, t, n) {
                        lh(e.start), lh(e.end);
                        for (const i of e.getItems({shallow: !0})) {
                            const s = i.is("$textProxy") ? i.textNode : i;
                            n !== null ? s._setAttribute(t, n) : s._removeAttribute(t), ah(s.parent, s.index)
                        }
                        ah(e.end.parent, e.end.index)
                    }(this.range, this.key, this.newValue)
                }

                static get className() {
                    return "AttributeOperation"
                }

                static fromJSON(e, t) {
                    return new ir(Ee.fromJSON(e.range, t), e.key, e.oldValue, e.newValue, e.baseVersion)
                }
            }

            class hr extends Mi {
                get type() {
                    return "noop"
                }

                get affectedSelectable() {
                    return null
                }

                clone() {
                    return new hr(this.baseVersion)
                }

                getReversed() {
                    return new hr(this.baseVersion + 1)
                }

                _execute() {
                }

                static get className() {
                    return "NoOperation"
                }
            }

            class ci extends Mi {
                constructor(e, t, n, i) {
                    super(i), this.position = e, this.position.stickiness = "toNext", this.oldName = t, this.newName = n
                }

                get type() {
                    return "rename"
                }

                get affectedSelectable() {
                    return this.position.nodeAfter
                }

                clone() {
                    return new ci(this.position.clone(), this.oldName, this.newName, this.baseVersion)
                }

                getReversed() {
                    return new ci(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
                }

                _validate() {
                    const e = this.position.nodeAfter;
                    if (!(e instanceof pn)) throw new R("rename-operation-wrong-position", this);
                    if (e.name !== this.oldName) throw new R("rename-operation-wrong-name", this)
                }

                _execute() {
                    this.position.nodeAfter.name = this.newName
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.position = this.position.toJSON(), e
                }

                static get className() {
                    return "RenameOperation"
                }

                static fromJSON(e, t) {
                    return new ci(Fe.fromJSON(e.position, t), e.oldName, e.newName, e.baseVersion)
                }
            }

            class Ms extends Mi {
                constructor(e, t, n, i, s) {
                    super(s), this.root = e, this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = i === void 0 ? null : i
                }

                get type() {
                    return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute"
                }

                get affectedSelectable() {
                    return this.root
                }

                clone() {
                    return new Ms(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
                }

                getReversed() {
                    return new Ms(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
                }

                _validate() {
                    if (this.root != this.root.root || this.root.is("documentFragment")) throw new R("rootattribute-operation-not-a-root", this, {
                        root: this.root,
                        key: this.key
                    });
                    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) throw new R("rootattribute-operation-wrong-old-value", this, {
                        root: this.root,
                        key: this.key
                    });
                    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) throw new R("rootattribute-operation-attribute-exists", this, {
                        root: this.root,
                        key: this.key
                    })
                }

                _execute() {
                    this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key)
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.root = this.root.toJSON(), e
                }

                static get className() {
                    return "RootAttributeOperation"
                }

                static fromJSON(e, t) {
                    if (!t.getRoot(e.root)) throw new R("rootattribute-operation-fromjson-no-root", this, {rootName: e.root});
                    return new Ms(t.getRoot(e.root), e.key, e.oldValue, e.newValue, e.baseVersion)
                }
            }

            class Xo extends Mi {
                constructor(e, t, n, i, s) {
                    super(s), this.rootName = e, this.elementName = t, this.isAdd = n, this._document = i, !this._document.getRoot(this.rootName) && (this._document.createRoot(this.elementName, this.rootName)._isAttached = !1)
                }

                get type() {
                    return this.isAdd ? "addRoot" : "detachRoot"
                }

                get affectedSelectable() {
                    return this._document.getRoot(this.rootName)
                }

                clone() {
                    return new Xo(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion)
                }

                getReversed() {
                    return new Xo(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1)
                }

                _execute() {
                    this._document.getRoot(this.rootName)._isAttached = this.isAdd
                }

                toJSON() {
                    const e = super.toJSON();
                    return delete e._document, e
                }

                static get className() {
                    return "RootOperation"
                }

                static fromJSON(e, t) {
                    return new Xo(e.rootName, e.elementName, e.isAdd, t, e.baseVersion)
                }
            }

            const Yi = {};
            Yi[ir.className] = ir, Yi[Dr.className] = Dr, Yi[li.className] = li, Yi[on.className] = on, Yi[hr.className] = hr, Yi[Mi.className] = Mi, Yi[ci.className] = ci, Yi[Ms.className] = Ms, Yi[Xo.className] = Xo, Yi[Cn.className] = Cn, Yi[Yn.className] = Yn;

            class QS {
                static fromJSON(e, t) {
                    return Yi[e.__className].fromJSON(e, t)
                }
            }

            const gb = new Map;

            function Jt(r, e, t) {
                let n = gb.get(r);
                n || (n = new Map, gb.set(r, n)), n.set(e, t)
            }

            function JS(r) {
                return [r]
            }

            function ww(r, e, t = {}) {
                const n = function (i, s) {
                    const l = gb.get(i);
                    return l && l.has(s) ? l.get(s) : JS
                }(r.constructor, e.constructor);
                try {
                    return n(r = r.clone(), e, t)
                } catch (i) {
                    throw i
                }
            }

            function XS(r, e, t) {
                r = r.slice(), e = e.slice();
                const n = new e3(t.document, t.useRelations, t.forceWeakRemove);
                n.setOriginalOperations(r), n.setOriginalOperations(e);
                const i = n.originalOperations;
                if (r.length == 0 || e.length == 0) return {operationsA: r, operationsB: e, originalOperations: i};
                const s = new WeakMap;
                for (const g of r) s.set(g, 0);
                const l = {
                    nextBaseVersionA: r[r.length - 1].baseVersion + 1,
                    nextBaseVersionB: e[e.length - 1].baseVersion + 1,
                    originalOperationsACount: r.length,
                    originalOperationsBCount: e.length
                };
                let d = 0;
                for (; d < r.length;) {
                    const g = r[d], v = s.get(g);
                    if (v == e.length) {
                        d++;
                        continue
                    }
                    const _ = e[v], x = ww(g, _, n.getContext(g, _, !0)), M = ww(_, g, n.getContext(_, g, !1));
                    n.updateRelation(g, _), n.setOriginalOperations(x, g), n.setOriginalOperations(M, _);
                    for (const O of x) s.set(O, v + M.length);
                    r.splice(d, 1, ...x), e.splice(v, 1, ...M)
                }
                if (t.padWithNoOps) {
                    const g = r.length - l.originalOperationsACount, v = e.length - l.originalOperationsBCount;
                    Cw(r, v - g), Cw(e, g - v)
                }
                return Aw(r, l.nextBaseVersionB), Aw(e, l.nextBaseVersionA), {
                    operationsA: r,
                    operationsB: e,
                    originalOperations: i
                }
            }

            class e3 {
                constructor(e, t, n = !1) {
                    this.originalOperations = new Map, this._history = e.history, this._useRelations = t, this._forceWeakRemove = !!n, this._relations = new Map
                }

                setOriginalOperations(e, t = null) {
                    const n = t ? this.originalOperations.get(t) : null;
                    for (const i of e) this.originalOperations.set(i, n || i)
                }

                updateRelation(e, t) {
                    if (e instanceof on) t instanceof Yn ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof on && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter")); else if (e instanceof Cn) {
                        if (t instanceof Yn) e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore"); else if (t instanceof on) if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition)) this._setRelation(e, t, "splitBefore"); else {
                            const n = Ee._createFromPositionAndShift(t.sourcePosition, t.howMany);
                            if (e.splitPosition.hasSameParentAs(t.sourcePosition) && n.containsPosition(e.splitPosition)) {
                                const i = n.end.offset - e.splitPosition.offset,
                                    s = e.splitPosition.offset - n.start.offset;
                                this._setRelation(e, t, {howMany: i, offset: s})
                            }
                        }
                    } else if (e instanceof Yn) t instanceof Yn ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"), e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"), e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof Cn && e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource"); else if (e instanceof li) {
                        const n = e.newRange;
                        if (!n) return;
                        if (t instanceof on) {
                            const i = Ee._createFromPositionAndShift(t.sourcePosition, t.howMany),
                                s = i.containsPosition(n.start) || i.start.isEqual(n.start),
                                l = i.containsPosition(n.end) || i.end.isEqual(n.end);
                            !s && !l || i.containsRange(n) || this._setRelation(e, t, {
                                side: s ? "left" : "right",
                                path: s ? n.start.path.slice() : n.end.path.slice()
                            })
                        } else if (t instanceof Yn) {
                            const i = n.start.isEqual(t.targetPosition), s = n.start.isEqual(t.deletionPosition),
                                l = n.end.isEqual(t.deletionPosition), d = n.end.isEqual(t.sourcePosition);
                            (i || s || l || d) && this._setRelation(e, t, {
                                wasInLeftElement: i,
                                wasStartBeforeMergedElement: s,
                                wasEndBeforeMergedElement: l,
                                wasInRightElement: d
                            })
                        }
                    }
                }

                getContext(e, t, n) {
                    return {
                        aIsStrong: n,
                        aWasUndone: this._wasUndone(e),
                        bWasUndone: this._wasUndone(t),
                        abRelation: this._useRelations ? this._getRelation(e, t) : null,
                        baRelation: this._useRelations ? this._getRelation(t, e) : null,
                        forceWeakRemove: this._forceWeakRemove
                    }
                }

                _wasUndone(e) {
                    const t = this.originalOperations.get(e);
                    return t.wasUndone || this._history.isUndoneOperation(t)
                }

                _getRelation(e, t) {
                    const n = this.originalOperations.get(t), i = this._history.getUndoneOperation(n);
                    if (!i) return null;
                    const s = this.originalOperations.get(e), l = this._relations.get(s);
                    return l && l.get(i) || null
                }

                _setRelation(e, t, n) {
                    const i = this.originalOperations.get(e), s = this.originalOperations.get(t);
                    let l = this._relations.get(i);
                    l || (l = new Map, this._relations.set(i, l)), l.set(s, n)
                }
            }

            function Aw(r, e) {
                for (const t of r) t.baseVersion = e++
            }

            function Cw(r, e) {
                for (let t = 0; t < e; t++) r.push(new hr(0))
            }

            function _w(r, e, t) {
                const n = r.nodes.getNode(0).getAttribute(e);
                if (n == t) return null;
                const i = new Ee(r.position, r.position.getShiftedBy(r.howMany));
                return new ir(i, e, n, t, 0)
            }

            function yw(r, e) {
                return r.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
            }

            function gu(r, e) {
                const t = [];
                for (let n = 0; n < r.length; n++) {
                    const i = r[n], s = new on(i.start, i.end.offset - i.start.offset, e, 0);
                    t.push(s);
                    for (let l = n + 1; l < r.length; l++) r[l] = r[l]._getTransformedByMove(s.sourcePosition, s.targetPosition, s.howMany)[0];
                    e = e._getTransformedByMove(s.sourcePosition, s.targetPosition, s.howMany)
                }
                return t
            }

            Jt(ir, ir, (r, e, t) => {
                if (r.key === e.key && r.range.start.hasSameParentAs(e.range.start)) {
                    const n = r.range.getDifference(e.range).map(s => new ir(s, r.key, r.oldValue, r.newValue, 0)),
                        i = r.range.getIntersection(e.range);
                    return i && t.aIsStrong && n.push(new ir(i, e.key, e.newValue, r.newValue, 0)), n.length == 0 ? [new hr(0)] : n
                }
                return [r]
            }), Jt(ir, Dr, (r, e) => {
                if (r.range.start.hasSameParentAs(e.position) && r.range.containsPosition(e.position)) {
                    const t = r.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map(n => new ir(n, r.key, r.oldValue, r.newValue, r.baseVersion));
                    if (e.shouldReceiveAttributes) {
                        const n = _w(e, r.key, r.oldValue);
                        n && t.unshift(n)
                    }
                    return t
                }
                return r.range = r.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [r]
            }), Jt(ir, Yn, (r, e) => {
                const t = [];
                r.range.start.hasSameParentAs(e.deletionPosition) && (r.range.containsPosition(e.deletionPosition) || r.range.start.isEqual(e.deletionPosition)) && t.push(Ee._createFromPositionAndShift(e.graveyardPosition, 1));
                const n = r.range._getTransformedByMergeOperation(e);
                return n.isCollapsed || t.push(n), t.map(i => new ir(i, r.key, r.oldValue, r.newValue, r.baseVersion))
            }), Jt(ir, on, (r, e) => function (n, i) {
                const s = Ee._createFromPositionAndShift(i.sourcePosition, i.howMany);
                let l = null, d = [];
                s.containsRange(n, !0) ? l = n : n.start.hasSameParentAs(s.start) ? (d = n.getDifference(s), l = n.getIntersection(s)) : d = [n];
                const g = [];
                for (let v of d) {
                    v = v._getTransformedByDeletion(i.sourcePosition, i.howMany);
                    const _ = i.getMovedRangeStart(), x = v.start.hasSameParentAs(_),
                        M = v._getTransformedByInsertion(_, i.howMany, x);
                    g.push(...M)
                }
                return l && g.push(l._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany, !1)[0]), g
            }(r.range, e).map(n => new ir(n, r.key, r.oldValue, r.newValue, r.baseVersion))), Jt(ir, Cn, (r, e) => {
                if (r.range.end.isEqual(e.insertionPosition)) return e.graveyardPosition || r.range.end.offset++, [r];
                if (r.range.start.hasSameParentAs(e.splitPosition) && r.range.containsPosition(e.splitPosition)) {
                    const t = r.clone();
                    return t.range = new Ee(e.moveTargetPosition.clone(), r.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), r.range.end = e.splitPosition.clone(), r.range.end.stickiness = "toPrevious", [r, t]
                }
                return r.range = r.range._getTransformedBySplitOperation(e), [r]
            }), Jt(Dr, ir, (r, e) => {
                const t = [r];
                if (r.shouldReceiveAttributes && r.position.hasSameParentAs(e.range.start) && e.range.containsPosition(r.position)) {
                    const n = _w(r, e.key, e.newValue);
                    n && t.push(n)
                }
                return t
            }), Jt(Dr, Dr, (r, e, t) => (r.position.isEqual(e.position) && t.aIsStrong || (r.position = r.position._getTransformedByInsertOperation(e)), [r])), Jt(Dr, on, (r, e) => (r.position = r.position._getTransformedByMoveOperation(e), [r])), Jt(Dr, Cn, (r, e) => (r.position = r.position._getTransformedBySplitOperation(e), [r])), Jt(Dr, Yn, (r, e) => (r.position = r.position._getTransformedByMergeOperation(e), [r])), Jt(li, Dr, (r, e) => (r.oldRange && (r.oldRange = r.oldRange._getTransformedByInsertOperation(e)[0]), r.newRange && (r.newRange = r.newRange._getTransformedByInsertOperation(e)[0]), [r])), Jt(li, li, (r, e, t) => {
                if (r.name == e.name) {
                    if (!t.aIsStrong) return [new hr(0)];
                    r.oldRange = e.newRange ? e.newRange.clone() : null
                }
                return [r]
            }), Jt(li, Yn, (r, e) => (r.oldRange && (r.oldRange = r.oldRange._getTransformedByMergeOperation(e)), r.newRange && (r.newRange = r.newRange._getTransformedByMergeOperation(e)), [r])), Jt(li, on, (r, e, t) => {
                if (r.oldRange && (r.oldRange = Ee._createFromRanges(r.oldRange._getTransformedByMoveOperation(e))), r.newRange) {
                    if (t.abRelation) {
                        const n = Ee._createFromRanges(r.newRange._getTransformedByMoveOperation(e));
                        if (t.abRelation.side == "left" && e.targetPosition.isEqual(r.newRange.start)) return r.newRange.end = n.end, r.newRange.start.path = t.abRelation.path, [r];
                        if (t.abRelation.side == "right" && e.targetPosition.isEqual(r.newRange.end)) return r.newRange.start = n.start, r.newRange.end.path = t.abRelation.path, [r]
                    }
                    r.newRange = Ee._createFromRanges(r.newRange._getTransformedByMoveOperation(e))
                }
                return [r]
            }), Jt(li, Cn, (r, e, t) => {
                if (r.oldRange && (r.oldRange = r.oldRange._getTransformedBySplitOperation(e)), r.newRange) {
                    if (t.abRelation) {
                        const n = r.newRange._getTransformedBySplitOperation(e);
                        return r.newRange.start.isEqual(e.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? r.newRange.start = Fe._createAt(e.insertionPosition) : r.newRange.start.isEqual(e.splitPosition) && !t.abRelation.wasInLeftElement && (r.newRange.start = Fe._createAt(e.moveTargetPosition)), r.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasInRightElement ? r.newRange.end = Fe._createAt(e.moveTargetPosition) : r.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? r.newRange.end = Fe._createAt(e.insertionPosition) : r.newRange.end = n.end, [r]
                    }
                    r.newRange = r.newRange._getTransformedBySplitOperation(e)
                }
                return [r]
            }), Jt(Yn, Dr, (r, e) => (r.sourcePosition.hasSameParentAs(e.position) && (r.howMany += e.howMany), r.sourcePosition = r.sourcePosition._getTransformedByInsertOperation(e), r.targetPosition = r.targetPosition._getTransformedByInsertOperation(e), [r])), Jt(Yn, Yn, (r, e, t) => {
                if (r.sourcePosition.isEqual(e.sourcePosition) && r.targetPosition.isEqual(e.targetPosition)) {
                    if (t.bWasUndone) {
                        const n = e.graveyardPosition.path.slice();
                        return n.push(0), r.sourcePosition = new Fe(e.graveyardPosition.root, n), r.howMany = 0, [r]
                    }
                    return [new hr(0)]
                }
                if (r.sourcePosition.isEqual(e.sourcePosition) && !r.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
                    const n = r.targetPosition.root.rootName == "$graveyard",
                        i = e.targetPosition.root.rootName == "$graveyard";
                    if (i && !n || !(n && !i) && t.aIsStrong) {
                        const s = e.targetPosition._getTransformedByMergeOperation(e),
                            l = r.targetPosition._getTransformedByMergeOperation(e);
                        return [new on(s, r.howMany, l, 0)]
                    }
                    return [new hr(0)]
                }
                return r.sourcePosition.hasSameParentAs(e.targetPosition) && (r.howMany += e.howMany), r.sourcePosition = r.sourcePosition._getTransformedByMergeOperation(e), r.targetPosition = r.targetPosition._getTransformedByMergeOperation(e), r.graveyardPosition.isEqual(e.graveyardPosition) && t.aIsStrong || (r.graveyardPosition = r.graveyardPosition._getTransformedByMergeOperation(e)), [r]
            }), Jt(Yn, on, (r, e, t) => {
                const n = Ee._createFromPositionAndShift(e.sourcePosition, e.howMany);
                return e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && r.deletionPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(r.sourcePosition) ? [new hr(0)] : (r.sourcePosition.hasSameParentAs(e.targetPosition) && (r.howMany += e.howMany), r.sourcePosition.hasSameParentAs(e.sourcePosition) && (r.howMany -= e.howMany), r.sourcePosition = r.sourcePosition._getTransformedByMoveOperation(e), r.targetPosition = r.targetPosition._getTransformedByMoveOperation(e), r.graveyardPosition.isEqual(e.targetPosition) || (r.graveyardPosition = r.graveyardPosition._getTransformedByMoveOperation(e)), [r])
            }), Jt(Yn, Cn, (r, e, t) => {
                if (e.graveyardPosition && (r.graveyardPosition = r.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), r.deletionPosition.isEqual(e.graveyardPosition) && (r.howMany = e.howMany)), r.targetPosition.isEqual(e.splitPosition)) {
                    const n = e.howMany != 0,
                        i = e.graveyardPosition && r.deletionPosition.isEqual(e.graveyardPosition);
                    if (n || i || t.abRelation == "mergeTargetNotMoved") return r.sourcePosition = r.sourcePosition._getTransformedBySplitOperation(e), [r]
                }
                if (r.sourcePosition.isEqual(e.splitPosition)) {
                    if (t.abRelation == "mergeSourceNotMoved") return r.howMany = 0, r.targetPosition = r.targetPosition._getTransformedBySplitOperation(e), [r];
                    if (t.abRelation == "mergeSameElement" || r.sourcePosition.offset > 0) return r.sourcePosition = e.moveTargetPosition.clone(), r.targetPosition = r.targetPosition._getTransformedBySplitOperation(e), [r]
                }
                return r.sourcePosition.hasSameParentAs(e.splitPosition) && (r.howMany = e.splitPosition.offset), r.sourcePosition = r.sourcePosition._getTransformedBySplitOperation(e), r.targetPosition = r.targetPosition._getTransformedBySplitOperation(e), [r]
            }), Jt(on, Dr, (r, e) => {
                const t = Ee._createFromPositionAndShift(r.sourcePosition, r.howMany)._getTransformedByInsertOperation(e, !1)[0];
                return r.sourcePosition = t.start, r.howMany = t.end.offset - t.start.offset, r.targetPosition.isEqual(e.position) || (r.targetPosition = r.targetPosition._getTransformedByInsertOperation(e)), [r]
            }), Jt(on, on, (r, e, t) => {
                const n = Ee._createFromPositionAndShift(r.sourcePosition, r.howMany),
                    i = Ee._createFromPositionAndShift(e.sourcePosition, e.howMany);
                let s, l = t.aIsStrong, d = !t.aIsStrong;
                if (t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? d = !0 : t.abRelation != "insertAfter" && t.baRelation != "insertBefore" || (d = !1), s = r.targetPosition.isEqual(e.targetPosition) && d ? r.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : r.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), yw(r, e) && yw(e, r)) return [e.getReversed()];
                if (n.containsPosition(e.targetPosition) && n.containsRange(i, !0)) return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), gu([n], s);
                if (i.containsPosition(r.targetPosition) && i.containsRange(n, !0)) return n.start = n.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), n.end = n.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), gu([n], s);
                const g = te(r.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
                if (g == "prefix" || g == "extension") return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), gu([n], s);
                r.type != "remove" || e.type == "remove" || t.aWasUndone || t.forceWeakRemove ? r.type == "remove" || e.type != "remove" || t.bWasUndone || t.forceWeakRemove || (l = !1) : l = !0;
                const v = [], _ = n.getDifference(i);
                for (const M of _) {
                    M.start = M.start._getTransformedByDeletion(e.sourcePosition, e.howMany), M.end = M.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
                    const O = te(M.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same",
                        j = M._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, O);
                    v.push(...j)
                }
                const x = n.getIntersection(i);
                return x !== null && l && (x.start = x.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), x.end = x.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), v.length === 0 ? v.push(x) : v.length == 1 ? i.start.isBefore(n.start) || i.start.isEqual(n.start) ? v.unshift(x) : v.push(x) : v.splice(1, 0, x)), v.length === 0 ? [new hr(r.baseVersion)] : gu(v, s)
            }), Jt(on, Cn, (r, e, t) => {
                let n = r.targetPosition.clone();
                r.targetPosition.isEqual(e.insertionPosition) && e.graveyardPosition && t.abRelation != "moveTargetAfter" || (n = r.targetPosition._getTransformedBySplitOperation(e));
                const i = Ee._createFromPositionAndShift(r.sourcePosition, r.howMany);
                if (i.end.isEqual(e.insertionPosition)) return e.graveyardPosition || r.howMany++, r.targetPosition = n, [r];
                if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
                    let l = new Ee(e.splitPosition, i.end);
                    return l = l._getTransformedBySplitOperation(e), gu([new Ee(i.start, e.splitPosition), l], n)
                }
                r.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (n = e.moveTargetPosition), r.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (n = r.targetPosition);
                const s = [i._getTransformedBySplitOperation(e)];
                if (e.graveyardPosition) {
                    const l = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
                    r.howMany > 1 && l && !t.aWasUndone && s.push(Ee._createFromPositionAndShift(e.insertionPosition, 1))
                }
                return gu(s, n)
            }), Jt(on, Yn, (r, e, t) => {
                const n = Ee._createFromPositionAndShift(r.sourcePosition, r.howMany);
                if (e.deletionPosition.hasSameParentAs(r.sourcePosition) && n.containsPosition(e.sourcePosition)) {
                    if (r.type != "remove" || t.forceWeakRemove) {
                        if (r.howMany == 1) return t.bWasUndone ? (r.sourcePosition = e.graveyardPosition.clone(), r.targetPosition = r.targetPosition._getTransformedByMergeOperation(e), [r]) : [new hr(0)]
                    } else if (!t.aWasUndone) {
                        const s = [];
                        let l = e.graveyardPosition.clone(), d = e.targetPosition._getTransformedByMergeOperation(e);
                        r.howMany > 1 && (s.push(new on(r.sourcePosition, r.howMany - 1, r.targetPosition, 0)), l = l._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany - 1), d = d._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany - 1));
                        const g = e.deletionPosition._getCombined(r.sourcePosition, r.targetPosition),
                            v = new on(l, 1, g, 0), _ = v.getMovedRangeStart().path.slice();
                        _.push(0);
                        const x = new Fe(v.targetPosition.root, _);
                        d = d._getTransformedByMove(l, g, 1);
                        const M = new on(d, e.howMany, x, 0);
                        return s.push(v), s.push(M), s
                    }
                }
                const i = Ee._createFromPositionAndShift(r.sourcePosition, r.howMany)._getTransformedByMergeOperation(e);
                return r.sourcePosition = i.start, r.howMany = i.end.offset - i.start.offset, r.targetPosition = r.targetPosition._getTransformedByMergeOperation(e), [r]
            }), Jt(ci, Dr, (r, e) => (r.position = r.position._getTransformedByInsertOperation(e), [r])), Jt(ci, Yn, (r, e) => r.position.isEqual(e.deletionPosition) ? (r.position = e.graveyardPosition.clone(), r.position.stickiness = "toNext", [r]) : (r.position = r.position._getTransformedByMergeOperation(e), [r])), Jt(ci, on, (r, e) => (r.position = r.position._getTransformedByMoveOperation(e), [r])), Jt(ci, ci, (r, e, t) => {
                if (r.position.isEqual(e.position)) {
                    if (!t.aIsStrong) return [new hr(0)];
                    r.oldName = e.newName
                }
                return [r]
            }), Jt(ci, Cn, (r, e) => {
                if (te(r.position.path, e.splitPosition.getParentPath()) == "same" && !e.graveyardPosition) {
                    const t = new ci(r.position.getShiftedBy(1), r.oldName, r.newName, 0);
                    return [r, t]
                }
                return r.position = r.position._getTransformedBySplitOperation(e), [r]
            }), Jt(Ms, Ms, (r, e, t) => {
                if (r.root === e.root && r.key === e.key) {
                    if (!t.aIsStrong || r.newValue === e.newValue) return [new hr(0)];
                    r.oldValue = e.newValue
                }
                return [r]
            }), Jt(Xo, Xo, (r, e) => r.rootName === e.rootName && r.isAdd === e.isAdd ? [new hr(0)] : [r]), Jt(Cn, Dr, (r, e) => (r.splitPosition.hasSameParentAs(e.position) && r.splitPosition.offset < e.position.offset && (r.howMany += e.howMany), r.splitPosition = r.splitPosition._getTransformedByInsertOperation(e), r.insertionPosition = r.insertionPosition._getTransformedByInsertOperation(e), [r])), Jt(Cn, Yn, (r, e, t) => {
                if (!r.graveyardPosition && !t.bWasUndone && r.splitPosition.hasSameParentAs(e.sourcePosition)) {
                    const n = e.graveyardPosition.path.slice();
                    n.push(0);
                    const i = new Fe(e.graveyardPosition.root, n),
                        s = Cn.getInsertionPosition(new Fe(e.graveyardPosition.root, n)), l = new Cn(i, 0, s, null, 0);
                    return r.splitPosition = r.splitPosition._getTransformedByMergeOperation(e), r.insertionPosition = Cn.getInsertionPosition(r.splitPosition), r.graveyardPosition = l.insertionPosition.clone(), r.graveyardPosition.stickiness = "toNext", [l, r]
                }
                return r.splitPosition.hasSameParentAs(e.deletionPosition) && !r.splitPosition.isAfter(e.deletionPosition) && r.howMany--, r.splitPosition.hasSameParentAs(e.targetPosition) && (r.howMany += e.howMany), r.splitPosition = r.splitPosition._getTransformedByMergeOperation(e), r.insertionPosition = Cn.getInsertionPosition(r.splitPosition), r.graveyardPosition && (r.graveyardPosition = r.graveyardPosition._getTransformedByMergeOperation(e)), [r]
            }), Jt(Cn, on, (r, e, t) => {
                const n = Ee._createFromPositionAndShift(e.sourcePosition, e.howMany);
                if (r.graveyardPosition) {
                    const s = n.start.isEqual(r.graveyardPosition) || n.containsPosition(r.graveyardPosition);
                    if (!t.bWasUndone && s) {
                        const l = r.splitPosition._getTransformedByMoveOperation(e),
                            d = r.graveyardPosition._getTransformedByMoveOperation(e), g = d.path.slice();
                        g.push(0);
                        const v = new Fe(d.root, g);
                        return [new on(l, r.howMany, v, 0)]
                    }
                    r.graveyardPosition = r.graveyardPosition._getTransformedByMoveOperation(e)
                }
                const i = r.splitPosition.isEqual(e.targetPosition);
                if (i && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore")) return r.howMany += e.howMany, r.splitPosition = r.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), r.insertionPosition = Cn.getInsertionPosition(r.splitPosition), [r];
                if (i && t.abRelation && t.abRelation.howMany) {
                    const {howMany: s, offset: l} = t.abRelation;
                    return r.howMany += s, r.splitPosition = r.splitPosition.getShiftedBy(l), [r]
                }
                if (r.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(r.splitPosition)) {
                    const s = e.howMany - (r.splitPosition.offset - e.sourcePosition.offset);
                    return r.howMany -= s, r.splitPosition.hasSameParentAs(e.targetPosition) && r.splitPosition.offset < e.targetPosition.offset && (r.howMany += e.howMany), r.splitPosition = e.sourcePosition.clone(), r.insertionPosition = Cn.getInsertionPosition(r.splitPosition), [r]
                }
                return e.sourcePosition.isEqual(e.targetPosition) || (r.splitPosition.hasSameParentAs(e.sourcePosition) && r.splitPosition.offset <= e.sourcePosition.offset && (r.howMany -= e.howMany), r.splitPosition.hasSameParentAs(e.targetPosition) && r.splitPosition.offset < e.targetPosition.offset && (r.howMany += e.howMany)), r.splitPosition.stickiness = "toNone", r.splitPosition = r.splitPosition._getTransformedByMoveOperation(e), r.splitPosition.stickiness = "toNext", r.graveyardPosition ? r.insertionPosition = r.insertionPosition._getTransformedByMoveOperation(e) : r.insertionPosition = Cn.getInsertionPosition(r.splitPosition), [r]
            }), Jt(Cn, Cn, (r, e, t) => {
                if (r.splitPosition.isEqual(e.splitPosition)) {
                    if (!r.graveyardPosition && !e.graveyardPosition) return [new hr(0)];
                    if (r.graveyardPosition && e.graveyardPosition && r.graveyardPosition.isEqual(e.graveyardPosition)) return [new hr(0)];
                    if (t.abRelation == "splitBefore") return r.howMany = 0, r.graveyardPosition = r.graveyardPosition._getTransformedBySplitOperation(e), [r]
                }
                if (r.graveyardPosition && e.graveyardPosition && r.graveyardPosition.isEqual(e.graveyardPosition)) {
                    const n = r.splitPosition.root.rootName == "$graveyard",
                        i = e.splitPosition.root.rootName == "$graveyard";
                    if (i && !n || !(n && !i) && t.aIsStrong) {
                        const s = [];
                        return e.howMany && s.push(new on(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), r.howMany && s.push(new on(r.splitPosition, r.howMany, r.moveTargetPosition, 0)), s
                    }
                    return [new hr(0)]
                }
                if (r.graveyardPosition && (r.graveyardPosition = r.graveyardPosition._getTransformedBySplitOperation(e)), r.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore") return r.howMany++, [r];
                if (e.splitPosition.isEqual(r.insertionPosition) && t.baRelation == "splitBefore") {
                    const n = e.insertionPosition.path.slice();
                    n.push(0);
                    const i = new Fe(e.insertionPosition.root, n);
                    return [r, new on(r.insertionPosition, 1, i, 0)]
                }
                return r.splitPosition.hasSameParentAs(e.splitPosition) && r.splitPosition.offset < e.splitPosition.offset && (r.howMany -= e.howMany), r.splitPosition = r.splitPosition._getTransformedBySplitOperation(e), r.insertionPosition = Cn.getInsertionPosition(r.splitPosition), [r]
            });

            class Fr extends Le(Fe) {
                constructor(e, t, n = "toNone") {
                    if (super(e, t, n), !this.root.is("rootElement")) throw new R("model-liveposition-root-not-rootelement", e);
                    t3.call(this)
                }

                detach() {
                    this.stopListening()
                }

                toPosition() {
                    return new Fe(this.root, this.path.slice(), this.stickiness)
                }

                static fromPosition(e, t) {
                    return new this(e.root, e.path.slice(), t || e.stickiness)
                }
            }

            function t3() {
                this.listenTo(this.root.document.model, "applyOperation", (r, e) => {
                    const t = e[0];
                    t.isDocumentOperation && n3.call(this, t)
                }, {priority: "low"})
            }

            function n3(r) {
                const e = this.getTransformedByOperation(r);
                if (!this.isEqual(e)) {
                    const t = this.toPosition();
                    this.path = e.path, this.root = e.root, this.fire("change", t)
                }
            }

            Fr.prototype.is = function (r) {
                return r === "livePosition" || r === "model:livePosition" || r == "position" || r === "model:position"
            };

            class pu {
                constructor(e = {}) {
                    typeof e == "string" && (e = e === "transparent" ? {isUndoable: !1} : {}, ae("batch-constructor-deprecated-string-type"));
                    const {isUndoable: t = !0, isLocal: n = !0, isUndo: i = !1, isTyping: s = !1} = e;
                    this.operations = [], this.isUndoable = t, this.isLocal = n, this.isUndo = i, this.isTyping = s
                }

                get type() {
                    return ae("batch-type-deprecated"), "default"
                }

                get baseVersion() {
                    for (const e of this.operations) if (e.baseVersion !== null) return e.baseVersion;
                    return null
                }

                addOperation(e) {
                    return e.batch = this, this.operations.push(e), e
                }
            }

            var r3 = Object.defineProperty, i3 = Object.defineProperties, o3 = Object.getOwnPropertyDescriptors,
                Dw = Object.getOwnPropertySymbols, s3 = Object.prototype.hasOwnProperty,
                a3 = Object.prototype.propertyIsEnumerable, xw = (r, e, t) => e in r ? r3(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, Ew = (r, e) => {
                    for (var t in e || (e = {})) s3.call(e, t) && xw(r, t, e[t]);
                    if (Dw) for (var t of Dw(e)) a3.call(e, t) && xw(r, t, e[t]);
                    return r
                };

            class l3 {
                constructor(e) {
                    this._changesInElement = new Map, this._elementSnapshots = new Map, this._changedMarkers = new Map, this._changedRoots = new Map, this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = new Set, this._markerCollection = e
                }

                get isEmpty() {
                    return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0
                }

                bufferOperation(e) {
                    const t = e;
                    switch (t.type) {
                        case"insert":
                            if (this._isInInsertedElement(t.position.parent)) return;
                            this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
                            break;
                        case"addAttribute":
                        case"removeAttribute":
                        case"changeAttribute":
                            for (const n of t.range.getItems({shallow: !0})) this._isInInsertedElement(n.parent) || this._markAttribute(n);
                            break;
                        case"remove":
                        case"move":
                        case"reinsert": {
                            if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)) return;
                            const n = this._isInInsertedElement(t.sourcePosition.parent),
                                i = this._isInInsertedElement(t.targetPosition.parent);
                            n || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), i || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
                            break
                        }
                        case"rename": {
                            if (this._isInInsertedElement(t.position.parent)) return;
                            this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
                            const n = Ee._createFromPositionAndShift(t.position, 1);
                            for (const i of this._markerCollection.getMarkersIntersectingRange(n)) {
                                const s = i.getData();
                                this.bufferMarkerChange(i.name, s, s)
                            }
                            break
                        }
                        case"split": {
                            const n = t.splitPosition.parent;
                            this._isInInsertedElement(n) || this._markRemove(n, t.splitPosition.offset, t.howMany), this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
                            break
                        }
                        case"merge": {
                            const n = t.sourcePosition.parent;
                            this._isInInsertedElement(n.parent) || this._markRemove(n.parent, n.startOffset, 1);
                            const i = t.graveyardPosition.parent;
                            this._markInsert(i, t.graveyardPosition.offset, 1);
                            const s = t.targetPosition.parent;
                            this._isInInsertedElement(s) || this._markInsert(s, t.targetPosition.offset, n.maxOffset);
                            break
                        }
                        case"detachRoot":
                        case"addRoot": {
                            const n = t.affectedSelectable;
                            if (!n._isLoaded || n.isAttached() == t.isAdd) return;
                            this._bufferRootStateChange(t.rootName, t.isAdd);
                            break
                        }
                        case"addRootAttribute":
                        case"removeRootAttribute":
                        case"changeRootAttribute": {
                            if (!t.root._isLoaded) return;
                            const n = t.root.rootName;
                            this._bufferRootAttributeChange(n, t.key, t.oldValue, t.newValue);
                            break
                        }
                    }
                    this._cachedChanges = null
                }

                bufferMarkerChange(e, t, n) {
                    t.range && t.range.root.is("rootElement") && !t.range.root._isLoaded && (t.range = null), n.range && n.range.root.is("rootElement") && !n.range.root._isLoaded && (n.range = null);
                    let i = this._changedMarkers.get(e);
                    i ? i.newMarkerData = n : (i = {
                        newMarkerData: n,
                        oldMarkerData: t
                    }, this._changedMarkers.set(e, i)), i.oldMarkerData.range == null && n.range == null && this._changedMarkers.delete(e)
                }

                getMarkersToRemove() {
                    const e = [];
                    for (const [t, n] of this._changedMarkers) n.oldMarkerData.range != null && e.push({
                        name: t,
                        range: n.oldMarkerData.range
                    });
                    return e
                }

                getMarkersToAdd() {
                    const e = [];
                    for (const [t, n] of this._changedMarkers) n.newMarkerData.range != null && e.push({
                        name: t,
                        range: n.newMarkerData.range
                    });
                    return e
                }

                getChangedMarkers() {
                    return Array.from(this._changedMarkers).map(([e, t]) => ({
                        name: e,
                        data: {oldRange: t.oldMarkerData.range, newRange: t.newMarkerData.range}
                    }))
                }

                hasDataChanges() {
                    if (this._changesInElement.size > 0 || this._changedRoots.size > 0) return !0;
                    for (const {newMarkerData: e, oldMarkerData: t} of this._changedMarkers.values()) {
                        if (e.affectsData !== t.affectsData) return !0;
                        if (e.affectsData) {
                            const n = e.range && !t.range, i = !e.range && t.range,
                                s = e.range && t.range && !e.range.isEqual(t.range);
                            if (n || i || s) return !0
                        }
                    }
                    return !1
                }

                getChanges(e = {}) {
                    if (this._cachedChanges) return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
                    let t = [];
                    for (const n of this._changesInElement.keys()) {
                        const i = this._changesInElement.get(n).sort((_, x) => _.offset === x.offset ? _.type != x.type ? _.type == "remove" ? -1 : 1 : 0 : _.offset < x.offset ? -1 : 1),
                            s = this._elementSnapshots.get(n), l = Sw(n.getChildren()), d = c3(s.length, i);
                        let g = 0, v = 0;
                        for (const _ of d) if (_ === "i") t.push(this._getInsertDiff(n, g, l[g])), g++; else if (_ === "r") t.push(this._getRemoveDiff(n, g, s[v])), v++; else if (_ === "a") {
                            const x = l[g].attributes, M = s[v].attributes;
                            let O;
                            if (l[g].name == "$text") O = new Ee(Fe._createAt(n, g), Fe._createAt(n, g + 1)); else {
                                const j = n.offsetToIndex(g);
                                O = new Ee(Fe._createAt(n, g), Fe._createAt(n.getChild(j), 0))
                            }
                            t.push(...this._getAttributesDiff(O, M, x)), g++, v++
                        } else g++, v++
                    }
                    t.sort((n, i) => n.position.root != i.position.root ? n.position.root.rootName < i.position.root.rootName ? -1 : 1 : n.position.isEqual(i.position) ? n.changeCount - i.changeCount : n.position.isBefore(i.position) ? -1 : 1);
                    for (let n = 1, i = 0; n < t.length; n++) {
                        const s = t[i], l = t[n],
                            d = s.type == "remove" && l.type == "remove" && s.name == "$text" && l.name == "$text" && s.position.isEqual(l.position),
                            g = s.type == "insert" && l.type == "insert" && s.name == "$text" && l.name == "$text" && s.position.parent == l.position.parent && s.position.offset + s.length == l.position.offset,
                            v = s.type == "attribute" && l.type == "attribute" && s.position.parent == l.position.parent && s.range.isFlat && l.range.isFlat && s.position.offset + s.length == l.position.offset && s.attributeKey == l.attributeKey && s.attributeOldValue == l.attributeOldValue && s.attributeNewValue == l.attributeNewValue;
                        d || g || v ? (s.length++, v && (s.range.end = s.range.end.getShiftedBy(1)), t[n] = null) : i = n
                    }
                    t = t.filter(n => n);
                    for (const n of t) delete n.changeCount, n.type == "attribute" && (delete n.position, delete n.length);
                    return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(u3), e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice()
                }

                getChangedRoots() {
                    return Array.from(this._changedRoots.values()).map(e => {
                        const t = Ew({}, e);
                        return t.state !== void 0 && delete t.attributes, t
                    })
                }

                getRefreshedItems() {
                    return new Set(this._refreshedItems)
                }

                reset() {
                    this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = new Set, this._cachedChanges = null
                }

                _bufferRootStateChange(e, t) {
                    if (!this._changedRoots.has(e)) return void this._changedRoots.set(e, {
                        name: e,
                        state: t ? "attached" : "detached"
                    });
                    const n = this._changedRoots.get(e);
                    n.state !== void 0 ? (delete n.state, n.attributes === void 0 && this._changedRoots.delete(e)) : n.state = t ? "attached" : "detached"
                }

                _bufferRootAttributeChange(e, t, n, i) {
                    const s = this._changedRoots.get(e) || {name: e}, l = s.attributes || {};
                    if (l[t]) {
                        const d = l[t];
                        i === d.oldValue ? delete l[t] : d.newValue = i
                    } else l[t] = {oldValue: n, newValue: i};
                    Object.entries(l).length === 0 ? (delete s.attributes, s.state === void 0 && this._changedRoots.delete(e)) : (s.attributes = l, this._changedRoots.set(e, s))
                }

                _refreshItem(e) {
                    if (this._isInInsertedElement(e.parent)) return;
                    this._markRemove(e.parent, e.startOffset, e.offsetSize), this._markInsert(e.parent, e.startOffset, e.offsetSize), this._refreshedItems.add(e);
                    const t = Ee._createOn(e);
                    for (const n of this._markerCollection.getMarkersIntersectingRange(t)) {
                        const i = n.getData();
                        this.bufferMarkerChange(n.name, i, i)
                    }
                    this._cachedChanges = null
                }

                _bufferRootLoad(e) {
                    if (e.isAttached()) {
                        this._bufferRootStateChange(e.rootName, !0), this._markInsert(e, 0, e.maxOffset);
                        for (const n of e.getAttributeKeys()) this._bufferRootAttributeChange(e.rootName, n, null, e.getAttribute(n));
                        for (const n of this._markerCollection) if (n.getRange().root == e) {
                            const i = n.getData();
                            this.bufferMarkerChange(n.name, (t = Ew({}, i), i3(t, o3({range: null}))), i)
                        }
                        var t
                    }
                }

                _markInsert(e, t, n) {
                    if (e.root.is("rootElement") && !e.root._isLoaded) return;
                    const i = {type: "insert", offset: t, howMany: n, count: this._changeCount++};
                    this._markChange(e, i)
                }

                _markRemove(e, t, n) {
                    if (e.root.is("rootElement") && !e.root._isLoaded) return;
                    const i = {type: "remove", offset: t, howMany: n, count: this._changeCount++};
                    this._markChange(e, i), this._removeAllNestedChanges(e, t, n)
                }

                _markAttribute(e) {
                    if (e.root.is("rootElement") && !e.root._isLoaded) return;
                    const t = {
                        type: "attribute",
                        offset: e.startOffset,
                        howMany: e.offsetSize,
                        count: this._changeCount++
                    };
                    this._markChange(e.parent, t)
                }

                _markChange(e, t) {
                    this._makeSnapshot(e);
                    const n = this._getChangesForElement(e);
                    this._handleChange(t, n), n.push(t);
                    for (let i = 0; i < n.length; i++) n[i].howMany < 1 && (n.splice(i, 1), i--)
                }

                _getChangesForElement(e) {
                    let t;
                    return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [], this._changesInElement.set(e, t)), t
                }

                _makeSnapshot(e) {
                    this._elementSnapshots.has(e) || this._elementSnapshots.set(e, Sw(e.getChildren()))
                }

                _handleChange(e, t) {
                    e.nodesToHandle = e.howMany;
                    for (const n of t) {
                        const i = e.offset + e.howMany, s = n.offset + n.howMany;
                        if (e.type == "insert" && (n.type == "insert" && (e.offset <= n.offset ? n.offset += e.howMany : e.offset < s && (n.howMany += e.nodesToHandle, e.nodesToHandle = 0)), n.type == "remove" && e.offset < n.offset && (n.offset += e.howMany), n.type == "attribute")) {
                            if (e.offset <= n.offset) n.offset += e.howMany; else if (e.offset < s) {
                                const l = n.howMany;
                                n.howMany = e.offset - n.offset, t.unshift({
                                    type: "attribute",
                                    offset: i,
                                    howMany: l - n.howMany,
                                    count: this._changeCount++
                                })
                            }
                        }
                        if (e.type == "remove") {
                            if (n.type == "insert") {
                                if (i <= n.offset) n.offset -= e.howMany; else if (i <= s) if (e.offset < n.offset) {
                                    const l = i - n.offset;
                                    n.offset = e.offset, n.howMany -= l, e.nodesToHandle -= l
                                } else n.howMany -= e.nodesToHandle, e.nodesToHandle = 0; else if (e.offset <= n.offset) e.nodesToHandle -= n.howMany, n.howMany = 0; else if (e.offset < s) {
                                    const l = s - e.offset;
                                    n.howMany -= l, e.nodesToHandle -= l
                                }
                            }
                            if (n.type == "remove" && (i <= n.offset ? n.offset -= e.howMany : e.offset < n.offset && (e.nodesToHandle += n.howMany, n.howMany = 0)), n.type == "attribute") {
                                if (i <= n.offset) n.offset -= e.howMany; else if (e.offset < n.offset) {
                                    const l = i - n.offset;
                                    n.offset = e.offset, n.howMany -= l
                                } else if (e.offset < s) if (i <= s) {
                                    const l = n.howMany;
                                    n.howMany = e.offset - n.offset;
                                    const d = l - n.howMany - e.nodesToHandle;
                                    t.unshift({
                                        type: "attribute",
                                        offset: e.offset,
                                        howMany: d,
                                        count: this._changeCount++
                                    })
                                } else n.howMany -= s - e.offset
                            }
                        }
                        if (e.type == "attribute") {
                            if (n.type == "insert") if (e.offset < n.offset && i > n.offset) {
                                if (i > s) {
                                    const l = {
                                        type: "attribute",
                                        offset: s,
                                        howMany: i - s,
                                        count: this._changeCount++
                                    };
                                    this._handleChange(l, t), t.push(l)
                                }
                                e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle
                            } else e.offset >= n.offset && e.offset < s && (i > s ? (e.nodesToHandle = i - s, e.offset = s) : e.nodesToHandle = 0);
                            if (n.type == "remove" && e.offset < n.offset && i > n.offset) {
                                const l = {
                                    type: "attribute",
                                    offset: n.offset,
                                    howMany: i - n.offset,
                                    count: this._changeCount++
                                };
                                this._handleChange(l, t), t.push(l), e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle
                            }
                            n.type == "attribute" && (e.offset >= n.offset && i <= s ? (e.nodesToHandle = 0, e.howMany = 0, e.offset = 0) : e.offset <= n.offset && i >= s && (n.howMany = 0))
                        }
                    }
                    e.howMany = e.nodesToHandle, delete e.nodesToHandle
                }

                _getInsertDiff(e, t, n) {
                    return {
                        type: "insert",
                        position: Fe._createAt(e, t),
                        name: n.name,
                        attributes: new Map(n.attributes),
                        length: 1,
                        changeCount: this._changeCount++
                    }
                }

                _getRemoveDiff(e, t, n) {
                    return {
                        type: "remove",
                        position: Fe._createAt(e, t),
                        name: n.name,
                        attributes: new Map(n.attributes),
                        length: 1,
                        changeCount: this._changeCount++
                    }
                }

                _getAttributesDiff(e, t, n) {
                    const i = [];
                    n = new Map(n);
                    for (const [s, l] of t) {
                        const d = n.has(s) ? n.get(s) : null;
                        d !== l && i.push({
                            type: "attribute",
                            position: e.start,
                            range: e.clone(),
                            length: 1,
                            attributeKey: s,
                            attributeOldValue: l,
                            attributeNewValue: d,
                            changeCount: this._changeCount++
                        }), n.delete(s)
                    }
                    for (const [s, l] of n) i.push({
                        type: "attribute",
                        position: e.start,
                        range: e.clone(),
                        length: 1,
                        attributeKey: s,
                        attributeOldValue: null,
                        attributeNewValue: l,
                        changeCount: this._changeCount++
                    });
                    return i
                }

                _isInInsertedElement(e) {
                    const t = e.parent;
                    if (!t) return !1;
                    const n = this._changesInElement.get(t), i = e.startOffset;
                    if (n) {
                        for (const s of n) if (s.type == "insert" && i >= s.offset && i < s.offset + s.howMany) return !0
                    }
                    return this._isInInsertedElement(t)
                }

                _removeAllNestedChanges(e, t, n) {
                    const i = new Ee(Fe._createAt(e, t), Fe._createAt(e, t + n));
                    for (const s of i.getItems({shallow: !0})) s.is("element") && (this._elementSnapshots.delete(s), this._changesInElement.delete(s), this._removeAllNestedChanges(s, 0, s.maxOffset))
                }
            }

            function Sw(r) {
                const e = [];
                for (const t of r) if (t.is("$text")) for (let n = 0; n < t.data.length; n++) e.push({
                    name: "$text",
                    attributes: new Map(t.getAttributes())
                }); else e.push({name: t.name, attributes: new Map(t.getAttributes())});
                return e
            }

            function c3(r, e) {
                const t = [];
                let n = 0, i = 0;
                for (const s of e) {
                    if (s.offset > n) {
                        for (let l = 0; l < s.offset - n; l++) t.push("e");
                        i += s.offset - n
                    }
                    if (s.type == "insert") {
                        for (let l = 0; l < s.howMany; l++) t.push("i");
                        n = s.offset + s.howMany
                    } else if (s.type == "remove") {
                        for (let l = 0; l < s.howMany; l++) t.push("r");
                        n = s.offset, i += s.howMany
                    } else t.push(..."a".repeat(s.howMany).split("")), n = s.offset + s.howMany, i += s.howMany
                }
                if (i < r) for (let s = 0; s < r - i - n; s++) t.push("e");
                return t
            }

            function u3(r) {
                const e = "position" in r && r.position.root.rootName == "$graveyard",
                    t = "range" in r && r.range.root.rootName == "$graveyard";
                return !e && !t
            }

            class d3 {
                constructor() {
                    this._operations = [], this._undoPairs = new Map, this._undoneOperations = new Set, this._baseVersionToOperationIndex = new Map, this._version = 0, this._gaps = new Map
                }

                get version() {
                    return this._version
                }

                set version(e) {
                    this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e), this._version = e
                }

                get lastOperation() {
                    return this._operations[this._operations.length - 1]
                }

                addOperation(e) {
                    if (e.baseVersion !== this.version) throw new R("model-document-history-addoperation-incorrect-version", this, {
                        operation: e,
                        historyVersion: this.version
                    });
                    this._operations.push(e), this._version++, this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1)
                }

                getOperations(e, t = this.version) {
                    if (!this._operations.length) return [];
                    const n = this._operations[0];
                    e === void 0 && (e = n.baseVersion);
                    let i = t - 1;
                    for (const [d, g] of this._gaps) e > d && e < g && (e = g), i > d && i < g && (i = d - 1);
                    if (i < n.baseVersion || e > this.lastOperation.baseVersion) return [];
                    let s = this._baseVersionToOperationIndex.get(e);
                    s === void 0 && (s = 0);
                    let l = this._baseVersionToOperationIndex.get(i);
                    return l === void 0 && (l = this._operations.length - 1), this._operations.slice(s, l + 1)
                }

                getOperation(e) {
                    const t = this._baseVersionToOperationIndex.get(e);
                    if (t !== void 0) return this._operations[t]
                }

                setOperationAsUndone(e, t) {
                    this._undoPairs.set(t, e), this._undoneOperations.add(e)
                }

                isUndoingOperation(e) {
                    return this._undoPairs.has(e)
                }

                isUndoneOperation(e) {
                    return this._undoneOperations.has(e)
                }

                getUndoneOperation(e) {
                    return this._undoPairs.get(e)
                }

                reset() {
                    this._version = 0, this._undoPairs = new Map, this._operations = [], this._undoneOperations = new Set, this._gaps = new Map, this._baseVersionToOperationIndex = new Map
                }
            }

            class Ig extends pn {
                constructor(e, t, n = "main") {
                    super(t), this._isAttached = !0, this._isLoaded = !0, this._document = e, this.rootName = n
                }

                get document() {
                    return this._document
                }

                isAttached() {
                    return this._isAttached
                }

                toJSON() {
                    return this.rootName
                }
            }

            Ig.prototype.is = function (r, e) {
                return e ? e === this.name && (r === "rootElement" || r === "model:rootElement" || r === "element" || r === "model:element") : r === "rootElement" || r === "model:rootElement" || r === "element" || r === "model:element" || r === "node" || r === "model:node"
            };
            var h3 = Object.defineProperty, f3 = Object.defineProperties, g3 = Object.getOwnPropertyDescriptors,
                Tw = Object.getOwnPropertySymbols, p3 = Object.prototype.hasOwnProperty,
                m3 = Object.prototype.propertyIsEnumerable, Iw = (r, e, t) => e in r ? h3(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, Mw = (r, e) => {
                    for (var t in e || (e = {})) p3.call(e, t) && Iw(r, t, e[t]);
                    if (Tw) for (var t of Tw(e)) m3.call(e, t) && Iw(r, t, e[t]);
                    return r
                }, Bw = (r, e) => f3(r, g3(e));
            const Nw = "$graveyard";

            class b3 extends Le() {
                constructor(e) {
                    super(), this.model = e, this.history = new d3, this.selection = new Co(this), this.roots = new br({idProperty: "rootName"}), this.differ = new l3(e.markers), this.isReadOnly = !1, this._postFixers = new Set, this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", Nw), this.listenTo(e, "applyOperation", (t, n) => {
                        const i = n[0];
                        i.isDocumentOperation && this.differ.bufferOperation(i)
                    }, {priority: "high"}), this.listenTo(e, "applyOperation", (t, n) => {
                        const i = n[0];
                        i.isDocumentOperation && this.history.addOperation(i)
                    }, {priority: "low"}), this.listenTo(this.selection, "change", () => {
                        this._hasSelectionChangedFromTheLastChangeBlock = !0
                    }), this.listenTo(e.markers, "update", (t, n, i, s, l) => {
                        const d = Bw(Mw({}, n.getData()), {range: s});
                        this.differ.bufferMarkerChange(n.name, l, d), i === null && n.on("change", (g, v) => {
                            const _ = n.getData();
                            this.differ.bufferMarkerChange(n.name, Bw(Mw({}, _), {range: v}), _)
                        })
                    }), this.registerPostFixer(t => {
                        let n = !1;
                        for (const i of this.roots) i.isAttached() || i.isEmpty || (t.remove(t.createRangeIn(i)), n = !0);
                        for (const i of this.model.markers) i.getRange().root.isAttached() || (t.removeMarker(i), n = !0);
                        return n
                    })
                }

                get version() {
                    return this.history.version
                }

                set version(e) {
                    this.history.version = e
                }

                get graveyard() {
                    return this.getRoot(Nw)
                }

                createRoot(e = "$root", t = "main") {
                    if (this.roots.get(t)) throw new R("model-document-createroot-name-exists", this, {name: t});
                    const n = new Ig(this, e, t);
                    return this.roots.add(n), n
                }

                destroy() {
                    this.selection.destroy(), this.stopListening()
                }

                getRoot(e = "main") {
                    return this.roots.get(e)
                }

                getRootNames(e = !1) {
                    return this.getRoots(e).map(t => t.rootName)
                }

                getRoots(e = !1) {
                    return this.roots.filter(t => t != this.graveyard && (e || t.isAttached()) && t._isLoaded)
                }

                registerPostFixer(e) {
                    this._postFixers.add(e)
                }

                toJSON() {
                    const e = cg(this);
                    return e.selection = "[engine.model.DocumentSelection]", e.model = "[engine.model.Model]", e
                }

                _handleChangeBlock(e) {
                    this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1
                }

                _hasDocumentChangedFromTheLastChangeBlock() {
                    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
                }

                _getDefaultRoot() {
                    const e = this.getRoots();
                    return e.length ? e[0] : this.graveyard
                }

                _getDefaultRange() {
                    const e = this._getDefaultRoot(), t = this.model, n = t.schema,
                        i = t.createPositionFromPath(e, [0]);
                    return n.getNearestSelectionRange(i) || t.createRange(i)
                }

                _validateSelectionRange(e) {
                    return Lw(e.start) && Lw(e.end)
                }

                _callPostFixers(e) {
                    let t = !1;
                    do for (const n of this._postFixers) if (this.selection.refresh(), t = n(e), t) break; while (t)
                }
            }

            function Lw(r) {
                const e = r.textNode;
                if (e) {
                    const t = e.data, n = r.offset - e.startOffset;
                    return !Cd(t, n) && !_r(t, n)
                }
                return !0
            }

            var k3 = Object.defineProperty, v3 = Object.defineProperties, w3 = Object.getOwnPropertyDescriptors,
                Pw = Object.getOwnPropertySymbols, A3 = Object.prototype.hasOwnProperty,
                C3 = Object.prototype.propertyIsEnumerable, Ow = (r, e, t) => e in r ? k3(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            class _3 extends Le() {
                constructor() {
                    super(...arguments), this._markers = new Map
                }

                [Symbol.iterator]() {
                    return this._markers.values()
                }

                has(e) {
                    const t = e instanceof mu ? e.name : e;
                    return this._markers.has(t)
                }

                get(e) {
                    return this._markers.get(e) || null
                }

                _set(e, t, n = !1, i = !1) {
                    const s = e instanceof mu ? e.name : e;
                    if (s.includes(",")) throw new R("markercollection-incorrect-marker-name", this);
                    const l = this._markers.get(s);
                    if (l) {
                        const _ = l.getData(), x = l.getRange();
                        let M = !1;
                        return x.isEqual(t) || (l._attachLiveRange(Ii.fromRange(t)), M = !0), n != l.managedUsingOperations && (l._managedUsingOperations = n, M = !0), typeof i == "boolean" && i != l.affectsData && (l._affectsData = i, M = !0), M && this.fire(`update:${s}`, l, x, t, _), l
                    }
                    const d = Ii.fromRange(t), g = new mu(s, d, n, i);
                    var v;
                    return this._markers.set(s, g), this.fire(`update:${s}`, g, null, t, (v = ((_, x) => {
                        for (var M in x || (x = {})) A3.call(x, M) && Ow(_, M, x[M]);
                        if (Pw) for (var M of Pw(x)) C3.call(x, M) && Ow(_, M, x[M]);
                        return _
                    })({}, g.getData()), v3(v, w3({range: null})))), g
                }

                _remove(e) {
                    const t = e instanceof mu ? e.name : e, n = this._markers.get(t);
                    return !!n && (this._markers.delete(t), this.fire(`update:${t}`, n, n.getRange(), null, n.getData()), this._destroyMarker(n), !0)
                }

                _refresh(e) {
                    const t = e instanceof mu ? e.name : e, n = this._markers.get(t);
                    if (!n) throw new R("markercollection-refresh-marker-not-exists", this);
                    const i = n.getRange();
                    this.fire(`update:${t}`, n, i, i, n.getData())
                }

                * getMarkersAtPosition(e) {
                    for (const t of this) t.getRange().containsPosition(e) && (yield t)
                }

                * getMarkersIntersectingRange(e) {
                    for (const t of this) t.getRange().getIntersection(e) !== null && (yield t)
                }

                destroy() {
                    for (const e of this._markers.values()) this._destroyMarker(e);
                    this._markers = null, this.stopListening()
                }

                * getMarkersGroup(e) {
                    for (const t of this._markers.values()) t.name.startsWith(e + ":") && (yield t)
                }

                _destroyMarker(e) {
                    e.stopListening(), e._detachLiveRange()
                }
            }

            class mu extends Le(Ta) {
                constructor(e, t, n, i) {
                    super(), this.name = e, this._liveRange = this._attachLiveRange(t), this._managedUsingOperations = n, this._affectsData = i
                }

                get managedUsingOperations() {
                    if (!this._liveRange) throw new R("marker-destroyed", this);
                    return this._managedUsingOperations
                }

                get affectsData() {
                    if (!this._liveRange) throw new R("marker-destroyed", this);
                    return this._affectsData
                }

                getData() {
                    return {
                        range: this.getRange(),
                        affectsData: this.affectsData,
                        managedUsingOperations: this.managedUsingOperations
                    }
                }

                getStart() {
                    if (!this._liveRange) throw new R("marker-destroyed", this);
                    return this._liveRange.start.clone()
                }

                getEnd() {
                    if (!this._liveRange) throw new R("marker-destroyed", this);
                    return this._liveRange.end.clone()
                }

                getRange() {
                    if (!this._liveRange) throw new R("marker-destroyed", this);
                    return this._liveRange.toRange()
                }

                _attachLiveRange(e) {
                    return this._liveRange && this._detachLiveRange(), e.delegate("change:range").to(this), e.delegate("change:content").to(this), this._liveRange = e, e
                }

                _detachLiveRange() {
                    this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null
                }
            }

            mu.prototype.is = function (r) {
                return r === "marker" || r === "model:marker"
            };

            class y3 extends Mi {
                constructor(e, t) {
                    super(null), this.sourcePosition = e.clone(), this.howMany = t
                }

                get type() {
                    return "detach"
                }

                get affectedSelectable() {
                    return null
                }

                toJSON() {
                    const e = super.toJSON();
                    return e.sourcePosition = this.sourcePosition.toJSON(), e
                }

                _validate() {
                    if (this.sourcePosition.root.document) throw new R("detach-operation-on-document-node", this)
                }

                _execute() {
                    mw(Ee._createFromPositionAndShift(this.sourcePosition, this.howMany))
                }

                static get className() {
                    return "DetachOperation"
                }
            }

            class Bs extends Ta {
                constructor(e) {
                    super(), this.markers = new Map, this._children = new th, e && this._insertChild(0, e)
                }

                [Symbol.iterator]() {
                    return this.getChildren()
                }

                get childCount() {
                    return this._children.length
                }

                get maxOffset() {
                    return this._children.maxOffset
                }

                get isEmpty() {
                    return this.childCount === 0
                }

                get nextSibling() {
                    return null
                }

                get previousSibling() {
                    return null
                }

                get root() {
                    return this
                }

                get parent() {
                    return null
                }

                get document() {
                    return null
                }

                isAttached() {
                    return !1
                }

                getAncestors() {
                    return []
                }

                getChild(e) {
                    return this._children.getNode(e)
                }

                getChildren() {
                    return this._children[Symbol.iterator]()
                }

                getChildIndex(e) {
                    return this._children.getNodeIndex(e)
                }

                getChildStartOffset(e) {
                    return this._children.getNodeStartOffset(e)
                }

                getPath() {
                    return []
                }

                getNodeByPath(e) {
                    let t = this;
                    for (const n of e) t = t.getChild(t.offsetToIndex(n));
                    return t
                }

                offsetToIndex(e) {
                    return this._children.offsetToIndex(e)
                }

                toJSON() {
                    const e = [];
                    for (const t of this._children) e.push(t.toJSON());
                    return e
                }

                static fromJSON(e) {
                    const t = [];
                    for (const n of e) n.name ? t.push(pn.fromJSON(n)) : t.push(An.fromJSON(n));
                    return new Bs(t)
                }

                _appendChild(e) {
                    this._insertChild(this.childCount, e)
                }

                _insertChild(e, t) {
                    const n = function (i) {
                        return typeof i == "string" ? [new An(i)] : (oe(i) || (i = [i]), Array.from(i).map(s => typeof s == "string" ? new An(s) : s instanceof wo ? new An(s.data, s.getAttributes()) : s))
                    }(t);
                    for (const i of n) i.parent !== null && i._remove(), i.parent = this;
                    this._children._insertNodes(e, n)
                }

                _removeChildren(e, t = 1) {
                    const n = this._children._removeNodes(e, t);
                    for (const i of n) i.parent = null;
                    return n
                }
            }

            Bs.prototype.is = function (r) {
                return r === "documentFragment" || r === "model:documentFragment"
            };

            class D3 {
                constructor(e, t) {
                    this.model = e, this.batch = t
                }

                createText(e, t) {
                    return new An(e, t)
                }

                createElement(e, t) {
                    return new pn(e, t)
                }

                createDocumentFragment() {
                    return new Bs
                }

                cloneElement(e, t = !0) {
                    return e._clone(t)
                }

                insert(e, t, n = 0) {
                    if (this._assertWriterUsedCorrectly(), e instanceof An && e.data == "") return;
                    const i = Fe._createAt(t, n);
                    if (e.parent) {
                        if (zw(e.root, i.root)) return void this.move(Ee._createOn(e), i);
                        if (e.root.document) throw new R("model-writer-insert-forbidden-move", this);
                        this.remove(e)
                    }
                    const s = i.root.document ? i.root.document.version : null, l = new Dr(i, e, s);
                    if (e instanceof An && (l.shouldReceiveAttributes = !0), this.batch.addOperation(l), this.model.applyOperation(l), e instanceof Bs) for (const [d, g] of e.markers) {
                        const v = Fe._createAt(g.root, 0), _ = {
                            range: new Ee(g.start._getCombined(v, i), g.end._getCombined(v, i)),
                            usingOperation: !0,
                            affectsData: !0
                        };
                        this.model.markers.has(d) ? this.updateMarker(d, _) : this.addMarker(d, _)
                    }
                }

                insertText(e, t, n, i) {
                    t instanceof Bs || t instanceof pn || t instanceof Fe ? this.insert(this.createText(e), t, n) : this.insert(this.createText(e, t), n, i)
                }

                insertElement(e, t, n, i) {
                    t instanceof Bs || t instanceof pn || t instanceof Fe ? this.insert(this.createElement(e), t, n) : this.insert(this.createElement(e, t), n, i)
                }

                append(e, t) {
                    this.insert(e, t, "end")
                }

                appendText(e, t, n) {
                    t instanceof Bs || t instanceof pn ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), n, "end")
                }

                appendElement(e, t, n) {
                    t instanceof Bs || t instanceof pn ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), n, "end")
                }

                setAttribute(e, t, n) {
                    if (this._assertWriterUsedCorrectly(), n instanceof Ee) {
                        const i = n.getMinimalFlatRanges();
                        for (const s of i) Fw(this, e, t, s)
                    } else Rw(this, e, t, n)
                }

                setAttributes(e, t) {
                    for (const [n, i] of qi(e)) this.setAttribute(n, i, t)
                }

                removeAttribute(e, t) {
                    if (this._assertWriterUsedCorrectly(), t instanceof Ee) {
                        const n = t.getMinimalFlatRanges();
                        for (const i of n) Fw(this, e, null, i)
                    } else Rw(this, e, null, t)
                }

                clearAttributes(e) {
                    this._assertWriterUsedCorrectly();
                    const t = n => {
                        for (const i of n.getAttributeKeys()) this.removeAttribute(i, n)
                    };
                    if (e instanceof Ee) for (const n of e.getItems()) t(n); else t(e)
                }

                move(e, t, n) {
                    if (this._assertWriterUsedCorrectly(), !(e instanceof Ee)) throw new R("writer-move-invalid-range", this);
                    if (!e.isFlat) throw new R("writer-move-range-not-flat", this);
                    const i = Fe._createAt(t, n);
                    if (i.isEqual(e.start)) return;
                    if (this._addOperationForAffectedMarkers("move", e), !zw(e.root, i.root)) throw new R("writer-move-different-document", this);
                    const s = e.root.document ? e.root.document.version : null,
                        l = new on(e.start, e.end.offset - e.start.offset, i, s);
                    this.batch.addOperation(l), this.model.applyOperation(l)
                }

                remove(e) {
                    this._assertWriterUsedCorrectly();
                    const t = (e instanceof Ee ? e : Ee._createOn(e)).getMinimalFlatRanges().reverse();
                    for (const n of t) this._addOperationForAffectedMarkers("move", n), x3(n.start, n.end.offset - n.start.offset, this.batch, this.model)
                }

                merge(e) {
                    this._assertWriterUsedCorrectly();
                    const t = e.nodeBefore, n = e.nodeAfter;
                    if (this._addOperationForAffectedMarkers("merge", e), !(t instanceof pn)) throw new R("writer-merge-no-element-before", this);
                    if (!(n instanceof pn)) throw new R("writer-merge-no-element-after", this);
                    e.root.document ? this._merge(e) : this._mergeDetached(e)
                }

                createPositionFromPath(e, t, n) {
                    return this.model.createPositionFromPath(e, t, n)
                }

                createPositionAt(e, t) {
                    return this.model.createPositionAt(e, t)
                }

                createPositionAfter(e) {
                    return this.model.createPositionAfter(e)
                }

                createPositionBefore(e) {
                    return this.model.createPositionBefore(e)
                }

                createRange(e, t) {
                    return this.model.createRange(e, t)
                }

                createRangeIn(e) {
                    return this.model.createRangeIn(e)
                }

                createRangeOn(e) {
                    return this.model.createRangeOn(e)
                }

                createSelection(...e) {
                    return this.model.createSelection(...e)
                }

                _mergeDetached(e) {
                    const t = e.nodeBefore, n = e.nodeAfter;
                    this.move(Ee._createIn(n), Fe._createAt(t, "end")), this.remove(n)
                }

                _merge(e) {
                    const t = Fe._createAt(e.nodeBefore, "end"), n = Fe._createAt(e.nodeAfter, 0),
                        i = e.root.document.graveyard, s = new Fe(i, [0]), l = e.root.document.version,
                        d = new Yn(n, e.nodeAfter.maxOffset, t, s, l);
                    this.batch.addOperation(d), this.model.applyOperation(d)
                }

                rename(e, t) {
                    if (this._assertWriterUsedCorrectly(), !(e instanceof pn)) throw new R("writer-rename-not-element-instance", this);
                    const n = e.root.document ? e.root.document.version : null,
                        i = new ci(Fe._createBefore(e), e.name, t, n);
                    this.batch.addOperation(i), this.model.applyOperation(i)
                }

                split(e, t) {
                    this._assertWriterUsedCorrectly();
                    let n, i, s = e.parent;
                    if (!s.parent) throw new R("writer-split-element-no-parent", this);
                    if (t || (t = s.parent), !e.parent.getAncestors({includeSelf: !0}).includes(t)) throw new R("writer-split-invalid-limit-element", this);
                    do {
                        const l = s.root.document ? s.root.document.version : null, d = s.maxOffset - e.offset,
                            g = Cn.getInsertionPosition(e), v = new Cn(e, d, g, null, l);
                        this.batch.addOperation(v), this.model.applyOperation(v), n || i || (n = s, i = e.parent.nextSibling), s = (e = this.createPositionAfter(e.parent)).parent
                    } while (s !== t);
                    return {position: e, range: new Ee(Fe._createAt(n, "end"), Fe._createAt(i, 0))}
                }

                wrap(e, t) {
                    if (this._assertWriterUsedCorrectly(), !e.isFlat) throw new R("writer-wrap-range-not-flat", this);
                    const n = t instanceof pn ? t : new pn(t);
                    if (n.childCount > 0) throw new R("writer-wrap-element-not-empty", this);
                    if (n.parent !== null) throw new R("writer-wrap-element-attached", this);
                    this.insert(n, e.start);
                    const i = new Ee(e.start.getShiftedBy(1), e.end.getShiftedBy(1));
                    this.move(i, Fe._createAt(n, 0))
                }

                unwrap(e) {
                    if (this._assertWriterUsedCorrectly(), e.parent === null) throw new R("writer-unwrap-element-no-parent", this);
                    this.move(Ee._createIn(e), this.createPositionAfter(e)), this.remove(e)
                }

                addMarker(e, t) {
                    if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean") throw new R("writer-addmarker-no-usingoperation", this);
                    const n = t.usingOperation, i = t.range, s = t.affectsData !== void 0 && t.affectsData;
                    if (this.model.markers.has(e)) throw new R("writer-addmarker-marker-exists", this);
                    if (!i) throw new R("writer-addmarker-no-range", this);
                    return n ? (ch(this, e, null, i, s), this.model.markers.get(e)) : this.model.markers._set(e, i, n, s)
                }

                updateMarker(e, t) {
                    this._assertWriterUsedCorrectly();
                    const n = typeof e == "string" ? e : e.name, i = this.model.markers.get(n);
                    if (!i) throw new R("writer-updatemarker-marker-not-exists", this);
                    if (!t) return ae("writer-updatemarker-reconvert-using-editingcontroller", {markerName: n}), void this.model.markers._refresh(i);
                    const s = typeof t.usingOperation == "boolean", l = typeof t.affectsData == "boolean",
                        d = l ? t.affectsData : i.affectsData;
                    if (!s && !t.range && !l) throw new R("writer-updatemarker-wrong-options", this);
                    const g = i.getRange(), v = t.range ? t.range : g;
                    s && t.usingOperation !== i.managedUsingOperations ? t.usingOperation ? ch(this, n, null, v, d) : (ch(this, n, g, null, d), this.model.markers._set(n, v, void 0, d)) : i.managedUsingOperations ? ch(this, n, g, v, d) : this.model.markers._set(n, v, void 0, d)
                }

                removeMarker(e) {
                    this._assertWriterUsedCorrectly();
                    const t = typeof e == "string" ? e : e.name;
                    if (!this.model.markers.has(t)) throw new R("writer-removemarker-no-marker", this);
                    const n = this.model.markers.get(t);
                    if (!n.managedUsingOperations) return void this.model.markers._remove(t);
                    ch(this, t, n.getRange(), null, n.affectsData)
                }

                addRoot(e, t = "$root") {
                    this._assertWriterUsedCorrectly();
                    const n = this.model.document.getRoot(e);
                    if (n && n.isAttached()) throw new R("writer-addroot-root-exists", this);
                    const i = this.model.document, s = new Xo(e, t, !0, i, i.version);
                    return this.batch.addOperation(s), this.model.applyOperation(s), this.model.document.getRoot(e)
                }

                detachRoot(e) {
                    this._assertWriterUsedCorrectly();
                    const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
                    if (!t || !t.isAttached()) throw new R("writer-detachroot-no-root", this);
                    for (const s of this.model.markers) s.getRange().root === t && this.removeMarker(s);
                    for (const s of t.getAttributeKeys()) this.removeAttribute(s, t);
                    this.remove(this.createRangeIn(t));
                    const n = this.model.document, i = new Xo(t.rootName, t.name, !1, n, n.version);
                    this.batch.addOperation(i), this.model.applyOperation(i)
                }

                setSelection(...e) {
                    this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...e)
                }

                setSelectionFocus(e, t) {
                    this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e, t)
                }

                setSelectionAttribute(e, t) {
                    if (this._assertWriterUsedCorrectly(), typeof e == "string") this._setSelectionAttribute(e, t); else for (const [n, i] of qi(e)) this._setSelectionAttribute(n, i)
                }

                removeSelectionAttribute(e) {
                    if (this._assertWriterUsedCorrectly(), typeof e == "string") this._removeSelectionAttribute(e); else for (const t of e) this._removeSelectionAttribute(t)
                }

                overrideSelectionGravity() {
                    return this.model.document.selection._overrideGravity()
                }

                restoreSelectionGravity(e) {
                    this.model.document.selection._restoreGravity(e)
                }

                _setSelectionAttribute(e, t) {
                    const n = this.model.document.selection;
                    if (n.isCollapsed && n.anchor.parent.isEmpty) {
                        const i = Co._getStoreAttributeKey(e);
                        this.setAttribute(i, t, n.anchor.parent)
                    }
                    n._setAttribute(e, t)
                }

                _removeSelectionAttribute(e) {
                    const t = this.model.document.selection;
                    if (t.isCollapsed && t.anchor.parent.isEmpty) {
                        const n = Co._getStoreAttributeKey(e);
                        this.removeAttribute(n, t.anchor.parent)
                    }
                    t._removeAttribute(e)
                }

                _assertWriterUsedCorrectly() {
                    if (this.model._currentWriter !== this) throw new R("writer-incorrect-use", this)
                }

                _addOperationForAffectedMarkers(e, t) {
                    for (const n of this.model.markers) {
                        if (!n.managedUsingOperations) continue;
                        const i = n.getRange();
                        let s = !1;
                        if (e === "move") {
                            const l = t;
                            s = l.containsPosition(i.start) || l.start.isEqual(i.start) || l.containsPosition(i.end) || l.end.isEqual(i.end)
                        } else {
                            const l = t, d = l.nodeBefore, g = l.nodeAfter, v = i.start.parent == d && i.start.isAtEnd,
                                _ = i.end.parent == g && i.end.offset == 0, x = i.end.nodeAfter == g,
                                M = i.start.nodeAfter == g;
                            s = v || _ || x || M
                        }
                        s && this.updateMarker(n.name, {range: i})
                    }
                }
            }

            function Fw(r, e, t, n) {
                const i = r.model, s = i.document;
                let l, d, g, v = n.start;
                for (const x of n.getWalker({shallow: !0})) g = x.item.getAttribute(e), l && d != g && (d != t && _(), v = l), l = x.nextPosition, d = g;

                function _() {
                    const x = new Ee(v, l), M = x.root.document ? s.version : null, O = new ir(x, e, d, t, M);
                    r.batch.addOperation(O), i.applyOperation(O)
                }

                l instanceof Fe && l != v && d != t && _()
            }

            function Rw(r, e, t, n) {
                const i = r.model, s = i.document, l = n.getAttribute(e);
                let d, g;
                if (l != t) {
                    if (n.root === n) {
                        const v = n.document ? s.version : null;
                        g = new Ms(n, e, l, t, v)
                    } else {
                        d = new Ee(Fe._createBefore(n), r.createPositionAfter(n));
                        const v = d.root.document ? s.version : null;
                        g = new ir(d, e, l, t, v)
                    }
                    r.batch.addOperation(g), i.applyOperation(g)
                }
            }

            function ch(r, e, t, n, i) {
                const s = r.model, l = s.document, d = new li(e, t, n, s.markers, !!i, l.version);
                r.batch.addOperation(d), s.applyOperation(d)
            }

            function x3(r, e, t, n) {
                let i;
                if (r.root.document) {
                    const s = n.document, l = new Fe(s.graveyard, [0]);
                    i = new on(r, e, l, s.version)
                } else i = new y3(r, e);
                t.addOperation(i), n.applyOperation(i)
            }

            function zw(r, e) {
                return r === e || r instanceof Ig && e instanceof Ig
            }

            function E3(r, e, t = {}) {
                if (e.isCollapsed) return;
                const n = e.getFirstRange();
                if (n.root.rootName == "$graveyard") return;
                const i = r.schema;
                r.change(s => {
                    if (!t.doNotResetEntireContent && function (v, _) {
                        const x = v.getLimitElement(_);
                        if (!_.containsEntireContent(x)) return !1;
                        const M = _.getFirstRange();
                        return M.start.parent == M.end.parent ? !1 : v.checkChild(x, "paragraph")
                    }(i, e)) return void function (v, _) {
                        const x = v.model.schema.getLimitElement(_);
                        v.remove(v.createRangeIn(x)), Hw(v, v.createPositionAt(x, 0), _)
                    }(s, e);
                    const l = {};
                    if (!t.doNotAutoparagraph) {
                        const v = e.getSelectedElement();
                        v && Object.assign(l, i.getAttributesWithProperty(v, "copyOnReplace", !0))
                    }
                    const [d, g] = function (v) {
                        const _ = v.root.document.model, x = v.start;
                        let M = v.end;
                        if (_.hasContent(v, {ignoreMarkers: !0})) {
                            const O = function (j) {
                                const U = j.parent, K = U.root.document.model.schema,
                                    ne = U.getAncestors({parentFirst: !0, includeSelf: !0});
                                for (const pe of ne) {
                                    if (K.isLimit(pe)) return null;
                                    if (K.isBlock(pe)) return pe
                                }
                            }(M);
                            if (O && M.isTouching(_.createPositionAt(O, 0))) {
                                const j = _.createSelection(v);
                                _.modifySelection(j, {direction: "backward"});
                                const U = j.getLastPosition(), K = _.createRange(U, M);
                                _.hasContent(K, {ignoreMarkers: !0}) || (M = U)
                            }
                        }
                        return [Fr.fromPosition(x, "toPrevious"), Fr.fromPosition(M, "toNext")]
                    }(n);
                    d.isTouching(g) || s.remove(s.createRange(d, g)), t.leaveUnmerged || (function (v, _, x) {
                        const M = v.model;
                        if (!pb(v.model.schema, _, x)) return;
                        const [O, j] = function (U, K) {
                            const ne = U.getAncestors(), pe = K.getAncestors();
                            let Se = 0;
                            for (; ne[Se] && ne[Se] == pe[Se];) Se++;
                            return [ne[Se], pe[Se]]
                        }(_, x);
                        !O || !j || (!M.hasContent(O, {ignoreMarkers: !0}) && M.hasContent(j, {ignoreMarkers: !0}) ? Vw(v, _, x, O.parent) : jw(v, _, x, O.parent))
                    }(s, d, g), i.removeDisallowedAttributes(d.parent.getChildren(), s)), Uw(s, e, d), !t.doNotAutoparagraph && function (v, _) {
                        const x = v.checkChild(_, "$text"), M = v.checkChild(_, "paragraph");
                        return !x && M
                    }(i, d) && Hw(s, d, e, l), d.detach(), g.detach()
                })
            }

            function jw(r, e, t, n) {
                const i = e.parent, s = t.parent;
                if (i != n && s != n) {
                    for (e = r.createPositionAfter(i), (t = r.createPositionBefore(s)).isEqual(e) || r.insert(s, e), r.merge(e); t.parent.isEmpty;) {
                        const l = t.parent;
                        t = r.createPositionBefore(l), r.remove(l)
                    }
                    pb(r.model.schema, e, t) && jw(r, e, t, n)
                }
            }

            function Vw(r, e, t, n) {
                const i = e.parent, s = t.parent;
                if (i != n && s != n) {
                    for (e = r.createPositionAfter(i), (t = r.createPositionBefore(s)).isEqual(e) || r.insert(i, t); e.parent.isEmpty;) {
                        const l = e.parent;
                        e = r.createPositionBefore(l), r.remove(l)
                    }
                    t = r.createPositionBefore(s), function (l, d) {
                        const g = d.nodeBefore, v = d.nodeAfter;
                        g.name != v.name && l.rename(g, v.name), l.clearAttributes(g), l.setAttributes(Object.fromEntries(v.getAttributes()), g), l.merge(d)
                    }(r, t), pb(r.model.schema, e, t) && Vw(r, e, t, n)
                }
            }

            function pb(r, e, t) {
                const n = e.parent, i = t.parent;
                return n != i && !r.isLimit(n) && !r.isLimit(i) && function (s, l, d) {
                    const g = new Ee(s, l);
                    for (const v of g.getWalker()) if (d.isLimit(v.item)) return !1;
                    return !0
                }(e, t, r)
            }

            function Hw(r, e, t, n = {}) {
                const i = r.createElement("paragraph");
                r.model.schema.setAllowedAttributes(i, n, r), r.insert(i, e), Uw(r, t, r.createPositionAt(i, 0))
            }

            function Uw(r, e, t) {
                e instanceof Co ? r.setSelection(t) : e.setTo(t)
            }

            function qw(r, e) {
                const t = [];
                Array.from(r.getItems({direction: "backward"})).map(n => e.createRangeOn(n)).filter(n => (n.start.isAfter(r.start) || n.start.isEqual(r.start)) && (n.end.isBefore(r.end) || n.end.isEqual(r.end))).forEach(n => {
                    t.push(n.start.parent), e.remove(n)
                }), t.forEach(n => {
                    let i = n;
                    for (; i.parent && i.isEmpty;) {
                        const s = e.createRangeOn(i);
                        i = i.parent, e.remove(s)
                    }
                })
            }

            class S3 {
                constructor(e, t, n) {
                    this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = e, this.writer = t, this.position = n, this.canMergeWith = new Set([this.position.parent]), this.schema = e.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0)
                }

                handleNodes(e) {
                    for (const t of Array.from(e)) this._handleNode(t);
                    this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = []
                }

                _updateLastNodeFromAutoParagraph(e) {
                    const t = this.writer.createPositionAfter(this._lastNode), n = this.writer.createPositionAfter(e);
                    if (n.isAfter(t)) {
                        if (this._lastNode = e, this.position.parent != e || !this.position.isAtEnd) throw new R("insertcontent-invalid-insertion-position", this);
                        this.position = n, this._setAffectedBoundaries(this.position)
                    }
                }

                getSelectionRange() {
                    return this._nodeToSelect ? Ee._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position)
                }

                getAffectedRange() {
                    return this._affectedStart ? new Ee(this._affectedStart, this._affectedEnd) : null
                }

                destroy() {
                    this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach()
                }

                _handleNode(e) {
                    if (this.schema.isObject(e)) return void this._handleObject(e);
                    let t = this._checkAndAutoParagraphToAllowedPosition(e);
                    t || (t = this._checkAndSplitToAllowedPosition(e), t) ? (this._appendToFragment(e), this._firstNode || (this._firstNode = e), this._lastNode = e) : this._handleDisallowedNode(e)
                }

                _insertPartialFragment() {
                    if (this._documentFragment.isEmpty) return;
                    const e = Fr.fromPosition(this.position, "toNext");
                    this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e.toPosition(), e.detach()
                }

                _handleObject(e) {
                    this._checkAndSplitToAllowedPosition(e) ? this._appendToFragment(e) : this._tryAutoparagraphing(e)
                }

                _handleDisallowedNode(e) {
                    e.is("element") ? this.handleNodes(e.getChildren()) : this._tryAutoparagraphing(e)
                }

                _appendToFragment(e) {
                    if (!this.schema.checkChild(this.position, e)) throw new R("insertcontent-wrong-position", this, {
                        node: e,
                        position: this.position
                    });
                    this.writer.insert(e, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize), this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null, this._filterAttributesOf.push(e)
                }

                _setAffectedBoundaries(e) {
                    this._affectedStart || (this._affectedStart = Fr.fromPosition(e, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(e) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = Fr.fromPosition(e, "toNext"))
                }

                _mergeOnLeft() {
                    const e = this._firstNode;
                    if (!(e instanceof pn) || !this._canMergeLeft(e)) return;
                    const t = Fr._createBefore(e);
                    t.stickiness = "toNext";
                    const n = Fr.fromPosition(this.position, "toNext");
                    this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = Fr._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = Fr._createAt(t.nodeBefore, "end", "toNext")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach()
                }

                _mergeOnRight() {
                    const e = this._lastNode;
                    if (!(e instanceof pn) || !this._canMergeRight(e)) return;
                    const t = Fr._createAfter(e);
                    if (t.stickiness = "toNext", !this.position.isEqual(t)) throw new R("insertcontent-invalid-insertion-position", this);
                    this.position = Fe._createAt(t.nodeBefore, "end");
                    const n = Fr.fromPosition(this.position, "toPrevious");
                    this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = Fr._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = Fr._createAt(t.nodeBefore, 0, "toPrevious")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach()
                }

                _canMergeLeft(e) {
                    const t = e.previousSibling;
                    return t instanceof pn && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e)
                }

                _canMergeRight(e) {
                    const t = e.nextSibling;
                    return t instanceof pn && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t)
                }

                _tryAutoparagraphing(e) {
                    const t = this.writer.createElement("paragraph");
                    this._getAllowedIn(this.position.parent, t) && this.schema.checkChild(t, e) && (t._appendChild(e), this._handleNode(t))
                }

                _checkAndAutoParagraphToAllowedPosition(e) {
                    if (this.schema.checkChild(this.position.parent, e)) return !0;
                    if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e)) return !1;
                    this._insertPartialFragment();
                    const t = this.writer.createElement("paragraph");
                    return this.writer.insert(t, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = t, this.position = this.writer.createPositionAt(t, 0), !0
                }

                _checkAndSplitToAllowedPosition(e) {
                    const t = this._getAllowedIn(this.position.parent, e);
                    if (!t) return !1;
                    for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent;) if (this.position.isAtStart) {
                        const n = this.position.parent;
                        this.position = this.writer.createPositionBefore(n), n.isEmpty && n.parent === t && this.writer.remove(n)
                    } else if (this.position.isAtEnd) this.position = this.writer.createPositionAfter(this.position.parent); else {
                        const n = this.writer.createPositionAfter(this.position.parent);
                        this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = n, this.canMergeWith.add(this.position.nodeAfter)
                    }
                    return !0
                }

                _getAllowedIn(e, t) {
                    return this.schema.checkChild(e, t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t)
                }
            }

            function Ww(r, e, t = "auto") {
                const n = r.getSelectedElement();
                if (n && e.schema.isObject(n) && !e.schema.isInline(n)) return t == "before" || t == "after" ? e.createRange(e.createPositionAt(n, t)) : e.createRangeOn(n);
                const i = Wn(r.getSelectedBlocks());
                if (!i) return e.createRange(r.focus);
                if (i.isEmpty) return e.createRange(e.createPositionAt(i, 0));
                const s = e.createPositionAfter(i);
                return r.focus.isTouching(s) ? e.createRange(s) : e.createRange(e.createPositionBefore(i))
            }

            function T3(r, e, t, n = {}) {
                if (!r.schema.isObject(e)) throw new R("insertobject-element-not-an-object", r, {object: e});
                const i = t || r.document.selection;
                let s = i;
                n.findOptimalPosition && r.schema.isBlock(e) && (s = r.createSelection(Ww(i, r, n.findOptimalPosition)));
                const l = Wn(i.getSelectedBlocks()), d = {};
                return l && Object.assign(d, r.schema.getAttributesWithProperty(l, "copyOnReplace", !0)), r.change(g => {
                    s.isCollapsed || r.deleteContent(s, {doNotAutoparagraph: !0});
                    let v = e;
                    const _ = s.anchor.parent;
                    !r.schema.checkChild(_, e) && r.schema.checkChild(_, "paragraph") && r.schema.checkChild("paragraph", e) && (v = g.createElement("paragraph"), g.insert(e, v)), r.schema.setAllowedAttributes(v, d, g);
                    const x = r.insertContent(v, s);
                    return x.isCollapsed || n.setSelection && function (M, O, j, U) {
                        const K = M.model;
                        if (j == "on") return void M.setSelection(O, "on");
                        if (j != "after") throw new R("insertobject-invalid-place-parameter-value", K);
                        let ne = O.nextSibling;
                        if (K.schema.isInline(O)) return void M.setSelection(O, "after");
                        !(ne && K.schema.checkChild(ne, "$text")) && K.schema.checkChild(O.parent, "paragraph") && (ne = M.createElement("paragraph"), K.schema.setAllowedAttributes(ne, U, M), K.insertContent(ne, M.createPositionAfter(O))), ne && M.setSelection(ne, 0)
                    }(g, e, n.setSelection, d), x
                })
            }

            const I3 = ' ,.?!:;"-()';

            function M3(r, e) {
                const {isForward: t, walker: n, unit: i, schema: s, treatEmojiAsSingleUnit: l} = r, {
                    type: d,
                    item: g,
                    nextPosition: v
                } = e;
                if (d == "text") return r.unit === "word" ? function (_, x) {
                    let M = _.position.textNode;
                    for (M || (M = x ? _.position.nodeAfter : _.position.nodeBefore); M && M.is("$text");) {
                        const O = _.position.offset - M.startOffset;
                        if (L3(M, O, x)) M = x ? _.position.nodeAfter : _.position.nodeBefore; else {
                            if (N3(M.data, O, x)) break;
                            _.next()
                        }
                    }
                    return _.position
                }(n, t) : function (_, x, M) {
                    const O = _.position.textNode;
                    if (O) {
                        const j = O.data;
                        let U = _.position.offset - O.startOffset;
                        for (; Cd(j, U) || x == "character" && _r(j, U) || M && kr(j, U);) _.next(), U = _.position.offset - O.startOffset
                    }
                    return _.position
                }(n, i, l);
                if (d == (t ? "elementStart" : "elementEnd")) {
                    if (s.isSelectable(g)) return Fe._createAt(g, t ? "after" : "before");
                    if (s.checkChild(v, "$text")) return v
                } else {
                    if (s.isLimit(g)) return void n.skip(() => !0);
                    if (s.checkChild(v, "$text")) return v
                }
            }

            function B3(r, e) {
                const t = r.root, n = Fe._createAt(t, e ? "end" : 0);
                return e ? new Ee(r, n) : new Ee(n, r)
            }

            function N3(r, e, t) {
                const n = e + (t ? 0 : -1);
                return I3.includes(r.charAt(n))
            }

            function L3(r, e, t) {
                return e === (t ? r.offsetSize : 0)
            }

            class P3 extends we() {
                constructor() {
                    super(), this.markers = new _3, this.document = new b3(this), this.schema = new TS, this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach(e => this.decorate(e)), this.on("applyOperation", (e, t) => {
                        t[0]._validate()
                    }, {priority: "highest"}), this.schema.register("$root", {isLimit: !0}), this.schema.register("$container", {allowIn: ["$root", "$container"]}), this.schema.register("$block", {
                        allowIn: ["$root", "$container"],
                        isBlock: !0
                    }), this.schema.register("$blockObject", {
                        allowWhere: "$block",
                        isBlock: !0,
                        isObject: !0
                    }), this.schema.register("$inlineObject", {
                        allowWhere: "$text",
                        allowAttributesOf: "$text",
                        isInline: !0,
                        isObject: !0
                    }), this.schema.register("$text", {
                        allowIn: "$block",
                        isInline: !0,
                        isContent: !0
                    }), this.schema.register("$clipboardHolder", {
                        allowContentOf: "$root",
                        allowChildren: "$text",
                        isLimit: !0
                    }), this.schema.register("$documentFragment", {
                        allowContentOf: "$root",
                        allowChildren: "$text",
                        isLimit: !0
                    }), this.schema.register("$marker"), this.schema.addChildCheck((e, t) => {
                        if (t.name === "$marker") return !0
                    }), xS(this), this.document.registerPostFixer(ew), this.on("insertContent", (e, [t, n]) => {
                        e.return = function (i, s, l) {
                            return i.change(d => {
                                const g = l || i.document.selection;
                                g.isCollapsed || i.deleteContent(g, {doNotAutoparagraph: !0});
                                const v = new S3(i, d, g.anchor), _ = [];
                                let x;
                                if (s.is("documentFragment")) {
                                    if (s.markers.size) {
                                        const j = [];
                                        for (const [U, K] of s.markers) {
                                            const {start: ne, end: pe} = K, Se = ne.isEqual(pe);
                                            j.push({position: ne, name: U, isCollapsed: Se}, {
                                                position: pe,
                                                name: U,
                                                isCollapsed: Se
                                            })
                                        }
                                        j.sort(({position: U}, {position: K}) => U.isBefore(K) ? 1 : -1);
                                        for (const {position: U, name: K, isCollapsed: ne} of j) {
                                            let pe = null, Se = null;
                                            const Je = U.parent === s && U.isAtStart, wt = U.parent === s && U.isAtEnd;
                                            Je || wt ? ne && (Se = Je ? "start" : "end") : (pe = d.createElement("$marker"), d.insert(pe, U)), _.push({
                                                name: K,
                                                element: pe,
                                                collapsed: Se
                                            })
                                        }
                                    }
                                    x = s.getChildren()
                                } else x = [s];
                                v.handleNodes(x);
                                let M = v.getSelectionRange();
                                if (s.is("documentFragment") && _.length) {
                                    const j = M ? Ii.fromRange(M) : null, U = {};
                                    for (let K = _.length - 1; K >= 0; K--) {
                                        const {name: ne, element: pe, collapsed: Se} = _[K], Je = !U[ne];
                                        if (Je && (U[ne] = []), pe) {
                                            const wt = d.createPositionAt(pe, "before");
                                            U[ne].push(wt), d.remove(pe)
                                        } else {
                                            const wt = v.getAffectedRange();
                                            if (!wt) {
                                                Se && U[ne].push(v.position);
                                                continue
                                            }
                                            Se ? U[ne].push(wt[Se]) : U[ne].push(Je ? wt.start : wt.end)
                                        }
                                    }
                                    for (const [K, [ne, pe]] of Object.entries(U)) ne && pe && ne.root === pe.root && d.addMarker(K, {
                                        usingOperation: !0,
                                        affectsData: !0,
                                        range: new Ee(ne, pe)
                                    });
                                    j && (M = j.toRange(), j.detach())
                                }
                                M && (g instanceof Co ? d.setSelection(M) : g.setTo(M));
                                const O = v.getAffectedRange() || i.createRange(g.anchor);
                                return v.destroy(), O
                            })
                        }(this, t, n)
                    }), this.on("insertObject", (e, [t, n, i]) => {
                        e.return = T3(this, t, n, i)
                    }), this.on("canEditAt", e => {
                        const t = !this.document.isReadOnly;
                        e.return = t, t || e.stop()
                    })
                }

                change(e) {
                    try {
                        return this._pendingChanges.length === 0 ? (this._pendingChanges.push({
                            batch: new pu,
                            callback: e
                        }), this._runPendingChanges()[0]) : e(this._currentWriter)
                    } catch (t) {
                        R.rethrowUnexpectedError(t, this)
                    }
                }

                enqueueChange(e, t) {
                    try {
                        e ? typeof e == "function" ? (t = e, e = new pu) : e instanceof pu || (e = new pu(e)) : e = new pu, this._pendingChanges.push({
                            batch: e,
                            callback: t
                        }), this._pendingChanges.length == 1 && this._runPendingChanges()
                    } catch (n) {
                        R.rethrowUnexpectedError(n, this)
                    }
                }

                applyOperation(e) {
                    e._execute()
                }

                insertContent(e, t, n, ...i) {
                    const s = mb(t, n);
                    return this.fire("insertContent", [e, s, n, ...i])
                }

                insertObject(e, t, n, i, ...s) {
                    const l = mb(t, n);
                    return this.fire("insertObject", [e, l, i, i, ...s])
                }

                deleteContent(e, t) {
                    E3(this, e, t)
                }

                modifySelection(e, t) {
                    (function (n, i, s = {}) {
                        const l = n.schema, d = s.direction != "backward", g = s.unit ? s.unit : "character",
                            v = !!s.treatEmojiAsSingleUnit, _ = i.focus, x = new Ao({
                                boundaries: B3(_, d),
                                singleCharacters: !0,
                                direction: d ? "forward" : "backward"
                            }), M = {walker: x, schema: l, isForward: d, unit: g, treatEmojiAsSingleUnit: v};
                        let O;
                        for (; O = x.next();) {
                            if (O.done) return;
                            const j = M3(M, O.value);
                            if (j) return void (i instanceof Co ? n.change(U => {
                                U.setSelectionFocus(j)
                            }) : i.setFocus(j))
                        }
                    })(this, e, t)
                }

                getSelectedContent(e) {
                    return function (t, n) {
                        return t.change(i => {
                            const s = i.createDocumentFragment(), l = n.getFirstRange();
                            if (!l || l.isCollapsed) return s;
                            const d = l.start.root, g = l.start.getCommonPath(l.end), v = d.getNodeByPath(g);
                            let _;
                            _ = l.start.parent == l.end.parent ? l : i.createRange(i.createPositionAt(v, l.start.path[g.length]), i.createPositionAt(v, l.end.path[g.length] + 1));
                            const x = _.end.offset - _.start.offset;
                            for (const M of _.getItems({shallow: !0})) M.is("$textProxy") ? i.appendText(M.data, M.getAttributes(), s) : i.append(i.cloneElement(M, !0), s);
                            if (_ != l) {
                                const M = l._getTransformedByMove(_.start, i.createPositionAt(s, 0), x)[0],
                                    O = i.createRange(i.createPositionAt(s, 0), M.start);
                                qw(i.createRange(M.end, i.createPositionAt(s, "end")), i), qw(O, i)
                            }
                            return s
                        })
                    }(this, e)
                }

                hasContent(e, t = {}) {
                    const n = e instanceof Ee ? e : Ee._createIn(e);
                    if (n.isCollapsed) return !1;
                    const {ignoreWhitespaces: i = !1, ignoreMarkers: s = !1} = t;
                    if (!s) {
                        for (const l of this.markers.getMarkersIntersectingRange(n)) if (l.affectsData) return !0
                    }
                    for (const l of n.getItems()) if (this.schema.isContent(l) && (!l.is("$textProxy") || !i || l.data.search(/\S/) !== -1)) return !0;
                    return !1
                }

                canEditAt(e) {
                    const t = mb(e);
                    return this.fire("canEditAt", [t])
                }

                createPositionFromPath(e, t, n) {
                    return new Fe(e, t, n)
                }

                createPositionAt(e, t) {
                    return Fe._createAt(e, t)
                }

                createPositionAfter(e) {
                    return Fe._createAfter(e)
                }

                createPositionBefore(e) {
                    return Fe._createBefore(e)
                }

                createRange(e, t) {
                    return new Ee(e, t)
                }

                createRangeIn(e) {
                    return Ee._createIn(e)
                }

                createRangeOn(e) {
                    return Ee._createOn(e)
                }

                createSelection(...e) {
                    return new Ti(...e)
                }

                createBatch(e) {
                    return new pu(e)
                }

                createOperationFromJSON(e) {
                    return QS.fromJSON(e, this.document)
                }

                destroy() {
                    this.document.destroy(), this.stopListening()
                }

                _runPendingChanges() {
                    const e = [];
                    this.fire("_beforeChanges");
                    try {
                        for (; this._pendingChanges.length;) {
                            const t = this._pendingChanges[0].batch;
                            this._currentWriter = new D3(this, t);
                            const n = this._pendingChanges[0].callback(this._currentWriter);
                            e.push(n), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null
                        }
                    } finally {
                        this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges")
                    }
                    return e
                }
            }

            function mb(r, e) {
                if (r) return r instanceof Ti || r instanceof Co ? r : r instanceof Hl ? e || e === 0 ? new Ti(r, e) : r.is("rootElement") ? new Ti(r, "in") : new Ti(r, "on") : new Ti(r)
            }

            class O3 extends xn {
                constructor() {
                    super(...arguments), this.domEventType = "click"
                }

                onDomEvent(e) {
                    this.fire(e.type, e)
                }
            }

            class bb extends xn {
                constructor() {
                    super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"]
                }

                onDomEvent(e) {
                    this.fire(e.type, e)
                }
            }

            class Ia {
                constructor(e) {
                    this.document = e
                }

                createDocumentFragment(e) {
                    return new Zo(this.document, e)
                }

                createElement(e, t, n) {
                    return new Qr(this.document, e, t, n)
                }

                createText(e) {
                    return new dn(this.document, e)
                }

                clone(e, t = !1) {
                    return e._clone(t)
                }

                appendChild(e, t) {
                    return t._appendChild(e)
                }

                insertChild(e, t, n) {
                    return n._insertChild(e, t)
                }

                removeChildren(e, t, n) {
                    return n._removeChildren(e, t)
                }

                remove(e) {
                    const t = e.parent;
                    return t ? this.removeChildren(t.getChildIndex(e), 1, t) : []
                }

                replace(e, t) {
                    const n = e.parent;
                    if (n) {
                        const i = n.getChildIndex(e);
                        return this.removeChildren(i, 1, n), this.insertChild(i, t, n), !0
                    }
                    return !1
                }

                unwrapElement(e) {
                    const t = e.parent;
                    if (t) {
                        const n = t.getChildIndex(e);
                        this.remove(e), this.insertChild(n, e.getChildren(), t)
                    }
                }

                rename(e, t) {
                    const n = new Qr(this.document, e, t.getAttributes(), t.getChildren());
                    return this.replace(t, n) ? n : null
                }

                setAttribute(e, t, n) {
                    n._setAttribute(e, t)
                }

                removeAttribute(e, t) {
                    t._removeAttribute(e)
                }

                addClass(e, t) {
                    t._addClass(e)
                }

                removeClass(e, t) {
                    t._removeClass(e)
                }

                setStyle(e, t, n) {
                    ur(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t)
                }

                removeStyle(e, t) {
                    t._removeStyle(e)
                }

                setCustomProperty(e, t, n) {
                    n._setCustomProperty(e, t)
                }

                removeCustomProperty(e, t) {
                    return t._removeCustomProperty(e)
                }

                createPositionAt(e, t) {
                    return We._createAt(e, t)
                }

                createPositionAfter(e) {
                    return We._createAfter(e)
                }

                createPositionBefore(e) {
                    return We._createBefore(e)
                }

                createRange(e, t) {
                    return new Ct(e, t)
                }

                createRangeOn(e) {
                    return Ct._createOn(e)
                }

                createRangeIn(e) {
                    return Ct._createIn(e)
                }

                createSelection(...e) {
                    return new Ur(...e)
                }
            }

            class F3 {
                constructor() {
                    this._commands = new Map
                }

                add(e, t) {
                    this._commands.set(e, t)
                }

                get(e) {
                    return this._commands.get(e)
                }

                execute(e, ...t) {
                    const n = this.get(e);
                    if (!n) throw new R("commandcollection-command-not-found", this, {commandName: e});
                    return n.execute(...t)
                }

                * names() {
                    yield* this._commands.keys()
                }

                * commands() {
                    yield* this._commands.values()
                }

                [Symbol.iterator]() {
                    return this._commands[Symbol.iterator]()
                }

                destroy() {
                    for (const e of this.commands()) e.destroy()
                }
            }

            class R3 extends we() {
                constructor(e = {}) {
                    super();
                    const t = this.constructor, n = e.language || t.defaultConfig && t.defaultConfig.language;
                    this._context = e.context || new Nd({language: n}), this._context._addEditor(this, !e.context);
                    const i = Array.from(t.builtinPlugins || []);
                    this.config = new pd(e, t.defaultConfig), this.config.define("plugins", i), this.config.define(this._context._getEditorConfig()), this.plugins = new Ds(this, i, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = new Set, this.commands = new F3, this.set("state", "initializing"), this.once("ready", () => this.state = "ready", {priority: "high"}), this.once("destroy", () => this.state = "destroyed", {priority: "high"}), this.model = new P3, this.on("change:isReadOnly", () => {
                        this.model.document.isReadOnly = this.isReadOnly
                    });
                    const s = new tb;
                    this.data = new ZS(this.model, s), this.editing = new ES(this.model, s), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new YS([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new lg(this), this.keystrokes.listenTo(this.editing.view.document)
                }

                get isReadOnly() {
                    return this._readOnlyLocks.size > 0
                }

                set isReadOnly(e) {
                    throw new R("editor-isreadonly-has-no-setter")
                }

                enableReadOnlyMode(e) {
                    if (typeof e != "string" && typeof e != "symbol") throw new R("editor-read-only-lock-id-invalid", null, {lockId: e});
                    this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1))
                }

                disableReadOnlyMode(e) {
                    if (typeof e != "string" && typeof e != "symbol") throw new R("editor-read-only-lock-id-invalid", null, {lockId: e});
                    this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0))
                }

                initPlugins() {
                    const e = this.config, t = e.get("plugins"), n = e.get("removePlugins") || [],
                        i = e.get("extraPlugins") || [], s = e.get("substitutePlugins") || [];
                    return this.plugins.init(t.concat(i), n, s)
                }

                destroy() {
                    let e = Promise.resolve();
                    return this.state == "initializing" && (e = new Promise(t => this.once("ready", t))), e.then(() => {
                        this.fire("destroy"), this.stopListening(), this.commands.destroy()
                    }).then(() => this.plugins.destroy()).then(() => {
                        this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy()
                    }).then(() => this._context._removeEditor(this))
                }

                execute(e, ...t) {
                    try {
                        return this.commands.execute(e, ...t)
                    } catch (n) {
                        R.rethrowUnexpectedError(n, this)
                    }
                }

                focus() {
                    this.editing.view.focus()
                }

                static create(...e) {
                    throw new Error("This is an abstract method.")
                }
            }

            function Mg(r) {
                return class extends r {
                    setData(e) {
                        this.data.set(e)
                    }

                    getData(e) {
                        return this.data.get(e)
                    }
                }
            }

            {
                const r = Mg(Object);
                Mg.setData = r.prototype.setData, Mg.getData = r.prototype.getData
            }

            function kb(r) {
                return class extends r {
                    updateSourceElement(e) {
                        if (!this.sourceElement) throw new R("editor-missing-sourceelement", this);
                        const t = this.config.get("updateSourceElementOnDestroy"),
                            n = this.sourceElement instanceof HTMLTextAreaElement;
                        if (!t && !n) return void Fc(this.sourceElement, "");
                        const i = typeof e == "string" ? e : this.data.get();
                        Fc(this.sourceElement, i)
                    }
                }
            }

            kb.updateSourceElement = kb(Object).prototype.updateSourceElement;

            class $w extends Tl {
                static get pluginName() {
                    return "PendingActions"
                }

                init() {
                    this.set("hasAny", !1), this._actions = new br({idProperty: "_id"}), this._actions.delegate("add", "remove").to(this)
                }

                add(e) {
                    if (typeof e != "string") throw new R("pendingactions-add-invalid-message", this);
                    const t = new (we());
                    return t.set("message", e), this._actions.add(t), this.hasAny = !0, t
                }

                remove(e) {
                    this._actions.remove(e), this.hasAny = !!this._actions.length
                }

                get first() {
                    return this._actions.get(0)
                }

                [Symbol.iterator]() {
                    return this._actions[Symbol.iterator]()
                }
            }

            const mn = {
                bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
                cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',
                caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',
                check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
                cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>',
                eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',
                history: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>',
                image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1l4.16-4.482ZM17.8 1c.652 0 1.2.47 1.2 1.1v12.862c0 .64-.532 1.038-1.184 1.038H2.184C1.532 16 1 15.603 1 14.962V2.1C1 1.47 1.537 1 2.2 1h15.6Zm-5.655 6a2.129 2.129 0 0 1 .157-2.364 2.133 2.133 0 1 1-.157 2.363Z"/></svg>',
                imageUpload: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.2 1C.536 1 0 1.47 0 2.1v12.863C0 15.603.547 16 1.199 16h6.3c.908-1.19 1.892-2.41 2.8-3.6L6.615 9.15a.694.694 0 0 0-.957-.033L1.5 13.5v-11h15v6c.6.6 1.012.857 1.5 1.5V2.1c0-.63-.55-1.1-1.201-1.1h-15.6Zm11.724 2.805a2.133 2.133 0 0 0-.998.283 2.129 2.129 0 0 0-.992 1.295c-.074.27-.095.55-.057.828a2.136 2.136 0 0 0 1.56 1.783 2.13 2.13 0 0 0 2.612-1.506 2.129 2.129 0 0 0-2.125-2.683Z"/><path d="M15.208 19.011c.436 0 .79-.327.79-.763v-5.4l2.059 2.455a.79.79 0 0 0 1.212-1.015l-3.352-3.995a.79.79 0 0 0-.996-.179.786.786 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017L14.5 12.9v5.3c0 .437.272.811.709.811Z"/></svg>',
                imageAssetManager: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.54 1 0 1.47 0 2.1v12.86c0 .64.448 1.029 1.1 1.039h6.4v-6l-.885-.85a.692.692 0 0 0-.955-.033L1.5 13.5v-11h15V10H18V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.723 2.805a2.129 2.129 0 0 0-1.621.832A2.125 2.125 0 0 0 11.146 7a2.13 2.13 0 0 0 3.905-.512 2.135 2.135 0 0 0-.76-2.244 2.13 2.13 0 0 0-1.367-.44Z"/><path clip-rule="evenodd" d="M19.5 12.5v6.156c0 .224-.192.439-.35.597a.844.844 0 0 1-.597.247H9.834a.844.844 0 0 1-.843-.844v-7.312a.844.844 0 0 1 .843-.844h2.532c.223 0 .476.049.634.207l1 .793h4.5c.224 0 .491.214.65.372.158.158.35.404.35.628ZM18 13h-4.5l-1-1h-2v6H18v-5Z"/></svg>',
                imageUrl: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_355_284)"><path d="M1.201 1C.54 1 0 1.47 0 2.1v12.863C0 15.603.548 16 1.2 16H8c.022-1.034.222-1.961.783-2.9L9.5 12 6.617 9.15a.694.694 0 0 0-.957-.033L1.5 13.5v-11h15v5.8c.58.188 1.012.43 1.5.8v-7c0-.63-.547-1.1-1.2-1.1H1.202Zm11.723 2.805a2.133 2.133 0 0 0-.996.283 2.131 2.131 0 0 0-.994 1.295 2.136 2.136 0 0 0 1.506 2.611 2.13 2.13 0 0 0 2.61-1.505 2.128 2.128 0 0 0-2.126-2.684Z"/><path d="M16.63 10.294a3.003 3.003 0 0 0-4.142.887l-.117.177a.649.649 0 0 0-.096.493.665.665 0 0 0 .278.417.7.7 0 0 0 .944-.233 1.741 1.741 0 0 1 2.478-.464 1.869 1.869 0 0 1 .476 2.55.634.634 0 0 0-.071.5.648.648 0 0 0 .309.397.628.628 0 0 0 .869-.19l.027-.042a3.226 3.226 0 0 0-.956-4.492Zm-6.061 3.781-.044.065a3.228 3.228 0 0 0 .82 4.404 3.005 3.005 0 0 0 4.275-.799l.13-.196a.626.626 0 0 0 .092-.475.642.642 0 0 0-.268-.402.713.713 0 0 0-.99.26l-.018.028a1.742 1.742 0 0 1-2.477.462 1.87 1.87 0 0 1-.476-2.551l.03-.047a.647.647 0 0 0 .086-.485.66.66 0 0 0-.275-.407l-.04-.027a.609.609 0 0 0-.845.17Z"/><path d="M15.312 13.925c.24-.36.154-.837-.19-1.067-.346-.229-.82-.123-1.059.237l-1.268 1.907c-.239.36-.153.837.192 1.066.345.23.818.124 1.057-.236l1.268-1.907Z"/></g><defs><clipPath id="clip0_355_284"><rect width="20" height="20"/></clipPath></defs></svg>',
                lowVision: `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>
`,
                textAlternative: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M.91 10.488A.909.909 0 0 0 0 11.4v6.877c0 .505.405.91.91.91h18.178a.909.909 0 0 0 .912-.91V11.4a.91.91 0 0 0-.912-.912H.91Zm2.758 1.5h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516l2.152-5.7Zm4.947 0h1.801v4.3h2.7v1.4h-4.5v-5.7Zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9v-1.4Zm-8.517 1.457-.614 2.059h1.262l-.648-2.06Z"/><path d="M3.035 0C2.446 0 2 .54 2 1.098V9.5h1.5v-8h13v8H18V1.098C18 .539 17.48 0 16.9 0H3.035Zm10.453 2.61a1.885 1.885 0 0 0-1.442.736 1.894 1.894 0 0 0-.376 1.396 1.89 1.89 0 0 0 1.387 1.58c.485.13 1.004.063 1.439-.187a1.887 1.887 0 0 0-1.008-3.526ZM7.463 7.163a.611.611 0 0 0-.432.154L5.071 9.5h5.119L7.88 7.348a.627.627 0 0 0-.417-.184Zm6.236 1.059a.62.62 0 0 0-.42.164L12.07 9.5h2.969l-.92-1.113a.617.617 0 0 0-.42-.164Z"/></svg>',
                loupe: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>',
                importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>',
                paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>',
                plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>',
                text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>',
                alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>',
                alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>',
                alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>',
                alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
                alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
                alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
                alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
                objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',
                objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
                objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',
                objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
                objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',
                objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>',
                objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>',
                objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>',
                pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
                pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>',
                quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
                threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>',
                dragIndicator: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>'
            };
            var Gw = C(5542),
                z3 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Gw.Z, z3), Gw.Z.locals;
            const {threeVerticalDots: Kw} = mn, j3 = {
                alignLeft: mn.alignLeft,
                bold: mn.bold,
                importExport: mn.importExport,
                paragraph: mn.paragraph,
                plus: mn.plus,
                text: mn.text,
                threeVerticalDots: mn.threeVerticalDots,
                pilcrow: mn.pilcrow,
                dragIndicator: mn.dragIndicator
            };

            class vb extends It {
                constructor(e, t) {
                    super(e);
                    const n = this.bindTemplate, i = this.t;
                    this.options = t || {}, this.set("ariaLabel", i("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Nr, this.keystrokes = new si, this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new V3(e), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
                    const s = e.uiLanguageDirection === "rtl";
                    this._focusCycler = new yn({
                        focusables: this.focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: [s ? "arrowright" : "arrowleft", "arrowup"],
                            focusNext: [s ? "arrowleft" : "arrowright", "arrowdown"]
                        }
                    });
                    const l = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
                    var d;
                    this.options.shouldGroupWhenFull && this.options.isFloating && l.push("ck-toolbar_floating"), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: l,
                            role: "toolbar",
                            "aria-label": n.to("ariaLabel"),
                            style: {maxWidth: n.to("maxWidth")},
                            tabindex: -1
                        },
                        children: this.children,
                        on: {
                            mousedown: (d = this, d.bindTemplate.to(g => {
                                g.target === d.element && g.preventDefault()
                            }))
                        }
                    }), this._behavior = this.options.shouldGroupWhenFull ? new U3(this) : new H3(this)
                }

                render() {
                    super.render(), this.focusTracker.add(this.element);
                    for (const e of this.items) this.focusTracker.add(e.element);
                    this.items.on("add", (e, t) => {
                        this.focusTracker.add(t.element)
                    }), this.items.on("remove", (e, t) => {
                        this.focusTracker.remove(t.element)
                    }), this.keystrokes.listenTo(this.element), this._behavior.render(this)
                }

                destroy() {
                    return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy()
                }

                focus() {
                    this._focusCycler.focusFirst()
                }

                focusLast() {
                    this._focusCycler.focusLast()
                }

                fillFromConfig(e, t, n) {
                    this.items.addMany(this._buildItemsFromConfig(e, t, n))
                }

                _buildItemsFromConfig(e, t, n) {
                    const i = ys(e), s = n || i.removeItems;
                    return this._cleanItemsConfiguration(i.items, t, s).map(l => Oe(l) ? this._createNestedToolbarDropdown(l, t, s) : l === "|" ? new Id : l === "-" ? new ig : t.create(l)).filter(l => !!l)
                }

                _cleanItemsConfiguration(e, t, n) {
                    const i = e.filter((s, l, d) => s === "|" || n.indexOf(s) === -1 && (s === "-" ? !this.options.shouldGroupWhenFull || (ae("toolbarview-line-break-ignored-when-grouping-items", d), !1) : !(!Oe(s) && !t.has(s)) || (ae("toolbarview-item-unavailable", {item: s}), !1)));
                    return this._cleanSeparatorsAndLineBreaks(i)
                }

                _cleanSeparatorsAndLineBreaks(e) {
                    const t = l => l !== "-" && l !== "|", n = e.length, i = e.findIndex(t);
                    if (i === -1) return [];
                    const s = n - e.slice().reverse().findIndex(t);
                    return e.slice(i, s).filter((l, d, g) => t(l) ? !0 : !(d > 0 && g[d - 1] === l))
                }

                _createNestedToolbarDropdown(e, t, n) {
                    let {label: i, icon: s, items: l, tooltip: d = !0, withText: g = !1} = e;
                    if (l = this._cleanItemsConfiguration(l, t, n), !l.length) return null;
                    const v = Ns(this.locale);
                    return i || ae("toolbarview-nested-toolbar-dropdown-missing-label", e), v.class = "ck-toolbar__nested-toolbar-dropdown", v.buttonView.set({
                        label: i,
                        tooltip: d,
                        withText: !!g
                    }), s !== !1 ? v.buttonView.icon = j3[s] || s || Kw : v.buttonView.withText = !0, Ab(v, () => v.toolbarView._buildItemsFromConfig(l, t, n)), v
                }
            }

            class V3 extends It {
                constructor(e) {
                    super(e), this.children = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-toolbar__items"]},
                        children: this.children
                    })
                }
            }

            class H3 {
                constructor(e) {
                    const t = e.bindTemplate;
                    e.set("isVertical", !1), e.itemsView.children.bindTo(e.items).using(n => n), e.focusables.bindTo(e.items).using(n => n), e.extendTemplate({attributes: {class: [t.if("isVertical", "ck-toolbar_vertical")]}})
                }

                render() {
                }

                destroy() {
                }
            }

            class U3 {
                constructor(e) {
                    this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, this.view = e, this.viewChildren = e.children, this.viewFocusables = e.focusables, this.viewItemsView = e.itemsView, this.viewFocusTracker = e.focusTracker, this.viewLocale = e.locale, this.ungroupedItems = e.createCollection(), this.groupedItems = e.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), e.itemsView.children.bindTo(this.ungroupedItems).using(t => t), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), e.children.on("change", this._updateFocusCycleableItems.bind(this)), e.items.on("change", (t, n) => {
                        const i = n.index, s = Array.from(n.added);
                        for (const l of n.removed) i >= this.ungroupedItems.length ? this.groupedItems.remove(l) : this.ungroupedItems.remove(l);
                        for (let l = i; l < i + s.length; l++) {
                            const d = s[l - i];
                            l > this.ungroupedItems.length ? this.groupedItems.add(d, l - this.ungroupedItems.length) : this.ungroupedItems.add(d, l)
                        }
                        this._updateGrouping()
                    }), e.extendTemplate({attributes: {class: ["ck-toolbar_grouping"]}})
                }

                render(e) {
                    this.viewElement = e.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e)
                }

                destroy() {
                    this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy()
                }

                _updateGrouping() {
                    if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) return;
                    if (!mo(this.viewElement)) return void (this.shouldUpdateGroupingOnNextResize = !0);
                    const e = this.groupedItems.length;
                    let t;
                    for (; this._areItemsOverflowing;) this._groupLastItem(), t = !0;
                    if (!t && this.groupedItems.length) {
                        for (; this.groupedItems.length && !this._areItemsOverflowing;) this._ungroupFirstItem();
                        this._areItemsOverflowing && this._groupLastItem()
                    }
                    this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate")
                }

                get _areItemsOverflowing() {
                    if (!this.ungroupedItems.length) return !1;
                    const e = this.viewElement, t = this.viewLocale.uiLanguageDirection, n = new Lt(e.lastChild),
                        i = new Lt(e);
                    if (!this.cachedPadding) {
                        const s = bt.window.getComputedStyle(e), l = t === "ltr" ? "paddingRight" : "paddingLeft";
                        this.cachedPadding = Number.parseInt(s[l])
                    }
                    return t === "ltr" ? n.right > i.right - this.cachedPadding : n.left < i.left + this.cachedPadding
                }

                _enableGroupingOnResize() {
                    let e;
                    this.resizeObserver = new ua(this.viewElement, t => {
                        e && e === t.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), e = t.contentRect.width)
                    }), this._updateGrouping()
                }

                _enableGroupingOnMaxWidthChange(e) {
                    e.on("change:maxWidth", () => {
                        this._updateGrouping()
                    })
                }

                _groupLastItem() {
                    this.groupedItems.length || (this.viewChildren.add(new Id), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
                }

                _ungroupFirstItem() {
                    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element))
                }

                _createGroupedItemsDropdown() {
                    const e = this.viewLocale, t = e.t, n = Ns(e);
                    return n.class = "ck-toolbar__grouped-dropdown", n.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se", Ab(n, this.groupedItems), n.buttonView.set({
                        label: t("Show more items"),
                        tooltip: !0,
                        tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw",
                        icon: Kw
                    }), n
                }

                _updateFocusCycleableItems() {
                    this.viewFocusables.clear(), this.ungroupedItems.map(e => {
                        this.viewFocusables.add(e)
                    }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown)
                }
            }

            class wb extends It {
                constructor(e) {
                    super(e);
                    const t = this.bindTemplate;
                    this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({
                        tag: "li",
                        attributes: {
                            class: ["ck", "ck-list__item", t.if("isVisible", "ck-hidden", n => !n)],
                            role: "presentation"
                        },
                        children: this.children
                    })
                }

                focus() {
                    this.children.first && this.children.first.focus()
                }
            }

            class Zw extends It {
                constructor(e) {
                    super(e), this.setTemplate({tag: "li", attributes: {class: ["ck", "ck-list__separator"]}})
                }
            }

            class Bg extends It {
                constructor(e, t = new Jc) {
                    super(e);
                    const n = this.bindTemplate, i = new Qw(e);
                    this.set({
                        label: "",
                        isVisible: !0
                    }), this.labelView = t, this.labelView.bind("text").to(this, "label"), this.children = this.createCollection(), this.children.addMany([this.labelView, i]), i.set({
                        role: "group",
                        ariaLabelledBy: t.id
                    }), i.focusTracker.destroy(), i.keystrokes.destroy(), this.items = i.items, this.setTemplate({
                        tag: "li",
                        attributes: {
                            role: "presentation",
                            class: ["ck", "ck-list__group", n.if("isVisible", "ck-hidden", s => !s)]
                        },
                        children: this.children
                    })
                }

                focus() {
                    if (this.items) {
                        const e = this.items.find(t => !(t instanceof Zw));
                        e && e.focus()
                    }
                }
            }

            var Yw = C(1046),
                q3 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Yw.Z, q3), Yw.Z.locals;

            class Qw extends It {
                constructor(e) {
                    super(e), this._listItemGroupToChangeListeners = new WeakMap;
                    const t = this.bindTemplate;
                    this.focusables = new un, this.items = this.createCollection(), this.focusTracker = new Nr, this.keystrokes = new si, this._focusCycler = new yn({
                        focusables: this.focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {focusPrevious: "arrowup", focusNext: "arrowdown"}
                    }), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", void 0), this.set("role", void 0), this.setTemplate({
                        tag: "ul",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-list"],
                            role: t.to("role"),
                            "aria-label": t.to("ariaLabel"),
                            "aria-labelledby": t.to("ariaLabelledBy")
                        },
                        children: this.items
                    })
                }

                render() {
                    super.render();
                    for (const e of this.items) e instanceof Bg ? this._registerFocusableItemsGroup(e) : e instanceof wb && this._registerFocusableListItem(e);
                    this.items.on("change", (e, t) => {
                        for (const n of t.removed) n instanceof Bg ? this._deregisterFocusableItemsGroup(n) : this._deregisterFocusableListItem(n);
                        for (const n of Array.from(t.added).reverse()) n instanceof Bg ? this._registerFocusableItemsGroup(n, t.index) : this._registerFocusableListItem(n, t.index)
                    }), this.keystrokes.listenTo(this.element)
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }

                focus() {
                    this._focusCycler.focusFirst()
                }

                focusFirst() {
                    this._focusCycler.focusFirst()
                }

                focusLast() {
                    this._focusCycler.focusLast()
                }

                _registerFocusableListItem(e, t) {
                    this.focusTracker.add(e.element), this.focusables.add(e, t)
                }

                _deregisterFocusableListItem(e) {
                    this.focusTracker.remove(e.element), this.focusables.remove(e)
                }

                _getOnGroupItemsChangeCallback(e) {
                    return (t, n) => {
                        for (const i of n.removed) this._deregisterFocusableListItem(i);
                        for (const i of Array.from(n.added).reverse()) this._registerFocusableListItem(i, this.items.getIndex(e) + n.index)
                    }
                }

                _registerFocusableItemsGroup(e, t) {
                    Array.from(e.items).forEach((i, s) => {
                        const l = t !== void 0 ? t + s : void 0;
                        this._registerFocusableListItem(i, l)
                    });
                    const n = this._getOnGroupItemsChangeCallback(e);
                    this._listItemGroupToChangeListeners.set(e, n), e.items.on("change", n)
                }

                _deregisterFocusableItemsGroup(e) {
                    for (const t of e.items) this._deregisterFocusableListItem(t);
                    e.items.off("change", this._listItemGroupToChangeListeners.get(e)), this._listItemGroupToChangeListeners.delete(e)
                }
            }

            var Jw = C(7686),
                W3 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Jw.Z, W3), Jw.Z.locals;

            class Ng extends It {
                constructor(e, t) {
                    super(e);
                    const n = this.bindTemplate;
                    this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(t), this.arrowView = this._createArrowView(), this.keystrokes = new si, this.focusTracker = new Nr, this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-splitbutton", n.to("class"), n.if("isVisible", "ck-hidden", i => !i), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]},
                        children: this.children
                    })
                }

                render() {
                    super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e, t) => {
                        this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t())
                    }), this.keystrokes.set("arrowleft", (e, t) => {
                        this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t())
                    })
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }

                focus() {
                    this.actionView.focus()
                }

                _createActionView(e) {
                    const t = e || new sn;
                    return e || t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t.extendTemplate({attributes: {class: "ck-splitbutton__action"}}), t.delegate("execute").to(this), t
                }

                _createArrowView() {
                    const e = new sn, t = e.bindTemplate;
                    return e.icon = Td, e.extendTemplate({
                        attributes: {
                            class: ["ck-splitbutton__arrow"],
                            "data-cke-tooltip-disabled": t.to("isOn"),
                            "aria-haspopup": !0,
                            "aria-expanded": t.to("isOn", n => String(n))
                        }
                    }), e.bind("isEnabled").to(this), e.bind("label").to(this), e.bind("tooltip").to(this), e.delegate("execute").to(this, "open"), e
                }
            }

            var Xw = C(7339),
                $3 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Xw.Z, $3), Xw.Z.locals;
            var eA = C(3949),
                G3 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(eA.Z, G3), eA.Z.locals;

            function Ns(r, e = rg) {
                const t = typeof e == "function" ? new e(r) : e, n = new Sd(r), i = new eu(r, t, n);
                return t.bind("isEnabled").to(i), t instanceof Ng ? t.arrowView.bind("isOn").to(i, "isOpen") : t.bind("isOn").to(i, "isOpen"), function (s) {
                    (function (l) {
                        l.on("render", () => {
                            A({
                                emitter: l, activator: () => l.isOpen, callback: () => {
                                    l.isOpen = !1
                                }, contextElements: () => [l.element, ...l.focusTracker._elements]
                            })
                        })
                    })(s), function (l) {
                        l.on("execute", d => {
                            d.source instanceof _l || (l.isOpen = !1)
                        })
                    }(s), function (l) {
                        l.focusTracker.on("change:isFocused", (d, g, v) => {
                            l.isOpen && !v && (l.isOpen = !1)
                        })
                    }(s), function (l) {
                        l.keystrokes.set("arrowdown", (d, g) => {
                            l.isOpen && (l.panelView.focus(), g())
                        }), l.keystrokes.set("arrowup", (d, g) => {
                            l.isOpen && (l.panelView.focusLast(), g())
                        })
                    }(s), function (l) {
                        l.on("change:isOpen", (d, g, v) => {
                            if (v) return;
                            const _ = l.panelView.element;
                            _ && _.contains(bt.document.activeElement) && l.buttonView.focus()
                        })
                    }(s), function (l) {
                        l.on("change:isOpen", (d, g, v) => {
                            v && l.panelView.focus()
                        }, {priority: "low"})
                    }(s)
                }(i), i
            }

            function Ab(r, e, t = {}) {
                r.extendTemplate({attributes: {class: ["ck-toolbar-dropdown"]}}), r.isOpen ? tA(r, e, t) : r.once("change:isOpen", () => tA(r, e, t), {priority: "highest"}), t.enableActiveItemFocusOnDropdownOpen && iA(r, () => r.toolbarView.items.find(n => n.isOn))
            }

            function tA(r, e, t) {
                const n = r.locale, i = n.t, s = r.toolbarView = new vb(n), l = typeof e == "function" ? e() : e;
                s.ariaLabel = t.ariaLabel || i("Dropdown toolbar"), t.maxWidth && (s.maxWidth = t.maxWidth), t.class && (s.class = t.class), t.isCompact && (s.isCompact = t.isCompact), t.isVertical && (s.isVertical = !0), l instanceof un ? s.items.bindTo(l).using(d => d) : s.items.addMany(l), r.panelView.children.add(s), s.items.delegate("execute").to(r)
            }

            function nA(r, e, t = {}) {
                r.isOpen ? rA(r, e, t) : r.once("change:isOpen", () => rA(r, e, t), {priority: "highest"}), iA(r, () => r.listView.items.find(n => n instanceof wb && n.children.first.isOn))
            }

            function rA(r, e, t) {
                const n = r.locale, i = r.listView = new Qw(n), s = typeof e == "function" ? e() : e;
                i.ariaLabel = t.ariaLabel, i.role = t.role, oA(r, i.items, s, n), r.panelView.children.add(i), i.items.delegate("execute").to(r)
            }

            function iA(r, e) {
                r.on("change:isOpen", () => {
                    if (!r.isOpen) return;
                    const t = e();
                    t && (typeof t.focus == "function" ? t.focus() : ae("ui-dropdown-focus-child-on-open-child-missing-focus", {view: t}))
                }, {priority: ce.low - 10})
            }

            function oA(r, e, t, n) {
                e.bindTo(t).using(i => {
                    if (i.type === "separator") return new Zw(n);
                    if (i.type === "group") {
                        const s = new Bg(n);
                        return s.set({label: i.label}), oA(r, s.items, i.items, n), s.items.delegate("execute").to(r), s
                    }
                    if (i.type === "button" || i.type === "switchbutton") {
                        const s = new wb(n);
                        let l;
                        return i.type === "button" ? (l = new sn(n), l.extendTemplate({attributes: {"aria-checked": l.bindTemplate.to("isOn")}})) : l = new _l(n), l.bind(...Object.keys(i.model)).to(i.model), l.delegate("execute").to(s), s.children.add(l), s
                    }
                    return null
                })
            }

            const Lg = (r, e, t) => {
                    const n = new Um(r.locale);
                    return n.set({
                        id: e,
                        ariaDescribedById: t
                    }), n.bind("isReadOnly").to(r, "isEnabled", i => !i), n.bind("hasError").to(r, "errorText", i => !!i), n.on("input", () => {
                        r.errorText = null
                    }), r.bind("isEmpty", "isFocused", "placeholder").to(n), n
                }, uh = (r, e = 0, t = 1) => r > t ? t : r < e ? e : r,
                Rr = (r, e = 0, t = Math.pow(10, e)) => Math.round(t * r) / t,
                Cb = r => (r[0] === "#" && (r = r.substring(1)), r.length < 6 ? {
                    r: parseInt(r[0] + r[0], 16),
                    g: parseInt(r[1] + r[1], 16),
                    b: parseInt(r[2] + r[2], 16),
                    a: r.length === 4 ? Rr(parseInt(r[3] + r[3], 16) / 255, 2) : 1
                } : {
                    r: parseInt(r.substring(0, 2), 16),
                    g: parseInt(r.substring(2, 4), 16),
                    b: parseInt(r.substring(4, 6), 16),
                    a: r.length === 8 ? Rr(parseInt(r.substring(6, 8), 16) / 255, 2) : 1
                }), K3 = ({h: r, s: e, v: t, a: n}) => {
                    const i = (200 - e) * t / 100;
                    return {
                        h: Rr(r),
                        s: Rr(i > 0 && i < 200 ? e * t / 100 / (i <= 100 ? i : 200 - i) * 100 : 0),
                        l: Rr(i / 2),
                        a: Rr(n, 2)
                    }
                }, _b = r => {
                    const {h: e, s: t, l: n} = K3(r);
                    return `hsl(${e}, ${t}%, ${n}%)`
                }, Z3 = ({h: r, s: e, v: t, a: n}) => {
                    r = r / 360 * 6, e /= 100, t /= 100;
                    const i = Math.floor(r), s = t * (1 - e), l = t * (1 - (r - i) * e), d = t * (1 - (1 - r + i) * e),
                        g = i % 6;
                    return {
                        r: Rr(255 * [t, l, s, s, d, t][g]),
                        g: Rr(255 * [d, t, t, l, s, s][g]),
                        b: Rr(255 * [s, s, d, t, t, l][g]),
                        a: Rr(n, 2)
                    }
                }, Pg = r => {
                    const e = r.toString(16);
                    return e.length < 2 ? "0" + e : e
                }, Y3 = ({r, g: e, b: t, a: n}) => {
                    const i = n < 1 ? Pg(Rr(255 * n)) : "";
                    return "#" + Pg(r) + Pg(e) + Pg(t) + i
                }, Q3 = ({r, g: e, b: t, a: n}) => {
                    const i = Math.max(r, e, t), s = i - Math.min(r, e, t),
                        l = s ? i === r ? (e - t) / s : i === e ? 2 + (t - r) / s : 4 + (r - e) / s : 0;
                    return {h: Rr(60 * (l < 0 ? l + 6 : l)), s: Rr(i ? s / i * 100 : 0), v: Rr(i / 255 * 100), a: n}
                }, sA = (r, e) => {
                    if (r === e) return !0;
                    for (const t in r) if (r[t] !== e[t]) return !1;
                    return !0
                }, aA = {}, lA = r => {
                    let e = aA[r];
                    return e || (e = document.createElement("template"), e.innerHTML = r, aA[r] = e), e
                }, yb = (r, e, t) => {
                    r.dispatchEvent(new CustomEvent(e, {bubbles: !0, detail: t}))
                };
            let bu = !1;
            const Db = r => "touches" in r, cA = (r, e) => {
                const t = Db(e) ? e.touches[0] : e, n = r.el.getBoundingClientRect();
                yb(r.el, "move", r.getMove({
                    x: uh((t.pageX - (n.left + window.pageXOffset)) / n.width),
                    y: uh((t.pageY - (n.top + window.pageYOffset)) / n.height)
                }))
            };

            class uA {
                constructor(e, t, n, i) {
                    const s = lA(`<div role="slider" tabindex="0" part="${t}" ${n}><div part="${t}-pointer"></div></div>`);
                    e.appendChild(s.content.cloneNode(!0));
                    const l = e.querySelector(`[part=${t}]`);
                    l.addEventListener("mousedown", this), l.addEventListener("touchstart", this), l.addEventListener("keydown", this), this.el = l, this.xy = i, this.nodes = [l.firstChild, l]
                }

                set dragging(e) {
                    const t = e ? document.addEventListener : document.removeEventListener;
                    t(bu ? "touchmove" : "mousemove", this), t(bu ? "touchend" : "mouseup", this)
                }

                handleEvent(e) {
                    switch (e.type) {
                        case"mousedown":
                        case"touchstart":
                            if (e.preventDefault(), !(t => !(bu && !Db(t) || (bu || (bu = Db(t)), 0)))(e) || !bu && e.button != 0) return;
                            this.el.focus(), cA(this, e), this.dragging = !0;
                            break;
                        case"mousemove":
                        case"touchmove":
                            e.preventDefault(), cA(this, e);
                            break;
                        case"mouseup":
                        case"touchend":
                            this.dragging = !1;
                            break;
                        case"keydown":
                            ((t, n) => {
                                const i = n.keyCode;
                                i > 40 || t.xy && i < 37 || i < 33 || (n.preventDefault(), yb(t.el, "move", t.getMove({
                                    x: i === 39 ? .01 : i === 37 ? -.01 : i === 34 ? .05 : i === 33 ? -.05 : i === 35 ? 1 : i === 36 ? -1 : 0,
                                    y: i === 40 ? .01 : i === 38 ? -.01 : 0
                                }, !0)))
                            })(this, e)
                    }
                }

                style(e) {
                    e.forEach((t, n) => {
                        for (const i in t) this.nodes[n].style.setProperty(i, t[i])
                    })
                }
            }

            class J3 extends uA {
                constructor(e) {
                    super(e, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1)
                }

                update({h: e}) {
                    this.h = e, this.style([{
                        left: e / 360 * 100 + "%",
                        color: _b({h: e, s: 100, v: 100, a: 1})
                    }]), this.el.setAttribute("aria-valuenow", `${Rr(e)}`)
                }

                getMove(e, t) {
                    return {h: t ? uh(this.h + 360 * e.x, 0, 360) : 360 * e.x}
                }
            }

            class X3 extends uA {
                constructor(e) {
                    super(e, "saturation", 'aria-label="Color"', !0)
                }

                update(e) {
                    this.hsva = e, this.style([{
                        top: 100 - e.v + "%",
                        left: `${e.s}%`,
                        color: _b(e)
                    }, {
                        "background-color": _b({
                            h: e.h,
                            s: 100,
                            v: 100,
                            a: 1
                        })
                    }]), this.el.setAttribute("aria-valuetext", `Saturation ${Rr(e.s)}%, Brightness ${Rr(e.v)}%`)
                }

                getMove(e, t) {
                    return {
                        s: t ? uh(this.hsva.s + 100 * e.x, 0, 100) : 100 * e.x,
                        v: t ? uh(this.hsva.v - 100 * e.y, 0, 100) : Math.round(100 - 100 * e.y)
                    }
                }
            }

            const Og = Symbol("same"), xb = Symbol("color"), dA = Symbol("hsva"), Eb = Symbol("update"),
                hA = Symbol("parts"), fA = Symbol("css"), gA = Symbol("sliders");

            class eT extends HTMLElement {
                static get observedAttributes() {
                    return ["color"]
                }

                get [fA]() {
                    return [':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}"]
                }

                get [gA]() {
                    return [X3, J3]
                }

                get color() {
                    return this[xb]
                }

                set color(e) {
                    if (!this[Og](e)) {
                        const t = this.colorModel.toHsva(e);
                        this[Eb](t), this[xb] = e
                    }
                }

                constructor() {
                    super();
                    const e = lA(`<style>${this[fA].join("")}</style>`), t = this.attachShadow({mode: "open"});
                    t.appendChild(e.content.cloneNode(!0)), t.addEventListener("move", this), this[hA] = this[gA].map(n => new n(t))
                }

                connectedCallback() {
                    if (this.hasOwnProperty("color")) {
                        const e = this.color;
                        delete this.color, this.color = e
                    } else this.color || (this.color = this.colorModel.defaultColor)
                }

                attributeChangedCallback(e, t, n) {
                    const i = this.colorModel.fromAttr(n);
                    this[Og](i) || (this.color = i)
                }

                handleEvent(e) {
                    const t = this[dA], n = {...t, ...e.detail};
                    let i;
                    this[Eb](n), sA(n, t) || this[Og](i = this.colorModel.fromHsva(n)) || (this[xb] = i, yb(this, "color-changed", {value: i}))
                }

                [Og](e) {
                    return this.color && this.colorModel.equal(e, this.color)
                }

                [Eb](e) {
                    this[dA] = e, this[hA].forEach(t => t.update(e))
                }
            }

            const tT = {
                defaultColor: "#000",
                toHsva: r => Q3(Cb(r)),
                fromHsva: ({h: r, s: e, v: t}) => Y3(Z3({h: r, s: e, v: t, a: 1})),
                equal: (r, e) => r.toLowerCase() === e.toLowerCase() || sA(Cb(r), Cb(e)),
                fromAttr: r => r
            };

            class nT extends eT {
                get colorModel() {
                    return tT
                }
            }

            customElements.define("hex-color-picker", class extends nT {
            });
            var pA = C(3398),
                rT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(pA.Z, rT), pA.Z.locals;
            var mA = C(4157),
                iT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(mA.Z, iT), mA.Z.locals;

            class oT {
                constructor(e) {
                    this._components = new Map, this.editor = e
                }

                * names() {
                    for (const e of this._components.values()) yield e.originalName
                }

                add(e, t) {
                    this._components.set(Sb(e), {callback: t, originalName: e})
                }

                create(e) {
                    if (!this.has(e)) throw new R("componentfactory-item-missing", this, {name: e});
                    return this._components.get(Sb(e)).callback(this.editor.locale)
                }

                has(e) {
                    return this._components.has(Sb(e))
                }
            }

            function Sb(r) {
                return String(r).toLowerCase()
            }

            var bA = C(8793),
                sT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(bA.Z, sT), bA.Z.locals;
            var aT = Object.defineProperty, kA = Object.getOwnPropertySymbols, lT = Object.prototype.hasOwnProperty,
                cT = Object.prototype.propertyIsEnumerable, vA = (r, e, t) => e in r ? aT(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, Xt = (r, e) => {
                    for (var t in e || (e = {})) lT.call(e, t) && vA(r, t, e[t]);
                    if (kA) for (var t of kA(e)) cT.call(e, t) && vA(r, t, e[t]);
                    return r
                };
            const wA = Ro("px"), AA = bt.document.body,
                uT = {top: -99999, left: -99999, name: "arrowless", config: {withArrow: !1}}, Tb = class extends It {
                    constructor(r) {
                        super(r);
                        const e = this.bindTemplate;
                        this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-balloon-panel", e.to("position", t => `ck-balloon-panel_${t}`), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")],
                                style: {top: e.to("top", wA), left: e.to("left", wA)}
                            },
                            children: this.content
                        })
                    }

                    show() {
                        this.isVisible = !0
                    }

                    hide() {
                        this.isVisible = !1
                    }

                    attachTo(r) {
                        this.show();
                        const e = Tb.defaultPositions, t = Object.assign({}, {
                                element: this.element,
                                positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth],
                                limiter: AA,
                                fitInViewport: !0
                            }, r), n = Tb._getOptimalPosition(t) || uT, i = parseInt(n.left), s = parseInt(n.top), l = n.name,
                            d = n.config || {}, {withArrow: g = !0} = d;
                        this.top = s, this.left = i, this.position = l, this.withArrow = g
                    }

                    pin(r) {
                        this.unpin(), this._pinWhenIsVisibleCallback = () => {
                            this.isVisible ? this._startPinning(r) : this._stopPinning()
                        }, this._startPinning(r), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
                    }

                    unpin() {
                        this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide())
                    }

                    _startPinning(r) {
                        this.attachTo(r);
                        const e = Ib(r.target), t = r.limiter ? Ib(r.limiter) : AA;
                        this.listenTo(bt.document, "scroll", (n, i) => {
                            const s = i.target, l = e && s.contains(e), d = t && s.contains(t);
                            !l && !d && e && t || this.attachTo(r)
                        }, {useCapture: !0}), this.listenTo(bt.window, "resize", () => {
                            this.attachTo(r)
                        })
                    }

                    _stopPinning() {
                        this.stopListening(bt.document, "scroll"), this.stopListening(bt.window, "resize")
                    }
                };
            let ui = Tb;

            function Ib(r) {
                return po(r) ? r : ca(r) ? r.commonAncestorContainer : typeof r == "function" ? Ib(r()) : null
            }

            function CA(r = {}) {
                const {
                    sideOffset: e = ui.arrowSideOffset,
                    heightOffset: t = ui.arrowHeightOffset,
                    stickyVerticalOffset: n = ui.stickyVerticalOffset,
                    config: i
                } = r;
                return {
                    northWestArrowSouthWest: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left - e,
                        name: "arrow_sw"
                    }, i && {config: i}),
                    northWestArrowSouthMiddleWest: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left - .25 * g.width - e,
                        name: "arrow_smw"
                    }, i && {config: i}),
                    northWestArrowSouth: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left - g.width / 2,
                        name: "arrow_s"
                    }, i && {config: i}),
                    northWestArrowSouthMiddleEast: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left - .75 * g.width + e,
                        name: "arrow_sme"
                    }, i && {config: i}),
                    northWestArrowSouthEast: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left - g.width + e,
                        name: "arrow_se"
                    }, i && {config: i}),
                    northArrowSouthWest: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left + d.width / 2 - e,
                        name: "arrow_sw"
                    }, i && {config: i}),
                    northArrowSouthMiddleWest: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left + d.width / 2 - .25 * g.width - e,
                        name: "arrow_smw"
                    }, i && {config: i}),
                    northArrowSouth: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left + d.width / 2 - g.width / 2,
                        name: "arrow_s"
                    }, i && {config: i}),
                    northArrowSouthMiddleEast: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left + d.width / 2 - .75 * g.width + e,
                        name: "arrow_sme"
                    }, i && {config: i}),
                    northArrowSouthEast: (d, g) => Xt({
                        top: s(d, g),
                        left: d.left + d.width / 2 - g.width + e,
                        name: "arrow_se"
                    }, i && {config: i}),
                    northEastArrowSouthWest: (d, g) => Xt({
                        top: s(d, g),
                        left: d.right - e,
                        name: "arrow_sw"
                    }, i && {config: i}),
                    northEastArrowSouthMiddleWest: (d, g) => Xt({
                        top: s(d, g),
                        left: d.right - .25 * g.width - e,
                        name: "arrow_smw"
                    }, i && {config: i}),
                    northEastArrowSouth: (d, g) => Xt({
                        top: s(d, g),
                        left: d.right - g.width / 2,
                        name: "arrow_s"
                    }, i && {config: i}),
                    northEastArrowSouthMiddleEast: (d, g) => Xt({
                        top: s(d, g),
                        left: d.right - .75 * g.width + e,
                        name: "arrow_sme"
                    }, i && {config: i}),
                    northEastArrowSouthEast: (d, g) => Xt({
                        top: s(d, g),
                        left: d.right - g.width + e,
                        name: "arrow_se"
                    }, i && {config: i}),
                    southWestArrowNorthWest: d => Xt({top: l(d), left: d.left - e, name: "arrow_nw"}, i && {config: i}),
                    southWestArrowNorthMiddleWest: (d, g) => Xt({
                        top: l(d),
                        left: d.left - .25 * g.width - e,
                        name: "arrow_nmw"
                    }, i && {config: i}),
                    southWestArrowNorth: (d, g) => Xt({
                        top: l(d),
                        left: d.left - g.width / 2,
                        name: "arrow_n"
                    }, i && {config: i}),
                    southWestArrowNorthMiddleEast: (d, g) => Xt({
                        top: l(d),
                        left: d.left - .75 * g.width + e,
                        name: "arrow_nme"
                    }, i && {config: i}),
                    southWestArrowNorthEast: (d, g) => Xt({
                        top: l(d),
                        left: d.left - g.width + e,
                        name: "arrow_ne"
                    }, i && {config: i}),
                    southArrowNorthWest: d => Xt({
                        top: l(d),
                        left: d.left + d.width / 2 - e,
                        name: "arrow_nw"
                    }, i && {config: i}),
                    southArrowNorthMiddleWest: (d, g) => Xt({
                        top: l(d),
                        left: d.left + d.width / 2 - .25 * g.width - e,
                        name: "arrow_nmw"
                    }, i && {config: i}),
                    southArrowNorth: (d, g) => Xt({
                        top: l(d),
                        left: d.left + d.width / 2 - g.width / 2,
                        name: "arrow_n"
                    }, i && {config: i}),
                    southArrowNorthMiddleEast: (d, g) => Xt({
                        top: l(d),
                        left: d.left + d.width / 2 - .75 * g.width + e,
                        name: "arrow_nme"
                    }, i && {config: i}),
                    southArrowNorthEast: (d, g) => Xt({
                        top: l(d),
                        left: d.left + d.width / 2 - g.width + e,
                        name: "arrow_ne"
                    }, i && {config: i}),
                    southEastArrowNorthWest: d => Xt({
                        top: l(d),
                        left: d.right - e,
                        name: "arrow_nw"
                    }, i && {config: i}),
                    southEastArrowNorthMiddleWest: (d, g) => Xt({
                        top: l(d),
                        left: d.right - .25 * g.width - e,
                        name: "arrow_nmw"
                    }, i && {config: i}),
                    southEastArrowNorth: (d, g) => Xt({
                        top: l(d),
                        left: d.right - g.width / 2,
                        name: "arrow_n"
                    }, i && {config: i}),
                    southEastArrowNorthMiddleEast: (d, g) => Xt({
                        top: l(d),
                        left: d.right - .75 * g.width + e,
                        name: "arrow_nme"
                    }, i && {config: i}),
                    southEastArrowNorthEast: (d, g) => Xt({
                        top: l(d),
                        left: d.right - g.width + e,
                        name: "arrow_ne"
                    }, i && {config: i}),
                    westArrowEast: (d, g) => Xt({
                        top: d.top + d.height / 2 - g.height / 2,
                        left: d.left - g.width - t,
                        name: "arrow_e"
                    }, i && {config: i}),
                    eastArrowWest: (d, g) => Xt({
                        top: d.top + d.height / 2 - g.height / 2,
                        left: d.right + t,
                        name: "arrow_w"
                    }, i && {config: i}),
                    viewportStickyNorth: (d, g, v, _) => {
                        const x = _ || v;
                        return d.getIntersection(x) ? x.height - d.height > n ? null : {
                            top: x.top + n,
                            left: d.left + d.width / 2 - g.width / 2,
                            name: "arrowless",
                            config: Xt({withArrow: !1}, i)
                        } : null
                    }
                };

                function s(d, g) {
                    return d.top - g.height - t
                }

                function l(d) {
                    return d.bottom + t
                }
            }

            ui.arrowSideOffset = 25, ui.arrowHeightOffset = 10, ui.stickyVerticalOffset = 20, ui._getOptimalPosition = zo, ui.defaultPositions = CA();
            var _A = C(3332),
                dT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(_A.Z, dT), _A.Z.locals;
            const yA = "ck-tooltip", di = class extends dr() {
                constructor(r) {
                    if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, di._editors.add(r), di._instance) return di._instance;
                    di._instance = this, this.tooltipTextView = new It(r.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({
                        tag: "span",
                        attributes: {class: ["ck", "ck-tooltip__text"]},
                        children: [{text: this.tooltipTextView.bindTemplate.to("text")}]
                    }), this.balloonPanelView = new ui(r.locale), this.balloonPanelView.class = yA, this.balloonPanelView.content.add(this.tooltipTextView), this._pinTooltipDebounced = Zn(this._pinTooltip, 600), this.listenTo(bt.document, "mouseenter", this._onEnterOrFocus.bind(this), {useCapture: !0}), this.listenTo(bt.document, "mouseleave", this._onLeaveOrBlur.bind(this), {useCapture: !0}), this.listenTo(bt.document, "focus", this._onEnterOrFocus.bind(this), {useCapture: !0}), this.listenTo(bt.document, "blur", this._onLeaveOrBlur.bind(this), {useCapture: !0}), this.listenTo(bt.document, "scroll", this._onScroll.bind(this), {useCapture: !0}), this._watchdogExcluded = !0
                }

                destroy(r) {
                    const e = r.ui.view && r.ui.view.body;
                    di._editors.delete(r), this.stopListening(r.ui), e && e.has(this.balloonPanelView) && e.remove(this.balloonPanelView), di._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), di._instance = null)
                }

                static getPositioningFunctions(r) {
                    const e = di.defaultBalloonPositions;
                    return {
                        s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest],
                        n: [e.northArrowSouth],
                        e: [e.eastArrowWest],
                        w: [e.westArrowEast],
                        sw: [e.southArrowNorthEast],
                        se: [e.southArrowNorthWest]
                    }[r]
                }

                _onEnterOrFocus(r, {target: e}) {
                    const t = Mb(e);
                    var n;
                    t && t !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(t, {
                        text: (n = t).dataset.ckeTooltipText,
                        position: n.dataset.ckeTooltipPosition || "s",
                        cssClass: n.dataset.ckeTooltipClass || ""
                    }))
                }

                _onLeaveOrBlur(r, {target: e, relatedTarget: t}) {
                    if (r.name === "mouseleave") {
                        if (!po(e) || this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
                        const n = Mb(e), i = Mb(t);
                        n && n !== i && this._unpinTooltip()
                    } else {
                        if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
                        this._unpinTooltip()
                    }
                }

                _onScroll(r, {target: e}) {
                    this._currentElementWithTooltip && (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip) || this._unpinTooltip())
                }

                _pinTooltip(r, {text: e, position: t, cssClass: n}) {
                    const i = Wn(di._editors.values()).ui.view.body;
                    i.has(this.balloonPanelView) || i.add(this.balloonPanelView), this.tooltipTextView.text = e, this.balloonPanelView.pin({
                        target: r,
                        positions: di.getPositioningFunctions(t)
                    }), this._resizeObserver = new ua(r, () => {
                        mo(r) || this._unpinTooltip()
                    }), this.balloonPanelView.class = [yA, n].filter(s => s).join(" ");
                    for (const s of di._editors) this.listenTo(s.ui, "update", this._updateTooltipPosition.bind(this), {priority: "low"});
                    this._currentElementWithTooltip = r, this._currentTooltipPosition = t
                }

                _unpinTooltip() {
                    this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
                    for (const r of di._editors) this.stopListening(r.ui, "update");
                    this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy()
                }

                _updateTooltipPosition() {
                    mo(this._currentElementWithTooltip) ? this.balloonPanelView.pin({
                        target: this._currentElementWithTooltip,
                        positions: di.getPositioningFunctions(this._currentTooltipPosition)
                    }) : this._unpinTooltip()
                }
            };
            let Fg = di;

            function Mb(r) {
                return po(r) ? r.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null
            }

            Fg.defaultBalloonPositions = CA({
                heightOffset: 5,
                sideOffset: 13
            }), Fg._editors = new Set, Fg._instance = null;
            const Rg = function (r, e, t) {
                var n = !0, i = !0;
                if (typeof r != "function") throw new TypeError("Expected a function");
                return Oe(t) && (n = "leading" in t ? !!t.leading : n, i = "trailing" in t ? !!t.trailing : i), Zn(r, e, {
                    leading: n,
                    maxWait: e,
                    trailing: i
                })
            };
            var hT = Object.defineProperty, DA = Object.getOwnPropertySymbols, fT = Object.prototype.hasOwnProperty,
                gT = Object.prototype.propertyIsEnumerable, xA = (r, e, t) => e in r ? hT(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, pT = (r, e) => {
                    for (var t in e || (e = {})) fT.call(e, t) && xA(r, t, e[t]);
                    if (DA) for (var t of DA(e)) gT.call(e, t) && xA(r, t, e[t]);
                    return r
                };
            const mT = 50, bT = 350, kT = "Powered by";

            class vT extends dr() {
                constructor(e) {
                    super(), this.editor = e, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = Rg(this._showBalloon.bind(this), 50, {leading: !0}), e.on("ready", this._handleEditorReady.bind(this))
                }

                destroy() {
                    const e = this._balloonView;
                    e && (e.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening()
                }

                _handleEditorReady() {
                    const e = this.editor;
                    (e.config.get("ui.poweredBy.forceVisible") || function (t) {
                        function n(O) {
                            return O.length >= 40 && O.length <= 255 ? "VALID" : "INVALID"
                        }

                        if (!t) return "INVALID";
                        let i = "";
                        try {
                            i = atob(t)
                        } catch {
                            return "INVALID"
                        }
                        const s = i.split("-"), l = s[0], d = s[1];
                        if (!d) return n(t);
                        try {
                            atob(d)
                        } catch {
                            try {
                                if (atob(l), !atob(l).length) return n(t)
                            } catch {
                                return n(t)
                            }
                        }
                        if (l.length < 40 || l.length > 255) return "INVALID";
                        let g = "";
                        try {
                            atob(l), g = atob(d)
                        } catch {
                            return "INVALID"
                        }
                        if (g.length !== 8) return "INVALID";
                        const v = Number(g.substring(0, 4)), _ = Number(g.substring(4, 6)) - 1,
                            x = Number(g.substring(6, 8)), M = new Date(v, _, x);
                        return M < ye || isNaN(Number(M)) ? "INVALID" : "VALID"
                    }(e.config.get("licenseKey")) !== "VALID") && e.ui.view && (e.ui.focusTracker.on("change:isFocused", (t, n, i) => {
                        this._updateLastFocusedEditableElement(), i ? this._showBalloon() : this._hideBalloon()
                    }), e.ui.focusTracker.on("change:focusedElement", (t, n, i) => {
                        this._updateLastFocusedEditableElement(), i && this._showBalloon()
                    }), e.ui.on("update", () => {
                        this._showBalloonThrottled()
                    }))
                }

                _createBalloonView() {
                    const e = this.editor, t = this._balloonView = new ui, n = SA(e), i = new wT(e.locale, n.label);
                    t.content.add(i), t.set({class: "ck-powered-by-balloon"}), e.ui.view.body.add(t), e.ui.focusTracker.add(t.element), this._balloonView = t
                }

                _showBalloon() {
                    if (!this._lastFocusedEditableElement) return;
                    const e = function (t, n) {
                        const i = SA(t), s = i.side === "right" ? function (l, d) {
                            return EA(l, d, (g, v) => g.left + g.width - v.width - d.horizontalOffset)
                        }(n, i) : function (l, d) {
                            return EA(l, d, g => g.left + d.horizontalOffset)
                        }(n, i);
                        return {target: n, positions: [s]}
                    }(this.editor, this._lastFocusedEditableElement);
                    e && (this._balloonView || this._createBalloonView(), this._balloonView.pin(e))
                }

                _hideBalloon() {
                    this._balloonView && this._balloonView.unpin()
                }

                _updateLastFocusedEditableElement() {
                    const e = this.editor, t = e.ui.focusTracker.isFocused, n = e.ui.focusTracker.focusedElement;
                    if (!t || !n) return void (this._lastFocusedEditableElement = null);
                    const i = Array.from(e.ui.getEditableElementsNames()).map(s => e.ui.getEditableElement(s));
                    i.includes(n) ? this._lastFocusedEditableElement = n : this._lastFocusedEditableElement = i[0]
                }
            }

            class wT extends It {
                constructor(e, t) {
                    super(e);
                    const n = new Ho, i = this.bindTemplate;
                    n.set({
                        content: `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>
`, isColorInherited: !1
                    }), n.extendTemplate({
                        attributes: {
                            style: {
                                width: "53px",
                                height: "10px"
                            }
                        }
                    }), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-powered-by"], "aria-hidden": !0},
                        children: [{
                            tag: "a",
                            attributes: {
                                href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
                                target: "_blank",
                                tabindex: "-1"
                            },
                            children: [...t ? [{
                                tag: "span",
                                attributes: {class: ["ck", "ck-powered-by__label"]},
                                children: [t]
                            }] : [], n],
                            on: {dragstart: i.to(s => s.preventDefault())}
                        }]
                    })
                }
            }

            function EA(r, e, t) {
                return (n, i) => {
                    const s = new Lt(r);
                    if (s.width < bT || s.height < mT) return null;
                    let l;
                    l = e.position === "inside" ? s.bottom - i.height : s.bottom - i.height / 2, l -= e.verticalOffset;
                    const d = t(s, i), g = n.clone().moveTo(d, l).getIntersection(i.clone().moveTo(d, l)).getVisible();
                    return !g || g.getArea() < i.getArea() ? null : {
                        top: l,
                        left: d,
                        name: `position_${e.position}-side_${e.side}`,
                        config: {withArrow: !1}
                    }
                }
            }

            function SA(r) {
                const e = r.config.get("ui.poweredBy"), t = e && e.position || "border";
                return pT({
                    position: t,
                    label: kT,
                    verticalOffset: t === "inside" ? 5 : 0,
                    horizontalOffset: 5,
                    side: r.locale.contentLanguageDirection === "ltr" ? "right" : "left"
                }, e)
            }

            var TA = C(3210),
                AT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(TA.Z, AT), TA.Z.locals;

            class CT {
                constructor(e) {
                    this.editor = e
                }

                announce(e, t, n = "polite") {
                    const i = this.editor;
                    this.view || (this.view = new _T(i.locale), i.ui.view.body.add(this.view));
                    let s = this.view.regionViews.find(l => l.regionName === e);
                    s || (s = new yT(this.view.locale), this.view.regionViews.add(s)), s.set({
                        regionName: e,
                        text: t,
                        politeness: n
                    })
                }
            }

            class _T extends It {
                constructor(e) {
                    super(e), this.regionViews = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-aria-live-announcer"]},
                        children: this.regionViews
                    })
                }
            }

            class yT extends It {
                constructor(e) {
                    super(e);
                    const t = this.bindTemplate;
                    this.set("regionName", ""), this.set("text", ""), this.set("politeness", "polite"), this.setTemplate({
                        tag: "div",
                        attributes: {
                            role: "region",
                            "data-region": t.to("regionName"),
                            "aria-live": t.to("politeness")
                        },
                        children: [{text: t.to("text")}]
                    })
                }
            }

            var DT = Object.defineProperty, IA = Object.getOwnPropertySymbols, xT = Object.prototype.hasOwnProperty,
                ET = Object.prototype.propertyIsEnumerable, MA = (r, e, t) => e in r ? DT(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            class ST extends we() {
                constructor(e) {
                    super(), this.isReady = !1, this._editableElementsMap = new Map, this._focusableToolbarDefinitions = [];
                    const t = e.editing.view;
                    this.editor = e, this.componentFactory = new oT(e), this.focusTracker = new Nr, this.tooltipManager = new Fg(e), this.poweredBy = new vT(e), this.ariaLiveAnnouncer = new CT(e), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
                        this.isReady = !0
                    }), this.listenTo(t.document, "layoutChanged", this.update.bind(this)), this.listenTo(t, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)), this._initFocusTracking()
                }

                get element() {
                    return null
                }

                update() {
                    this.fire("update")
                }

                destroy() {
                    this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
                    for (const e of this._editableElementsMap.values()) e.ckeditorInstance = null, this.editor.keystrokes.stopListening(e);
                    this._editableElementsMap = new Map, this._focusableToolbarDefinitions = []
                }

                setEditableElement(e, t) {
                    this._editableElementsMap.set(e, t), t.ckeditorInstance || (t.ckeditorInstance = this.editor), this.focusTracker.add(t);
                    const n = () => {
                        this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t)
                    };
                    this.isReady ? n() : this.once("ready", n)
                }

                removeEditableElement(e) {
                    const t = this._editableElementsMap.get(e);
                    t && (this._editableElementsMap.delete(e), this.editor.keystrokes.stopListening(t), this.focusTracker.remove(t), t.ckeditorInstance = null)
                }

                getEditableElement(e = "main") {
                    return this._editableElementsMap.get(e)
                }

                getEditableElementsNames() {
                    return this._editableElementsMap.keys()
                }

                addToolbar(e, t = {}) {
                    e.isRendered ? (this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
                        this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element)
                    }), this._focusableToolbarDefinitions.push({toolbarView: e, options: t})
                }

                get _editableElements() {
                    return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {editorUI: this}), this._editableElementsMap
                }

                _readViewportOffsetFromConfig() {
                    const e = this.editor, t = e.config.get("ui.viewportOffset");
                    if (t) return t;
                    const n = e.config.get("toolbar.viewportTopOffset");
                    return n ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), {top: n}) : {top: 0}
                }

                _initFocusTracking() {
                    const e = this.editor, t = e.editing.view;
                    let n, i;
                    e.keystrokes.set("Alt+F10", (s, l) => {
                        const d = this.focusTracker.focusedElement;
                        Array.from(this._editableElementsMap.values()).includes(d) && !Array.from(t.domRoots.values()).includes(d) && (n = d);
                        const g = this._getCurrentFocusedToolbarDefinition();
                        g && i || (i = this._getFocusableCandidateToolbarDefinitions());
                        for (let v = 0; v < i.length; v++) {
                            const _ = i.shift();
                            if (i.push(_), _ !== g && this._focusFocusableCandidateToolbar(_)) {
                                g && g.options.afterBlur && g.options.afterBlur();
                                break
                            }
                        }
                        l()
                    }), e.keystrokes.set("Esc", (s, l) => {
                        const d = this._getCurrentFocusedToolbarDefinition();
                        d && (n ? (n.focus(), n = null) : e.editing.view.focus(), d.options.afterBlur && d.options.afterBlur(), l())
                    })
                }

                _getFocusableCandidateToolbarDefinitions() {
                    const e = [];
                    for (const t of this._focusableToolbarDefinitions) {
                        const {toolbarView: n, options: i} = t;
                        (mo(n.element) || i.beforeFocus) && e.push(t)
                    }
                    return e.sort((t, n) => BA(t) - BA(n)), e
                }

                _getCurrentFocusedToolbarDefinition() {
                    for (const e of this._focusableToolbarDefinitions) if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement)) return e;
                    return null
                }

                _focusFocusableCandidateToolbar(e) {
                    const {toolbarView: t, options: {beforeFocus: n}} = e;
                    return n && n(), !!mo(t.element) && (t.focus(), !0)
                }

                _handleScrollToTheSelection(e, t) {
                    const n = ((i, s) => {
                        for (var l in s || (s = {})) xT.call(s, l) && MA(i, l, s[l]);
                        if (IA) for (var l of IA(s)) ET.call(s, l) && MA(i, l, s[l]);
                        return i
                    })({top: 0, bottom: 0, left: 0, right: 0}, this.viewportOffset);
                    t.viewportOffset.top += n.top, t.viewportOffset.bottom += n.bottom, t.viewportOffset.left += n.left, t.viewportOffset.right += n.right
                }
            }

            function BA(r) {
                const {toolbarView: e, options: t} = r;
                let n = 10;
                return mo(e.element) && n--, t.isContextual && n--, n
            }

            var NA = C(9688),
                TT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(NA.Z, TT), NA.Z.locals;

            class IT extends It {
                constructor(e) {
                    super(e), this.body = new Vo(e)
                }

                render() {
                    super.render(), this.body.attachToDom()
                }

                destroy() {
                    return this.body.detachFromDom(), super.destroy()
                }
            }

            class MT extends IT {
                constructor(e) {
                    super(e), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
                            role: "application",
                            dir: e.uiLanguageDirection,
                            lang: e.uiLanguage,
                            "aria-labelledby": this._voiceLabelView.id
                        },
                        children: [this._voiceLabelView, {
                            tag: "div",
                            attributes: {class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation"},
                            children: this.top
                        }, {
                            tag: "div",
                            attributes: {class: ["ck", "ck-editor__main"], role: "presentation"},
                            children: this.main
                        }]
                    })
                }

                _createVoiceLabel() {
                    const e = this.t, t = new Jc;
                    return t.text = e("Rich Text Editor"), t.extendTemplate({attributes: {class: "ck-voice-label"}}), t
                }
            }

            class BT extends It {
                constructor(e, t, n) {
                    super(e), this.name = null, this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                            lang: e.contentLanguage,
                            dir: e.contentLanguageDirection
                        }
                    }), this.set("isFocused", !1), this._editableElement = n, this._hasExternalElement = !!this._editableElement, this._editingView = t
                }

                render() {
                    super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses()
                }

                destroy() {
                    this._hasExternalElement && this.template.revert(this._editableElement), super.destroy()
                }

                get hasExternalElement() {
                    return this._hasExternalElement
                }

                _updateIsFocusedClasses() {
                    const e = this._editingView;

                    function t(n) {
                        e.change(i => {
                            const s = e.document.getRoot(n.name);
                            i.addClass(n.isFocused ? "ck-focused" : "ck-blurred", s), i.removeClass(n.isFocused ? "ck-blurred" : "ck-focused", s)
                        })
                    }

                    e.isRenderingInProgress ? function n(i) {
                        e.once("change:isRenderingInProgress", (s, l, d) => {
                            d ? n(i) : t(i)
                        })
                    }(this) : t(this)
                }
            }

            class NT extends BT {
                constructor(e, t, n, i = {}) {
                    super(e, t, n);
                    const s = e.t;
                    this.extendTemplate({
                        attributes: {
                            role: "textbox",
                            class: "ck-editor__editable_inline"
                        }
                    }), this._generateLabel = i.label || (() => s("Editor editing area: %0", this.name))
                }

                render() {
                    super.render();
                    const e = this._editingView;
                    e.change(t => {
                        const n = e.document.getRoot(this.name);
                        t.setAttribute("aria-label", this._generateLabel(this), n)
                    })
                }
            }

            var LA = C(8847),
                LT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(LA.Z, LT), LA.Z.locals;

            class Bb extends Tl {
                static get pluginName() {
                    return "Notification"
                }

                init() {
                    this.on("show:warning", (e, t) => {
                        window.alert(t.message)
                    }, {priority: "lowest"})
                }

                showSuccess(e, t = {}) {
                    this._showNotification({message: e, type: "success", namespace: t.namespace, title: t.title})
                }

                showInfo(e, t = {}) {
                    this._showNotification({message: e, type: "info", namespace: t.namespace, title: t.title})
                }

                showWarning(e, t = {}) {
                    this._showNotification({message: e, type: "warning", namespace: t.namespace, title: t.title})
                }

                _showNotification(e) {
                    const t = e.namespace ? `show:${e.type}:${e.namespace}` : `show:${e.type}`;
                    this.fire(t, {message: e.message, type: e.type, title: e.title || ""})
                }
            }

            class PA extends we() {
                constructor(e, t) {
                    super(), t && Ln(this, t), e && this.set(e)
                }
            }

            var OA = C(4650),
                PT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(OA.Z, PT), OA.Z.locals;
            var FA = C(7676),
                OT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(FA.Z, OT), FA.Z.locals;
            const zg = Ro("px");

            class jg extends Re {
                constructor(e) {
                    super(e), this._viewToStack = new Map, this._idToStack = new Map, this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
                        const t = this.editor.editing.view, n = t.document.selection.editableElement;
                        return n ? t.domConverter.mapViewToDom(n.root) : null
                    }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1)
                }

                static get pluginName() {
                    return "ContextualBalloon"
                }

                destroy() {
                    super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy()
                }

                get view() {
                    return this._view || this._createPanelView(), this._view
                }

                hasView(e) {
                    return Array.from(this._viewToStack.keys()).includes(e)
                }

                add(e) {
                    if (this._view || this._createPanelView(), this.hasView(e.view)) throw new R("contextualballoon-add-view-exist", [this, e]);
                    const t = e.stackId || "main";
                    if (!this._idToStack.has(t)) return this._idToStack.set(t, new Map([[e.view, e]])), this._viewToStack.set(e.view, this._idToStack.get(t)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !e.singleViewMode || this.showStack(t));
                    const n = this._idToStack.get(t);
                    e.singleViewMode && this.showStack(t), n.set(e.view, e), this._viewToStack.set(e.view, n), n === this._visibleStack && this._showView(e)
                }

                remove(e) {
                    if (!this.hasView(e)) throw new R("contextualballoon-remove-view-not-exist", [this, e]);
                    const t = this._viewToStack.get(e);
                    this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1), this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])), t.size === 1 ? (this._idToStack.delete(this._getStackId(t)), this._numberOfStacks = this._idToStack.size) : t.delete(e), this._viewToStack.delete(e)
                }

                updatePosition(e) {
                    e && (this._visibleStack.get(this.visibleView).position = e), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition()
                }

                showStack(e) {
                    this.visibleStack = e;
                    const t = this._idToStack.get(e);
                    if (!t) throw new R("contextualballoon-showstack-stack-not-exist", this);
                    this._visibleStack !== t && this._showView(Array.from(t.values()).pop())
                }

                _createPanelView() {
                    this._view = new ui(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView()
                }

                get _visibleStack() {
                    return this._viewToStack.get(this.visibleView)
                }

                _getStackId(e) {
                    return Array.from(this._idToStack.entries()).find(t => t[1] === e)[0]
                }

                _showNextStack() {
                    const e = Array.from(this._idToStack.values());
                    let t = e.indexOf(this._visibleStack) + 1;
                    e[t] || (t = 0), this.showStack(this._getStackId(e[t]))
                }

                _showPrevStack() {
                    const e = Array.from(this._idToStack.values());
                    let t = e.indexOf(this._visibleStack) - 1;
                    e[t] || (t = e.length - 1), this.showStack(this._getStackId(e[t]))
                }

                _createRotatorView() {
                    const e = new FT(this.editor.locale), t = this.editor.locale.t;
                    return this.view.content.add(e), e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (n, i) => !i && n > 1), e.on("change:isNavigationVisible", () => this.updatePosition(), {priority: "low"}), e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (n, i) => {
                        if (i < 2) return "";
                        const s = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                        return t("%0 of %1", [s, i])
                    }), e.buttonNextView.on("execute", () => {
                        e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack()
                    }), e.buttonPrevView.on("execute", () => {
                        e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack()
                    }), e
                }

                _createFakePanelsView() {
                    const e = new RT(this.editor.locale, this.view);
                    return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, n) => !n && t >= 2 ? Math.min(t - 1, 2) : 0), e.listenTo(this.view, "change:top", () => e.updatePosition()), e.listenTo(this.view, "change:left", () => e.updatePosition()), this.editor.ui.view.body.add(e), e
                }

                _showView({view: e, balloonClassName: t = "", withArrow: n = !0, singleViewMode: i = !1}) {
                    this.view.class = t, this.view.withArrow = n, this._rotatorView.showView(e), this.visibleView = e, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), i && (this._singleViewMode = !0)
                }

                _getBalloonPosition() {
                    let e = Array.from(this._visibleStack.values()).pop().position;
                    return e && (e.limiter || (e = Object.assign({}, e, {limiter: this.positionLimiter})), e = Object.assign({}, e, {viewportOffsetConfig: this.editor.ui.viewportOffset})), e
                }
            }

            class FT extends It {
                constructor(e) {
                    super(e);
                    const t = e.t, n = this.bindTemplate;
                    this.set("isNavigationVisible", !0), this.focusTracker = new Nr, this.buttonPrevView = this._createButtonView(t("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(t("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-balloon-rotator"], "z-index": "-1"},
                        children: [{
                            tag: "div",
                            attributes: {class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", i => i ? "" : "ck-hidden")]},
                            children: [this.buttonPrevView, {
                                tag: "span",
                                attributes: {class: ["ck-balloon-rotator__counter"]},
                                children: [{text: n.to("counter")}]
                            }, this.buttonNextView]
                        }, {tag: "div", attributes: {class: "ck-balloon-rotator__content"}, children: this.content}]
                    })
                }

                render() {
                    super.render(), this.focusTracker.add(this.element)
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy()
                }

                showView(e) {
                    this.hideView(), this.content.add(e)
                }

                hideView() {
                    this.content.clear()
                }

                _createButtonView(e, t) {
                    const n = new sn(this.locale);
                    return n.set({label: e, icon: t, tooltip: !0}), n
                }
            }

            class RT extends It {
                constructor(e, t) {
                    super(e);
                    const n = this.bindTemplate;
                    this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t, this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck-fake-panel", n.to("numberOfPanels", i => i ? "" : "ck-hidden")],
                            style: {
                                top: n.to("top", zg),
                                left: n.to("left", zg),
                                width: n.to("width", zg),
                                height: n.to("height", zg)
                            }
                        },
                        children: this.content
                    }), this.on("change:numberOfPanels", (i, s, l, d) => {
                        l > d ? this._addPanels(l - d) : this._removePanels(d - l), this.updatePosition()
                    })
                }

                _addPanels(e) {
                    for (; e--;) {
                        const t = new It;
                        t.setTemplate({tag: "div"}), this.content.add(t), this.registerChild(t)
                    }
                }

                _removePanels(e) {
                    for (; e--;) {
                        const t = this.content.last;
                        this.content.remove(t), this.deregisterChild(t), t.destroy()
                    }
                }

                updatePosition() {
                    if (this.numberOfPanels) {
                        const {top: e, left: t} = this._balloonPanelView, {
                            width: n,
                            height: i
                        } = new Lt(this._balloonPanelView.element);
                        Object.assign(this, {top: e, left: t, width: n, height: i})
                    }
                }
            }

            var RA = C(5868),
                zT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(RA.Z, zT), RA.Z.locals;
            const ku = Ro("px");

            class jT extends It {
                constructor(e) {
                    super(e);
                    const t = this.bindTemplate;
                    this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheBottomOfLimiter", !1), this.set("_stickyTopOffset", null), this.set("_stickyBottomOffset", null), this.content = this.createCollection(), this._contentPanelPlaceholder = new xi({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel__placeholder"],
                            style: {
                                display: t.to("isSticky", n => n ? "block" : "none"),
                                height: t.to("isSticky", n => n ? ku(this._contentPanelRect.height) : null)
                            }
                        }
                    }).render(), this._contentPanel = new xi({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel__content", t.if("isSticky", "ck-sticky-panel__content_sticky"), t.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")],
                            style: {
                                width: t.to("isSticky", n => n ? ku(this._contentPanelPlaceholder.getBoundingClientRect().width) : null),
                                top: t.to("_stickyTopOffset", n => n && ku(n)),
                                bottom: t.to("_stickyBottomOffset", n => n && ku(n)),
                                marginLeft: t.to("_marginLeft")
                            }
                        },
                        children: this.content
                    }).render(), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-sticky-panel"]},
                        children: [this._contentPanelPlaceholder, this._contentPanel]
                    })
                }

                render() {
                    super.render(), this.checkIfShouldBeSticky(), this.listenTo(bt.document, "scroll", () => {
                        this.checkIfShouldBeSticky()
                    }, {useCapture: !0}), this.listenTo(this, "change:isActive", () => {
                        this.checkIfShouldBeSticky()
                    })
                }

                checkIfShouldBeSticky() {
                    if (!this.limiterElement || !this.isActive) return void this._unstick();
                    const e = new Lt(this.limiterElement);
                    let t = e.getVisible();
                    if (t) {
                        const n = new Lt(bt.window);
                        n.top += this.viewportTopOffset, n.height -= this.viewportTopOffset, t = t.getIntersection(n)
                    }
                    if (t && e.top < t.top) {
                        const n = t.top;
                        if (n + this._contentPanelRect.height + this.limiterBottomOffset > t.bottom) {
                            const i = Math.max(e.bottom - t.bottom, 0) + this.limiterBottomOffset;
                            e.bottom - i > e.top + this._contentPanelRect.height ? this._stickToBottomOfLimiter(i) : this._unstick()
                        } else this._contentPanelRect.height + this.limiterBottomOffset < e.height ? this._stickToTopOfAncestors(n) : this._unstick()
                    } else this._unstick()
                }

                _stickToTopOfAncestors(e) {
                    this.isSticky = !0, this._isStickyToTheBottomOfLimiter = !1, this._stickyTopOffset = e, this._stickyBottomOffset = null, this._marginLeft = ku(-bt.window.scrollX)
                }

                _stickToBottomOfLimiter(e) {
                    this.isSticky = !0, this._isStickyToTheBottomOfLimiter = !0, this._stickyTopOffset = null, this._stickyBottomOffset = e, this._marginLeft = ku(-bt.window.scrollX)
                }

                _unstick() {
                    this.isSticky = !1, this._isStickyToTheBottomOfLimiter = !1, this._stickyTopOffset = null, this._stickyBottomOffset = null, this._marginLeft = null
                }

                get _contentPanelRect() {
                    return new Lt(this._contentPanel)
                }
            }

            class VT extends Xc {
                constructor(e, t) {
                    const n = e.t, i = Object.assign({}, {showResetButton: !0, showIcon: !0, creator: Lg}, t);
                    super(e, i.creator), this.label = t.label, this._viewConfig = i, this._viewConfig.showIcon && (this.iconView = new Ho, this.iconView.content = mn.loupe, this.fieldWrapperChildren.add(this.iconView, 0), this.extendTemplate({attributes: {class: "ck-search__query_with-icon"}})), this._viewConfig.showResetButton && (this.resetButtonView = new sn(e), this.resetButtonView.set({
                        label: n("Clear"),
                        icon: mn.cancel,
                        class: "ck-search__reset",
                        isVisible: !1,
                        tooltip: !0
                    }), this.resetButtonView.on("execute", () => {
                        this.reset(), this.focus(), this.fire("reset")
                    }), this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", s => !s), this.fieldWrapperChildren.add(this.resetButtonView), this.extendTemplate({attributes: {class: "ck-search__query_with-reset"}}))
                }

                reset() {
                    this.fieldView.reset(), this._viewConfig.showResetButton && (this.resetButtonView.isVisible = !1)
                }
            }

            class HT extends It {
                constructor() {
                    super();
                    const e = this.bindTemplate;
                    this.set({isVisible: !1, primaryText: "", secondaryText: ""}), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-search__info", e.if("isVisible", "ck-hidden", t => !t)],
                            tabindex: -1
                        },
                        children: [{tag: "span", children: [{text: [e.to("primaryText")]}]}, {
                            tag: "span",
                            children: [{text: [e.to("secondaryText")]}]
                        }]
                    })
                }

                focus() {
                    this.element.focus()
                }
            }

            class UT extends It {
                constructor(e) {
                    super(e), this.children = this.createCollection(), this.focusTracker = new Nr, this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-search__results"], tabindex: -1},
                        children: this.children
                    }), this._focusCycler = new yn({focusables: this.children, focusTracker: this.focusTracker})
                }

                render() {
                    super.render();
                    for (const e of this.children) this.focusTracker.add(e.element)
                }

                focus() {
                    this._focusCycler.focusFirst()
                }

                focusFirst() {
                    this._focusCycler.focusFirst()
                }

                focusLast() {
                    this._focusCycler.focusLast()
                }
            }

            var zA = /[\\^$.*+?()[\]{}|]/g, qT = RegExp(zA.source);
            const jA = function (r) {
                return (r = Pd(r)) && qT.test(r) ? r.replace(zA, "\\$&") : r
            };
            var VA = C(6770),
                WT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(VA.Z, WT), VA.Z.locals;
            var $T = Object.defineProperty, HA = Object.getOwnPropertySymbols, GT = Object.prototype.hasOwnProperty,
                KT = Object.prototype.propertyIsEnumerable, UA = (r, e, t) => e in r ? $T(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            class ZT extends It {
                constructor(e, t) {
                    super(e), this._config = t, this.filteredView = t.filteredView, this.queryView = this._createSearchTextQueryView(), this.focusTracker = new Nr, this.keystrokes = new si, this.resultsView = new UT(e), this.children = this.createCollection(), this.focusableChildren = this.createCollection([this.queryView, this.resultsView]), this.set("isEnabled", !0), this.set("resultsCount", 0), this.set("totalItemsCount", 0), t.infoView && t.infoView.instance ? this.infoView = t.infoView.instance : (this.infoView = new HT, this._enableDefaultInfoViewBehavior(), this.on("render", () => {
                        this.search("")
                    })), this.resultsView.children.addMany([this.infoView, this.filteredView]), this.focusCycler = new yn({
                        focusables: this.focusableChildren,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                    }), this.on("search", (n, {resultsCount: i, totalItemsCount: s}) => {
                        this.resultsCount = i, this.totalItemsCount = s
                    }), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-search", t.class || null], tabindex: "-1"},
                        children: this.children
                    })
                }

                render() {
                    super.render(), this.children.addMany([this.queryView, this.resultsView]);
                    const e = t => t.stopPropagation();
                    for (const t of this.focusableChildren) this.focusTracker.add(t.element);
                    this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e)
                }

                focus() {
                    this.queryView.focus()
                }

                reset() {
                    this.queryView.reset(), this.search("")
                }

                search(e) {
                    const t = e ? new RegExp(jA(e), "ig") : null, n = this.filteredView.filter(t);
                    this.fire("search", ((i, s) => {
                        for (var l in s || (s = {})) GT.call(s, l) && UA(i, l, s[l]);
                        if (HA) for (var l of HA(s)) KT.call(s, l) && UA(i, l, s[l]);
                        return i
                    })({query: e}, n))
                }

                _createSearchTextQueryView() {
                    const e = new VT(this.locale, this._config.queryView);
                    return this.listenTo(e.fieldView, "input", () => {
                        this.search(e.fieldView.element.value)
                    }), e.on("reset", () => this.reset()), e.bind("isEnabled").to(this), e
                }

                _enableDefaultInfoViewBehavior() {
                    const e = this.locale.t, t = this.infoView;

                    function n(i, {query: s, resultsCount: l, totalItemsCount: d}) {
                        return typeof i == "function" ? i(s, l, d) : i
                    }

                    this.on("search", (i, s) => {
                        if (s.resultsCount) t.set({isVisible: !1}); else {
                            const l = this._config.infoView && this._config.infoView.text;
                            let d, g;
                            s.totalItemsCount ? l && l.notFound ? (d = l.notFound.primary, g = l.notFound.secondary) : (d = e("No results found"), g = "") : l && l.noSearchableItems ? (d = l.noSearchableItems.primary, g = l.noSearchableItems.secondary) : (d = e("No searchable items"), g = ""), t.set({
                                primaryText: n(d, s),
                                secondaryText: n(g, s),
                                isVisible: !0
                            })
                        }
                    })
                }
            }

            var qA = C(8157),
                YT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(qA.Z, YT), qA.Z.locals;
            const Nb = class extends ZT {
                constructor(r, e) {
                    super(r, e), this._config = e;
                    const t = Ro("px");
                    this.extendTemplate({attributes: {class: ["ck-autocomplete"]}});
                    const n = this.resultsView.bindTemplate;
                    this.resultsView.set("isVisible", !1), this.resultsView.set("_position", "s"), this.resultsView.set("_width", 0), this.resultsView.extendTemplate({
                        attributes: {
                            class: [n.if("isVisible", "ck-hidden", i => !i), n.to("_position", i => `ck-search__results_${i}`)],
                            style: {width: n.to("_width", t)}
                        }
                    }), this.focusTracker.on("change:isFocused", (i, s, l) => {
                        this._updateResultsVisibility(), l ? this.resultsView.element.scrollTop = 0 : e.resetOnBlur && this.queryView.reset()
                    }), this.on("search", () => {
                        this._updateResultsVisibility(), this._updateResultsViewWidthAndPosition()
                    }), this.keystrokes.set("esc", (i, s) => {
                        this.resultsView.isVisible && (this.queryView.focus(), this.resultsView.isVisible = !1, s())
                    }), this.listenTo(bt.document, "scroll", () => {
                        this._updateResultsViewWidthAndPosition()
                    }), this.on("change:isEnabled", () => {
                        this._updateResultsVisibility()
                    }), this.filteredView.on("execute", (i, {value: s}) => {
                        this.focus(), this.reset(), this.queryView.fieldView.value = this.queryView.fieldView.element.value = s, this.resultsView.isVisible = !1
                    }), this.resultsView.on("change:isVisible", () => {
                        this._updateResultsViewWidthAndPosition()
                    })
                }

                _updateResultsViewWidthAndPosition() {
                    if (!this.resultsView.isVisible) return;
                    this.resultsView._width = new Lt(this.queryView.fieldView.element).width;
                    const r = Nb._getOptimalPosition({
                        element: this.resultsView.element,
                        target: this.queryView.element,
                        fitInViewport: !0,
                        positions: Nb.defaultResultsPositions
                    });
                    this.resultsView._position = r ? r.name : "s"
                }

                _updateResultsVisibility() {
                    const r = this._config.queryMinChars === void 0 ? 0 : this._config.queryMinChars,
                        e = this.queryView.fieldView.element.value.length;
                    this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && e >= r
                }
            };
            let WA = Nb;
            WA.defaultResultsPositions = [r => ({
                top: r.bottom,
                left: r.left,
                name: "s"
            }), (r, e) => ({top: r.top - e.height, left: r.left, name: "n"})], WA._getOptimalPosition = zo;
            var $A = C(8960),
                QT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()($A.Z, QT), $A.Z.locals;
            var GA = C(8010),
                JT = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(GA.Z, JT), GA.Z.locals;

            class XT extends It {
                constructor(e, t) {
                    super(e);
                    const n = this.bindTemplate;
                    this.set("isCollapsed", !1), this.set("label", ""), this.buttonView = this._createButtonView(), this.children = this.createCollection(), this.set("_collapsibleAriaLabelUid", void 0), t && this.children.addMany(t), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-collapsible", n.if("isCollapsed", "ck-collapsible_collapsed")]},
                        children: [this.buttonView, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-collapsible__children"],
                                role: "region",
                                hidden: n.if("isCollapsed", "hidden"),
                                "aria-labelledby": n.to("_collapsibleAriaLabelUid")
                            },
                            children: this.children
                        }]
                    })
                }

                render() {
                    super.render(), this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id
                }

                focus() {
                    this.buttonView.focus()
                }

                _createButtonView() {
                    const e = new sn(this.locale), t = e.bindTemplate;
                    return e.set({
                        withText: !0,
                        icon: Td
                    }), e.extendTemplate({attributes: {"aria-expanded": t.to("isOn", n => String(n))}}), e.bind("label").to(this), e.bind("isOn").to(this, "isCollapsed", n => !n), e.on("execute", () => {
                        this.isCollapsed = !this.isCollapsed
                    }), e
                }
            }

            var KA = C(498),
                eI = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(KA.Z, eI), KA.Z.locals;
            var ZA = C(9695),
                tI = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(ZA.Z, tI), ZA.Z.locals;

            class nI extends ST {
                constructor(e, t) {
                    super(e), this.view = t, this._toolbarConfig = ys(e.config.get("toolbar")), this._elementReplacer = new V, this.listenTo(e.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this))
                }

                get element() {
                    return this.view.element
                }

                init(e) {
                    const t = this.editor, n = this.view, i = t.editing.view, s = n.editable, l = i.document.getRoot();
                    s.name = l.rootName, n.render();
                    const d = s.element;
                    this.setEditableElement(s.name, d), n.editable.bind("isFocused").to(this.focusTracker), i.attachDomRoot(d), e && this._elementReplacer.replace(e, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready")
                }

                destroy() {
                    super.destroy();
                    const e = this.view, t = this.editor.editing.view;
                    this._elementReplacer.restore(), t.detachDomRoot(e.editable.name), e.destroy()
                }

                _initToolbar() {
                    const e = this.view;
                    e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e.stickyPanel.limiterElement = e.element, e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({top: t}) => t || 0), e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(e.toolbar)
                }

                _initPlaceholder() {
                    const e = this.editor, t = e.editing.view, n = t.document.getRoot(), i = e.sourceElement;
                    let s;
                    const l = e.config.get("placeholder");
                    l && (s = typeof l == "string" ? l : l[this.view.editable.name]), !s && i && i.tagName.toLowerCase() === "textarea" && (s = i.getAttribute("placeholder")), s && (n.placeholder = s), Ld({
                        view: t,
                        element: n,
                        isDirectHost: !1,
                        keepOnFocus: !0
                    })
                }

                _handleScrollToTheSelectionWithStickyPanel(e, t, n) {
                    const i = this.view.stickyPanel;
                    if (i.isSticky) {
                        const s = new Lt(i.element).height;
                        t.viewportOffset.top += s
                    } else {
                        const s = () => {
                            this.editor.editing.view.scrollToTheSelection(n)
                        };
                        this.listenTo(i, "change:isSticky", s), setTimeout(() => {
                            this.stopListening(i, "change:isSticky", s)
                        }, 20)
                    }
                }
            }

            var YA = C(3143),
                rI = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(YA.Z, rI), YA.Z.locals;

            class iI extends MT {
                constructor(e, t, n = {}) {
                    super(e), this.stickyPanel = new jT(e), this.toolbar = new vb(e, {shouldGroupWhenFull: n.shouldToolbarGroupWhenFull}), this.editable = new NT(e, t)
                }

                render() {
                    super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable)
                }
            }

            class QA {
                constructor(e) {
                    if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = t => {
                        const n = "error" in t ? t.error : t.reason;
                        n instanceof Error && this._handleError(n, t)
                    }, this._listeners = {}, !this._restart) throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.")
                }

                destroy() {
                    this._stopErrorHandling(), this._listeners = {}
                }

                on(e, t) {
                    this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t)
                }

                off(e, t) {
                    this._listeners[e] = this._listeners[e].filter(n => n !== t)
                }

                _fire(e, ...t) {
                    const n = this._listeners[e] || [];
                    for (const i of n) i.apply(this, [null, ...t])
                }

                _startErrorHandling() {
                    window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler)
                }

                _stopErrorHandling() {
                    window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler)
                }

                _handleError(e, t) {
                    if (this._shouldReactToError(e)) {
                        this.crashes.push({
                            message: e.message,
                            stack: e.stack,
                            filename: t instanceof ErrorEvent ? t.filename : void 0,
                            lineno: t instanceof ErrorEvent ? t.lineno : void 0,
                            colno: t instanceof ErrorEvent ? t.colno : void 0,
                            date: this._now()
                        });
                        const n = this._shouldRestart();
                        this.state = "crashed", this._fire("stateChange"), this._fire("error", {
                            error: e,
                            causesRestart: n
                        }), n ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"))
                    }
                }

                _shouldReactToError(e) {
                    return e.is && e.is("CKEditorError") && e.context !== void 0 && e.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(e)
                }

                _shouldRestart() {
                    return this.crashes.length <= this._crashNumberLimit ? !0 : (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod
                }
            }

            function Lb(r, e = new Set) {
                const t = [r], n = new Set;
                let i = 0;
                for (; t.length > i;) {
                    const s = t[i++];
                    if (!n.has(s) && oI(s) && !e.has(s)) if (n.add(s), Symbol.iterator in s) try {
                        for (const l of s) t.push(l)
                    } catch {
                    } else for (const l in s) l !== "defaultValue" && t.push(s[l])
                }
                return n
            }

            function oI(r) {
                const e = Object.prototype.toString.call(r), t = typeof r;
                return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || r == null || r._watchdogExcluded || r instanceof EventTarget || r instanceof Event)
            }

            function JA(r, e, t = new Set) {
                if (r === e && typeof (n = r) == "object" && n !== null) return !0;
                var n;
                const i = Lb(r, t), s = Lb(e, t);
                for (const l of i) if (s.has(l)) return !0;
                return !1
            }

            var sI = Object.defineProperty, aI = Object.defineProperties, lI = Object.getOwnPropertyDescriptors,
                Vg = Object.getOwnPropertySymbols, XA = Object.prototype.hasOwnProperty,
                eC = Object.prototype.propertyIsEnumerable, tC = (r, e, t) => e in r ? sI(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, Pb = (r, e) => {
                    for (var t in e || (e = {})) XA.call(e, t) && tC(r, t, e[t]);
                    if (Vg) for (var t of Vg(e)) eC.call(e, t) && tC(r, t, e[t]);
                    return r
                };

            class nC extends QA {
                constructor(e, t = {}) {
                    super(t), this._editor = null, this._initUsingData = !0, this._editables = {}, this._throttledSave = Rg(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3), e && (this._creator = (n, i) => e.create(n, i)), this._destructor = n => n.destroy()
                }

                get editor() {
                    return this._editor
                }

                get _item() {
                    return this._editor
                }

                setCreator(e) {
                    this._creator = e
                }

                setDestructor(e) {
                    this._destructor = e
                }

                _restart() {
                    return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch(e => {
                        console.error("An error happened during the editor destroying.", e)
                    }).then(() => {
                        const e = {}, t = [], n = this._config.rootsAttributes || {}, i = {};
                        for (const [g, v] of Object.entries(this._data.roots)) v.isLoaded ? (e[g] = "", i[g] = n[g] || {}) : t.push(g);
                        const s = (l = Pb({}, this._config), d = {
                            extraPlugins: this._config.extraPlugins || [],
                            lazyRoots: t,
                            rootsAttributes: i,
                            _watchdogInitialData: this._data
                        }, aI(l, lI(d)));
                        var l, d;
                        return delete s.initialData, s.extraPlugins.push(cI), this._initUsingData ? this.create(e, s, s.context) : po(this._elementOrData) ? this.create(this._elementOrData, s, s.context) : this.create(this._editables, s, s.context)
                    }).then(() => {
                        this._fire("restart")
                    })
                }

                create(e = this._elementOrData, t = this._config, n) {
                    return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = e, this._initUsingData = typeof e == "string" || Object.keys(e).length > 0 && typeof Object.values(e)[0] == "string", this._config = this._cloneEditorConfiguration(t) || {}, this._config.context = n, this._creator(e, this._config))).then(i => {
                        this._editor = i, i.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = i.model.document.version, this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this.state = "ready", this._fire("stateChange")
                    })
                }

                destroy() {
                    return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()))
                }

                _destroy() {
                    return Promise.resolve().then(() => {
                        this._stopErrorHandling(), this._throttledSave.cancel();
                        const e = this._editor;
                        return this._editor = null, e.model.document.off("change:data", this._throttledSave), this._destructor(e)
                    })
                }

                _save() {
                    const e = this._editor.model.document.version;
                    try {
                        this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this._lastDocumentVersion = e
                    } catch (t) {
                        console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.")
                    }
                }

                _setExcludedProperties(e) {
                    this._excludedProps = e
                }

                _getData() {
                    const e = this._editor,
                        t = e.model.document.roots.filter(d => d.isAttached() && d.rootName != "$graveyard"), {plugins: n} = e,
                        i = n.has("CommentsRepository") && n.get("CommentsRepository"),
                        s = n.has("TrackChanges") && n.get("TrackChanges"), l = {
                            roots: {},
                            markers: {},
                            commentThreads: JSON.stringify([]),
                            suggestions: JSON.stringify([])
                        };
                    t.forEach(d => {
                        l.roots[d.rootName] = {
                            content: JSON.stringify(Array.from(d.getChildren())),
                            attributes: JSON.stringify(Array.from(d.getAttributes())),
                            isLoaded: d._isLoaded
                        }
                    });
                    for (const d of e.model.markers) d._affectsData && (l.markers[d.name] = {
                        rangeJSON: d.getRange().toJSON(),
                        usingOperation: d._managedUsingOperations,
                        affectsData: d._affectsData
                    });
                    return i && (l.commentThreads = JSON.stringify(i.getCommentThreads({
                        toJSON: !0,
                        skipNotAttached: !0
                    }))), s && (l.suggestions = JSON.stringify(s.getSuggestions({toJSON: !0, skipNotAttached: !0}))), l
                }

                _getEditables() {
                    const e = {};
                    for (const t of this.editor.model.document.getRootNames()) {
                        const n = this.editor.ui.getEditableElement(t);
                        n && (e[t] = n)
                    }
                    return e
                }

                _isErrorComingFromThisItem(e) {
                    return JA(this._editor, e.context, this._excludedProps)
                }

                _cloneEditorConfiguration(e) {
                    return hl(e, (t, n) => po(t) || n === "context" ? t : void 0)
                }
            }

            class cI {
                constructor(e) {
                    this.editor = e, this._data = e.config.get("_watchdogInitialData")
                }

                init() {
                    this.editor.data.on("init", e => {
                        e.stop(), this.editor.model.enqueueChange({isUndoable: !1}, t => {
                            this._restoreCollaborationData(), this._restoreEditorData(t)
                        }), this.editor.data.fire("ready")
                    }, {priority: 999})
                }

                _createNode(e, t) {
                    if ("name" in t) {
                        const n = e.createElement(t.name, t.attributes);
                        if (t.children) for (const i of t.children) n._appendChild(this._createNode(e, i));
                        return n
                    }
                    return e.createText(t.data, t.attributes)
                }

                _restoreEditorData(e) {
                    const t = this.editor;
                    Object.entries(this._data.roots).forEach(([n, {content: i, attributes: s}]) => {
                        const l = JSON.parse(i), d = JSON.parse(s), g = t.model.document.getRoot(n);
                        for (const [v, _] of d) e.setAttribute(v, _, g);
                        for (const v of l) {
                            const _ = this._createNode(e, v);
                            e.insert(_, g, "end")
                        }
                    }), Object.entries(this._data.markers).forEach(([n, i]) => {
                        const {document: s} = t.model, l = i, {rangeJSON: {start: d, end: g}} = l, v = ((j, U) => {
                                var K = {};
                                for (var ne in j) XA.call(j, ne) && U.indexOf(ne) < 0 && (K[ne] = j[ne]);
                                if (j != null && Vg) for (var ne of Vg(j)) U.indexOf(ne) < 0 && eC.call(j, ne) && (K[ne] = j[ne]);
                                return K
                            })(l, ["rangeJSON"]), _ = s.getRoot(d.root),
                            x = e.createPositionFromPath(_, d.path, d.stickiness),
                            M = e.createPositionFromPath(_, g.path, g.stickiness), O = e.createRange(x, M);
                        e.addMarker(n, Pb({range: O}, v))
                    })
                }

                _restoreCollaborationData() {
                    const e = JSON.parse(this._data.commentThreads), t = JSON.parse(this._data.suggestions);
                    e.forEach(n => {
                        const i = this.editor.config.get("collaboration.channelId"),
                            s = this.editor.plugins.get("CommentsRepository");
                        s.hasCommentThread(n.threadId) && s.getCommentThread(n.threadId).remove(), s.addCommentThread(Pb({channelId: i}, n))
                    }), t.forEach(n => {
                        const i = this.editor.plugins.get("TrackChangesEditing");
                        i.hasSuggestion(n.id) ? i.getSuggestion(n.id).attributes = n.attributes : i.addSuggestionData(n)
                    })
                }
            }

            const dh = Symbol("MainQueueId");

            class uI {
                constructor() {
                    this._onEmptyCallbacks = [], this._queues = new Map, this._activeActions = 0
                }

                onEmpty(e) {
                    this._onEmptyCallbacks.push(e)
                }

                enqueue(e, t) {
                    const n = e === dh;
                    this._activeActions++, this._queues.get(e) || this._queues.set(e, Promise.resolve());
                    const i = (n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(dh), this._queues.get(e)])).then(t),
                        s = i.catch(() => {
                        });
                    return this._queues.set(e, s), i.finally(() => {
                        this._activeActions--, this._queues.get(e) === s && this._activeActions === 0 && this._onEmptyCallbacks.forEach(l => l())
                    })
                }
            }

            function rC(r) {
                return Array.isArray(r) ? r : [r]
            }

            class Hg extends Mg(kb(R3)) {
                constructor(e, t = {}) {
                    if (!Ug(e) && t.initialData !== void 0) throw new R("editor-create-initial-data", null);
                    super(t), this.config.get("initialData") === void 0 && this.config.set("initialData", function (s) {
                        return Ug(s) ? (l = s, l instanceof HTMLTextAreaElement ? l.value : l.innerHTML) : s;
                        var l
                    }(e)), Ug(e) && (this.sourceElement = e), this.model.document.createRoot();
                    const n = !this.config.get("toolbar.shouldNotGroupWhenFull"),
                        i = new iI(this.locale, this.editing.view, {shouldToolbarGroupWhenFull: n});
                    this.ui = new nI(this, i), function (s) {
                        if (!ni(s.updateSourceElement)) throw new R("attachtoform-missing-elementapi-interface", s);
                        const l = s.sourceElement;
                        if (function (d) {
                            return !!d && d.tagName.toLowerCase() === "textarea"
                        }(l) && l.form) {
                            let d;
                            const g = l.form, v = () => s.updateSourceElement();
                            ni(g.submit) && (d = g.submit, g.submit = () => {
                                v(), d.apply(g)
                            }), g.addEventListener("submit", v), s.on("destroy", () => {
                                g.removeEventListener("submit", v), d && (g.submit = d)
                            })
                        }
                    }(this)
                }

                destroy() {
                    return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy()
                }

                static create(e, t = {}) {
                    return new Promise(n => {
                        const i = new this(e, t);
                        n(i.initPlugins().then(() => i.ui.init(Ug(e) ? e : null)).then(() => i.data.init(i.config.get("initialData"))).then(() => i.fire("ready")).then(() => i))
                    })
                }
            }

            function Ug(r) {
                return po(r)
            }

            Hg.Context = Nd, Hg.EditorWatchdog = nC, Hg.ContextWatchdog = class extends QA {
                constructor(r, e = {}) {
                    super(e), this._watchdogs = new Map, this._context = null, this._contextProps = new Set, this._actionQueues = new uI, this._watchdogConfig = e, this._creator = t => r.create(t), this._destructor = t => t.destroy(), this._actionQueues.onEmpty(() => {
                        this.state === "initializing" && (this.state = "ready", this._fire("stateChange"))
                    })
                }

                setCreator(r) {
                    this._creator = r
                }

                setDestructor(r) {
                    this._destructor = r
                }

                get context() {
                    return this._context
                }

                create(r = {}) {
                    return this._actionQueues.enqueue(dh, () => (this._contextConfig = r, this._create()))
                }

                getItem(r) {
                    return this._getWatchdog(r)._item
                }

                getItemState(r) {
                    return this._getWatchdog(r).state
                }

                add(r) {
                    const e = rC(r);
                    return Promise.all(e.map(t => this._actionQueues.enqueue(t.id, () => {
                        if (this.state === "destroyed") throw new Error("Cannot add items to destroyed watchdog.");
                        if (!this._context) throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
                        let n;
                        if (this._watchdogs.has(t.id)) throw new Error(`Item with the given id is already added: '${t.id}'.`);
                        if (t.type === "editor") return n = new nC(null, this._watchdogConfig), n.setCreator(t.creator), n._setExcludedProperties(this._contextProps), t.destructor && n.setDestructor(t.destructor), this._watchdogs.set(t.id, n), n.on("error", (i, {
                            error: s,
                            causesRestart: l
                        }) => {
                            this._fire("itemError", {
                                itemId: t.id,
                                error: s
                            }), l && this._actionQueues.enqueue(t.id, () => new Promise(d => {
                                const g = () => {
                                    n.off("restart", g), this._fire("itemRestart", {itemId: t.id}), d()
                                };
                                n.on("restart", g)
                            }))
                        }), n.create(t.sourceElementOrData, t.config, this._context);
                        throw new Error(`Not supported item type: '${t.type}'.`)
                    })))
                }

                remove(r) {
                    const e = rC(r);
                    return Promise.all(e.map(t => this._actionQueues.enqueue(t, () => {
                        const n = this._getWatchdog(t);
                        return this._watchdogs.delete(t), n.destroy()
                    })))
                }

                destroy() {
                    return this._actionQueues.enqueue(dh, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()))
                }

                _restart() {
                    return this._actionQueues.enqueue(dh, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch(r => {
                        console.error("An error happened during destroying the context or items.", r)
                    }).then(() => this._create()).then(() => this._fire("restart"))))
                }

                _create() {
                    return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then(r => (this._context = r, this._contextProps = Lb(this._context), Promise.all(Array.from(this._watchdogs.values()).map(e => (e._setExcludedProperties(this._contextProps), e.create(void 0, void 0, this._context))))))
                }

                _destroy() {
                    return Promise.resolve().then(() => {
                        this._stopErrorHandling();
                        const r = this._context;
                        return this._context = null, this._contextProps = new Set, Promise.all(Array.from(this._watchdogs.values()).map(e => e.destroy())).then(() => this._destructor(r))
                    })
                }

                _getWatchdog(r) {
                    const e = this._watchdogs.get(r);
                    if (!e) throw new Error(`Item with the given id was not registered: ${r}.`);
                    return e
                }

                _isErrorComingFromThisItem(r) {
                    for (const e of this._watchdogs.values()) if (e._isErrorComingFromThisItem(r)) return !1;
                    return JA(this._context, r.context)
                }
            };

            class hh extends xn {
                constructor(e) {
                    super(e), this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];
                    const t = this.document;

                    function n(i) {
                        return (s, l) => {
                            l.preventDefault();
                            const d = l.dropRange ? [l.dropRange] : null, g = new G(t, i);
                            t.fire(g, {
                                dataTransfer: l.dataTransfer,
                                method: s.name,
                                targetRanges: d,
                                target: l.target,
                                domEvent: l.domEvent
                            }), g.stop.called && l.stopPropagation()
                        }
                    }

                    this.listenTo(t, "paste", n("clipboardInput"), {priority: "low"}), this.listenTo(t, "drop", n("clipboardInput"), {priority: "low"}), this.listenTo(t, "dragover", n("dragging"), {priority: "low"})
                }

                onDomEvent(e) {
                    const t = "clipboardData" in e ? e.clipboardData : e.dataTransfer,
                        n = e.type == "drop" || e.type == "paste", i = {dataTransfer: new Bv(t, {cacheFiles: n})};
                    e.type != "drop" && e.type != "dragover" || (i.dropRange = function (s, l) {
                        const d = l.target.ownerDocument, g = l.clientX, v = l.clientY;
                        let _;
                        return d.caretRangeFromPoint && d.caretRangeFromPoint(g, v) ? _ = d.caretRangeFromPoint(g, v) : l.rangeParent && (_ = d.createRange(), _.setStart(l.rangeParent, l.rangeOffset), _.collapse(!0)), _ ? s.domConverter.domRangeToView(_) : null
                    }(this.view, e)), this.fire(e.type, e, i)
                }
            }

            const iC = ["figcaption", "li"], oC = ["ol", "ul"];

            function sC(r) {
                if (r.is("$text") || r.is("$textProxy")) return r.data;
                if (r.is("element", "img") && r.hasAttribute("alt")) return r.getAttribute("alt");
                if (r.is("element", "br")) return `
`;
                let e = "", t = null;
                for (const n of r.getChildren()) e += dI(n, t) + sC(n), t = n;
                return e
            }

            function dI(r, e) {
                return e ? r.is("element", "li") && !r.isEmpty && r.getChild(0).is("containerElement") || oC.includes(r.name) && oC.includes(e.name) ? `

` : r.is("containerElement") || e.is("containerElement") ? iC.includes(r.name) || iC.includes(e.name) ? `
` : `

` : "" : ""
            }

            class es extends Re {
                static get pluginName() {
                    return "ClipboardPipeline"
                }

                init() {
                    this.editor.editing.view.addObserver(hh), this._setupPasteDrop(), this._setupCopyCut()
                }

                _fireOutputTransformationEvent(e, t, n) {
                    const i = this.editor.model.getSelectedContent(t);
                    this.fire("outputTransformation", {dataTransfer: e, content: i, method: n})
                }

                _setupPasteDrop() {
                    const e = this.editor, t = e.model, n = e.editing.view, i = n.document;
                    this.listenTo(i, "clipboardInput", (s, l) => {
                        l.method != "paste" || e.model.canEditAt(e.model.document.selection) || s.stop()
                    }, {priority: "highest"}), this.listenTo(i, "clipboardInput", (s, l) => {
                        const d = l.dataTransfer;
                        let g;
                        if (l.content) g = l.content; else {
                            let x = "";
                            d.getData("text/html") ? x = function (M) {
                                return M.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (O, j) => j.length == 1 ? " " : j).replace(/<!--[\s\S]*?-->/g, "")
                            }(d.getData("text/html")) : d.getData("text/plain") && (((v = (v = d.getData("text/plain")).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || v.includes("<br>")) && (v = `<p>${v}</p>`), x = v), g = this.editor.data.htmlProcessor.toView(x)
                        }
                        var v;
                        const _ = new G(this, "inputTransformation");
                        this.fire(_, {
                            content: g,
                            dataTransfer: d,
                            targetRanges: l.targetRanges,
                            method: l.method
                        }), _.stop.called && s.stop(), n.scrollToTheSelection()
                    }, {priority: "low"}), this.listenTo(this, "inputTransformation", (s, l) => {
                        if (l.content.isEmpty) return;
                        const d = this.editor.data.toModel(l.content, "$clipboardHolder");
                        d.childCount != 0 && (s.stop(), t.change(() => {
                            this.fire("contentInsertion", {
                                content: d,
                                method: l.method,
                                dataTransfer: l.dataTransfer,
                                targetRanges: l.targetRanges
                            })
                        }))
                    }, {priority: "low"}), this.listenTo(this, "contentInsertion", (s, l) => {
                        l.resultRange = t.insertContent(l.content)
                    }, {priority: "low"})
                }

                _setupCopyCut() {
                    const e = this.editor, t = e.model.document, n = e.editing.view.document, i = (s, l) => {
                        const d = l.dataTransfer;
                        l.preventDefault(), this._fireOutputTransformationEvent(d, t.selection, s.name)
                    };
                    this.listenTo(n, "copy", i, {priority: "low"}), this.listenTo(n, "cut", (s, l) => {
                        e.model.canEditAt(e.model.document.selection) ? i(s, l) : l.preventDefault()
                    }, {priority: "low"}), this.listenTo(this, "outputTransformation", (s, l) => {
                        const d = e.data.toView(l.content);
                        n.fire("clipboardOutput", {dataTransfer: l.dataTransfer, content: d, method: l.method})
                    }, {priority: "low"}), this.listenTo(n, "clipboardOutput", (s, l) => {
                        l.content.isEmpty || (l.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(l.content)), l.dataTransfer.setData("text/plain", sC(l.content))), l.method == "cut" && e.model.deleteContent(t.selection)
                    }, {priority: "low"})
                }
            }

            class aC {
                constructor(e, t = 20) {
                    this._batch = null, this.model = e, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (n, i) => {
                        i.isLocal && i.isUndoable && i !== this._batch && this._reset(!0)
                    }, this._selectionChangeCallback = () => {
                        this._reset()
                    }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
                }

                get batch() {
                    return this._batch || (this._batch = this.model.createBatch({isTyping: !0})), this._batch
                }

                get size() {
                    return this._size
                }

                input(e) {
                    this._size += e, this._size >= this.limit && this._reset(!0)
                }

                get isLocked() {
                    return this._isLocked
                }

                lock() {
                    this._isLocked = !0
                }

                unlock() {
                    this._isLocked = !1
                }

                destroy() {
                    this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
                }

                _reset(e = !1) {
                    this.isLocked && !e || (this._batch = null, this._size = 0)
                }
            }

            class hI extends Ft {
                constructor(e, t) {
                    super(e), this._buffer = new aC(e.model, t), this._isEnabledBasedOnSelection = !1
                }

                get buffer() {
                    return this._buffer
                }

                destroy() {
                    super.destroy(), this._buffer.destroy()
                }

                execute(e = {}) {
                    const t = this.editor.model, n = t.document, i = e.text || "", s = i.length;
                    let l = n.selection;
                    if (e.selection ? l = e.selection : e.range && (l = t.createSelection(e.range)), !t.canEditAt(l)) return;
                    const d = e.resultRange;
                    t.enqueueChange(this._buffer.batch, g => {
                        this._buffer.lock();
                        const v = Array.from(n.selection.getAttributes());
                        t.deleteContent(l), i && t.insertContent(g.createText(i, v), l), d ? g.setSelection(d) : l.is("documentSelection") || g.setSelection(l), this._buffer.unlock(), this._buffer.input(s)
                    })
                }
            }

            const lC = ["insertText", "insertReplacementText"];

            class fI extends En {
                constructor(e) {
                    super(e), this.focusObserver = e.getObserver(xg), T.isAndroid && lC.push("insertCompositionText");
                    const t = e.document;
                    t.on("beforeinput", (n, i) => {
                        if (!this.isEnabled) return;
                        const {data: s, targetRanges: l, inputType: d, domEvent: g} = i;
                        if (!lC.includes(d)) return;
                        this.focusObserver.flush();
                        const v = new G(t, "insertText");
                        t.fire(v, new Gn(e, g, {text: s, selection: e.createSelection(l)})), v.stop.called && n.stop()
                    }), t.on("compositionend", (n, {data: i, domEvent: s}) => {
                        this.isEnabled && !T.isAndroid && i && t.fire("insertText", new Gn(e, s, {
                            text: i,
                            selection: t.selection
                        }))
                    }, {priority: "lowest"})
                }

                observe() {
                }

                stopObserving() {
                }
            }

            class cC extends Re {
                static get pluginName() {
                    return "Input"
                }

                init() {
                    const e = this.editor, t = e.model, n = e.editing.view, i = t.document.selection;
                    n.addObserver(fI);
                    const s = new hI(e, e.config.get("typing.undoStep") || 20);
                    e.commands.add("insertText", s), e.commands.add("input", s), this.listenTo(n.document, "insertText", (l, d) => {
                        n.document.isComposing || d.preventDefault();
                        const {text: g, selection: v, resultRange: _} = d,
                            x = Array.from(v.getRanges()).map(j => e.editing.mapper.toModelRange(j));
                        let M = g;
                        if (T.isAndroid) {
                            const j = Array.from(x[0].getItems()).reduce((U, K) => U + (K.is("$textProxy") ? K.data : ""), "");
                            j && (j.length <= M.length ? M.startsWith(j) && (M = M.substring(j.length), x[0].start = x[0].start.getShiftedBy(j.length)) : j.startsWith(M) && (x[0].start = x[0].start.getShiftedBy(M.length), M = ""))
                        }
                        const O = {text: M, selection: t.createSelection(x)};
                        _ && (O.resultRange = e.editing.mapper.toModelRange(_)), e.execute("insertText", O), n.scrollToTheSelection()
                    }), T.isAndroid ? this.listenTo(n.document, "keydown", (l, d) => {
                        !i.isCollapsed && d.keyCode == 229 && n.document.isComposing && uC(t, s)
                    }) : this.listenTo(n.document, "compositionstart", () => {
                        i.isCollapsed || uC(t, s)
                    })
                }
            }

            function uC(r, e) {
                if (!e.isEnabled) return;
                const t = e.buffer;
                t.lock(), r.enqueueChange(t.batch, () => {
                    r.deleteContent(r.document.selection)
                }), t.unlock()
            }

            class dC extends Ft {
                constructor(e, t) {
                    super(e), this.direction = t, this._buffer = new aC(e.model, e.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1
                }

                get buffer() {
                    return this._buffer
                }

                execute(e = {}) {
                    const t = this.editor.model, n = t.document;
                    t.enqueueChange(this._buffer.batch, i => {
                        this._buffer.lock();
                        const s = i.createSelection(e.selection || n.selection);
                        if (!t.canEditAt(s)) return;
                        const l = e.sequence || 1, d = s.isCollapsed;
                        if (s.isCollapsed && t.modifySelection(s, {
                            direction: this.direction,
                            unit: e.unit,
                            treatEmojiAsSingleUnit: !0
                        }), this._shouldEntireContentBeReplacedWithParagraph(l)) return void this._replaceEntireContentWithParagraph(i);
                        if (this._shouldReplaceFirstBlockWithParagraph(s, l)) return void this.editor.execute("paragraph", {selection: s});
                        if (s.isCollapsed) return;
                        let g = 0;
                        s.getFirstRange().getMinimalFlatRanges().forEach(v => {
                            g += $(v.getWalker({singleCharacters: !0, ignoreElementEnd: !0, shallow: !0}))
                        }), t.deleteContent(s, {
                            doNotResetEntireContent: d,
                            direction: this.direction
                        }), this._buffer.input(g), i.setSelection(s), this._buffer.unlock()
                    })
                }

                _shouldEntireContentBeReplacedWithParagraph(e) {
                    if (e > 1) return !1;
                    const t = this.editor.model, n = t.document.selection, i = t.schema.getLimitElement(n);
                    if (!(n.isCollapsed && n.containsEntireContent(i)) || !t.schema.checkChild(i, "paragraph")) return !1;
                    const s = i.getChild(0);
                    return !s || !s.is("element", "paragraph")
                }

                _replaceEntireContentWithParagraph(e) {
                    const t = this.editor.model, n = t.document.selection, i = t.schema.getLimitElement(n),
                        s = e.createElement("paragraph");
                    e.remove(e.createRangeIn(i)), e.insert(s, i), e.setSelection(s, 0)
                }

                _shouldReplaceFirstBlockWithParagraph(e, t) {
                    const n = this.editor.model;
                    if (t > 1 || this.direction != "backward" || !e.isCollapsed) return !1;
                    const i = e.getFirstPosition(), s = n.schema.getLimitElement(i), l = s.getChild(0);
                    return i.parent == l && !!e.containsEntireContent(l) && !!n.schema.checkChild(s, "paragraph") && l.name != "paragraph"
                }
            }

            const hC = "word", Ma = "selection", vu = "backward", fh = "forward", fC = {
                deleteContent: {unit: Ma, direction: vu},
                deleteContentBackward: {unit: "codePoint", direction: vu},
                deleteWordBackward: {unit: hC, direction: vu},
                deleteHardLineBackward: {unit: Ma, direction: vu},
                deleteSoftLineBackward: {unit: Ma, direction: vu},
                deleteContentForward: {unit: "character", direction: fh},
                deleteWordForward: {unit: hC, direction: fh},
                deleteHardLineForward: {unit: Ma, direction: fh},
                deleteSoftLineForward: {unit: Ma, direction: fh}
            };

            class gI extends En {
                constructor(e) {
                    super(e);
                    const t = e.document;
                    let n = 0;
                    t.on("keydown", () => {
                        n++
                    }), t.on("keyup", () => {
                        n = 0
                    }), t.on("beforeinput", (i, s) => {
                        if (!this.isEnabled) return;
                        const {targetRanges: l, domEvent: d, inputType: g} = s, v = fC[g];
                        if (!v) return;
                        const _ = {direction: v.direction, unit: v.unit, sequence: n};
                        _.unit == Ma && (_.selectionToRemove = e.createSelection(l[0])), g === "deleteContentBackward" && (T.isAndroid && (_.sequence = 1), function (M) {
                            if (M.length != 1 || M[0].isCollapsed) return !1;
                            const O = M[0].getWalker({
                                direction: "backward",
                                singleCharacters: !0,
                                ignoreElementEnd: !0
                            });
                            let j = 0;
                            for (const {nextPosition: U} of O) {
                                if (U.parent.is("$text")) {
                                    const K = U.parent.data, ne = U.offset;
                                    if (Cd(K, ne) || _r(K, ne) || kr(K, ne)) continue;
                                    j++
                                } else j++;
                                if (j > 1) return !0
                            }
                            return !1
                        }(l) && (_.unit = Ma, _.selectionToRemove = e.createSelection(l)));
                        const x = new ya(t, "delete", l[0]);
                        t.fire(x, new Gn(e, d, _)), x.stop.called && i.stop()
                    }), T.isBlink && function (i) {
                        const s = i.view, l = s.document;
                        let d = null, g = !1;

                        function v(x) {
                            return x == Ut.backspace || x == Ut.delete
                        }

                        function _(x) {
                            return x == Ut.backspace ? vu : fh
                        }

                        l.on("keydown", (x, {keyCode: M}) => {
                            d = M, g = !1
                        }), l.on("keyup", (x, {keyCode: M, domEvent: O}) => {
                            const j = l.selection, U = i.isEnabled && M == d && v(M) && !j.isCollapsed && !g;
                            if (d = null, U) {
                                const K = j.getFirstRange(), ne = new ya(l, "delete", K),
                                    pe = {unit: Ma, direction: _(M), selectionToRemove: j};
                                l.fire(ne, new Gn(s, O, pe))
                            }
                        }), l.on("beforeinput", (x, {inputType: M}) => {
                            const O = fC[M];
                            v(d) && O && O.direction == _(d) && (g = !0)
                        }, {priority: "high"}), l.on("beforeinput", (x, {inputType: M, data: O}) => {
                            d == Ut.delete && M == "insertText" && O == "" && x.stop()
                        }, {priority: "high"})
                    }(this)
                }

                observe() {
                }

                stopObserving() {
                }
            }

            class Ls extends Re {
                static get pluginName() {
                    return "Delete"
                }

                init() {
                    const e = this.editor, t = e.editing.view, n = t.document, i = e.model.document;
                    t.addObserver(gI), this._undoOnBackspace = !1;
                    const s = new dC(e, "forward");
                    e.commands.add("deleteForward", s), e.commands.add("forwardDelete", s), e.commands.add("delete", new dC(e, "backward")), this.listenTo(n, "delete", (l, d) => {
                        n.isComposing || d.preventDefault();
                        const {direction: g, sequence: v, selectionToRemove: _, unit: x} = d,
                            M = g === "forward" ? "deleteForward" : "delete", O = {sequence: v};
                        if (x == "selection") {
                            const j = Array.from(_.getRanges()).map(U => e.editing.mapper.toModelRange(U));
                            O.selection = e.model.createSelection(j)
                        } else O.unit = x;
                        e.execute(M, O), t.scrollToTheSelection()
                    }, {priority: "low"}), this.editor.plugins.has("UndoEditing") && (this.listenTo(n, "delete", (l, d) => {
                        this._undoOnBackspace && d.direction == "backward" && d.sequence == 1 && d.unit == "codePoint" && (this._undoOnBackspace = !1, e.execute("undo"), d.preventDefault(), l.stop())
                    }, {context: "$capture"}), this.listenTo(i, "change", () => {
                        this._undoOnBackspace = !1
                    }))
                }

                requestUndoOnBackspace() {
                    this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0)
                }
            }

            class pI extends Re {
                static get requires() {
                    return [cC, Ls]
                }

                static get pluginName() {
                    return "Typing"
                }
            }

            function gC(r, e) {
                let t = r.start;
                return {
                    text: Array.from(r.getWalker({ignoreElementEnd: !1})).reduce((n, {item: i}) => i.is("$text") || i.is("$textProxy") ? n + i.data : (t = e.createPositionAfter(i), ""), ""),
                    range: e.createRange(t, r.end)
                }
            }

            class pC extends we() {
                constructor(e, t) {
                    super(), this.model = e, this.testCallback = t, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
                        this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection), this.stopListening(e.document))
                    }), this._startListening()
                }

                get hasMatch() {
                    return this._hasMatch
                }

                _startListening() {
                    const e = this.model.document;
                    this.listenTo(e.selection, "change:range", (t, {directChange: n}) => {
                        n && (e.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1))
                    }), this.listenTo(e, "change:data", (t, n) => {
                        !n.isUndo && n.isLocal && this._evaluateTextBeforeSelection("data", {batch: n})
                    })
                }

                _evaluateTextBeforeSelection(e, t = {}) {
                    const n = this.model, i = n.document.selection,
                        s = n.createRange(n.createPositionAt(i.focus.parent, 0), i.focus), {
                            text: l,
                            range: d
                        } = gC(s, n), g = this.testCallback(l);
                    if (!g && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!g, g) {
                        const v = Object.assign(t, {text: l, range: d});
                        typeof g == "object" && Object.assign(v, g), this.fire(`matched:${e}`, v)
                    }
                }
            }

            class mC extends Re {
                constructor(e) {
                    super(e), this._isNextGravityRestorationSkipped = !1, this.attributes = new Set, this._overrideUid = null
                }

                static get pluginName() {
                    return "TwoStepCaretMovement"
                }

                init() {
                    const e = this.editor, t = e.model, n = e.editing.view, i = e.locale, s = t.document.selection;
                    this.listenTo(n.document, "arrowKey", (l, d) => {
                        if (!s.isCollapsed || d.shiftKey || d.altKey || d.ctrlKey) return;
                        const g = d.keyCode == Ut.arrowright, v = d.keyCode == Ut.arrowleft;
                        if (!g && !v) return;
                        const _ = i.contentLanguageDirection;
                        let x = !1;
                        x = _ === "ltr" && g || _ === "rtl" && v ? this._handleForwardMovement(d) : this._handleBackwardMovement(d), x === !0 && l.stop()
                    }, {context: "$text", priority: "highest"}), this.listenTo(s, "change:range", (l, d) => {
                        this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = !1 : this._isGravityOverridden && (!d.directChange && Qi(s.getFirstPosition(), this.attributes) || this._restoreGravity())
                    }), this._enableClickingAfterNode(), this._enableInsertContentSelectionAttributesFixer(), this._handleDeleteContentAfterNode()
                }

                registerAttribute(e) {
                    this.attributes.add(e)
                }

                _handleForwardMovement(e) {
                    const t = this.attributes, n = this.editor.model, i = n.document.selection,
                        s = i.getFirstPosition();
                    return !this._isGravityOverridden && (!s.isAtStart || !Ps(i, t)) && !!Qi(s, t) && (ph(e), Ps(i, t) && Qi(s, t, !0) ? gh(n, t) : this._overrideGravity(), !0)
                }

                _handleBackwardMovement(e) {
                    const t = this.attributes, n = this.editor.model, i = n.document.selection,
                        s = i.getFirstPosition();
                    return this._isGravityOverridden ? (ph(e), this._restoreGravity(), Qi(s, t, !0) ? gh(n, t) : qg(n, t, s), !0) : s.isAtStart ? !!Ps(i, t) && (ph(e), qg(n, t, s), !0) : !Ps(i, t) && Qi(s, t, !0) ? (ph(e), qg(n, t, s), !0) : !!bC(s, t) && (s.isAtEnd && !Ps(i, t) && Qi(s, t) ? (ph(e), qg(n, t, s), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1))
                }

                _enableClickingAfterNode() {
                    const e = this.editor, t = e.model, n = t.document.selection, i = e.editing.view.document;
                    e.editing.view.addObserver(bb);
                    let s = !1;
                    this.listenTo(i, "mousedown", () => {
                        s = !0
                    }), this.listenTo(i, "selectionChange", () => {
                        const l = this.attributes;
                        if (!s || (s = !1, !n.isCollapsed) || !Ps(n, l)) return;
                        const d = n.getFirstPosition();
                        Qi(d, l) && (d.isAtStart || Qi(d, l, !0) ? gh(t, l) : this._isGravityOverridden || this._overrideGravity())
                    })
                }

                _enableInsertContentSelectionAttributesFixer() {
                    const e = this.editor.model, t = e.document.selection, n = this.attributes;
                    this.listenTo(e, "insertContent", () => {
                        const i = t.getFirstPosition();
                        Ps(t, n) && Qi(i, n) && gh(e, n)
                    }, {priority: "low"})
                }

                _handleDeleteContentAfterNode() {
                    const e = this.editor, t = e.model, n = t.document.selection, i = e.editing.view;
                    let s = !1, l = !1;
                    this.listenTo(i.document, "delete", (d, g) => {
                        s = g.direction === "backward"
                    }, {priority: "high"}), this.listenTo(t, "deleteContent", () => {
                        if (!s) return;
                        const d = n.getFirstPosition();
                        l = Ps(n, this.attributes) && !bC(d, this.attributes)
                    }, {priority: "high"}), this.listenTo(t, "deleteContent", () => {
                        s && (s = !1, l || e.model.enqueueChange(() => {
                            const d = n.getFirstPosition();
                            Ps(n, this.attributes) && Qi(d, this.attributes) && (d.isAtStart || Qi(d, this.attributes, !0) ? gh(t, this.attributes) : this._isGravityOverridden || this._overrideGravity())
                        }))
                    }, {priority: "low"})
                }

                get _isGravityOverridden() {
                    return !!this._overrideUid
                }

                _overrideGravity() {
                    this._overrideUid = this.editor.model.change(e => e.overrideSelectionGravity())
                }

                _restoreGravity() {
                    this.editor.model.change(e => {
                        e.restoreSelectionGravity(this._overrideUid), this._overrideUid = null
                    })
                }
            }

            function Ps(r, e) {
                for (const t of e) if (r.hasAttribute(t)) return !0;
                return !1
            }

            function qg(r, e, t) {
                const n = t.nodeBefore;
                r.change(i => {
                    if (n) {
                        const s = [], l = r.schema.isObject(n) && r.schema.isInline(n);
                        for (const [d, g] of n.getAttributes()) !r.schema.checkAttribute("$text", d) || l && r.schema.getAttributeProperties(d).copyFromObject === !1 || s.push([d, g]);
                        i.setSelectionAttribute(s)
                    } else i.removeSelectionAttribute(e)
                })
            }

            function gh(r, e) {
                r.change(t => {
                    t.removeSelectionAttribute(e)
                })
            }

            function ph(r) {
                r.preventDefault()
            }

            function bC(r, e) {
                return Qi(r.getShiftedBy(-1), e)
            }

            function Qi(r, e, t = !1) {
                const {nodeBefore: n, nodeAfter: i} = r;
                for (const s of e) {
                    const l = n ? n.getAttribute(s) : void 0, d = i ? i.getAttribute(s) : void 0;
                    if ((!t || l !== void 0 && d !== void 0) && d !== l) return !0
                }
                return !1
            }

            const kC = {
                copyright: {from: "(c)", to: "©"},
                registeredTrademark: {from: "(r)", to: "®"},
                trademark: {from: "(tm)", to: "™"},
                oneHalf: {from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null]},
                oneThird: {from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null]},
                twoThirds: {from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null]},
                oneForth: {from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null]},
                threeQuarters: {from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null]},
                lessThanOrEqual: {from: "<=", to: "≤"},
                greaterThanOrEqual: {from: ">=", to: "≥"},
                notEqual: {from: "!=", to: "≠"},
                arrowLeft: {from: "<-", to: "←"},
                arrowRight: {from: "->", to: "→"},
                horizontalEllipsis: {from: "...", to: "…"},
                enDash: {from: /(^| )(--)( )$/, to: [null, "–", null]},
                emDash: {from: /(^| )(---)( )$/, to: [null, "—", null]},
                quotesPrimary: {from: wu('"'), to: [null, "“", null, "”"]},
                quotesSecondary: {from: wu("'"), to: [null, "‘", null, "’"]},
                quotesPrimaryEnGb: {from: wu("'"), to: [null, "‘", null, "’"]},
                quotesSecondaryEnGb: {from: wu('"'), to: [null, "“", null, "”"]},
                quotesPrimaryPl: {from: wu('"'), to: [null, "„", null, "”"]},
                quotesSecondaryPl: {from: wu("'"), to: [null, "‚", null, "’"]}
            }, vC = {
                symbols: ["copyright", "registeredTrademark", "trademark"],
                mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"],
                typography: ["horizontalEllipsis", "enDash", "emDash"],
                quotes: ["quotesPrimary", "quotesSecondary"]
            }, mI = ["symbols", "mathematical", "typography", "quotes"];

            function bI(r) {
                return typeof r == "string" ? new RegExp(`(${jA(r)})$`) : r
            }

            function kI(r) {
                return typeof r == "string" ? () => [r] : r instanceof Array ? () => r : r
            }

            function vI(r) {
                return (r.textNode ? r.textNode : r.nodeAfter).getAttributes()
            }

            function wu(r) {
                return new RegExp(`(^|\\s)(${r})([^${r}]*)(${r})$`)
            }

            function Wg(r, e, t, n) {
                return n.createRange(wC(r, e, t, !0, n), wC(r, e, t, !1, n))
            }

            function wC(r, e, t, n, i) {
                let s = r.textNode || (n ? r.nodeBefore : r.nodeAfter), l = null;
                for (; s && s.getAttribute(e) == t;) l = s, s = n ? s.previousSibling : s.nextSibling;
                return l ? i.createPositionAt(l, n ? "before" : "after") : r
            }

            function* AC(r, e) {
                for (const t of e) t && r.getAttributeProperties(t[0]).copyOnEnter && (yield t)
            }

            class wI extends Ft {
                execute() {
                    this.editor.model.change(e => {
                        this.enterBlock(e), this.fire("afterExecute", {writer: e})
                    })
                }

                enterBlock(e) {
                    const t = this.editor.model, n = t.document.selection, i = t.schema, s = n.isCollapsed,
                        l = n.getFirstRange(), d = l.start.parent, g = l.end.parent;
                    if (i.isLimit(d) || i.isLimit(g)) return s || d != g || t.deleteContent(n), !1;
                    if (s) {
                        const v = AC(e.model.schema, n.getAttributes());
                        return CC(e, l.start), e.setSelectionAttribute(v), !0
                    }
                    {
                        const v = !(l.start.isAtStart && l.end.isAtEnd), _ = d == g;
                        if (t.deleteContent(n, {leaveUnmerged: v}), v) {
                            if (_) return CC(e, n.focus), !0;
                            e.setSelection(g, 0)
                        }
                    }
                    return !1
                }
            }

            function CC(r, e) {
                r.split(e), r.setSelection(e.parent.nextSibling, 0)
            }

            const AI = {insertParagraph: {isSoft: !1}, insertLineBreak: {isSoft: !0}};

            class _C extends En {
                constructor(e) {
                    super(e);
                    const t = this.document;
                    let n = !1;
                    t.on("keydown", (i, s) => {
                        n = s.shiftKey
                    }), t.on("beforeinput", (i, s) => {
                        if (!this.isEnabled) return;
                        let l = s.inputType;
                        T.isSafari && n && l == "insertParagraph" && (l = "insertLineBreak");
                        const d = s.domEvent, g = AI[l];
                        if (!g) return;
                        const v = new ya(t, "enter", s.targetRanges[0]);
                        t.fire(v, new Gn(e, d, {isSoft: g.isSoft})), v.stop.called && i.stop()
                    })
                }

                observe() {
                }

                stopObserving() {
                }
            }

            class $g extends Re {
                static get pluginName() {
                    return "Enter"
                }

                init() {
                    const e = this.editor, t = e.editing.view, n = t.document;
                    t.addObserver(_C), e.commands.add("enter", new wI(e)), this.listenTo(n, "enter", (i, s) => {
                        n.isComposing || s.preventDefault(), s.isSoft || (e.execute("enter"), t.scrollToTheSelection())
                    }, {priority: "low"})
                }
            }

            class CI extends Ft {
                execute() {
                    const e = this.editor.model, t = e.document;
                    e.change(n => {
                        (function (i, s, l) {
                            const d = l.isCollapsed, g = l.getFirstRange(), v = g.start.parent, _ = g.end.parent,
                                x = v == _;
                            if (d) {
                                const M = AC(i.schema, l.getAttributes());
                                yC(i, s, g.end), s.removeSelectionAttribute(l.getAttributeKeys()), s.setSelectionAttribute(M)
                            } else {
                                const M = !(g.start.isAtStart && g.end.isAtEnd);
                                i.deleteContent(l, {leaveUnmerged: M}), x ? yC(i, s, l.focus) : M && s.setSelection(_, 0)
                            }
                        })(e, n, t.selection), this.fire("afterExecute", {writer: n})
                    })
                }

                refresh() {
                    const e = this.editor.model, t = e.document;
                    this.isEnabled = function (n, i) {
                        if (i.rangeCount > 1) return !1;
                        const s = i.anchor;
                        if (!s || !n.checkChild(s, "softBreak")) return !1;
                        const l = i.getFirstRange(), d = l.start.parent, g = l.end.parent;
                        return !((Ob(d, n) || Ob(g, n)) && d !== g)
                    }(e.schema, t.selection)
                }
            }

            function yC(r, e, t) {
                const n = e.createElement("softBreak");
                r.insertContent(n, t), e.setSelection(n, "after")
            }

            function Ob(r, e) {
                return !r.is("rootElement") && (e.isLimit(r) || Ob(r.parent, e))
            }

            class _I extends Re {
                static get pluginName() {
                    return "ShiftEnter"
                }

                init() {
                    const e = this.editor, t = e.model.schema, n = e.conversion, i = e.editing.view, s = i.document;
                    t.register("softBreak", {
                        allowWhere: "$text",
                        isInline: !0
                    }), n.for("upcast").elementToElement({
                        model: "softBreak",
                        view: "br"
                    }), n.for("downcast").elementToElement({
                        model: "softBreak",
                        view: (l, {writer: d}) => d.createEmptyElement("br")
                    }), i.addObserver(_C), e.commands.add("shiftEnter", new CI(e)), this.listenTo(s, "enter", (l, d) => {
                        s.isComposing || d.preventDefault(), d.isSoft && (e.execute("shiftEnter"), i.scrollToTheSelection())
                    }, {priority: "low"})
                }
            }

            class yI extends Le() {
                constructor() {
                    super(...arguments), this._stack = []
                }

                add(e, t) {
                    const n = this._stack, i = n[0];
                    this._insertDescriptor(e);
                    const s = n[0];
                    i === s || Fb(i, s) || this.fire("change:top", {oldDescriptor: i, newDescriptor: s, writer: t})
                }

                remove(e, t) {
                    const n = this._stack, i = n[0];
                    this._removeDescriptor(e);
                    const s = n[0];
                    i === s || Fb(i, s) || this.fire("change:top", {oldDescriptor: i, newDescriptor: s, writer: t})
                }

                _insertDescriptor(e) {
                    const t = this._stack, n = t.findIndex(s => s.id === e.id);
                    if (Fb(e, t[n])) return;
                    n > -1 && t.splice(n, 1);
                    let i = 0;
                    for (; t[i] && DI(t[i], e);) i++;
                    t.splice(i, 0, e)
                }

                _removeDescriptor(e) {
                    const t = this._stack, n = t.findIndex(i => i.id === e);
                    n > -1 && t.splice(n, 1)
                }
            }

            function Fb(r, e) {
                return r && e && r.priority == e.priority && Gg(r.classes) == Gg(e.classes)
            }

            function DI(r, e) {
                return r.priority > e.priority || !(r.priority < e.priority) && Gg(r.classes) > Gg(e.classes)
            }

            function Gg(r) {
                return Array.isArray(r) ? r.sort().join(",") : r
            }

            const xI = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>',
                EI = "ck-widget", DC = "ck-widget_selected";

            function wr(r) {
                return !!r.is("element") && !!r.getCustomProperty("widget")
            }

            function Rb(r, e, t = {}) {
                if (!r.is("containerElement")) throw new R("widget-to-widget-wrong-element-type", null, {element: r});
                return e.setAttribute("contenteditable", "false", r), e.addClass(EI, r), e.setCustomProperty("widget", !0, r), r.getFillerOffset = II, e.setCustomProperty("widgetLabel", [], r), t.label && function (n, i) {
                    n.getCustomProperty("widgetLabel").push(i)
                }(r, t.label), t.hasSelectionHandle && function (n, i) {
                    const s = i.createUIElement("div", {class: "ck ck-widget__selection-handle"}, function (l) {
                        const d = this.toDomElement(l), g = new Ho;
                        return g.set("content", xI), g.render(), d.appendChild(g.element), d
                    });
                    i.insert(i.createPositionAt(n, 0), s), i.addClass(["ck-widget_with-selection-handle"], n)
                }(r, e), xC(r, e), r
            }

            function SI(r, e, t) {
                if (e.classes && t.addClass(qn(e.classes), r), e.attributes) for (const n in e.attributes) t.setAttribute(n, e.attributes[n], r)
            }

            function TI(r, e, t) {
                if (e.classes && t.removeClass(qn(e.classes), r), e.attributes) for (const n in e.attributes) t.removeAttribute(n, r)
            }

            function xC(r, e, t = SI, n = TI) {
                const i = new yI;
                i.on("change:top", (s, l) => {
                    l.oldDescriptor && n(r, l.oldDescriptor, l.writer), l.newDescriptor && t(r, l.newDescriptor, l.writer)
                }), e.setCustomProperty("addHighlight", (s, l, d) => i.add(l, d), r), e.setCustomProperty("removeHighlight", (s, l, d) => i.remove(l, d), r)
            }

            function EC(r, e, t = {}) {
                return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], r), e.setAttribute("role", "textbox", r), t.label && e.setAttribute("aria-label", t.label, r), e.setAttribute("contenteditable", r.isReadOnly ? "false" : "true", r), r.on("change:isReadOnly", (n, i, s) => {
                    e.setAttribute("contenteditable", s ? "false" : "true", r)
                }), r.on("change:isFocused", (n, i, s) => {
                    s ? e.addClass("ck-editor__nested-editable_focused", r) : e.removeClass("ck-editor__nested-editable_focused", r)
                }), xC(r, e), r
            }

            function SC(r, e) {
                const t = r.getSelectedElement();
                if (t) {
                    const n = Ba(r);
                    if (n) return e.createRange(e.createPositionAt(t, n))
                }
                return Ww(r, e)
            }

            function II() {
                return null
            }

            const Os = "widget-type-around";

            function $l(r, e, t) {
                return !!r && wr(r) && !t.isInline(e)
            }

            function Ba(r) {
                return r.getAttribute(Os)
            }

            var TC = C(4921),
                MI = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(TC.Z, MI), TC.Z.locals;
            const IC = ["before", "after"],
                BI = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild,
                MC = "ck-widget__type-around_disabled";

            class NI extends Re {
                constructor() {
                    super(...arguments), this._currentFakeCaretModelElement = null
                }

                static get pluginName() {
                    return "WidgetTypeAround"
                }

                static get requires() {
                    return [$g, Ls]
                }

                init() {
                    const e = this.editor, t = e.editing.view;
                    this.on("change:isEnabled", (n, i, s) => {
                        t.change(l => {
                            for (const d of t.document.roots) s ? l.removeClass(MC, d) : l.addClass(MC, d)
                        }), s || e.model.change(l => {
                            l.removeSelectionAttribute(Os)
                        })
                    }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration()
                }

                destroy() {
                    super.destroy(), this._currentFakeCaretModelElement = null
                }

                _insertParagraph(e, t) {
                    const n = this.editor, i = n.editing.view,
                        s = n.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
                    n.execute("insertParagraph", {
                        position: n.model.createPositionAt(e, t),
                        attributes: s
                    }), i.focus(), i.scrollToTheSelection()
                }

                _listenToIfEnabled(e, t, n, i) {
                    this.listenTo(e, t, (...s) => {
                        this.isEnabled && n(...s)
                    }, i)
                }

                _insertParagraphAccordingToFakeCaretPosition() {
                    const e = this.editor.model.document.selection, t = Ba(e);
                    if (!t) return !1;
                    const n = e.getSelectedElement();
                    return this._insertParagraph(n, t), !0
                }

                _enableTypeAroundUIInjection() {
                    const e = this.editor, t = e.model.schema, n = e.locale.t,
                        i = {before: n("Insert paragraph before block"), after: n("Insert paragraph after block")};
                    e.editing.downcastDispatcher.on("insert", (s, l, d) => {
                        const g = d.mapper.toViewElement(l.item);
                        g && $l(g, l.item, t) && (function (v, _, x) {
                            const M = v.createUIElement("div", {class: "ck ck-reset_all ck-widget__type-around"}, function (O) {
                                const j = this.toDomElement(O);
                                return function (U, K) {
                                    for (const ne of IC) {
                                        const pe = new xi({
                                            tag: "div",
                                            attributes: {
                                                class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${ne}`],
                                                title: K[ne],
                                                "aria-hidden": "true"
                                            },
                                            children: [U.ownerDocument.importNode(BI, !0)]
                                        });
                                        U.appendChild(pe.render())
                                    }
                                }(j, _), function (U) {
                                    const K = new xi({
                                        tag: "div",
                                        attributes: {class: ["ck", "ck-widget__type-around__fake-caret"]}
                                    });
                                    U.appendChild(K.render())
                                }(j), j
                            });
                            v.insert(v.createPositionAt(x, "end"), M)
                        }(d.writer, i, g), g.getCustomProperty("widgetLabel").push(() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""))
                    }, {priority: "low"})
                }

                _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
                    const e = this.editor, t = e.model, n = t.document.selection, i = t.schema, s = e.editing.view;

                    function l(d) {
                        return `ck-widget_type-around_show-fake-caret_${d}`
                    }

                    this._listenToIfEnabled(s.document, "arrowKey", (d, g) => {
                        this._handleArrowKeyPress(d, g)
                    }, {
                        context: [wr, "$text"],
                        priority: "high"
                    }), this._listenToIfEnabled(n, "change:range", (d, g) => {
                        g.directChange && e.model.change(v => {
                            v.removeSelectionAttribute(Os)
                        })
                    }), this._listenToIfEnabled(t.document, "change:data", () => {
                        const d = n.getSelectedElement();
                        d && $l(e.editing.mapper.toViewElement(d), d, i) || e.model.change(g => {
                            g.removeSelectionAttribute(Os)
                        })
                    }), this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (d, g, v) => {
                        const _ = v.writer;
                        if (this._currentFakeCaretModelElement) {
                            const j = v.mapper.toViewElement(this._currentFakeCaretModelElement);
                            j && (_.removeClass(IC.map(l), j), this._currentFakeCaretModelElement = null)
                        }
                        const x = g.selection.getSelectedElement();
                        if (!x) return;
                        const M = v.mapper.toViewElement(x);
                        if (!$l(M, x, i)) return;
                        const O = Ba(g.selection);
                        O && (_.addClass(l(O), M), this._currentFakeCaretModelElement = x)
                    }), this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (d, g, v) => {
                        v || e.model.change(_ => {
                            _.removeSelectionAttribute(Os)
                        })
                    })
                }

                _handleArrowKeyPress(e, t) {
                    const n = this.editor, i = n.model, s = i.document.selection, l = i.schema, d = n.editing.view,
                        g = function (x, M) {
                            const O = jo(x, M);
                            return O === "down" || O === "right"
                        }(t.keyCode, n.locale.contentLanguageDirection), v = d.document.selection.getSelectedElement();
                    let _;
                    $l(v, n.editing.mapper.toModelElement(v), l) ? _ = this._handleArrowKeyPressOnSelectedWidget(g) : s.isCollapsed ? _ = this._handleArrowKeyPressWhenSelectionNextToAWidget(g) : t.shiftKey || (_ = this._handleArrowKeyPressWhenNonCollapsedSelection(g)), _ && (t.preventDefault(), e.stop())
                }

                _handleArrowKeyPressOnSelectedWidget(e) {
                    const t = this.editor.model, n = Ba(t.document.selection);
                    return t.change(i => n ? n !== (e ? "after" : "before") ? (i.removeSelectionAttribute(Os), !0) : !1 : (i.setSelectionAttribute(Os, e ? "after" : "before"), !0))
                }

                _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
                    const t = this.editor, n = t.model, i = n.schema, s = t.plugins.get("Widget"),
                        l = s._getObjectElementNextToSelection(e);
                    return !!$l(t.editing.mapper.toViewElement(l), l, i) && (n.change(d => {
                        s._setSelectionOverElement(l), d.setSelectionAttribute(Os, e ? "before" : "after")
                    }), !0)
                }

                _handleArrowKeyPressWhenNonCollapsedSelection(e) {
                    const t = this.editor, n = t.model, i = n.schema, s = t.editing.mapper, l = n.document.selection,
                        d = e ? l.getLastPosition().nodeBefore : l.getFirstPosition().nodeAfter;
                    return !!$l(s.toViewElement(d), d, i) && (n.change(g => {
                        g.setSelection(d, "on"), g.setSelectionAttribute(Os, e ? "after" : "before")
                    }), !0)
                }

                _enableInsertingParagraphsOnButtonClick() {
                    const e = this.editor, t = e.editing.view;
                    this._listenToIfEnabled(t.document, "mousedown", (n, i) => {
                        const s = i.domTarget.closest(".ck-widget__type-around__button");
                        if (!s) return;
                        const l = function (v) {
                            return v.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
                        }(s), d = function (v, _) {
                            const x = v.closest(".ck-widget");
                            return _.mapDomToView(x)
                        }(s, t.domConverter), g = e.editing.mapper.toModelElement(d);
                        this._insertParagraph(g, l), i.preventDefault(), n.stop()
                    })
                }

                _enableInsertingParagraphsOnEnterKeypress() {
                    const e = this.editor, t = e.model.document.selection, n = e.editing.view;
                    this._listenToIfEnabled(n.document, "enter", (i, s) => {
                        if (i.eventPhase != "atTarget") return;
                        const l = t.getSelectedElement(), d = e.editing.mapper.toViewElement(l), g = e.model.schema;
                        let v;
                        this._insertParagraphAccordingToFakeCaretPosition() ? v = !0 : $l(d, l, g) && (this._insertParagraph(l, s.isSoft ? "before" : "after"), v = !0), v && (s.preventDefault(), i.stop())
                    }, {context: wr})
                }

                _enableInsertingParagraphsOnTypingKeystroke() {
                    const e = this.editor.editing.view.document;
                    this._listenToIfEnabled(e, "insertText", (t, n) => {
                        this._insertParagraphAccordingToFakeCaretPosition() && (n.selection = e.selection)
                    }, {priority: "high"}), T.isAndroid ? this._listenToIfEnabled(e, "keydown", (t, n) => {
                        n.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition()
                    }) : this._listenToIfEnabled(e, "compositionstart", () => {
                        this._insertParagraphAccordingToFakeCaretPosition()
                    }, {priority: "high"})
                }

                _enableDeleteIntegration() {
                    const e = this.editor, t = e.editing.view, n = e.model, i = n.schema;
                    this._listenToIfEnabled(t.document, "delete", (s, l) => {
                        if (s.eventPhase != "atTarget") return;
                        const d = Ba(n.document.selection);
                        if (!d) return;
                        const g = l.direction, v = n.document.selection.getSelectedElement(), _ = g == "forward";
                        if (d === "before" === _) e.execute("delete", {selection: n.createSelection(v, "on")}); else {
                            const x = i.getNearestSelectionRange(n.createPositionAt(v, d), g);
                            if (x) if (x.isCollapsed) {
                                const M = n.createSelection(x.start);
                                if (n.modifySelection(M, {direction: g}), M.focus.isEqual(x.start)) {
                                    const O = function (j, U) {
                                        let K = U;
                                        for (const ne of U.getAncestors({parentFirst: !0})) {
                                            if (ne.childCount > 1 || j.isLimit(ne)) break;
                                            K = ne
                                        }
                                        return K
                                    }(i, x.start.parent);
                                    n.deleteContent(n.createSelection(O, "on"), {doNotAutoparagraph: !0})
                                } else n.change(O => {
                                    O.setSelection(x), e.execute(_ ? "deleteForward" : "delete")
                                })
                            } else n.change(M => {
                                M.setSelection(x), e.execute(_ ? "deleteForward" : "delete")
                            })
                        }
                        l.preventDefault(), s.stop()
                    }, {context: wr})
                }

                _enableInsertContentIntegration() {
                    const e = this.editor, t = this.editor.model, n = t.document.selection;
                    this._listenToIfEnabled(e.model, "insertContent", (i, [s, l]) => {
                        if (l && !l.is("documentSelection")) return;
                        const d = Ba(n);
                        return d ? (i.stop(), t.change(g => {
                            const v = n.getSelectedElement(), _ = t.createPositionAt(v, d), x = g.createSelection(_),
                                M = t.insertContent(s, x);
                            return g.setSelection(x), M
                        })) : void 0
                    }, {priority: "high"})
                }

                _enableInsertObjectIntegration() {
                    const e = this.editor, t = this.editor.model.document.selection;
                    this._listenToIfEnabled(e.model, "insertObject", (n, i) => {
                        const [, s, l = {}] = i;
                        if (s && !s.is("documentSelection")) return;
                        const d = Ba(t);
                        d && (l.findOptimalPosition = d, i[3] = l)
                    }, {priority: "high"})
                }

                _enableDeleteContentIntegration() {
                    const e = this.editor, t = this.editor.model.document.selection;
                    this._listenToIfEnabled(e.model, "deleteContent", (n, [i]) => {
                        i && !i.is("documentSelection") || Ba(t) && n.stop()
                    }, {priority: "high"})
                }
            }

            function LI(r) {
                const e = r.model;
                return (t, n) => {
                    const i = n.keyCode == Ut.arrowup, s = n.keyCode == Ut.arrowdown, l = n.shiftKey,
                        d = e.document.selection;
                    if (!i && !s) return;
                    const g = s;
                    if (l && function (_, x) {
                        return !_.isCollapsed && _.isBackward == x
                    }(d, g)) return;
                    const v = function (_, x, M) {
                        const O = _.model;
                        if (M) {
                            const j = x.isCollapsed ? x.focus : x.getLastPosition(), U = BC(O, j, "forward");
                            if (!U) return null;
                            const K = O.createRange(j, U), ne = NC(O.schema, K, "backward");
                            return ne ? O.createRange(j, ne) : null
                        }
                        {
                            const j = x.isCollapsed ? x.focus : x.getFirstPosition(), U = BC(O, j, "backward");
                            if (!U) return null;
                            const K = O.createRange(U, j), ne = NC(O.schema, K, "forward");
                            return ne ? O.createRange(ne, j) : null
                        }
                    }(r, d, g);
                    if (v) {
                        if (v.isCollapsed && (d.isCollapsed || l)) return;
                        (v.isCollapsed || function (_, x, M) {
                            const O = _.model, j = _.view.domConverter;
                            if (M) {
                                const Se = O.createSelection(x.start);
                                O.modifySelection(Se), Se.focus.isAtEnd || x.start.isEqual(Se.focus) || (x = O.createRange(Se.focus, x.end))
                            }
                            const U = _.mapper.toViewRange(x), K = j.viewRangeToDom(U), ne = Lt.getDomRangeRects(K);
                            let pe;
                            for (const Se of ne) if (pe !== void 0) {
                                if (Math.round(Se.top) >= pe) return !1;
                                pe = Math.max(pe, Math.round(Se.bottom))
                            } else pe = Math.round(Se.bottom);
                            return !0
                        }(r, v, g)) && (e.change(_ => {
                            const x = g ? v.end : v.start;
                            if (l) {
                                const M = e.createSelection(d.anchor);
                                M.setFocus(x), _.setSelection(M)
                            } else _.setSelection(x)
                        }), t.stop(), n.preventDefault(), n.stopPropagation())
                    }
                }
            }

            function BC(r, e, t) {
                const n = r.schema, i = r.createRangeIn(e.root), s = t == "forward" ? "elementStart" : "elementEnd";
                for (const {previousPosition: l, item: d, type: g} of i.getWalker({startPosition: e, direction: t})) {
                    if (n.isLimit(d) && !n.isInline(d)) return l;
                    if (g == s && n.isBlock(d)) return null
                }
                return null
            }

            function NC(r, e, t) {
                const n = t == "backward" ? e.end : e.start;
                if (r.checkChild(n, "$text")) return n;
                for (const {nextPosition: i} of e.getWalker({direction: t})) if (r.checkChild(i, "$text")) return i;
                return null
            }

            var LC = C(3488),
                PI = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(LC.Z, PI), LC.Z.locals;

            class mh extends Re {
                constructor() {
                    super(...arguments), this._previouslySelected = new Set
                }

                static get pluginName() {
                    return "Widget"
                }

                static get requires() {
                    return [NI, Ls]
                }

                init() {
                    const e = this.editor, t = e.editing.view, n = t.document;
                    this.editor.editing.downcastDispatcher.on("selection", (i, s, l) => {
                        const d = l.writer, g = s.selection;
                        if (g.isCollapsed) return;
                        const v = g.getSelectedElement();
                        if (!v) return;
                        const _ = e.editing.mapper.toViewElement(v);
                        var x;
                        wr(_) && l.consumable.consume(g, "selection") && d.setSelection(d.createRangeOn(_), {
                            fake: !0,
                            label: (x = _, x.getCustomProperty("widgetLabel").reduce((M, O) => typeof O == "function" ? M ? M + ". " + O() : O() : M ? M + ". " + O : O, ""))
                        })
                    }), this.editor.editing.downcastDispatcher.on("selection", (i, s, l) => {
                        this._clearPreviouslySelectedWidgets(l.writer);
                        const d = l.writer, g = d.document.selection;
                        let v = null;
                        for (const _ of g.getRanges()) for (const x of _) {
                            const M = x.item;
                            wr(M) && !OI(M, v) && (d.addClass(DC, M), this._previouslySelected.add(M), v = M)
                        }
                    }, {priority: "low"}), t.addObserver(bb), this.listenTo(n, "mousedown", (...i) => this._onMousedown(...i)), this.listenTo(n, "arrowKey", (...i) => {
                        this._handleSelectionChangeOnArrowKeyPress(...i)
                    }, {context: [wr, "$text"]}), this.listenTo(n, "arrowKey", (...i) => {
                        this._preventDefaultOnArrowKeyPress(...i)
                    }, {context: "$root"}), this.listenTo(n, "arrowKey", LI(this.editor.editing), {context: "$text"}), this.listenTo(n, "delete", (i, s) => {
                        this._handleDelete(s.direction == "forward") && (s.preventDefault(), i.stop())
                    }, {context: "$root"})
                }

                _onMousedown(e, t) {
                    const n = this.editor, i = n.editing.view, s = i.document;
                    let l = t.target;
                    if (t.domEvent.detail >= 3) return void (this._selectBlockContent(l) && t.preventDefault());
                    if (function (g) {
                        let v = g;
                        for (; v;) {
                            if (v.is("editableElement") && !v.is("rootElement")) return !0;
                            if (wr(v)) return !1;
                            v = v.parent
                        }
                        return !1
                    }(l) || !wr(l) && (l = l.findAncestor(wr), !l)) return;
                    T.isAndroid && t.preventDefault(), s.isFocused || i.focus();
                    const d = n.editing.mapper.toModelElement(l);
                    this._setSelectionOverElement(d)
                }

                _selectBlockContent(e) {
                    const t = this.editor, n = t.model, i = t.editing.mapper, s = n.schema,
                        l = i.findMappedViewAncestor(this.editor.editing.view.createPositionAt(e, 0)),
                        d = function (g, v) {
                            for (const _ of g.getAncestors({includeSelf: !0, parentFirst: !0})) {
                                if (v.checkChild(_, "$text")) return _;
                                if (v.isLimit(_) && !v.isObject(_)) break
                            }
                            return null
                        }(i.toModelElement(l), n.schema);
                    return !!d && (n.change(g => {
                        const v = s.isLimit(d) ? null : function (M, O) {
                                const j = new Ao({startPosition: M});
                                for (const {item: U} of j) {
                                    if (O.isLimit(U) || !U.is("element")) return null;
                                    if (O.checkChild(U, "$text")) return U
                                }
                                return null
                            }(g.createPositionAfter(d), s), _ = g.createPositionAt(d, 0),
                            x = v ? g.createPositionAt(v, 0) : g.createPositionAt(d, "end");
                        g.setSelection(g.createRange(_, x))
                    }), !0)
                }

                _handleSelectionChangeOnArrowKeyPress(e, t) {
                    const n = t.keyCode, i = this.editor.model, s = i.schema, l = i.document.selection,
                        d = l.getSelectedElement(), g = jo(n, this.editor.locale.contentLanguageDirection),
                        v = g == "down" || g == "right", _ = g == "up" || g == "down";
                    if (d && s.isObject(d)) {
                        const M = v ? l.getLastPosition() : l.getFirstPosition(),
                            O = s.getNearestSelectionRange(M, v ? "forward" : "backward");
                        return void (O && (i.change(j => {
                            j.setSelection(O)
                        }), t.preventDefault(), e.stop()))
                    }
                    if (!l.isCollapsed && !t.shiftKey) {
                        const M = l.getFirstPosition(), O = l.getLastPosition(), j = M.nodeAfter, U = O.nodeBefore;
                        return void ((j && s.isObject(j) || U && s.isObject(U)) && (i.change(K => {
                            K.setSelection(v ? O : M)
                        }), t.preventDefault(), e.stop()))
                    }
                    if (!l.isCollapsed) return;
                    const x = this._getObjectElementNextToSelection(v);
                    if (x && s.isObject(x)) {
                        if (s.isInline(x) && _) return;
                        this._setSelectionOverElement(x), t.preventDefault(), e.stop()
                    }
                }

                _preventDefaultOnArrowKeyPress(e, t) {
                    const n = this.editor.model, i = n.schema, s = n.document.selection.getSelectedElement();
                    s && i.isObject(s) && (t.preventDefault(), e.stop())
                }

                _handleDelete(e) {
                    const t = this.editor.model.document.selection;
                    if (!this.editor.model.canEditAt(t) || !t.isCollapsed) return;
                    const n = this._getObjectElementNextToSelection(e);
                    return n ? (this.editor.model.change(i => {
                        let s = t.anchor.parent;
                        for (; s.isEmpty;) {
                            const l = s;
                            s = l.parent, i.remove(l)
                        }
                        this._setSelectionOverElement(n)
                    }), !0) : void 0
                }

                _setSelectionOverElement(e) {
                    this.editor.model.change(t => {
                        t.setSelection(t.createRangeOn(e))
                    })
                }

                _getObjectElementNextToSelection(e) {
                    const t = this.editor.model, n = t.schema, i = t.document.selection, s = t.createSelection(i);
                    if (t.modifySelection(s, {direction: e ? "forward" : "backward"}), s.isEqual(i)) return null;
                    const l = e ? s.focus.nodeBefore : s.focus.nodeAfter;
                    return l && n.isObject(l) ? l : null
                }

                _clearPreviouslySelectedWidgets(e) {
                    for (const t of this._previouslySelected) e.removeClass(DC, t);
                    this._previouslySelected.clear()
                }
            }

            function OI(r, e) {
                return !!e && Array.from(r.getAncestors()).includes(e)
            }

            class Kg extends Re {
                constructor() {
                    super(...arguments), this._toolbarDefinitions = new Map
                }

                static get requires() {
                    return [jg]
                }

                static get pluginName() {
                    return "WidgetToolbarRepository"
                }

                init() {
                    const e = this.editor;
                    if (e.plugins.has("BalloonToolbar")) {
                        const t = e.plugins.get("BalloonToolbar");
                        this.listenTo(t, "show", n => {
                            (function (i) {
                                const s = i.getSelectedElement();
                                return !(!s || !wr(s))
                            })(e.editing.view.document.selection) && n.stop()
                        }, {priority: "high"})
                    }
                    this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
                        this._updateToolbarsVisibility()
                    }), this.listenTo(e.ui, "update", () => {
                        this._updateToolbarsVisibility()
                    }), this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
                        this._updateToolbarsVisibility()
                    }, {priority: "low"})
                }

                destroy() {
                    super.destroy();
                    for (const e of this._toolbarDefinitions.values()) e.view.destroy()
                }

                register(e, {
                    ariaLabel: t,
                    items: n,
                    getRelatedElement: i,
                    balloonClassName: s = "ck-toolbar-container"
                }) {
                    if (!n.length) return void ae("widget-toolbar-no-items", {toolbarId: e});
                    const l = this.editor, d = l.t, g = new vb(l.locale);
                    if (g.ariaLabel = t || d("Widget toolbar"), this._toolbarDefinitions.has(e)) throw new R("widget-toolbar-duplicated", this, {toolbarId: e});
                    const v = {view: g, getRelatedElement: i, balloonClassName: s, itemsConfig: n, initialized: !1};
                    l.ui.addToolbar(g, {
                        isContextual: !0, beforeFocus: () => {
                            const _ = i(l.editing.view.document.selection);
                            _ && this._showToolbar(v, _)
                        }, afterBlur: () => {
                            this._hideToolbar(v)
                        }
                    }), this._toolbarDefinitions.set(e, v)
                }

                _updateToolbarsVisibility() {
                    let e = 0, t = null, n = null;
                    for (const i of this._toolbarDefinitions.values()) {
                        const s = i.getRelatedElement(this.editor.editing.view.document.selection);
                        if (this.isEnabled && s) if (this.editor.ui.focusTracker.isFocused) {
                            const l = s.getAncestors().length;
                            l > e && (e = l, t = s, n = i)
                        } else this._isToolbarVisible(i) && this._hideToolbar(i); else this._isToolbarInBalloon(i) && this._hideToolbar(i)
                    }
                    n && this._showToolbar(n, t)
                }

                _hideToolbar(e) {
                    this._balloon.remove(e.view), this.stopListening(this._balloon, "change:visibleView")
                }

                _showToolbar(e, t) {
                    this._isToolbarVisible(e) ? PC(this.editor, t) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0, e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({
                        view: e.view,
                        position: OC(this.editor, t),
                        balloonClassName: e.balloonClassName
                    }), this.listenTo(this._balloon, "change:visibleView", () => {
                        for (const n of this._toolbarDefinitions.values()) if (this._isToolbarVisible(n)) {
                            const i = n.getRelatedElement(this.editor.editing.view.document.selection);
                            PC(this.editor, i)
                        }
                    }))
                }

                _isToolbarVisible(e) {
                    return this._balloon.visibleView === e.view
                }

                _isToolbarInBalloon(e) {
                    return this._balloon.hasView(e.view)
                }
            }

            function PC(r, e) {
                const t = r.plugins.get("ContextualBalloon"), n = OC(r, e);
                t.updatePosition(n)
            }

            function OC(r, e) {
                const t = r.editing.view, n = ui.defaultPositions;
                return {
                    target: t.domConverter.mapViewToDom(e),
                    positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth]
                }
            }

            var FC = C(8506),
                FI = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(FC.Z, FI), FC.Z.locals;
            const zb = Ro("px");

            class RI extends It {
                constructor() {
                    super();
                    const e = this.bindTemplate;
                    this.set({isVisible: !1, left: null, top: null, width: null}), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-clipboard-drop-target-line", e.if("isVisible", "ck-hidden", t => !t)],
                            style: {
                                left: e.to("left", t => zb(t)),
                                top: e.to("top", t => zb(t)),
                                width: e.to("width", t => zb(t))
                            }
                        }
                    })
                }
            }

            class Zg extends Re {
                constructor() {
                    super(...arguments), this.removeDropMarkerDelayed = Ad(() => this.removeDropMarker(), 40), this._updateDropMarkerThrottled = Rg(e => this._updateDropMarker(e), 40), this._reconvertMarkerThrottled = Rg(() => {
                        this.editor.model.markers.has("drop-target") && this.editor.editing.reconvertMarker("drop-target")
                    }, 0), this._dropTargetLineView = new RI, this._domEmitter = new (dr()), this._scrollables = new Map
                }

                static get pluginName() {
                    return "DragDropTarget"
                }

                init() {
                    this._setupDropMarker()
                }

                destroy() {
                    this._domEmitter.stopListening();
                    for (const {resizeObserver: e} of this._scrollables.values()) e.destroy();
                    return this._updateDropMarkerThrottled.cancel(), this.removeDropMarkerDelayed.cancel(), this._reconvertMarkerThrottled.cancel(), super.destroy()
                }

                updateDropMarker(e, t, n, i, s, l) {
                    this.removeDropMarkerDelayed.cancel();
                    const d = RC(this.editor, e, t, n, i, s, l);
                    if (d) return l && l.containsRange(d) ? this.removeDropMarker() : void this._updateDropMarkerThrottled(d)
                }

                getFinalDropRange(e, t, n, i, s, l) {
                    const d = RC(this.editor, e, t, n, i, s, l);
                    return this.removeDropMarker(), d
                }

                removeDropMarker() {
                    const e = this.editor.model;
                    this.removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), this._dropTargetLineView.isVisible = !1, e.markers.has("drop-target") && e.change(t => {
                        t.removeMarker("drop-target")
                    })
                }

                _setupDropMarker() {
                    const e = this.editor;
                    e.ui.view.body.add(this._dropTargetLineView), e.conversion.for("editingDowncast").markerToHighlight({
                        model: "drop-target",
                        view: {classes: ["ck-clipboard-drop-target-range"]}
                    }), e.conversion.for("editingDowncast").markerToElement({
                        model: "drop-target",
                        view: (t, {writer: n}) => {
                            if (e.model.schema.checkChild(t.markerRange.start, "$text")) return this._dropTargetLineView.isVisible = !1, this._createDropTargetPosition(n);
                            t.markerRange.isCollapsed ? this._updateDropTargetLine(t.markerRange) : this._dropTargetLineView.isVisible = !1
                        }
                    })
                }

                _updateDropMarker(e) {
                    const t = this.editor, n = t.model.markers;
                    t.model.change(i => {
                        n.has("drop-target") ? n.get("drop-target").getRange().isEqual(e) || i.updateMarker("drop-target", {range: e}) : i.addMarker("drop-target", {
                            range: e,
                            usingOperation: !1,
                            affectsData: !1
                        })
                    })
                }

                _createDropTargetPosition(e) {
                    return e.createUIElement("span", {class: "ck ck-clipboard-drop-target-position"}, function (t) {
                        const n = this.toDomElement(t);
                        return n.append("⁠", t.createElement("span"), "⁠"), n
                    })
                }

                _updateDropTargetLine(e) {
                    const t = this.editor.editing, n = e.start.nodeBefore, i = e.start.nodeAfter, s = e.start.parent,
                        l = n ? t.mapper.toViewElement(n) : null, d = l ? t.view.domConverter.mapViewToDom(l) : null,
                        g = i ? t.mapper.toViewElement(i) : null, v = g ? t.view.domConverter.mapViewToDom(g) : null,
                        _ = t.mapper.toViewElement(s), x = t.view.domConverter.mapViewToDom(_),
                        M = this._getScrollableRect(_), {scrollX: O, scrollY: j} = bt.window, U = d ? new Lt(d) : null,
                        K = v ? new Lt(v) : null, ne = new Lt(x).excludeScrollbarsAndBorders(),
                        pe = U ? U.bottom : ne.top, Se = K ? K.top : ne.bottom, Je = bt.window.getComputedStyle(x),
                        wt = pe <= Se ? (pe + Se) / 2 : Se;
                    if (M.top < wt && wt < M.bottom) {
                        const qt = ne.left + parseFloat(Je.paddingLeft), Zt = ne.right - parseFloat(Je.paddingRight),
                            Jn = Math.max(qt + O, M.left), Xn = Math.min(Zt + O, M.right);
                        this._dropTargetLineView.set({isVisible: !0, left: Jn, top: wt + j, width: Xn - Jn})
                    } else this._dropTargetLineView.isVisible = !1
                }

                _getScrollableRect(e) {
                    const t = e.root.rootName;
                    let n;
                    if (this._scrollables.has(t)) n = this._scrollables.get(t).domElement; else {
                        n = function (s) {
                            let l = s;
                            do {
                                l = l.parentElement;
                                const d = bt.window.getComputedStyle(l).overflowY;
                                if (d == "auto" || d == "scroll") break
                            } while (l.tagName != "BODY");
                            return l
                        }(this.editor.editing.view.domConverter.mapViewToDom(e)), this._domEmitter.listenTo(n, "scroll", this._reconvertMarkerThrottled, {usePassive: !0});
                        const i = new ua(n, this._reconvertMarkerThrottled);
                        this._scrollables.set(t, {domElement: n, resizeObserver: i})
                    }
                    return new Lt(n).excludeScrollbarsAndBorders()
                }
            }

            function RC(r, e, t, n, i, s, l) {
                const d = r.model, g = r.editing.mapper;
                let v = jC(r, e);
                for (; v;) {
                    if (!s) {
                        if (d.schema.checkChild(v, "$text")) {
                            if (t) {
                                const _ = t[0].start, x = g.toModelPosition(_);
                                if (!l || Array.from(l.getItems()).every(M => d.schema.checkChild(x, M))) {
                                    if (d.schema.checkChild(x, "$text")) return d.createRange(x);
                                    if (_) return Yg(r, jC(r, _.parent), n, i)
                                }
                            }
                        } else if (d.schema.isInline(v)) return Yg(r, v, n, i)
                    }
                    if (d.schema.isBlock(v)) return Yg(r, v, n, i);
                    if (d.schema.checkChild(v, "$block")) {
                        const _ = Array.from(v.getChildren()).filter(O => O.is("element") && !zI(r, O));
                        let x = 0, M = _.length;
                        if (M == 0) return d.createRange(d.createPositionAt(v, "end"));
                        for (; x < M - 1;) {
                            const O = Math.floor((x + M) / 2);
                            zC(r, _[O], n, i) == "before" ? M = O : x = O
                        }
                        return Yg(r, _[x], n, i)
                    }
                    v = v.parent
                }
                return null
            }

            function zI(r, e) {
                const t = r.editing.mapper, n = r.editing.view.domConverter, i = t.toViewElement(e),
                    s = n.mapViewToDom(i);
                return bt.window.getComputedStyle(s).float != "none"
            }

            function Yg(r, e, t, n) {
                const i = r.model;
                return i.createRange(i.createPositionAt(e, zC(r, e, t, n)))
            }

            function zC(r, e, t, n) {
                const i = r.editing.mapper, s = r.editing.view.domConverter, l = i.toViewElement(e),
                    d = s.mapViewToDom(l), g = new Lt(d);
                return r.model.schema.isInline(e) ? t < (g.left + g.right) / 2 ? "before" : "after" : n < (g.top + g.bottom) / 2 ? "before" : "after"
            }

            function jC(r, e) {
                const t = r.editing.mapper, n = r.editing.view, i = t.toModelElement(e);
                if (i) return i;
                const s = n.createPositionBefore(e), l = t.findMappedViewAncestor(s);
                return t.toModelElement(l)
            }

            var jI = Object.defineProperty, VI = Object.defineProperties, HI = Object.getOwnPropertyDescriptors,
                VC = Object.getOwnPropertySymbols, UI = Object.prototype.hasOwnProperty,
                qI = Object.prototype.propertyIsEnumerable, HC = (r, e, t) => e in r ? jI(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            class WI extends Re {
                constructor() {
                    super(...arguments), this._isBlockDragging = !1, this._domEmitter = new (dr())
                }

                static get pluginName() {
                    return "DragDropBlockToolbar"
                }

                init() {
                    const e = this.editor;
                    if (this.listenTo(e, "change:isReadOnly", (t, n, i) => {
                        i ? (this.forceDisabled("readOnlyMode"), this._isBlockDragging = !1) : this.clearForceDisabled("readOnlyMode")
                    }), T.isAndroid && this.forceDisabled("noAndroidSupport"), e.plugins.has("BlockToolbar")) {
                        const t = e.plugins.get("BlockToolbar").buttonView.element;
                        this._domEmitter.listenTo(t, "dragstart", (n, i) => this._handleBlockDragStart(i)), this._domEmitter.listenTo(bt.document, "dragover", (n, i) => this._handleBlockDragging(i)), this._domEmitter.listenTo(bt.document, "drop", (n, i) => this._handleBlockDragging(i)), this._domEmitter.listenTo(bt.document, "dragend", () => this._handleBlockDragEnd(), {useCapture: !0}), this.isEnabled && t.setAttribute("draggable", "true"), this.on("change:isEnabled", (n, i, s) => {
                            t.setAttribute("draggable", s ? "true" : "false")
                        })
                    }
                }

                destroy() {
                    return this._domEmitter.stopListening(), super.destroy()
                }

                _handleBlockDragStart(e) {
                    if (!this.isEnabled) return;
                    const t = this.editor.model, n = t.document.selection, i = this.editor.editing.view,
                        s = Array.from(n.getSelectedBlocks()),
                        l = t.createRange(t.createPositionBefore(s[0]), t.createPositionAfter(s[s.length - 1]));
                    t.change(d => d.setSelection(l)), this._isBlockDragging = !0, i.focus(), i.getObserver(hh).onDomEvent(e)
                }

                _handleBlockDragging(e) {
                    if (!this.isEnabled || !this._isBlockDragging) return;
                    const t = e.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100),
                        n = e.clientY, i = document.elementFromPoint(t, n), s = this.editor.editing.view;
                    var l, d;
                    i && i.closest(".ck-editor__editable") && s.getObserver(hh).onDomEvent((l = ((g, v) => {
                        for (var _ in v || (v = {})) UI.call(v, _) && HC(g, _, v[_]);
                        if (VC) for (var _ of VC(v)) qI.call(v, _) && HC(g, _, v[_]);
                        return g
                    })({}, e), d = {
                        type: e.type,
                        dataTransfer: e.dataTransfer,
                        target: i,
                        clientX: t,
                        clientY: n,
                        preventDefault: () => e.preventDefault(),
                        stopPropagation: () => e.stopPropagation()
                    }, VI(l, HI(d))))
                }

                _handleBlockDragEnd() {
                    this._isBlockDragging = !1
                }
            }

            var UC = C(903),
                $I = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(UC.Z, $I), UC.Z.locals;

            class GI extends Re {
                constructor() {
                    super(...arguments), this._clearDraggableAttributesDelayed = Ad(() => this._clearDraggableAttributes(), 40), this._blockMode = !1, this._domEmitter = new (dr())
                }

                static get pluginName() {
                    return "DragDrop"
                }

                static get requires() {
                    return [es, mh, Zg, WI]
                }

                init() {
                    const e = this.editor, t = e.editing.view;
                    this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, t.addObserver(hh), t.addObserver(bb), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDraggableAttributeHandling(), this.listenTo(e, "change:isReadOnly", (n, i, s) => {
                        s ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode")
                    }), this.on("change:isEnabled", (n, i, s) => {
                        s || this._finalizeDragging(!1)
                    }), T.isAndroid && this.forceDisabled("noAndroidSupport")
                }

                destroy() {
                    return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._previewContainer && this._previewContainer.remove(), this._domEmitter.stopListening(), this._clearDraggableAttributesDelayed.cancel(), super.destroy()
                }

                _setupDragging() {
                    const e = this.editor, t = e.model, n = e.editing.view, i = n.document, s = e.plugins.get(Zg);
                    this.listenTo(i, "dragstart", (l, d) => {
                        if (d.target && d.target.is("editableElement") || (this._prepareDraggedRange(d.target), !this._draggedRange)) return void d.preventDefault();
                        this._draggingUid = Y(), d.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", d.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
                        const g = t.createSelection(this._draggedRange.toRange());
                        this.editor.plugins.get("ClipboardPipeline")._fireOutputTransformationEvent(d.dataTransfer, g, "dragstart");
                        const {dataTransfer: v, domTarget: _, domEvent: x} = d, {clientX: M} = x;
                        this._updatePreview({
                            dataTransfer: v,
                            domTarget: _,
                            clientX: M
                        }), d.stopPropagation(), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "")
                    }, {priority: "low"}), this.listenTo(i, "dragend", (l, d) => {
                        this._finalizeDragging(!d.dataTransfer.isCanceled && d.dataTransfer.dropEffect == "move")
                    }, {priority: "low"}), this._domEmitter.listenTo(bt.document, "dragend", () => {
                        this._blockMode = !1
                    }, {useCapture: !0}), this.listenTo(i, "dragenter", () => {
                        this.isEnabled && n.focus()
                    }), this.listenTo(i, "dragleave", () => {
                        s.removeDropMarkerDelayed()
                    }), this.listenTo(i, "dragging", (l, d) => {
                        if (!this.isEnabled) return void (d.dataTransfer.dropEffect = "none");
                        const {clientX: g, clientY: v} = d.domEvent;
                        s.updateDropMarker(d.target, d.targetRanges, g, v, this._blockMode, this._draggedRange), this._draggedRange || (d.dataTransfer.dropEffect = "copy"), T.isGecko || (d.dataTransfer.effectAllowed == "copy" ? d.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(d.dataTransfer.effectAllowed) && (d.dataTransfer.dropEffect = "move")), l.stop()
                    }, {priority: "low"})
                }

                _setupClipboardInputIntegration() {
                    const e = this.editor, t = e.editing.view.document, n = e.plugins.get(Zg);
                    this.listenTo(t, "clipboardInput", (i, s) => {
                        if (s.method != "drop") return;
                        const {clientX: l, clientY: d} = s.domEvent,
                            g = n.getFinalDropRange(s.target, s.targetRanges, l, d, this._blockMode, this._draggedRange);
                        if (!g) return this._finalizeDragging(!1), void i.stop();
                        if (this._draggedRange && this._draggingUid != s.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), qC(s.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(g, !0)) return this._finalizeDragging(!1), void i.stop();
                        s.targetRanges = [e.editing.mapper.toViewRange(g)]
                    }, {priority: "high"})
                }

                _setupContentInsertionIntegration() {
                    const e = this.editor.plugins.get(es);
                    e.on("contentInsertion", (t, n) => {
                        if (!this.isEnabled || n.method !== "drop") return;
                        const i = n.targetRanges.map(s => this.editor.editing.mapper.toModelRange(s));
                        this.editor.model.change(s => s.setSelection(i))
                    }, {priority: "high"}), e.on("contentInsertion", (t, n) => {
                        if (!this.isEnabled || n.method !== "drop") return;
                        const i = qC(n.dataTransfer) == "move", s = !n.resultRange || !n.resultRange.isCollapsed;
                        this._finalizeDragging(s && i)
                    }, {priority: "lowest"})
                }

                _setupDraggableAttributeHandling() {
                    const e = this.editor, t = e.editing.view, n = t.document;
                    this.listenTo(n, "mousedown", (i, s) => {
                        if (T.isAndroid || !s) return;
                        this._clearDraggableAttributesDelayed.cancel();
                        let l = WC(s.target);
                        if (T.isBlink && !e.isReadOnly && !l && !n.selection.isCollapsed) {
                            const d = n.selection.getSelectedElement();
                            d && wr(d) || (l = n.selection.editableElement)
                        }
                        l && (t.change(d => {
                            d.setAttribute("draggable", "true", l)
                        }), this._draggableElement = e.editing.mapper.toModelElement(l))
                    }), this.listenTo(n, "mouseup", () => {
                        T.isAndroid || this._clearDraggableAttributesDelayed()
                    })
                }

                _clearDraggableAttributes() {
                    const e = this.editor.editing;
                    e.view.change(t => {
                        this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)), this._draggableElement = null
                    })
                }

                _finalizeDragging(e) {
                    const t = this.editor, n = t.model;
                    t.plugins.get(Zg).removeDropMarker(), this._clearDraggableAttributes(), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._previewContainer && (this._previewContainer.remove(), this._previewContainer = void 0), this._draggedRange && (e && this.isEnabled && n.change(i => {
                        const s = n.createSelection(this._draggedRange);
                        n.deleteContent(s, {doNotAutoparagraph: !0});
                        const l = s.getFirstPosition().parent;
                        l.isEmpty && !n.schema.checkChild(l, "$text") && n.schema.checkChild(l, "paragraph") && i.insertElement("paragraph", l, 0)
                    }), this._draggedRange.detach(), this._draggedRange = null)
                }

                _prepareDraggedRange(e) {
                    const t = this.editor, n = t.model, i = n.document.selection, s = e ? WC(e) : null;
                    if (s) {
                        const v = t.editing.mapper.toModelElement(s);
                        this._draggedRange = Ii.fromRange(n.createRangeOn(v)), this._blockMode = n.schema.isBlock(v), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
                        return
                    }
                    if (i.isCollapsed && !i.getFirstPosition().parent.isEmpty) return;
                    const l = Array.from(i.getSelectedBlocks()), d = i.getFirstRange();
                    if (l.length == 0) return void (this._draggedRange = Ii.fromRange(d));
                    const g = $C(n, l);
                    if (l.length > 1) this._draggedRange = Ii.fromRange(g), this._blockMode = !0; else if (l.length == 1) {
                        const v = d.start.isTouching(g.start) && d.end.isTouching(g.end);
                        this._draggedRange = Ii.fromRange(v ? g : d), this._blockMode = v
                    }
                    n.change(v => v.setSelection(this._draggedRange.toRange()))
                }

                _updatePreview({dataTransfer: e, domTarget: t, clientX: n}) {
                    const i = this.editor.editing.view, s = i.document.selection.editableElement,
                        l = i.domConverter.mapViewToDom(s), d = bt.window.getComputedStyle(l);
                    this._previewContainer ? this._previewContainer.firstElementChild && this._previewContainer.removeChild(this._previewContainer.firstElementChild) : (this._previewContainer = Ir(bt.document, "div", {style: "position: fixed; left: -999999px;"}), bt.document.body.appendChild(this._previewContainer));
                    const g = new Lt(l);
                    if (l.contains(t)) return;
                    const v = parseFloat(d.paddingLeft), _ = Ir(bt.document, "div");
                    _.className = "ck ck-content", _.style.width = d.width, _.style.paddingLeft = `${g.left - n + v}px`, T.isiOS && (_.style.backgroundColor = "white"), _.innerHTML = e.getData("text/html"), e.setDragImage(_, 0, 0), this._previewContainer.appendChild(_)
                }
            }

            function qC(r) {
                return T.isGecko ? r.dropEffect : ["all", "copyMove"].includes(r.effectAllowed) ? "move" : "copy"
            }

            function WC(r) {
                if (r.is("editableElement")) return null;
                if (r.hasClass("ck-widget__selection-handle")) return r.findAncestor(wr);
                if (wr(r)) return r;
                const e = r.findAncestor(t => wr(t) || t.is("editableElement"));
                return wr(e) ? e : null
            }

            function $C(r, e) {
                const t = e[0], n = e[e.length - 1], i = t.getCommonAncestor(n), s = r.createPositionBefore(t),
                    l = r.createPositionAfter(n);
                if (i && i.is("element") && !r.schema.isLimit(i)) {
                    const d = r.createRangeOn(i), g = s.isTouching(d.start), v = l.isTouching(d.end);
                    if (g && v) return $C(r, [i])
                }
                return r.createRange(s, l)
            }

            class KI extends Re {
                static get pluginName() {
                    return "PastePlainText"
                }

                static get requires() {
                    return [es]
                }

                init() {
                    const e = this.editor, t = e.model, n = e.editing.view, i = n.document, s = t.document.selection;
                    let l = !1;
                    n.addObserver(hh), this.listenTo(i, "keydown", (d, g) => {
                        l = g.shiftKey
                    }), e.plugins.get(es).on("contentInsertion", (d, g) => {
                        (l || function (v, _) {
                            if (v.childCount > 1) return !1;
                            const x = v.getChild(0);
                            return _.isObject(x) ? !1 : Array.from(x.getAttributeKeys()).length == 0
                        }(g.content, t.schema)) && t.change(v => {
                            const _ = Array.from(s.getAttributes()).filter(([M]) => t.schema.getAttributeProperties(M).isFormatting);
                            s.isCollapsed || t.deleteContent(s, {doNotAutoparagraph: !0}), _.push(...s.getAttributes());
                            const x = v.createRangeIn(g.content);
                            for (const M of x.getItems()) M.is("$textProxy") && v.setAttributes(_, M)
                        })
                    })
                }
            }

            class GC extends Re {
                static get pluginName() {
                    return "Clipboard"
                }

                static get requires() {
                    return [es, GI, KI]
                }
            }

            class ZI extends Ft {
                constructor(e) {
                    super(e), this.affectsData = !1
                }

                execute() {
                    const e = this.editor.model, t = e.document.selection;
                    let n = e.schema.getLimitElement(t);
                    if (t.containsEntireContent(n) || !KC(e.schema, n)) do if (n = n.parent, !n) return; while (!KC(e.schema, n));
                    e.change(i => {
                        i.setSelection(n, "in")
                    })
                }
            }

            function KC(r, e) {
                return r.isLimit(e) && (r.checkChild(e, "$text") || r.checkChild(e, "paragraph"))
            }

            const YI = Di("Ctrl+A");

            class QI extends Re {
                static get pluginName() {
                    return "SelectAllEditing"
                }

                init() {
                    const e = this.editor, t = e.editing.view.document;
                    e.commands.add("selectAll", new ZI(e)), this.listenTo(t, "keydown", (n, i) => {
                        Ui(i) === YI && (e.execute("selectAll"), i.preventDefault())
                    })
                }
            }

            class JI extends Re {
                static get pluginName() {
                    return "SelectAllUI"
                }

                init() {
                    const e = this.editor;
                    e.ui.componentFactory.add("selectAll", t => {
                        const n = e.commands.get("selectAll"), i = new sn(t), s = t.t;
                        return i.set({
                            label: s("Select all"),
                            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
                            keystroke: "Ctrl+A",
                            tooltip: !0
                        }), i.bind("isEnabled").to(n, "isEnabled"), this.listenTo(i, "execute", () => {
                            e.execute("selectAll"), e.editing.view.focus()
                        }), i
                    })
                }
            }

            class XI extends Re {
                static get requires() {
                    return [QI, JI]
                }

                static get pluginName() {
                    return "SelectAll"
                }
            }

            var eM = Object.defineProperty, ZC = Object.getOwnPropertySymbols, tM = Object.prototype.hasOwnProperty,
                nM = Object.prototype.propertyIsEnumerable, YC = (r, e, t) => e in r ? eM(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            class QC extends Ft {
                constructor(e) {
                    super(e), this._stack = [], this._createdBatches = new WeakSet, this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(e.data, "set", (t, n) => {
                        n[1] = ((s, l) => {
                            for (var d in l || (l = {})) tM.call(l, d) && YC(s, d, l[d]);
                            if (ZC) for (var d of ZC(l)) nM.call(l, d) && YC(s, d, l[d]);
                            return s
                        })({}, n[1]);
                        const i = n[1];
                        i.batchType || (i.batchType = {isUndoable: !1})
                    }, {priority: "high"}), this.listenTo(e.data, "set", (t, n) => {
                        n[1].batchType.isUndoable || this.clearStack()
                    })
                }

                refresh() {
                    this.isEnabled = this._stack.length > 0
                }

                get createdBatches() {
                    return this._createdBatches
                }

                addBatch(e) {
                    const t = this.editor.model.document.selection,
                        n = {ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [], isBackward: t.isBackward};
                    this._stack.push({batch: e, selection: n}), this.refresh()
                }

                clearStack() {
                    this._stack = [], this.refresh()
                }

                _restoreSelection(e, t, n) {
                    const i = this.editor.model, s = i.document, l = [],
                        d = e.map(v => v.getTransformedByOperations(n)), g = d.flat();
                    for (const v of d) {
                        const _ = v.filter(x => x.root != s.graveyard).filter(x => !iM(x, g));
                        _.length && (rM(_), l.push(_[0]))
                    }
                    l.length && i.change(v => {
                        v.setSelection(l, {backward: t})
                    })
                }

                _undo(e, t) {
                    const n = this.editor.model, i = n.document;
                    this._createdBatches.add(t);
                    const s = e.operations.slice().filter(l => l.isDocumentOperation);
                    s.reverse();
                    for (const l of s) {
                        const d = l.baseVersion + 1, g = Array.from(i.history.getOperations(d)),
                            v = XS([l.getReversed()], g, {
                                useRelations: !0,
                                document: this.editor.model.document,
                                padWithNoOps: !1,
                                forceWeakRemove: !0
                            }).operationsA;
                        for (let _ of v) {
                            const x = _.affectedSelectable;
                            x && !n.canEditAt(x) && (_ = new hr(_.baseVersion)), t.addOperation(_), n.applyOperation(_), i.history.setOperationAsUndone(l, _)
                        }
                    }
                }
            }

            function rM(r) {
                r.sort((e, t) => e.start.isBefore(t.start) ? -1 : 1);
                for (let e = 1; e < r.length; e++) {
                    const t = r[e - 1].getJoined(r[e], !0);
                    t && (e--, r.splice(e, 2, t))
                }
            }

            function iM(r, e) {
                return e.some(t => t !== r && t.containsRange(r, !0))
            }

            class oM extends QC {
                execute(e = null) {
                    const t = e ? this._stack.findIndex(s => s.batch == e) : this._stack.length - 1,
                        n = this._stack.splice(t, 1)[0], i = this.editor.model.createBatch({isUndo: !0});
                    this.editor.model.enqueueChange(i, () => {
                        this._undo(n.batch, i);
                        const s = this.editor.model.document.history.getOperations(n.batch.baseVersion);
                        this._restoreSelection(n.selection.ranges, n.selection.isBackward, s)
                    }), this.fire("revert", n.batch, i), this.refresh()
                }
            }

            class sM extends QC {
                execute() {
                    const e = this._stack.pop(), t = this.editor.model.createBatch({isUndo: !0});
                    this.editor.model.enqueueChange(t, () => {
                        const n = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1,
                            i = this.editor.model.document.history.getOperations(n);
                        this._restoreSelection(e.selection.ranges, e.selection.isBackward, i), this._undo(e.batch, t)
                    }), this.refresh()
                }
            }

            class aM extends Re {
                constructor() {
                    super(...arguments), this._batchRegistry = new WeakSet
                }

                static get pluginName() {
                    return "UndoEditing"
                }

                init() {
                    const e = this.editor;
                    this._undoCommand = new oM(e), this._redoCommand = new sM(e), e.commands.add("undo", this._undoCommand), e.commands.add("redo", this._redoCommand), this.listenTo(e.model, "applyOperation", (t, n) => {
                        const i = n[0];
                        if (!i.isDocumentOperation) return;
                        const s = i.batch, l = this._redoCommand.createdBatches.has(s),
                            d = this._undoCommand.createdBatches.has(s);
                        this._batchRegistry.has(s) || (this._batchRegistry.add(s), s.isUndoable && (l ? this._undoCommand.addBatch(s) : d || (this._undoCommand.addBatch(s), this._redoCommand.clearStack())))
                    }, {priority: "highest"}), this.listenTo(this._undoCommand, "revert", (t, n, i) => {
                        this._redoCommand.addBatch(i)
                    }), e.keystrokes.set("CTRL+Z", "undo"), e.keystrokes.set("CTRL+Y", "redo"), e.keystrokes.set("CTRL+SHIFT+Z", "redo")
                }
            }

            const JC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
                XC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';

            class lM extends Re {
                static get pluginName() {
                    return "UndoUI"
                }

                init() {
                    const e = this.editor, t = e.locale, n = e.t, i = t.uiLanguageDirection == "ltr" ? JC : XC,
                        s = t.uiLanguageDirection == "ltr" ? XC : JC;
                    this._addButton("undo", n("Undo"), "CTRL+Z", i), this._addButton("redo", n("Redo"), "CTRL+Y", s)
                }

                _addButton(e, t, n, i) {
                    const s = this.editor;
                    s.ui.componentFactory.add(e, l => {
                        const d = s.commands.get(e), g = new sn(l);
                        return g.set({
                            label: t,
                            icon: i,
                            keystroke: n,
                            tooltip: !0
                        }), g.bind("isEnabled").to(d, "isEnabled"), this.listenTo(g, "execute", () => {
                            s.execute(e), s.editing.view.focus()
                        }), g
                    })
                }
            }

            class e_ extends Re {
                static get requires() {
                    return [aM, lM]
                }

                static get pluginName() {
                    return "Undo"
                }
            }

            class cM extends we() {
                constructor() {
                    super();
                    const e = new window.FileReader;
                    this._reader = e, this._data = void 0, this.set("loaded", 0), e.onprogress = t => {
                        this.loaded = t.loaded
                    }
                }

                get error() {
                    return this._reader.error
                }

                get data() {
                    return this._data
                }

                read(e) {
                    const t = this._reader;
                    return this.total = e.size, new Promise((n, i) => {
                        t.onload = () => {
                            const s = t.result;
                            this._data = s, n(s)
                        }, t.onerror = () => {
                            i("error")
                        }, t.onabort = () => {
                            i("aborted")
                        }, this._reader.readAsDataURL(e)
                    })
                }

                abort() {
                    this._reader.abort()
                }
            }

            class _o extends Re {
                constructor() {
                    super(...arguments), this.loaders = new br, this._loadersMap = new Map, this._pendingAction = null
                }

                static get pluginName() {
                    return "FileRepository"
                }

                static get requires() {
                    return [$w]
                }

                init() {
                    this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e, t) => t ? e / t * 100 : 0)
                }

                getLoader(e) {
                    return this._loadersMap.get(e) || null
                }

                createLoader(e) {
                    if (!this.createUploadAdapter) return ae("filerepository-no-upload-adapter"), null;
                    const t = new t_(Promise.resolve(e), this.createUploadAdapter);
                    return this.loaders.add(t), this._loadersMap.set(e, t), e instanceof Promise && t.file.then(n => {
                        this._loadersMap.set(n, t)
                    }).catch(() => {
                    }), t.on("change:uploaded", () => {
                        let n = 0;
                        for (const i of this.loaders) n += i.uploaded;
                        this.uploaded = n
                    }), t.on("change:uploadTotal", () => {
                        let n = 0;
                        for (const i of this.loaders) i.uploadTotal && (n += i.uploadTotal);
                        this.uploadTotal = n
                    }), t
                }

                destroyLoader(e) {
                    const t = e instanceof t_ ? e : this.getLoader(e);
                    t._destroy(), this.loaders.remove(t), this._loadersMap.forEach((n, i) => {
                        n === t && this._loadersMap.delete(i)
                    })
                }

                _updatePendingAction() {
                    const e = this.editor.plugins.get($w);
                    if (this.loaders.length) {
                        if (!this._pendingAction) {
                            const t = this.editor.t, n = i => `${t("Upload in progress")} ${parseInt(i)}%.`;
                            this._pendingAction = e.add(n(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n)
                        }
                    } else e.remove(this._pendingAction), this._pendingAction = null
                }
            }

            class t_ extends we() {
                constructor(e, t) {
                    super(), this.id = Y(), this._filePromiseWrapper = this._createFilePromiseWrapper(e), this._adapter = t(this), this._reader = new cM, this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (n, i) => i ? n / i * 100 : 0), this.set("uploadResponse", null)
                }

                get file() {
                    return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then(e => this._filePromiseWrapper ? e : null) : Promise.resolve(null)
                }

                get data() {
                    return this._reader.data
                }

                read() {
                    if (this.status != "idle") throw new R("filerepository-read-wrong-status", this);
                    return this.status = "reading", this.file.then(e => this._reader.read(e)).then(e => {
                        if (this.status !== "reading") throw this.status;
                        return this.status = "idle", e
                    }).catch(e => {
                        throw e === "aborted" ? (this.status = "aborted", "aborted") : (this.status = "error", this._reader.error ? this._reader.error : e)
                    })
                }

                upload() {
                    if (this.status != "idle") throw new R("filerepository-upload-wrong-status", this);
                    return this.status = "uploading", this.file.then(() => this._adapter.upload()).then(e => (this.uploadResponse = e, this.status = "idle", e)).catch(e => {
                        throw this.status === "aborted" ? "aborted" : (this.status = "error", e)
                    })
                }

                abort() {
                    const e = this.status;
                    this.status = "aborted", this._filePromiseWrapper.isFulfilled ? e == "reading" ? this._reader.abort() : e == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
                    }), this._filePromiseWrapper.rejecter("aborted")), this._destroy()
                }

                _destroy() {
                    this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0
                }

                _createFilePromiseWrapper(e) {
                    const t = {};
                    return t.promise = new Promise((n, i) => {
                        t.rejecter = i, t.isFulfilled = !1, e.then(s => {
                            t.isFulfilled = !0, n(s)
                        }).catch(s => {
                            t.isFulfilled = !0, i(s)
                        })
                    }), t
                }
            }

            class uM extends sn {
                constructor(e) {
                    super(e), this.buttonView = this, this._fileInputView = new dM(e), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.on("execute", () => {
                        this._fileInputView.open()
                    }), this.extendTemplate({attributes: {class: "ck-file-dialog-button"}})
                }

                render() {
                    super.render(), this.children.add(this._fileInputView)
                }
            }

            class dM extends It {
                constructor(e) {
                    super(e), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
                    const t = this.bindTemplate;
                    this.setTemplate({
                        tag: "input",
                        attributes: {
                            class: ["ck-hidden"],
                            type: "file",
                            tabindex: "-1",
                            accept: t.to("acceptedType"),
                            multiple: t.to("allowMultipleFiles")
                        },
                        on: {
                            change: t.to(() => {
                                this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = ""
                            })
                        }
                    })
                }

                open() {
                    this.element.click()
                }
            }

            const n_ = "ckCsrfToken", r_ = "abcdefghijklmnopqrstuvwxyz0123456789";

            function hM() {
                let r = function (n) {
                    n = n.toLowerCase();
                    const i = document.cookie.split(";");
                    for (const s of i) {
                        const l = s.split("=");
                        if (decodeURIComponent(l[0].trim().toLowerCase()) === n) return decodeURIComponent(l[1])
                    }
                    return null
                }(n_);
                var e, t;
                return r && r.length == 40 || (r = function (n) {
                    let i = "";
                    const s = new Uint8Array(n);
                    window.crypto.getRandomValues(s);
                    for (let l = 0; l < s.length; l++) {
                        const d = r_.charAt(s[l] % r_.length);
                        i += Math.random() > .5 ? d.toUpperCase() : d
                    }
                    return i
                }(40), e = n_, t = r, document.cookie = encodeURIComponent(e) + "=" + encodeURIComponent(t) + ";path=/"), r
            }

            class fM {
                constructor(e, t, n) {
                    this.loader = e, this.url = t, this.t = n
                }

                upload() {
                    return this.loader.file.then(e => new Promise((t, n) => {
                        this._initRequest(), this._initListeners(t, n, e), this._sendRequest(e)
                    }))
                }

                abort() {
                    this.xhr && this.xhr.abort()
                }

                _initRequest() {
                    const e = this.xhr = new XMLHttpRequest;
                    e.open("POST", this.url, !0), e.responseType = "json"
                }

                _initListeners(e, t, n) {
                    const i = this.xhr, s = this.loader, l = (0, this.t)("Cannot upload file:") + ` ${n.name}.`;
                    i.addEventListener("error", () => t(l)), i.addEventListener("abort", () => t()), i.addEventListener("load", () => {
                        const d = i.response;
                        if (!d || !d.uploaded) return t(d && d.error && d.error.message ? d.error.message : l);
                        e({default: d.url})
                    }), i.upload && i.upload.addEventListener("progress", d => {
                        d.lengthComputable && (s.uploadTotal = d.total, s.uploaded = d.loaded)
                    })
                }

                _sendRequest(e) {
                    const t = new FormData;
                    t.append("upload", e), t.append("ckCsrfToken", hM()), this.xhr.send(t)
                }
            }

            function Na(r, e, t, n) {
                let i, s = null;
                typeof n == "function" ? i = n : (s = r.commands.get(n), i = () => {
                    r.execute(n)
                }), r.model.document.on("change:data", (l, d) => {
                    if (s && !s.isEnabled || !e.isEnabled) return;
                    const g = Wn(r.model.document.selection.getRanges());
                    if (!g.isCollapsed || d.isUndo || !d.isLocal) return;
                    const v = Array.from(r.model.document.differ.getChanges()), _ = v[0];
                    if (v.length != 1 || _.type !== "insert" || _.name != "$text" || _.length != 1) return;
                    const x = _.position.parent;
                    if (x.is("element", "codeBlock") || x.is("element", "listItem") && typeof n != "function" && !["numberedList", "bulletedList", "todoList"].includes(n) || s && s.value === !0) return;
                    const M = x.getChild(0), O = r.model.createRangeOn(M);
                    if (!O.containsRange(g) && !g.end.isEqual(O.end)) return;
                    const j = t.exec(M.data.substr(0, g.end.offset));
                    j && r.model.enqueueChange(U => {
                        const K = U.createPositionAt(x, 0), ne = U.createPositionAt(x, j[0].length), pe = new Ii(K, ne);
                        if (i({match: j}) !== !1) {
                            U.remove(pe);
                            const Se = r.model.document.selection.getFirstRange(), Je = U.createRangeIn(x);
                            !x.isEmpty || Je.isEqual(Se) || Je.containsRange(Se, !0) || U.remove(x)
                        }
                        pe.detach(), r.model.enqueueChange(() => {
                            r.plugins.get("Delete").requestUndoOnBackspace()
                        })
                    })
                })
            }

            function Au(r, e, t, n) {
                let i, s;
                t instanceof RegExp ? i = t : s = t, s = s || (l => {
                    let d;
                    const g = [], v = [];
                    for (; (d = i.exec(l)) !== null && !(d && d.length < 4);) {
                        let {index: _, 1: x, 2: M, 3: O} = d;
                        const j = x + M + O;
                        _ += d[0].length - j.length;
                        const U = [_, _ + x.length], K = [_ + x.length + M.length, _ + x.length + M.length + O.length];
                        g.push(U), g.push(K), v.push([_ + x.length, _ + x.length + M.length])
                    }
                    return {remove: g, format: v}
                }), r.model.document.on("change:data", (l, d) => {
                    if (d.isUndo || !d.isLocal || !e.isEnabled) return;
                    const g = r.model, v = g.document.selection;
                    if (!v.isCollapsed) return;
                    const _ = Array.from(g.document.differ.getChanges()), x = _[0];
                    if (_.length != 1 || x.type !== "insert" || x.name != "$text" || x.length != 1) return;
                    const M = v.focus, O = M.parent, {text: j, range: U} = function (Se, Je) {
                            let wt = Se.start;
                            return {
                                text: Array.from(Se.getItems()).reduce((Zt, Jn) => !Jn.is("$text") && !Jn.is("$textProxy") || Jn.getAttribute("code") ? (wt = Je.createPositionAfter(Jn), "") : Zt + Jn.data, ""),
                                range: Je.createRange(wt, Se.end)
                            }
                        }(g.createRange(g.createPositionAt(O, 0), M), g), K = s(j), ne = i_(U.start, K.format, g),
                        pe = i_(U.start, K.remove, g);
                    ne.length && pe.length && g.enqueueChange(Se => {
                        if (n(Se, ne) !== !1) {
                            for (const Je of pe.reverse()) Se.remove(Je);
                            g.enqueueChange(() => {
                                r.plugins.get("Delete").requestUndoOnBackspace()
                            })
                        }
                    })
                })
            }

            function i_(r, e, t) {
                return e.filter(n => n[0] !== void 0 && n[1] !== void 0).map(n => t.createRange(r.getShiftedBy(n[0]), r.getShiftedBy(n[1])))
            }

            function Qg(r, e) {
                return (t, n) => {
                    if (!r.commands.get(e).isEnabled) return !1;
                    const i = r.model.schema.getValidRanges(n, e);
                    for (const s of i) t.setAttribute(e, !0, s);
                    t.removeSelectionAttribute(e)
                }
            }

            class o_ extends Ft {
                constructor(e, t) {
                    super(e), this.attributeKey = t
                }

                refresh() {
                    const e = this.editor.model, t = e.document;
                    this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey)
                }

                execute(e = {}) {
                    const t = this.editor.model, n = t.document.selection,
                        i = e.forceValue === void 0 ? !this.value : e.forceValue;
                    t.change(s => {
                        if (n.isCollapsed) i ? s.setSelectionAttribute(this.attributeKey, !0) : s.removeSelectionAttribute(this.attributeKey); else {
                            const l = t.schema.getValidRanges(n.getRanges(), this.attributeKey);
                            for (const d of l) i ? s.setAttribute(this.attributeKey, i, d) : s.removeAttribute(this.attributeKey, d)
                        }
                    })
                }

                _getValueFromFirstAllowedNode() {
                    const e = this.editor.model, t = e.schema, n = e.document.selection;
                    if (n.isCollapsed) return n.hasAttribute(this.attributeKey);
                    for (const i of n.getRanges()) for (const s of i.getItems()) if (t.checkAttribute(s, this.attributeKey)) return s.hasAttribute(this.attributeKey);
                    return !1
                }
            }

            const Cu = "bold";

            class gM extends Re {
                static get pluginName() {
                    return "BoldEditing"
                }

                init() {
                    const e = this.editor;
                    e.model.schema.extend("$text", {allowAttributes: Cu}), e.model.schema.setAttributeProperties(Cu, {
                        isFormatting: !0,
                        copyOnEnter: !0
                    }), e.conversion.attributeToElement({
                        model: Cu, view: "strong", upcastAlso: ["b", t => {
                            const n = t.getStyle("font-weight");
                            return n && (n == "bold" || Number(n) >= 600) ? {name: !0, styles: ["font-weight"]} : null
                        }]
                    }), e.commands.add(Cu, new o_(e, Cu)), e.keystrokes.set("CTRL+B", Cu)
                }
            }

            const jb = "bold";

            class pM extends Re {
                static get pluginName() {
                    return "BoldUI"
                }

                init() {
                    const e = this.editor, t = e.t;
                    e.ui.componentFactory.add(jb, n => {
                        const i = e.commands.get(jb), s = new sn(n);
                        return s.set({
                            label: t("Bold"),
                            icon: mn.bold,
                            keystroke: "CTRL+B",
                            tooltip: !0,
                            isToggleable: !0
                        }), s.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(s, "execute", () => {
                            e.execute(jb), e.editing.view.focus()
                        }), s
                    })
                }
            }

            var s_ = C(8603),
                mM = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(s_.Z, mM), s_.Z.locals;
            const _u = "italic";

            class bM extends Re {
                static get pluginName() {
                    return "ItalicEditing"
                }

                init() {
                    const e = this.editor;
                    e.model.schema.extend("$text", {allowAttributes: _u}), e.model.schema.setAttributeProperties(_u, {
                        isFormatting: !0,
                        copyOnEnter: !0
                    }), e.conversion.attributeToElement({
                        model: _u,
                        view: "i",
                        upcastAlso: ["em", {styles: {"font-style": "italic"}}]
                    }), e.commands.add(_u, new o_(e, _u)), e.keystrokes.set("CTRL+I", _u)
                }
            }

            const Vb = "italic";

            class kM extends Re {
                static get pluginName() {
                    return "ItalicUI"
                }

                init() {
                    const e = this.editor, t = e.t;
                    e.ui.componentFactory.add(Vb, n => {
                        const i = e.commands.get(Vb), s = new sn(n);
                        return s.set({
                            label: t("Italic"),
                            icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
                            keystroke: "CTRL+I",
                            tooltip: !0,
                            isToggleable: !0
                        }), s.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(s, "execute", () => {
                            e.execute(Vb), e.editing.view.focus()
                        }), s
                    })
                }
            }

            class vM extends Ft {
                refresh() {
                    this.value = this._getValue(), this.isEnabled = this._checkEnabled()
                }

                execute(e = {}) {
                    const t = this.editor.model, n = t.schema, i = t.document.selection,
                        s = Array.from(i.getSelectedBlocks()), l = e.forceValue === void 0 ? !this.value : e.forceValue;
                    t.change(d => {
                        if (l) {
                            const g = s.filter(v => Jg(v) || l_(n, v));
                            this._applyQuote(d, g)
                        } else this._removeQuote(d, s.filter(Jg))
                    })
                }

                _getValue() {
                    const e = Wn(this.editor.model.document.selection.getSelectedBlocks());
                    return !(!e || !Jg(e))
                }

                _checkEnabled() {
                    if (this.value) return !0;
                    const e = this.editor.model.document.selection, t = this.editor.model.schema,
                        n = Wn(e.getSelectedBlocks());
                    return !!n && l_(t, n)
                }

                _removeQuote(e, t) {
                    a_(e, t).reverse().forEach(n => {
                        if (n.start.isAtStart && n.end.isAtEnd) return void e.unwrap(n.start.parent);
                        if (n.start.isAtStart) {
                            const s = e.createPositionBefore(n.start.parent);
                            return void e.move(n, s)
                        }
                        n.end.isAtEnd || e.split(n.end);
                        const i = e.createPositionAfter(n.end.parent);
                        e.move(n, i)
                    })
                }

                _applyQuote(e, t) {
                    const n = [];
                    a_(e, t).reverse().forEach(i => {
                        let s = Jg(i.start);
                        s || (s = e.createElement("blockQuote"), e.wrap(i, s)), n.push(s)
                    }), n.reverse().reduce((i, s) => i.nextSibling == s ? (e.merge(e.createPositionAfter(i)), i) : s)
                }
            }

            function Jg(r) {
                return r.parent.name == "blockQuote" ? r.parent : null
            }

            function a_(r, e) {
                let t, n = 0;
                const i = [];
                for (; n < e.length;) {
                    const s = e[n], l = e[n + 1];
                    t || (t = r.createPositionBefore(s)), l && s.nextSibling == l || (i.push(r.createRange(t, r.createPositionAfter(s))), t = null), n++
                }
                return i
            }

            function l_(r, e) {
                const t = r.checkChild(e.parent, "blockQuote"), n = r.checkChild(["$root", "blockQuote"], e);
                return t && n
            }

            class wM extends Re {
                static get pluginName() {
                    return "BlockQuoteEditing"
                }

                static get requires() {
                    return [$g, Ls]
                }

                init() {
                    const e = this.editor, t = e.model.schema;
                    e.commands.add("blockQuote", new vM(e)), t.register("blockQuote", {inheritAllFrom: "$container"}), e.conversion.elementToElement({
                        model: "blockQuote",
                        view: "blockquote"
                    }), e.model.document.registerPostFixer(l => {
                        const d = e.model.document.differ.getChanges();
                        for (const g of d) if (g.type == "insert") {
                            const v = g.position.nodeAfter;
                            if (!v) continue;
                            if (v.is("element", "blockQuote") && v.isEmpty) return l.remove(v), !0;
                            if (v.is("element", "blockQuote") && !t.checkChild(g.position, v)) return l.unwrap(v), !0;
                            if (v.is("element")) {
                                const _ = l.createRangeIn(v);
                                for (const x of _.getItems()) if (x.is("element", "blockQuote") && !t.checkChild(l.createPositionBefore(x), x)) return l.unwrap(x), !0
                            }
                        } else if (g.type == "remove") {
                            const v = g.position.parent;
                            if (v.is("element", "blockQuote") && v.isEmpty) return l.remove(v), !0
                        }
                        return !1
                    });
                    const n = this.editor.editing.view.document, i = e.model.document.selection,
                        s = e.commands.get("blockQuote");
                    this.listenTo(n, "enter", (l, d) => {
                        !i.isCollapsed || !s.value || i.getLastPosition().parent.isEmpty && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), d.preventDefault(), l.stop())
                    }, {context: "blockquote"}), this.listenTo(n, "delete", (l, d) => {
                        if (d.direction != "backward" || !i.isCollapsed || !s.value) return;
                        const g = i.getLastPosition().parent;
                        g.isEmpty && !g.previousSibling && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), d.preventDefault(), l.stop())
                    }, {context: "blockquote"})
                }
            }

            var c_ = C(3062),
                AM = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(c_.Z, AM), c_.Z.locals;

            class CM extends Re {
                static get pluginName() {
                    return "BlockQuoteUI"
                }

                init() {
                    const e = this.editor, t = e.t;
                    e.ui.componentFactory.add("blockQuote", n => {
                        const i = e.commands.get("blockQuote"), s = new sn(n);
                        return s.set({
                            label: t("Block quote"),
                            icon: mn.quote,
                            tooltip: !0,
                            isToggleable: !0
                        }), s.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), this.listenTo(s, "execute", () => {
                            e.execute("blockQuote"), e.editing.view.focus()
                        }), s
                    })
                }
            }

            class _M extends Re {
                static get pluginName() {
                    return "CKBoxUI"
                }

                afterInit() {
                    const e = this.editor, t = e.commands.get("ckbox");
                    if (!t) return;
                    const n = e.t;
                    if (e.ui.componentFactory.add("ckbox", i => {
                        const s = new sn(i);
                        return s.set({
                            label: n("Open file manager"),
                            icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>',
                            tooltip: !0
                        }), s.bind("isOn", "isEnabled").to(t, "value", "isEnabled"), s.on("execute", () => {
                            e.execute("ckbox")
                        }), s
                    }), e.plugins.has("ImageInsertUI")) {
                        const i = e.plugins.get("ImageInsertUI");
                        i.registerIntegration({
                            name: "assetManager", observable: t, buttonViewCreator: () => {
                                const s = this.editor.ui.componentFactory.create("ckbox");
                                return s.icon = mn.imageAssetManager, s.bind("label").to(i, "isImageSelected", l => n(l ? "Replace image with file manager" : "Insert image with file manager")), s
                            }, formViewCreator: () => {
                                const s = this.editor.ui.componentFactory.create("ckbox");
                                return s.icon = mn.imageAssetManager, s.withText = !0, s.bind("label").to(i, "isImageSelected", l => n(l ? "Replace with file manager" : "Insert with file manager")), s.on("execute", () => {
                                    i.dropdownView.isOpen = !1
                                }), s
                            }
                        })
                    }
                }
            }

            var yM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "#", "$", "%", "*", "+", ",", "-", ".", ":", ";", "=", "?", "@", "[", "]", "^", "_", "{", "|", "}", "~"],
                bh = r => {
                    let e = 0;
                    for (let t = 0; t < r.length; t++) {
                        let n = r[t];
                        e = 83 * e + yM.indexOf(n)
                    }
                    return e
                }, Hb = r => {
                    let e = r / 255;
                    return e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
                }, Ub = r => {
                    let e = Math.max(0, Math.min(1, r));
                    return e <= .0031308 ? Math.trunc(12.92 * e * 255 + .5) : Math.trunc(255 * (1.055 * Math.pow(e, .4166666666666667) - .055) + .5)
                }, qb = (r, e) => (t => t < 0 ? -1 : 1)(r) * Math.pow(Math.abs(r), e), u_ = class extends Error {
                    constructor(r) {
                        super(r), this.name = "ValidationError", this.message = r
                    }
                }, DM = r => {
                    if (!r || r.length < 6) throw new u_("The blurhash string must be at least 6 characters");
                    let e = bh(r[0]), t = Math.floor(e / 9) + 1, n = e % 9 + 1;
                    if (r.length !== 4 + 2 * n * t) throw new u_(`blurhash length mismatch: length is ${r.length} but it should be ${4 + 2 * n * t}`)
                }, xM = r => {
                    let e = r >> 8 & 255, t = 255 & r;
                    return [Hb(r >> 16), Hb(e), Hb(t)]
                }, EM = (r, e) => {
                    let t = Math.floor(r / 361), n = Math.floor(r / 19) % 19, i = r % 19;
                    return [qb((t - 9) / 9, 2) * e, qb((n - 9) / 9, 2) * e, qb((i - 9) / 9, 2) * e]
                }, SM = (r, e, t, n) => {
                    DM(r), n |= 1;
                    let i = bh(r[0]), s = Math.floor(i / 9) + 1, l = i % 9 + 1, d = (bh(r[1]) + 1) / 166,
                        g = new Array(l * s);
                    for (let x = 0; x < g.length; x++) if (x === 0) {
                        let M = bh(r.substring(2, 6));
                        g[x] = xM(M)
                    } else {
                        let M = bh(r.substring(4 + 2 * x, 6 + 2 * x));
                        g[x] = EM(M, d * n)
                    }
                    let v = 4 * e, _ = new Uint8ClampedArray(v * t);
                    for (let x = 0; x < t; x++) for (let M = 0; M < e; M++) {
                        let O = 0, j = 0, U = 0;
                        for (let Se = 0; Se < s; Se++) for (let Je = 0; Je < l; Je++) {
                            let wt = Math.cos(Math.PI * M * Je / e) * Math.cos(Math.PI * x * Se / t), qt = g[Je + Se * l];
                            O += qt[0] * wt, j += qt[1] * wt, U += qt[2] * wt
                        }
                        let K = Ub(O), ne = Ub(j), pe = Ub(U);
                        _[4 * M + 0 + x * v] = K, _[4 * M + 1 + x * v] = ne, _[4 * M + 2 + x * v] = pe, _[4 * M + 3 + x * v] = 255
                    }
                    return _
                }, TM = Object.defineProperty, d_ = Object.getOwnPropertySymbols, IM = Object.prototype.hasOwnProperty,
                MM = Object.prototype.propertyIsEnumerable, h_ = (r, e, t) => e in r ? TM(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            function f_(r) {
                const e = [];
                let t = 0;
                for (const i in r) {
                    const s = parseInt(i, 10);
                    isNaN(s) || (s > t && (t = s), e.push(`${r[i]} ${i}w`))
                }
                const n = [{srcset: e.join(","), sizes: `(max-width: ${t}px) 100vw, ${t}px`, type: "image/webp"}];
                return {imageFallbackUrl: r.default, imageSources: n}
            }

            const kh = 32;

            function g_({url: r, method: e = "GET", data: t, onUploadProgress: n, signal: i, authorization: s}) {
                const l = new XMLHttpRequest;
                l.open(e, r.toString()), l.setRequestHeader("Authorization", s), l.setRequestHeader("CKBox-Version", "CKEditor 5"), l.responseType = "json";
                const d = () => {
                    l.abort()
                };
                return new Promise((g, v) => {
                    i.throwIfAborted(), i.addEventListener("abort", d), l.addEventListener("loadstart", () => {
                        i.addEventListener("abort", d)
                    }), l.addEventListener("loadend", () => {
                        i.removeEventListener("abort", d)
                    }), l.addEventListener("error", () => {
                        v()
                    }), l.addEventListener("abort", () => {
                        v()
                    }), l.addEventListener("load", () => {
                        const _ = l.response;
                        if (!_ || _.statusCode >= 400) return v(_ && _.message);
                        g(_)
                    }), n && l.upload.addEventListener("progress", _ => {
                        n(_)
                    }), l.send(t)
                })
            }

            const BM = {
                "image/gif": "gif",
                "image/jpeg": "jpg",
                "image/png": "png",
                "image/webp": "webp",
                "image/bmp": "bmp",
                "image/tiff": "tiff"
            };

            function NM(r, e) {
                return t = this, n = null, i = function* () {
                    try {
                        const s = yield fetch(r, ((l, d) => {
                            for (var g in d || (d = {})) IM.call(d, g) && h_(l, g, d[g]);
                            if (d_) for (var g of d_(d)) MM.call(d, g) && h_(l, g, d[g]);
                            return l
                        })({method: "HEAD", cache: "force-cache"}, e));
                        return s.ok && s.headers.get("content-type") || ""
                    } catch {
                        return ""
                    }
                }, new Promise((s, l) => {
                    var d = _ => {
                        try {
                            v(i.next(_))
                        } catch (x) {
                            l(x)
                        }
                    }, g = _ => {
                        try {
                            v(i.throw(_))
                        } catch (x) {
                            l(x)
                        }
                    }, v = _ => _.done ? s(_.value) : Promise.resolve(_.value).then(d, g);
                    v((i = i.apply(t, n)).next())
                });
                var t, n, i
            }

            var LM = Object.defineProperty, p_ = Object.getOwnPropertySymbols, PM = Object.prototype.hasOwnProperty,
                OM = Object.prototype.propertyIsEnumerable, m_ = (r, e, t) => e in r ? LM(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, b_ = (r, e) => {
                    for (var t in e || (e = {})) PM.call(e, t) && m_(r, t, e[t]);
                    if (p_) for (var t of p_(e)) OM.call(e, t) && m_(r, t, e[t]);
                    return r
                };

            class FM extends Ft {
                constructor(e) {
                    super(e), this._chosenAssets = new Set, this._wrapper = null, this._initListeners()
                }

                refresh() {
                    this.value = this._getValue(), this.isEnabled = this._checkEnabled()
                }

                execute() {
                    this.fire("ckbox:open")
                }

                _getValue() {
                    return this._wrapper !== null
                }

                _checkEnabled() {
                    const e = this.editor.commands.get("insertImage"), t = this.editor.commands.get("link");
                    return !(!e.isEnabled && !t.isEnabled)
                }

                _prepareOptions() {
                    const e = this.editor.config.get("ckbox");
                    return {
                        theme: e.theme,
                        language: e.language,
                        tokenUrl: e.tokenUrl,
                        serviceOrigin: e.serviceOrigin,
                        forceDemoLabel: e.forceDemoLabel,
                        dialog: {onClose: () => this.fire("ckbox:close")},
                        assets: {onChoose: t => this.fire("ckbox:choose", t)}
                    }
                }

                _initListeners() {
                    const e = this.editor, t = e.model, n = !e.config.get("ckbox.ignoreDataId");
                    this.on("ckbox", () => {
                        this.refresh()
                    }, {priority: "low"}), this.on("ckbox:open", () => {
                        this.isEnabled && !this.value && (this._wrapper = Ir(document, "div", {class: "ck ckbox-wrapper"}), document.body.appendChild(this._wrapper), window.CKBox.mount(this._wrapper, this._prepareOptions()))
                    }), this.on("ckbox:close", () => {
                        this.value && (this._wrapper.remove(), this._wrapper = null, e.editing.view.focus())
                    }), this.on("ckbox:choose", (i, s) => {
                        if (!this.isEnabled) return;
                        const l = e.commands.get("insertImage"), d = e.commands.get("link"),
                            g = function ({assets: _, isImageAllowed: x, isLinkAllowed: M}) {
                                return _.map(O => function (j) {
                                    const U = j.data.metadata;
                                    return U ? U.width && U.height : !1
                                }(O) ? {id: O.data.id, type: "image", attributes: RM(O)} : {
                                    id: O.data.id,
                                    type: "link",
                                    attributes: zM(O)
                                }).filter(O => O.type === "image" ? x : M)
                            }({assets: s, isImageAllowed: l.isEnabled, isLinkAllowed: d.isEnabled}), v = g.length;
                        v !== 0 && (t.change(_ => {
                            for (const x of g) {
                                const M = x === g[v - 1], O = v === 1;
                                this._insertAsset(x, M, _, O), n && (setTimeout(() => this._chosenAssets.delete(x), 1e3), this._chosenAssets.add(x))
                            }
                        }), e.editing.view.focus())
                    }), this.listenTo(e, "destroy", () => {
                        this.fire("ckbox:close"), this._chosenAssets.clear()
                    })
                }

                _insertAsset(e, t, n, i) {
                    const s = this.editor.model.document.selection;
                    n.removeSelectionAttribute("linkHref"), e.type === "image" ? this._insertImage(e) : this._insertLink(e, n, i), t || n.setSelection(s.getLastPosition())
                }

                _insertImage(e) {
                    const t = this.editor, {
                        imageFallbackUrl: n,
                        imageSources: i,
                        imageTextAlternative: s,
                        imageWidth: l,
                        imageHeight: d,
                        imagePlaceholder: g
                    } = e.attributes;
                    t.execute("insertImage", {
                        source: b_({
                            src: n,
                            sources: i,
                            alt: s,
                            width: l,
                            height: d
                        }, g ? {placeholder: g} : null)
                    })
                }

                _insertLink(e, t, n) {
                    const i = this.editor, s = i.model, l = s.document.selection, {
                        linkName: d,
                        linkHref: g
                    } = e.attributes;
                    if (l.isCollapsed) {
                        const v = qi(l.getAttributes()), _ = t.createText(d, v);
                        if (!n) {
                            const M = l.getLastPosition(), O = M.parent;
                            O.name === "paragraph" && O.isEmpty || i.execute("insertParagraph", {position: M});
                            const j = s.insertContent(_);
                            return t.setSelection(j), void i.execute("link", g)
                        }
                        const x = s.insertContent(_);
                        t.setSelection(x)
                    }
                    i.execute("link", g)
                }
            }

            function RM(r) {
                const {imageFallbackUrl: e, imageSources: t} = f_(r.data.imageUrls), {
                    description: n,
                    width: i,
                    height: s,
                    blurHash: l
                } = r.data.metadata, d = function (g) {
                    if (g) try {
                        const v = `${kh}px`, _ = document.createElement("canvas");
                        _.setAttribute("width", v), _.setAttribute("height", v);
                        const x = _.getContext("2d");
                        if (!x) return;
                        const M = x.createImageData(kh, kh), O = SM(g, kh, kh);
                        return M.data.set(O), x.putImageData(M, 0, 0), _.toDataURL()
                    } catch {
                        return
                    }
                }(l);
                return b_({
                    imageFallbackUrl: e,
                    imageSources: t,
                    imageTextAlternative: n || "",
                    imageWidth: i,
                    imageHeight: s
                }, d ? {imagePlaceholder: d} : null)
            }

            function zM(r) {
                return {linkName: r.data.name, linkHref: jM(r)}
            }

            function jM(r) {
                const e = new URL(r.data.url);
                return e.searchParams.set("download", "true"), e.toString()
            }

            var Wb = (r, e, t) => new Promise((n, i) => {
                var s = g => {
                    try {
                        d(t.next(g))
                    } catch (v) {
                        i(v)
                    }
                }, l = g => {
                    try {
                        d(t.throw(g))
                    } catch (v) {
                        i(v)
                    }
                }, d = g => g.done ? n(g.value) : Promise.resolve(g.value).then(s, l);
                d((t = t.apply(r, e)).next())
            });

            class k_ extends Re {
                static get pluginName() {
                    return "CKBoxUtils"
                }

                static get requires() {
                    return ["CloudServices"]
                }

                init() {
                    return Wb(this, null, function* () {
                        const e = this.editor, t = !!e.config.get("ckbox"), n = !!window.CKBox;
                        if (!t && !n) return;
                        e.config.define("ckbox", {
                            serviceOrigin: "https://api.ckbox.io",
                            defaultUploadCategories: null,
                            ignoreDataId: !1,
                            language: e.locale.uiLanguage,
                            theme: "lark",
                            tokenUrl: e.config.get("cloudServices.tokenUrl")
                        });
                        const i = e.plugins.get("CloudServices"), s = e.config.get("cloudServices.tokenUrl"),
                            l = e.config.get("ckbox.tokenUrl");
                        if (!l) throw new R("ckbox-plugin-missing-token-url", this);
                        this._token = l == s ? i.token : yield i.registerTokenUrl(l)
                    })
                }

                getToken() {
                    return this._token
                }

                getWorkspaceId() {
                    const e = (0, this.editor.t)("Cannot access default workspace."),
                        t = this.editor.config.get("ckbox.defaultUploadWorkspaceId"), n = function (i, s) {
                            const [, l] = i.value.split("."), d = JSON.parse(atob(l)),
                                g = d.auth && d.auth.ckbox && d.auth.ckbox.workspaces || [d.aud];
                            return s ? (d.auth && d.auth.ckbox && d.auth.ckbox.role) == "superadmin" || g.includes(s) ? s : null : g[0]
                        }(this._token, t);
                    if (n == null) throw ue("ckbox-access-default-workspace-error"), e;
                    return n
                }

                getCategoryIdForFile(e, t) {
                    return Wb(this, null, function* () {
                        const n = (0, this.editor.t)("Cannot determine a category for the uploaded file."),
                            i = this.editor.config.get("ckbox.defaultUploadCategories"),
                            s = this._getAvailableCategories(t),
                            l = typeof e == "string" ? (d = yield NM(e, t), BM[d]) : function (_) {
                                const x = _.name, M = new RegExp("\\.(?<ext>[^.]+)$");
                                return x.match(M).groups.ext.toLowerCase()
                            }(e);
                        var d;
                        const g = yield s;
                        if (!g) throw n;
                        if (i) {
                            const _ = Object.keys(i).find(x => i[x].find(M => M.toLowerCase() == l));
                            if (_) {
                                const x = g.find(M => M.id === _ || M.name === _);
                                if (!x) throw n;
                                return x.id
                            }
                        }
                        const v = g.find(_ => _.extensions.find(x => x.toLowerCase() == l));
                        if (!v) throw n;
                        return v.id
                    })
                }

                _getAvailableCategories(e) {
                    return Wb(this, null, function* () {
                        const t = this.editor, n = this._token, {signal: i} = e,
                            s = t.config.get("ckbox.serviceOrigin"), l = this.getWorkspaceId();
                        try {
                            const g = [];
                            let v, _ = 0;
                            do {
                                const x = yield d(_);
                                g.push(...x.items), v = x.totalCount - (_ + 50), _ += 50
                            } while (v > 0);
                            return g
                        } catch {
                            return i.throwIfAborted(), void ue("ckbox-fetch-category-http-error")
                        }

                        function d(g) {
                            const v = new URL("categories", s);
                            return v.searchParams.set("limit", "50"), v.searchParams.set("offset", g.toString()), v.searchParams.set("workspaceId", l), g_({
                                url: v,
                                signal: i,
                                authorization: n.value
                            })
                        }
                    })
                }
            }

            var $b = (r, e, t) => new Promise((n, i) => {
                var s = g => {
                    try {
                        d(t.next(g))
                    } catch (v) {
                        i(v)
                    }
                }, l = g => {
                    try {
                        d(t.throw(g))
                    } catch (v) {
                        i(v)
                    }
                }, d = g => g.done ? n(g.value) : Promise.resolve(g.value).then(s, l);
                d((t = t.apply(r, e)).next())
            });

            class VM extends Re {
                static get requires() {
                    return ["ImageUploadEditing", "ImageUploadProgress", _o, v_]
                }

                static get pluginName() {
                    return "CKBoxUploadAdapter"
                }

                afterInit() {
                    return $b(this, null, function* () {
                        const e = this.editor, t = !!e.config.get("ckbox"), n = !!window.CKBox;
                        if (!t && !n) return;
                        const i = e.plugins.get(_o), s = e.plugins.get(k_);
                        i.createUploadAdapter = g => new HM(g, e, s);
                        const l = !e.config.get("ckbox.ignoreDataId"), d = e.plugins.get("ImageUploadEditing");
                        l && d.on("uploadComplete", (g, {imageElement: v, data: _}) => {
                            e.model.change(x => {
                                x.setAttribute("ckboxImageId", _.ckboxImageId, v)
                            })
                        })
                    })
                }
            }

            class HM {
                constructor(e, t, n) {
                    this.loader = e, this.token = n.getToken(), this.ckboxUtils = n, this.editor = t, this.controller = new AbortController, this.serviceOrigin = t.config.get("ckbox.serviceOrigin")
                }

                upload() {
                    return $b(this, null, function* () {
                        const e = this.ckboxUtils, t = this.editor.t, n = yield this.loader.file,
                            i = yield e.getCategoryIdForFile(n, {signal: this.controller.signal}),
                            s = new URL("assets", this.serviceOrigin), l = new FormData;
                        return s.searchParams.set("workspaceId", e.getWorkspaceId()), l.append("categoryId", i), l.append("file", n), g_({
                            method: "POST",
                            url: s,
                            data: l,
                            onUploadProgress: d => {
                                d.lengthComputable && (this.loader.uploadTotal = d.total, this.loader.uploaded = d.loaded)
                            },
                            signal: this.controller.signal,
                            authorization: this.token.value
                        }).then(d => $b(this, null, function* () {
                            const g = f_(d.imageUrls);
                            return {ckboxImageId: d.id, default: g.imageFallbackUrl, sources: g.imageSources}
                        })).catch(() => {
                            const d = t("Cannot upload file:") + ` ${n.name}.`;
                            return Promise.reject(d)
                        })
                    })
                }

                abort() {
                    this.controller.abort()
                }
            }

            class v_ extends Re {
                static get pluginName() {
                    return "CKBoxEditing"
                }

                static get requires() {
                    return ["LinkEditing", "PictureEditing", VM, k_]
                }

                init() {
                    const e = this.editor, t = !!e.config.get("ckbox"), n = !!window.CKBox;
                    (t || n) && (this._checkImagePlugins(), e.config.get("ckbox.ignoreDataId") || (this._initSchema(), this._initConversion(), this._initFixers()), n && e.commands.add("ckbox", new FM(e)))
                }

                _checkImagePlugins() {
                    const e = this.editor;
                    e.plugins.has("ImageBlockEditing") || e.plugins.has("ImageInlineEditing") || ue("ckbox-plugin-image-feature-missing", e)
                }

                _initSchema() {
                    const e = this.editor.model.schema;
                    e.extend("$text", {allowAttributes: "ckboxLinkId"}), e.isRegistered("imageBlock") && e.extend("imageBlock", {allowAttributes: ["ckboxImageId", "ckboxLinkId"]}), e.isRegistered("imageInline") && e.extend("imageInline", {allowAttributes: ["ckboxImageId", "ckboxLinkId"]}), e.addAttributeCheck((t, n) => {
                        if (!t.last.getAttribute("linkHref") && n === "ckboxLinkId") return !1
                    })
                }

                _initConversion() {
                    const e = this.editor;
                    e.conversion.for("downcast").add(n => {
                        n.on("attribute:ckboxLinkId:imageBlock", (i, s, l) => {
                            const {writer: d, mapper: g, consumable: v} = l;
                            if (!v.consume(s.item, i.name)) return;
                            const _ = [...g.toViewElement(s.item).getChildren()].find(x => x.name === "a");
                            _ && (s.item.hasAttribute("ckboxLinkId") ? d.setAttribute("data-ckbox-resource-id", s.item.getAttribute("ckboxLinkId"), _) : d.removeAttribute("data-ckbox-resource-id", _))
                        }, {priority: "low"}), n.on("attribute:ckboxLinkId", (i, s, l) => {
                            const {writer: d, mapper: g, consumable: v} = l;
                            if (v.consume(s.item, i.name)) {
                                if (s.attributeOldValue) {
                                    const _ = w_(d, s.attributeOldValue);
                                    d.unwrap(g.toViewRange(s.range), _)
                                }
                                if (s.attributeNewValue) {
                                    const _ = w_(d, s.attributeNewValue);
                                    if (s.item.is("selection")) {
                                        const x = d.document.selection;
                                        d.wrap(x.getFirstRange(), _)
                                    } else d.wrap(g.toViewRange(s.range), _)
                                }
                            }
                        }, {priority: "low"})
                    }), e.conversion.for("upcast").add(n => {
                        n.on("element:a", (i, s, l) => {
                            const {writer: d, consumable: g} = l;
                            if (!s.viewItem.getAttribute("href") || !g.consume(s.viewItem, {attributes: ["data-ckbox-resource-id"]})) return;
                            const v = s.viewItem.getAttribute("data-ckbox-resource-id");
                            if (v) if (s.modelRange) for (let _ of s.modelRange.getItems()) _.is("$textProxy") && (_ = _.textNode), qM(_) && d.setAttribute("ckboxLinkId", v, _); else {
                                const _ = s.modelCursor.nodeBefore || s.modelCursor.parent;
                                d.setAttribute("ckboxLinkId", v, _)
                            }
                        }, {priority: "low"})
                    }), e.conversion.for("downcast").attributeToAttribute({
                        model: "ckboxImageId",
                        view: "data-ckbox-resource-id"
                    }), e.conversion.for("upcast").elementToAttribute({
                        model: {
                            key: "ckboxImageId",
                            value: n => n.getAttribute("data-ckbox-resource-id")
                        }, view: {attributes: {"data-ckbox-resource-id": /[\s\S]+/}}
                    });
                    const t = e.commands.get("replaceImageSource");
                    t && this.listenTo(t, "cleanupImage", (n, [i, s]) => {
                        i.removeAttribute("ckboxImageId", s)
                    })
                }

                _initFixers() {
                    const e = this.editor, t = e.model, n = t.document.selection;
                    t.document.registerPostFixer(function (i) {
                        return s => {
                            let l = !1;
                            const d = i.model, g = i.commands.get("ckbox");
                            if (!g) return l;
                            for (const v of d.document.differ.getChanges()) {
                                if (v.type !== "insert" && v.type !== "attribute") continue;
                                const _ = v.type === "insert" ? new Ee(v.position, v.position.getShiftedBy(v.length)) : v.range,
                                    x = v.type === "attribute" && v.attributeKey === "linkHref" && v.attributeNewValue === null;
                                for (const M of _.getItems()) {
                                    if (x && M.hasAttribute("ckboxLinkId")) {
                                        s.removeAttribute("ckboxLinkId", M), l = !0;
                                        continue
                                    }
                                    const O = UM(M, g._chosenAssets);
                                    for (const j of O) {
                                        const U = j.type === "image" ? "ckboxImageId" : "ckboxLinkId";
                                        j.id !== M.getAttribute(U) && (s.setAttribute(U, j.id, M), l = !0)
                                    }
                                }
                            }
                            return l
                        }
                    }(e)), t.document.registerPostFixer(function (i) {
                        return s => !(i.hasAttribute("linkHref") || !i.hasAttribute("ckboxLinkId")) && (s.removeSelectionAttribute("ckboxLinkId"), !0)
                    }(n))
                }
            }

            function UM(r, e) {
                const t = r.is("element", "imageInline") || r.is("element", "imageBlock"),
                    n = r.hasAttribute("linkHref");
                return [...e].filter(i => i.type === "image" && t ? i.attributes.imageFallbackUrl === r.getAttribute("src") : i.type === "link" && n ? i.attributes.linkHref === r.getAttribute("linkHref") : void 0)
            }

            function w_(r, e) {
                const t = r.createAttributeElement("a", {"data-ckbox-resource-id": e}, {priority: 5});
                return r.setCustomProperty("link", !0, t), t
            }

            function qM(r) {
                return !!r.is("$text") || !(!r.is("element", "imageInline") && !r.is("element", "imageBlock"))
            }

            var A_ = C(443),
                WM = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(A_.Z, WM), A_.Z.locals;

            class $M extends Re {
                static get pluginName() {
                    return "CKFinderUI"
                }

                init() {
                    const e = this.editor, t = e.ui.componentFactory, n = e.t;
                    if (t.add("ckfinder", i => {
                        const s = e.commands.get("ckfinder"), l = new sn(i);
                        return l.set({
                            label: n("Insert image or file"),
                            icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>',
                            tooltip: !0
                        }), l.bind("isEnabled").to(s), l.on("execute", () => {
                            e.execute("ckfinder"), e.editing.view.focus()
                        }), l
                    }), e.plugins.has("ImageInsertUI")) {
                        const i = e.plugins.get("ImageInsertUI"), s = e.commands.get("ckfinder");
                        i.registerIntegration({
                            name: "assetManager", observable: s, buttonViewCreator: () => {
                                const l = this.editor.ui.componentFactory.create("ckfinder");
                                return l.icon = mn.imageAssetManager, l.bind("label").to(i, "isImageSelected", d => n(d ? "Replace image with file manager" : "Insert image with file manager")), l
                            }, formViewCreator: () => {
                                const l = this.editor.ui.componentFactory.create("ckfinder");
                                return l.icon = mn.imageAssetManager, l.withText = !0, l.bind("label").to(i, "isImageSelected", d => n(d ? "Replace with file manager" : "Insert with file manager")), l.on("execute", () => {
                                    i.dropdownView.isOpen = !1
                                }), l
                            }
                        })
                    }
                }
            }

            class GM extends Ft {
                constructor(e) {
                    super(e), this.affectsData = !1, this.stopListening(this.editor.model.document, "change"), this.listenTo(this.editor.model.document, "change", () => this.refresh(), {priority: "low"})
                }

                refresh() {
                    const e = this.editor.commands.get("insertImage"), t = this.editor.commands.get("link");
                    this.isEnabled = e.isEnabled || t.isEnabled
                }

                execute() {
                    const e = this.editor, t = this.editor.config.get("ckfinder.openerMethod") || "modal";
                    if (t != "popup" && t != "modal") throw new R("ckfinder-unknown-openermethod", e);
                    const n = this.editor.config.get("ckfinder.options") || {};
                    n.chooseFiles = !0;
                    const i = n.onInit;
                    n.language || (n.language = e.locale.uiLanguage), n.onInit = s => {
                        i && i(s), s.on("files:choose", l => {
                            const d = l.data.files.toArray(), g = d.filter(x => !x.isImage()),
                                v = d.filter(x => x.isImage());
                            for (const x of g) e.execute("link", x.getUrl());
                            const _ = [];
                            for (const x of v) {
                                const M = x.getUrl();
                                _.push(M || s.request("file:getProxyUrl", {file: x}))
                            }
                            _.length && C_(e, _)
                        }), s.on("file:choose:resizedImage", l => {
                            const d = l.data.resizedUrl;
                            if (d) C_(e, [d]); else {
                                const g = e.plugins.get("Notification"), v = e.locale.t;
                                g.showWarning(v("Could not obtain resized image URL."), {
                                    title: v("Selecting resized image failed"),
                                    namespace: "ckfinder"
                                })
                            }
                        })
                    }, window.CKFinder[t](n)
                }
            }

            function C_(r, e) {
                if (r.commands.get("insertImage").isEnabled) r.execute("insertImage", {source: e}); else {
                    const t = r.plugins.get("Notification"), n = r.locale.t;
                    t.showWarning(n("Could not insert image at the current position."), {
                        title: n("Inserting image failed"),
                        namespace: "ckfinder"
                    })
                }
            }

            class KM extends Re {
                static get pluginName() {
                    return "CKFinderEditing"
                }

                static get requires() {
                    return [Bb, "LinkEditing"]
                }

                init() {
                    const e = this.editor;
                    if (!e.plugins.has("ImageBlockEditing") && !e.plugins.has("ImageInlineEditing")) throw new R("ckfinder-missing-image-plugin", e);
                    e.commands.add("ckfinder", new GM(e))
                }
            }

            class ZM extends Re {
                static get pluginName() {
                    return "CloudServicesUploadAdapter"
                }

                static get requires() {
                    return ["CloudServices", _o]
                }

                init() {
                    const e = this.editor, t = e.plugins.get("CloudServices"), n = t.token, i = t.uploadUrl;
                    if (!n) return;
                    const s = e.plugins.get("CloudServicesCore");
                    this._uploadGateway = s.createUploadGateway(n, i), e.plugins.get(_o).createUploadAdapter = l => new YM(this._uploadGateway, l)
                }
            }

            class YM {
                constructor(e, t) {
                    this.uploadGateway = e, this.loader = t
                }

                upload() {
                    return this.loader.file.then(e => (this.fileUploader = this.uploadGateway.upload(e), this.fileUploader.on("progress", (t, n) => {
                        this.loader.uploadTotal = n.total, this.loader.uploaded = n.uploaded
                    }), this.fileUploader.send()))
                }

                abort() {
                    this.fileUploader.abort()
                }
            }

            class QM extends Ft {
                constructor(e) {
                    super(e), this._isEnabledBasedOnSelection = !1
                }

                refresh() {
                    const e = this.editor.model, t = Wn(e.document.selection.getSelectedBlocks());
                    this.value = !!t && t.is("element", "paragraph"), this.isEnabled = !!t && __(t, e.schema)
                }

                execute(e = {}) {
                    const t = this.editor.model, n = t.document, i = e.selection || n.selection;
                    t.canEditAt(i) && t.change(s => {
                        const l = i.getSelectedBlocks();
                        for (const d of l) !d.is("element", "paragraph") && __(d, t.schema) && s.rename(d, "paragraph")
                    })
                }
            }

            function __(r, e) {
                return e.checkChild(r.parent, "paragraph") && !e.isObject(r)
            }

            class JM extends Ft {
                constructor(e) {
                    super(e), this._isEnabledBasedOnSelection = !1
                }

                execute(e) {
                    const t = this.editor.model, n = e.attributes;
                    let i = e.position;
                    t.canEditAt(i) && t.change(s => {
                        if (i = this._findPositionToInsertParagraph(i, s), !i) return;
                        const l = s.createElement("paragraph");
                        n && t.schema.setAllowedAttributes(l, n, s), t.insertContent(l, i), s.setSelection(l, "in")
                    })
                }

                _findPositionToInsertParagraph(e, t) {
                    const n = this.editor.model;
                    if (n.schema.checkChild(e, "paragraph")) return e;
                    const i = n.schema.findAllowedParent(e, "paragraph");
                    if (!i) return null;
                    const s = e.parent, l = n.schema.checkChild(s, "$text");
                    return s.isEmpty || l && e.isAtEnd ? n.createPositionAfter(s) : !s.isEmpty && l && e.isAtStart ? n.createPositionBefore(s) : t.split(e, i).position
                }
            }

            const y_ = class extends Re {
                static get pluginName() {
                    return "Paragraph"
                }

                init() {
                    const r = this.editor, e = r.model;
                    r.commands.add("paragraph", new QM(r)), r.commands.add("insertParagraph", new JM(r)), e.schema.register("paragraph", {inheritAllFrom: "$block"}), r.conversion.elementToElement({
                        model: "paragraph",
                        view: "p"
                    }), r.conversion.for("upcast").elementToElement({
                        model: (t, {writer: n}) => y_.paragraphLikeElements.has(t.name) ? t.isEmpty ? null : n.createElement("paragraph") : null,
                        view: /.+/,
                        converterPriority: "low"
                    })
                }
            };
            let Gb = y_;
            Gb.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);

            class XM extends Ft {
                constructor(e, t) {
                    super(e), this.modelElements = t
                }

                refresh() {
                    const e = Wn(this.editor.model.document.selection.getSelectedBlocks());
                    this.value = !!e && this.modelElements.includes(e.name) && e.name, this.isEnabled = !!e && this.modelElements.some(t => D_(e, t, this.editor.model.schema))
                }

                execute(e) {
                    const t = this.editor.model, n = t.document, i = e.value;
                    t.change(s => {
                        const l = Array.from(n.selection.getSelectedBlocks()).filter(d => D_(d, i, t.schema));
                        for (const d of l) d.is("element", i) || s.rename(d, i)
                    })
                }
            }

            function D_(r, e, t) {
                return t.checkChild(r.parent, e) && !t.isObject(r)
            }

            const x_ = "paragraph";

            class eB extends Re {
                static get pluginName() {
                    return "HeadingEditing"
                }

                constructor(e) {
                    super(e), e.config.define("heading", {
                        options: [{
                            model: "paragraph",
                            title: "Paragraph",
                            class: "ck-heading_paragraph"
                        }, {
                            model: "heading1",
                            view: "h2",
                            title: "Heading 1",
                            class: "ck-heading_heading1"
                        }, {
                            model: "heading2",
                            view: "h3",
                            title: "Heading 2",
                            class: "ck-heading_heading2"
                        }, {model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3"}]
                    })
                }

                static get requires() {
                    return [Gb]
                }

                init() {
                    const e = this.editor, t = e.config.get("heading.options"), n = [];
                    for (const i of t) i.model !== "paragraph" && (e.model.schema.register(i.model, {inheritAllFrom: "$block"}), e.conversion.elementToElement(i), n.push(i.model));
                    this._addDefaultH1Conversion(e), e.commands.add("heading", new XM(e, n))
                }

                afterInit() {
                    const e = this.editor, t = e.commands.get("enter"), n = e.config.get("heading.options");
                    t && this.listenTo(t, "afterExecute", (i, s) => {
                        const l = e.model.document.selection.getFirstPosition().parent;
                        n.some(d => l.is("element", d.model)) && !l.is("element", x_) && l.childCount === 0 && s.writer.rename(l, x_)
                    })
                }

                _addDefaultH1Conversion(e) {
                    e.conversion.for("upcast").elementToElement({
                        model: "heading1",
                        view: "h1",
                        converterPriority: ce.low + 1
                    })
                }
            }

            var E_ = C(8733),
                tB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(E_.Z, tB), E_.Z.locals;

            class nB extends Re {
                static get pluginName() {
                    return "HeadingUI"
                }

                init() {
                    const e = this.editor, t = e.t, n = function (l) {
                        const d = l.t, g = {
                            Paragraph: d("Paragraph"),
                            "Heading 1": d("Heading 1"),
                            "Heading 2": d("Heading 2"),
                            "Heading 3": d("Heading 3"),
                            "Heading 4": d("Heading 4"),
                            "Heading 5": d("Heading 5"),
                            "Heading 6": d("Heading 6")
                        };
                        return l.config.get("heading.options").map(v => {
                            const _ = g[v.title];
                            return _ && _ != v.title && (v.title = _), v
                        })
                    }(e), i = t("Choose heading"), s = t("Heading");
                    e.ui.componentFactory.add("heading", l => {
                        const d = {}, g = new br, v = e.commands.get("heading"), _ = e.commands.get("paragraph"),
                            x = [v];
                        for (const O of n) {
                            const j = {
                                type: "button",
                                model: new PA({label: O.title, class: O.class, role: "menuitemradio", withText: !0})
                            };
                            O.model === "paragraph" ? (j.model.bind("isOn").to(_, "value"), j.model.set("commandName", "paragraph"), x.push(_)) : (j.model.bind("isOn").to(v, "value", U => U === O.model), j.model.set({
                                commandName: "heading",
                                commandValue: O.model
                            })), g.add(j), d[O.model] = O.title
                        }
                        const M = Ns(l);
                        return nA(M, g, {ariaLabel: s, role: "menu"}), M.buttonView.set({
                            ariaLabel: s,
                            ariaLabelledBy: void 0,
                            isOn: !1,
                            withText: !0,
                            tooltip: s
                        }), M.extendTemplate({attributes: {class: ["ck-heading-dropdown"]}}), M.bind("isEnabled").toMany(x, "isEnabled", (...O) => O.some(j => j)), M.buttonView.bind("label").to(v, "value", _, "value", (O, j) => {
                            const U = O || j && "paragraph";
                            return typeof U == "boolean" ? i : d[U] ? d[U] : i
                        }), this.listenTo(M, "execute", O => {
                            const {commandName: j, commandValue: U} = O.source;
                            e.execute(j, U ? {value: U} : void 0), e.editing.view.focus()
                        }), M
                    })
                }
            }

            function S_(r) {
                return r.createContainerElement("figure", {class: "image"}, [r.createEmptyElement("img"), r.createSlot("children")])
            }

            function T_(r, e) {
                const t = r.plugins.get("ImageUtils"),
                    n = r.plugins.has("ImageInlineEditing") && r.plugins.has("ImageBlockEditing");
                return s => t.isInlineImageView(s) ? n && (s.getStyle("display") == "block" || s.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : i(s) : null;

                function i(s) {
                    const l = {name: !0};
                    return s.hasAttribute("src") && (l.attributes = ["src"]), l
                }
            }

            function Kb(r, e) {
                const t = Wn(e.getSelectedBlocks());
                return !t || r.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline"
            }

            function Xg(r) {
                return r && r.endsWith("px") ? parseInt(r) : null
            }

            function I_(r) {
                const e = Xg(r.getStyle("width")), t = Xg(r.getStyle("height"));
                return !(!e || !t)
            }

            var rB = Object.defineProperty, M_ = Object.getOwnPropertySymbols, iB = Object.prototype.hasOwnProperty,
                oB = Object.prototype.propertyIsEnumerable, B_ = (r, e, t) => e in r ? rB(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, N_ = (r, e) => {
                    for (var t in e || (e = {})) iB.call(e, t) && B_(r, t, e[t]);
                    if (M_) for (var t of M_(e)) oB.call(e, t) && B_(r, t, e[t]);
                    return r
                };
            const sB = /^(image|image-inline)$/;

            class hi extends Re {
                constructor() {
                    super(...arguments), this._domEmitter = new (dr())
                }

                static get pluginName() {
                    return "ImageUtils"
                }

                isImage(e) {
                    return this.isInlineImage(e) || this.isBlockImage(e)
                }

                isInlineImageView(e) {
                    return !!e && e.is("element", "img")
                }

                isBlockImageView(e) {
                    return !!e && e.is("element", "figure") && e.hasClass("image")
                }

                insertImage(e = {}, t = null, n = null, i = {}) {
                    const s = this.editor, l = s.model, d = l.document.selection, g = L_(s, t || d, n);
                    e = N_(N_({}, Object.fromEntries(d.getAttributes())), e);
                    for (const v in e) l.schema.checkAttribute(g, v) || delete e[v];
                    return l.change(v => {
                        const {setImageSizes: _ = !0} = i, x = v.createElement(g, e);
                        return l.insertObject(x, t, null, {
                            setSelection: "on",
                            findOptimalPosition: t || g == "imageInline" ? void 0 : "auto"
                        }), x.parent ? (_ && this.setImageNaturalSizeAttributes(x), x) : null
                    })
                }

                setImageNaturalSizeAttributes(e) {
                    const t = e.getAttribute("src");
                    t && (e.getAttribute("width") || e.getAttribute("height") || this.editor.model.change(n => {
                        const i = new bt.window.Image;
                        this._domEmitter.listenTo(i, "load", () => {
                            e.getAttribute("width") || e.getAttribute("height") || this.editor.model.enqueueChange(n.batch, s => {
                                s.setAttribute("width", i.naturalWidth, e), s.setAttribute("height", i.naturalHeight, e)
                            }), this._domEmitter.stopListening(i, "load")
                        }), i.src = t
                    }))
                }

                getClosestSelectedImageWidget(e) {
                    const t = e.getFirstPosition();
                    if (!t) return null;
                    const n = e.getSelectedElement();
                    if (n && this.isImageWidget(n)) return n;
                    let i = t.parent;
                    for (; i;) {
                        if (i.is("element") && this.isImageWidget(i)) return i;
                        i = i.parent
                    }
                    return null
                }

                getClosestSelectedImageElement(e) {
                    const t = e.getSelectedElement();
                    return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock")
                }

                getImageWidgetFromImageView(e) {
                    return e.findAncestor({classes: sB})
                }

                isImageAllowed() {
                    const e = this.editor.model.document.selection;
                    return function (t, n) {
                        if (L_(t, n, null) == "imageBlock") {
                            const s = function (l, d) {
                                const g = SC(l, d), v = g.start.parent;
                                return v.isEmpty && !v.is("element", "$root") ? v.parent : v
                            }(n, t.model);
                            if (t.model.schema.checkChild(s, "imageBlock")) return !0
                        } else if (t.model.schema.checkChild(n.focus, "imageInline")) return !0;
                        return !1
                    }(this.editor, e) && function (t) {
                        return [...t.focus.getAncestors()].every(n => !n.is("element", "imageBlock"))
                    }(e)
                }

                toImageWidget(e, t, n) {
                    return t.setCustomProperty("image", !0, e), Rb(e, t, {
                        label: () => {
                            const i = this.findViewImgElement(e).getAttribute("alt");
                            return i ? `${i} ${n}` : n
                        }
                    })
                }

                isImageWidget(e) {
                    return !!e.getCustomProperty("image") && wr(e)
                }

                isBlockImage(e) {
                    return !!e && e.is("element", "imageBlock")
                }

                isInlineImage(e) {
                    return !!e && e.is("element", "imageInline")
                }

                findViewImgElement(e) {
                    if (this.isInlineImageView(e)) return e;
                    const t = this.editor.editing.view;
                    for (const {item: n} of t.createRangeIn(e)) if (this.isInlineImageView(n)) return n
                }

                destroy() {
                    return this._domEmitter.stopListening(), super.destroy()
                }
            }

            function L_(r, e, t) {
                const n = r.model.schema, i = r.config.get("image.insert.type");
                return r.plugins.has("ImageBlockEditing") ? r.plugins.has("ImageInlineEditing") ? t || (i === "inline" ? "imageInline" : i !== "auto" ? "imageBlock" : e.is("selection") ? Kb(n, e) : n.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline"
            }

            class aB extends Ft {
                refresh() {
                    const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
                    this.isEnabled = !!e, this.isEnabled && e.hasAttribute("alt") ? this.value = e.getAttribute("alt") : this.value = !1
                }

                execute(e) {
                    const t = this.editor, n = t.plugins.get("ImageUtils"), i = t.model,
                        s = n.getClosestSelectedImageElement(i.document.selection);
                    i.change(l => {
                        l.setAttribute("alt", e.newValue, s)
                    })
                }
            }

            class lB extends Re {
                static get requires() {
                    return [hi]
                }

                static get pluginName() {
                    return "ImageTextAlternativeEditing"
                }

                init() {
                    this.editor.commands.add("imageTextAlternative", new aB(this.editor))
                }
            }

            var P_ = C(1905),
                cB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(P_.Z, cB), P_.Z.locals;
            var O_ = C(6764),
                uB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(O_.Z, uB), O_.Z.locals;

            class dB extends It {
                constructor(e) {
                    super(e);
                    const t = this.locale.t;
                    this.focusTracker = new Nr, this.keystrokes = new si, this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(t("Save"), mn.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(t("Cancel"), mn.cancel, "ck-button-cancel", "cancel"), this._focusables = new un, this._focusCycler = new yn({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                    }), this.setTemplate({
                        tag: "form",
                        attributes: {class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1"},
                        children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
                    })
                }

                render() {
                    super.render(), this.keystrokes.listenTo(this.element), w({view: this}), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach(e => {
                        this._focusables.add(e), this.focusTracker.add(e.element)
                    })
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }

                _createButton(e, t, n, i) {
                    const s = new sn(this.locale);
                    return s.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }), s.extendTemplate({attributes: {class: n}}), i && s.delegate("execute").to(this, i), s
                }

                _createLabeledInputView() {
                    const e = this.locale.t, t = new Xc(this.locale, Lg);
                    return t.label = e("Text alternative"), t
                }
            }

            function F_(r) {
                const e = r.editing.view, t = ui.defaultPositions, n = r.plugins.get("ImageUtils");
                return {
                    target: e.domConverter.mapViewToDom(n.getClosestSelectedImageWidget(e.document.selection)),
                    positions: [t.northArrowSouth, t.northArrowSouthWest, t.northArrowSouthEast, t.southArrowNorth, t.southArrowNorthWest, t.southArrowNorthEast, t.viewportStickyNorth]
                }
            }

            class hB extends Re {
                static get requires() {
                    return [jg]
                }

                static get pluginName() {
                    return "ImageTextAlternativeUI"
                }

                init() {
                    this._createButton()
                }

                destroy() {
                    super.destroy(), this._form && this._form.destroy()
                }

                _createButton() {
                    const e = this.editor, t = e.t;
                    e.ui.componentFactory.add("imageTextAlternative", n => {
                        const i = e.commands.get("imageTextAlternative"), s = new sn(n);
                        return s.set({
                            label: t("Change image text alternative"),
                            icon: mn.textAlternative,
                            tooltip: !0
                        }), s.bind("isEnabled").to(i, "isEnabled"), s.bind("isOn").to(i, "value", l => !!l), this.listenTo(s, "execute", () => {
                            this._showForm()
                        }), s
                    })
                }

                _createForm() {
                    const e = this.editor, t = e.editing.view.document, n = e.plugins.get("ImageUtils");
                    this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (y(dB))(e.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
                        e.execute("imageTextAlternative", {newValue: this._form.labeledInput.fieldView.element.value}), this._hideForm(!0)
                    }), this.listenTo(this._form, "cancel", () => {
                        this._hideForm(!0)
                    }), this._form.keystrokes.set("Esc", (i, s) => {
                        this._hideForm(!0), s()
                    }), this.listenTo(e.ui, "update", () => {
                        n.getClosestSelectedImageWidget(t.selection) ? this._isVisible && function (i) {
                            const s = i.plugins.get("ContextualBalloon");
                            if (i.plugins.get("ImageUtils").getClosestSelectedImageWidget(i.editing.view.document.selection)) {
                                const l = F_(i);
                                s.updatePosition(l)
                            }
                        }(e) : this._hideForm(!0)
                    }), A({
                        emitter: this._form,
                        activator: () => this._isVisible,
                        contextElements: () => [this._balloon.view.element],
                        callback: () => this._hideForm()
                    })
                }

                _showForm() {
                    if (this._isVisible) return;
                    this._form || this._createForm();
                    const e = this.editor, t = e.commands.get("imageTextAlternative"), n = this._form.labeledInput;
                    this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({
                        view: this._form,
                        position: F_(e)
                    }), n.fieldView.value = n.fieldView.element.value = t.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions()
                }

                _hideForm(e = !1) {
                    this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus())
                }

                get _isVisible() {
                    return !!this._balloon && this._balloon.visibleView === this._form
                }

                get _isInBalloon() {
                    return !!this._balloon && this._balloon.hasView(this._form)
                }
            }

            class R_ extends Re {
                static get requires() {
                    return [lB, hB]
                }

                static get pluginName() {
                    return "ImageTextAlternative"
                }
            }

            function z_(r, e) {
                const t = (n, i, s) => {
                    if (!s.consumable.consume(i.item, n.name)) return;
                    const l = s.writer, d = s.mapper.toViewElement(i.item), g = r.findViewImgElement(d);
                    i.attributeNewValue === null ? (l.removeAttribute("srcset", g), l.removeAttribute("sizes", g)) : i.attributeNewValue && (l.setAttribute("srcset", i.attributeNewValue, g), l.setAttribute("sizes", "100vw", g))
                };
                return n => {
                    n.on(`attribute:srcset:${e}`, t)
                }
            }

            function ep(r, e, t) {
                const n = (i, s, l) => {
                    if (!l.consumable.consume(s.item, i.name)) return;
                    const d = l.writer, g = l.mapper.toViewElement(s.item), v = r.findViewImgElement(g);
                    d.setAttribute(s.attributeKey, s.attributeNewValue || "", v)
                };
                return i => {
                    i.on(`attribute:${t}:${e}`, n)
                }
            }

            class j_ extends En {
                observe(e) {
                    this.listenTo(e, "load", (t, n) => {
                        const i = n.target;
                        this.checkShouldIgnoreEventFromTarget(i) || i.tagName == "IMG" && this._fireEvents(n)
                    }, {useCapture: !0})
                }

                stopObserving(e) {
                    this.stopListening(e)
                }

                _fireEvents(e) {
                    this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e))
                }
            }

            var fB = Object.defineProperty, V_ = Object.getOwnPropertySymbols, gB = Object.prototype.hasOwnProperty,
                pB = Object.prototype.propertyIsEnumerable, H_ = (r, e, t) => e in r ? fB(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, tp = (r, e) => {
                    for (var t in e || (e = {})) gB.call(e, t) && H_(r, t, e[t]);
                    if (V_) for (var t of V_(e)) pB.call(e, t) && H_(r, t, e[t]);
                    return r
                };

            class mB extends Ft {
                constructor(e) {
                    super(e);
                    const t = e.config.get("image.insert.type");
                    e.plugins.has("ImageBlockEditing") || t === "block" && ae("image-block-plugin-required"), e.plugins.has("ImageInlineEditing") || t === "inline" && ae("image-inline-plugin-required")
                }

                refresh() {
                    const e = this.editor.plugins.get("ImageUtils");
                    this.isEnabled = e.isImageAllowed()
                }

                execute(e) {
                    const t = qn(e.source), n = this.editor.model.document.selection,
                        i = this.editor.plugins.get("ImageUtils"), s = Object.fromEntries(n.getAttributes());
                    t.forEach((l, d) => {
                        const g = n.getSelectedElement();
                        if (typeof l == "string" && (l = {src: l}), d && g && i.isImage(g)) {
                            const v = this.editor.model.createPositionAfter(g);
                            i.insertImage(tp(tp({}, l), s), v)
                        } else i.insertImage(tp(tp({}, l), s))
                    })
                }
            }

            class bB extends Ft {
                constructor(e) {
                    super(e), this.decorate("cleanupImage")
                }

                refresh() {
                    const e = this.editor.plugins.get("ImageUtils"),
                        t = this.editor.model.document.selection.getSelectedElement();
                    this.isEnabled = e.isImage(t), this.value = this.isEnabled ? t.getAttribute("src") : null
                }

                execute(e) {
                    const t = this.editor.model.document.selection.getSelectedElement(),
                        n = this.editor.plugins.get("ImageUtils");
                    this.editor.model.change(i => {
                        i.setAttribute("src", e.source, t), this.cleanupImage(i, t), n.setImageNaturalSizeAttributes(t)
                    })
                }

                cleanupImage(e, t) {
                    e.removeAttribute("srcset", t), e.removeAttribute("sizes", t), e.removeAttribute("sources", t), e.removeAttribute("width", t), e.removeAttribute("height", t), e.removeAttribute("alt", t)
                }
            }

            class Zb extends Re {
                static get requires() {
                    return [hi]
                }

                static get pluginName() {
                    return "ImageEditing"
                }

                init() {
                    const e = this.editor, t = e.conversion;
                    e.editing.view.addObserver(j_), t.for("upcast").attributeToAttribute({
                        view: {
                            name: "img",
                            key: "alt"
                        }, model: "alt"
                    }).attributeToAttribute({view: {name: "img", key: "srcset"}, model: "srcset"});
                    const n = new mB(e), i = new bB(e);
                    e.commands.add("insertImage", n), e.commands.add("replaceImageSource", i), e.commands.add("imageInsert", n)
                }
            }

            class U_ extends Re {
                static get requires() {
                    return [hi]
                }

                static get pluginName() {
                    return "ImageSizeAttributes"
                }

                afterInit() {
                    this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline")
                }

                _registerSchema() {
                    this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", {allowAttributes: ["width", "height"]}), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", {allowAttributes: ["width", "height"]})
                }

                _registerConverters(e) {
                    const t = this.editor, n = t.plugins.get("ImageUtils"), i = e === "imageBlock" ? "figure" : "img";

                    function s(l, d, g, v) {
                        l.on(`attribute:${d}:${e}`, (_, x, M) => {
                            if (!M.consumable.consume(x.item, _.name)) return;
                            const O = M.writer, j = M.mapper.toViewElement(x.item), U = n.findViewImgElement(j);
                            if (x.attributeNewValue !== null ? O.setAttribute(g, x.attributeNewValue, U) : O.removeAttribute(g, U), x.item.hasAttribute("sources")) return;
                            const K = x.item.hasAttribute("resizedWidth");
                            if (e === "imageInline" && !K && !v) return;
                            const ne = x.item.getAttribute("width"), pe = x.item.getAttribute("height");
                            ne && pe && O.setStyle("aspect-ratio", `${ne}/${pe}`, U)
                        })
                    }

                    t.conversion.for("upcast").attributeToAttribute({
                        view: {name: i, styles: {width: /.+/}},
                        model: {key: "width", value: l => I_(l) ? Xg(l.getStyle("width")) : null}
                    }).attributeToAttribute({
                        view: {name: i, key: "width"},
                        model: "width"
                    }).attributeToAttribute({
                        view: {name: i, styles: {height: /.+/}},
                        model: {key: "height", value: l => I_(l) ? Xg(l.getStyle("height")) : null}
                    }).attributeToAttribute({
                        view: {name: i, key: "height"},
                        model: "height"
                    }), t.conversion.for("editingDowncast").add(l => {
                        s(l, "width", "width", !0), s(l, "height", "height", !0)
                    }), t.conversion.for("dataDowncast").add(l => {
                        s(l, "width", "width", !1), s(l, "height", "height", !1)
                    })
                }
            }

            class q_ extends Ft {
                constructor(e, t) {
                    super(e), this._modelElementName = t
                }

                refresh() {
                    const e = this.editor.plugins.get("ImageUtils"),
                        t = e.getClosestSelectedImageElement(this.editor.model.document.selection);
                    this._modelElementName === "imageBlock" ? this.isEnabled = e.isInlineImage(t) : this.isEnabled = e.isBlockImage(t)
                }

                execute(e = {}) {
                    const t = this.editor, n = this.editor.model, i = t.plugins.get("ImageUtils"),
                        s = i.getClosestSelectedImageElement(n.document.selection),
                        l = Object.fromEntries(s.getAttributes());
                    return l.src || l.uploadId ? n.change(d => {
                        const {setImageSizes: g = !0} = e,
                            v = Array.from(n.markers).filter(M => M.getRange().containsItem(s)),
                            _ = i.insertImage(l, n.createSelection(s, "on"), this._modelElementName, {setImageSizes: g});
                        if (!_) return null;
                        const x = d.createRangeOn(_);
                        for (const M of v) {
                            const O = M.getRange(), j = O.root.rootName != "$graveyard" ? O.getJoined(x, !0) : x;
                            d.updateMarker(M, {range: j})
                        }
                        return {oldElement: s, newElement: _}
                    }) : null
                }
            }

            var W_ = C(2873),
                kB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(W_.Z, kB), W_.Z.locals;

            class $_ extends Re {
                static get requires() {
                    return [hi]
                }

                static get pluginName() {
                    return "ImagePlaceholder"
                }

                afterInit() {
                    this._setupSchema(), this._setupConversion(), this._setupLoadListener()
                }

                _setupSchema() {
                    const e = this.editor.model.schema;
                    e.isRegistered("imageBlock") && e.extend("imageBlock", {allowAttributes: ["placeholder"]}), e.isRegistered("imageInline") && e.extend("imageInline", {allowAttributes: ["placeholder"]})
                }

                _setupConversion() {
                    const e = this.editor, t = e.conversion, n = e.plugins.get("ImageUtils");
                    t.for("editingDowncast").add(i => {
                        i.on("attribute:placeholder", (s, l, d) => {
                            if (!d.consumable.test(l.item, s.name) || !l.item.is("element", "imageBlock") && !l.item.is("element", "imageInline")) return;
                            d.consumable.consume(l.item, s.name);
                            const g = d.writer, v = d.mapper.toViewElement(l.item), _ = n.findViewImgElement(v);
                            l.attributeNewValue ? (g.addClass("image_placeholder", _), g.setStyle("background-image", `url(${l.attributeNewValue})`, _), g.setCustomProperty("editingPipeline:doNotReuseOnce", !0, _)) : (g.removeClass("image_placeholder", _), g.removeStyle("background-image", _))
                        })
                    })
                }

                _setupLoadListener() {
                    const e = this.editor, t = e.model, n = e.editing, i = n.view, s = e.plugins.get("ImageUtils");
                    i.addObserver(j_), this.listenTo(i.document, "imageLoaded", (l, d) => {
                        const g = i.domConverter.mapDomToView(d.target);
                        if (!g) return;
                        const v = s.getImageWidgetFromImageView(g);
                        if (!v) return;
                        const _ = n.mapper.toModelElement(v);
                        _ && _.hasAttribute("placeholder") && t.enqueueChange({isUndoable: !1}, x => {
                            x.removeAttribute("placeholder", _)
                        })
                    })
                }
            }

            class G_ extends Re {
                static get requires() {
                    return [Zb, U_, hi, $_, es]
                }

                static get pluginName() {
                    return "ImageBlockEditing"
                }

                init() {
                    const e = this.editor;
                    e.model.schema.register("imageBlock", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["alt", "src", "srcset"]
                    }), this._setupConversion(), e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new q_(this.editor, "imageBlock")), this._setupClipboardIntegration())
                }

                _setupConversion() {
                    const e = this.editor, t = e.t, n = e.conversion, i = e.plugins.get("ImageUtils");
                    n.for("dataDowncast").elementToStructure({
                        model: "imageBlock",
                        view: (s, {writer: l}) => S_(l)
                    }), n.for("editingDowncast").elementToStructure({
                        model: "imageBlock",
                        view: (s, {writer: l}) => i.toImageWidget(S_(l), l, t("image widget"))
                    }), n.for("downcast").add(ep(i, "imageBlock", "src")).add(ep(i, "imageBlock", "alt")).add(z_(i, "imageBlock")), n.for("upcast").elementToElement({
                        view: T_(e, "imageBlock"),
                        model: (s, {writer: l}) => l.createElement("imageBlock", s.hasAttribute("src") ? {src: s.getAttribute("src")} : void 0)
                    }).add(function (s) {
                        const l = (d, g, v) => {
                            if (!v.consumable.test(g.viewItem, {name: !0, classes: "image"})) return;
                            const _ = s.findViewImgElement(g.viewItem);
                            if (!_ || !v.consumable.test(_, {name: !0})) return;
                            v.consumable.consume(g.viewItem, {name: !0, classes: "image"});
                            const x = Wn(v.convertItem(_, g.modelCursor).modelRange.getItems());
                            x ? (v.convertChildren(g.viewItem, x), v.updateConversionResult(x, g)) : v.consumable.revert(g.viewItem, {
                                name: !0,
                                classes: "image"
                            })
                        };
                        return d => {
                            d.on("element:figure", l)
                        }
                    }(i))
                }

                _setupClipboardIntegration() {
                    const e = this.editor, t = e.model, n = e.editing.view, i = e.plugins.get("ImageUtils"),
                        s = e.plugins.get("ClipboardPipeline");
                    this.listenTo(s, "inputTransformation", (l, d) => {
                        const g = Array.from(d.content.getChildren());
                        let v;
                        if (!g.every(i.isInlineImageView)) return;
                        v = d.targetRanges ? e.editing.mapper.toModelRange(d.targetRanges[0]) : t.document.selection.getFirstRange();
                        const _ = t.createSelection(v);
                        if (Kb(t.schema, _) === "imageBlock") {
                            const x = new Ia(n.document),
                                M = g.map(O => x.createElement("figure", {class: "image"}, O));
                            d.content = x.createDocumentFragment(M)
                        }
                    }), this.listenTo(s, "contentInsertion", (l, d) => {
                        d.method === "paste" && t.change(g => {
                            const v = g.createRangeIn(d.content);
                            for (const _ of v.getItems()) _.is("element", "imageBlock") && i.setImageNaturalSizeAttributes(_)
                        })
                    })
                }
            }

            var K_ = C(3535),
                vB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(K_.Z, vB), K_.Z.locals;

            class wB extends It {
                constructor(e, t = []) {
                    super(e), this.focusTracker = new Nr, this.keystrokes = new si, this._focusables = new un, this.children = this.createCollection(), this._focusCycler = new yn({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                    });
                    for (const n of t) this.children.add(n), this._focusables.add(n), n instanceof XT && this._focusables.addMany(n.children);
                    if (this._focusables.length > 1) for (const n of this._focusables) AB(n) && (n.focusCycler.on("forwardCycle", i => {
                        this._focusCycler.focusNext(), i.stop()
                    }), n.focusCycler.on("backwardCycle", i => {
                        this._focusCycler.focusPrevious(), i.stop()
                    }));
                    this.setTemplate({
                        tag: "form",
                        attributes: {class: ["ck", "ck-image-insert-form"], tabindex: -1},
                        children: this.children
                    })
                }

                render() {
                    super.render(), w({view: this});
                    for (const t of this._focusables) this.focusTracker.add(t.element);
                    this.keystrokes.listenTo(this.element);
                    const e = t => t.stopPropagation();
                    this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e)
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }

                focus() {
                    this._focusCycler.focusFirst()
                }
            }

            function AB(r) {
                return "focusCycler" in r
            }

            class Z_ extends Re {
                constructor(e) {
                    super(e), this._integrations = new Map, e.config.define("image.insert.integrations", ["upload", "assetManager", "url"])
                }

                static get pluginName() {
                    return "ImageInsertUI"
                }

                static get requires() {
                    return [hi]
                }

                init() {
                    const e = this.editor, t = e.model.document.selection, n = e.plugins.get("ImageUtils");
                    this.set("isImageSelected", !1), this.listenTo(e.model.document, "change", () => {
                        this.isImageSelected = n.isImage(t.getSelectedElement())
                    });
                    const i = s => this._createToolbarComponent(s);
                    e.ui.componentFactory.add("insertImage", i), e.ui.componentFactory.add("imageInsert", i)
                }

                registerIntegration({
                                        name: e,
                                        observable: t,
                                        buttonViewCreator: n,
                                        formViewCreator: i,
                                        requiresForm: s
                                    }) {
                    this._integrations.has(e) && ae("image-insert-integration-exists", {name: e}), this._integrations.set(e, {
                        observable: t,
                        buttonViewCreator: n,
                        formViewCreator: i,
                        requiresForm: !!s
                    })
                }

                _createToolbarComponent(e) {
                    const t = this.editor, n = e.t, i = this._prepareIntegrations();
                    if (!i.length) return null;
                    let s;
                    const l = i[0];
                    if (i.length == 1) {
                        if (!l.requiresForm) return l.buttonViewCreator(!0);
                        s = l.buttonViewCreator(!0)
                    } else {
                        const v = l.buttonViewCreator(!1);
                        s = new Ng(e, v), s.tooltip = !0, s.bind("label").to(this, "isImageSelected", _ => n(_ ? "Replace image" : "Insert image"))
                    }
                    const d = this.dropdownView = Ns(e, s), g = i.map(({observable: v}) => v);
                    return d.bind("isEnabled").toMany(g, "isEnabled", (...v) => v.some(_ => _)), d.once("change:isOpen", () => {
                        const v = i.map(({formViewCreator: x}) => x(i.length == 1)), _ = new wB(t.locale, v);
                        d.panelView.children.add(_)
                    }), d
                }

                _prepareIntegrations() {
                    const e = this.editor.config.get("image.insert.integrations"), t = [];
                    if (!e.length) return ae("image-insert-integrations-not-specified"), t;
                    for (const n of e) this._integrations.has(n) ? t.push(this._integrations.get(n)) : ["upload", "assetManager", "url"].includes(n) || ae("image-insert-unknown-integration", {item: n});
                    return t.length || ae("image-insert-integrations-not-registered"), t
                }
            }

            var Y_ = C(3508),
                CB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Y_.Z, CB), Y_.Z.locals;

            class _B extends Re {
                static get requires() {
                    return [G_, mh, R_, Z_]
                }

                static get pluginName() {
                    return "ImageBlock"
                }
            }

            class yB extends Re {
                static get requires() {
                    return [Zb, U_, hi, $_, es]
                }

                static get pluginName() {
                    return "ImageInlineEditing"
                }

                init() {
                    const e = this.editor, t = e.model.schema;
                    t.register("imageInline", {
                        inheritAllFrom: "$inlineObject",
                        allowAttributes: ["alt", "src", "srcset"]
                    }), t.addChildCheck((n, i) => {
                        if (n.endsWith("caption") && i.name === "imageInline") return !1
                    }), this._setupConversion(), e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new q_(this.editor, "imageInline")), this._setupClipboardIntegration())
                }

                _setupConversion() {
                    const e = this.editor, t = e.t, n = e.conversion, i = e.plugins.get("ImageUtils");
                    n.for("dataDowncast").elementToElement({
                        model: "imageInline",
                        view: (s, {writer: l}) => l.createEmptyElement("img")
                    }), n.for("editingDowncast").elementToStructure({
                        model: "imageInline",
                        view: (s, {writer: l}) => i.toImageWidget(function (d) {
                            return d.createContainerElement("span", {class: "image-inline"}, d.createEmptyElement("img"))
                        }(l), l, t("image widget"))
                    }), n.for("downcast").add(ep(i, "imageInline", "src")).add(ep(i, "imageInline", "alt")).add(z_(i, "imageInline")), n.for("upcast").elementToElement({
                        view: T_(e, "imageInline"),
                        model: (s, {writer: l}) => l.createElement("imageInline", s.hasAttribute("src") ? {src: s.getAttribute("src")} : void 0)
                    })
                }

                _setupClipboardIntegration() {
                    const e = this.editor, t = e.model, n = e.editing.view, i = e.plugins.get("ImageUtils"),
                        s = e.plugins.get("ClipboardPipeline");
                    this.listenTo(s, "inputTransformation", (l, d) => {
                        const g = Array.from(d.content.getChildren());
                        let v;
                        if (!g.every(i.isBlockImageView)) return;
                        v = d.targetRanges ? e.editing.mapper.toModelRange(d.targetRanges[0]) : t.document.selection.getFirstRange();
                        const _ = t.createSelection(v);
                        if (Kb(t.schema, _) === "imageInline") {
                            const x = new Ia(n.document),
                                M = g.map(O => O.childCount === 1 ? (Array.from(O.getAttributes()).forEach(j => x.setAttribute(...j, i.findViewImgElement(O))), O.getChild(0)) : O);
                            d.content = x.createDocumentFragment(M)
                        }
                    }), this.listenTo(s, "contentInsertion", (l, d) => {
                        d.method === "paste" && t.change(g => {
                            const v = g.createRangeIn(d.content);
                            for (const _ of v.getItems()) _.is("element", "imageInline") && i.setImageNaturalSizeAttributes(_)
                        })
                    })
                }
            }

            class DB extends Re {
                static get requires() {
                    return [yB, mh, R_, Z_]
                }

                static get pluginName() {
                    return "ImageInline"
                }
            }

            class Q_ extends Re {
                static get pluginName() {
                    return "ImageCaptionUtils"
                }

                static get requires() {
                    return [hi]
                }

                getCaptionFromImageModelElement(e) {
                    for (const t of e.getChildren()) if (t && t.is("element", "caption")) return t;
                    return null
                }

                getCaptionFromModelSelection(e) {
                    const t = this.editor.plugins.get("ImageUtils"), n = e.getFirstPosition().findAncestor("caption");
                    return n && t.isBlockImage(n.parent) ? n : null
                }

                matchImageCaptionViewElement(e) {
                    const t = this.editor.plugins.get("ImageUtils");
                    return e.name == "figcaption" && t.isBlockImageView(e.parent) ? {name: !0} : null
                }
            }

            class xB extends Ft {
                refresh() {
                    const e = this.editor, t = e.plugins.get("ImageCaptionUtils"), n = e.plugins.get("ImageUtils");
                    if (!e.plugins.has(G_)) return this.isEnabled = !1, void (this.value = !1);
                    const i = e.model.document.selection, s = i.getSelectedElement();
                    if (!s) {
                        const l = t.getCaptionFromModelSelection(i);
                        return this.isEnabled = !!l, void (this.value = !!l)
                    }
                    this.isEnabled = n.isImage(s), this.isEnabled ? this.value = !!t.getCaptionFromImageModelElement(s) : this.value = !1
                }

                execute(e = {}) {
                    const {focusCaptionOnShow: t} = e;
                    this.editor.model.change(n => {
                        this.value ? this._hideImageCaption(n) : this._showImageCaption(n, t)
                    })
                }

                _showImageCaption(e, t) {
                    const n = this.editor.model.document.selection, i = this.editor.plugins.get("ImageCaptionEditing"),
                        s = this.editor.plugins.get("ImageUtils");
                    let l = n.getSelectedElement();
                    const d = i._getSavedCaption(l);
                    s.isInlineImage(l) && (this.editor.execute("imageTypeBlock"), l = n.getSelectedElement());
                    const g = d || e.createElement("caption");
                    e.append(g, l), t && e.setSelection(g, "in")
                }

                _hideImageCaption(e) {
                    const t = this.editor, n = t.model.document.selection, i = t.plugins.get("ImageCaptionEditing"),
                        s = t.plugins.get("ImageCaptionUtils");
                    let l, d = n.getSelectedElement();
                    d ? l = s.getCaptionFromImageModelElement(d) : (l = s.getCaptionFromModelSelection(n), d = l.parent), i._saveCaption(d, l), e.setSelection(d, "on"), e.remove(l)
                }
            }

            class EB extends Re {
                constructor(e) {
                    super(e), this._savedCaptionsMap = new WeakMap
                }

                static get requires() {
                    return [hi, Q_]
                }

                static get pluginName() {
                    return "ImageCaptionEditing"
                }

                init() {
                    const e = this.editor, t = e.model.schema;
                    t.isRegistered("caption") ? t.extend("caption", {allowIn: "imageBlock"}) : t.register("caption", {
                        allowIn: "imageBlock",
                        allowContentOf: "$block",
                        isLimit: !0
                    }), e.commands.add("toggleImageCaption", new xB(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion()
                }

                _setupConversion() {
                    const e = this.editor, t = e.editing.view, n = e.plugins.get("ImageUtils"),
                        i = e.plugins.get("ImageCaptionUtils"), s = e.t;
                    e.conversion.for("upcast").elementToElement({
                        view: l => i.matchImageCaptionViewElement(l),
                        model: "caption"
                    }), e.conversion.for("dataDowncast").elementToElement({
                        model: "caption",
                        view: (l, {writer: d}) => n.isBlockImage(l.parent) ? d.createContainerElement("figcaption") : null
                    }), e.conversion.for("editingDowncast").elementToElement({
                        model: "caption",
                        view: (l, {writer: d}) => {
                            if (!n.isBlockImage(l.parent)) return null;
                            const g = d.createEditableElement("figcaption");
                            d.setCustomProperty("imageCaption", !0, g), g.placeholder = s("Enter image caption"), Ld({
                                view: t,
                                element: g,
                                keepOnFocus: !0
                            });
                            const v = l.parent.getAttribute("alt");
                            return EC(g, d, {label: v ? s("Caption for image: %0", [v]) : s("Caption for the image")})
                        }
                    })
                }

                _setupImageTypeCommandsIntegration() {
                    const e = this.editor, t = e.plugins.get("ImageUtils"), n = e.plugins.get("ImageCaptionUtils"),
                        i = e.commands.get("imageTypeInline"), s = e.commands.get("imageTypeBlock"), l = d => {
                            if (!d.return) return;
                            const {oldElement: g, newElement: v} = d.return;
                            if (!g) return;
                            if (t.isBlockImage(g)) {
                                const x = n.getCaptionFromImageModelElement(g);
                                if (x) return void this._saveCaption(v, x)
                            }
                            const _ = this._getSavedCaption(g);
                            _ && this._saveCaption(v, _)
                        };
                    i && this.listenTo(i, "execute", l, {priority: "low"}), s && this.listenTo(s, "execute", l, {priority: "low"})
                }

                _getSavedCaption(e) {
                    const t = this._savedCaptionsMap.get(e);
                    return t ? pn.fromJSON(t) : null
                }

                _saveCaption(e, t) {
                    this._savedCaptionsMap.set(e, t.toJSON())
                }

                _registerCaptionReconversion() {
                    const e = this.editor, t = e.model, n = e.plugins.get("ImageUtils"),
                        i = e.plugins.get("ImageCaptionUtils");
                    t.document.on("change:data", () => {
                        const s = t.document.differ.getChanges();
                        for (const l of s) {
                            if (l.attributeKey !== "alt") continue;
                            const d = l.range.start.nodeAfter;
                            if (n.isBlockImage(d)) {
                                const g = i.getCaptionFromImageModelElement(d);
                                if (!g) return;
                                e.editing.reconvertItem(g)
                            }
                        }
                    })
                }
            }

            class SB extends Re {
                static get requires() {
                    return [Q_]
                }

                static get pluginName() {
                    return "ImageCaptionUI"
                }

                init() {
                    const e = this.editor, t = e.editing.view, n = e.plugins.get("ImageCaptionUtils"), i = e.t;
                    e.ui.componentFactory.add("toggleImageCaption", s => {
                        const l = e.commands.get("toggleImageCaption"), d = new sn(s);
                        return d.set({
                            icon: mn.caption,
                            tooltip: !0,
                            isToggleable: !0
                        }), d.bind("isOn", "isEnabled").to(l, "value", "isEnabled"), d.bind("label").to(l, "value", g => i(g ? "Toggle caption off" : "Toggle caption on")), this.listenTo(d, "execute", () => {
                            e.execute("toggleImageCaption", {focusCaptionOnShow: !0});
                            const g = n.getCaptionFromModelSelection(e.model.document.selection);
                            if (g) {
                                const v = e.editing.mapper.toViewElement(g);
                                t.scrollToTheSelection(), t.change(_ => {
                                    _.addClass("image__caption_highlighted", v)
                                })
                            }
                            e.editing.view.focus()
                        }), d
                    })
                }
            }

            var J_ = C(2640),
                TB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(J_.Z, TB), J_.Z.locals;

            function X_(r) {
                const e = r.map(t => t.replace("+", "\\+"));
                return new RegExp(`^image\\/(${e.join("|")})$`)
            }

            function IB(r) {
                return new Promise((e, t) => {
                    const n = r.getAttribute("src");
                    fetch(n).then(i => i.blob()).then(i => {
                        const s = e1(i, n), l = s.replace("image/", ""), d = new File([i], `image.${l}`, {type: s});
                        e(d)
                    }).catch(i => i && i.name === "TypeError" ? function (s) {
                        return function (l) {
                            return new Promise((d, g) => {
                                const v = bt.document.createElement("img");
                                v.addEventListener("load", () => {
                                    const _ = bt.document.createElement("canvas");
                                    _.width = v.width, _.height = v.height, _.getContext("2d").drawImage(v, 0, 0), _.toBlob(x => x ? d(x) : g())
                                }), v.addEventListener("error", () => g()), v.src = l
                            })
                        }(s).then(l => {
                            const d = e1(l, s), g = d.replace("image/", "");
                            return new File([l], `image.${g}`, {type: d})
                        })
                    }(n).then(e).catch(t) : t(i))
                })
            }

            function e1(r, e) {
                return r.type ? r.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg"
            }

            class MB extends Re {
                static get pluginName() {
                    return "ImageUploadUI"
                }

                init() {
                    const e = this.editor, t = e.t, n = i => {
                        const s = new uM(i), l = e.commands.get("uploadImage"), d = e.config.get("image.upload.types"),
                            g = X_(d);
                        return s.set({
                            acceptedType: d.map(v => `image/${v}`).join(","),
                            allowMultipleFiles: !0,
                            label: t("Upload image from computer"),
                            icon: mn.imageUpload,
                            tooltip: !0
                        }), s.bind("isEnabled").to(l), s.on("done", (v, _) => {
                            const x = Array.from(_).filter(M => g.test(M.type));
                            x.length && (e.execute("uploadImage", {file: x}), e.editing.view.focus())
                        }), s
                    };
                    if (e.ui.componentFactory.add("uploadImage", n), e.ui.componentFactory.add("imageUpload", n), e.plugins.has("ImageInsertUI")) {
                        const i = e.plugins.get("ImageInsertUI"), s = e.commands.get("uploadImage");
                        i.registerIntegration({
                            name: "upload", observable: s, buttonViewCreator: () => {
                                const l = e.ui.componentFactory.create("uploadImage");
                                return l.bind("label").to(i, "isImageSelected", d => t(d ? "Replace image from computer" : "Upload image from computer")), l
                            }, formViewCreator: () => {
                                const l = e.ui.componentFactory.create("uploadImage");
                                return l.withText = !0, l.bind("label").to(i, "isImageSelected", d => t(d ? "Replace from computer" : "Upload from computer")), l.on("execute", () => {
                                    i.dropdownView.isOpen = !1
                                }), l
                            }
                        })
                    }
                }
            }

            var t1 = C(3689),
                BB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(t1.Z, BB), t1.Z.locals;
            var n1 = C(4036),
                NB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(n1.Z, NB), n1.Z.locals;
            var r1 = C(3773),
                LB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(r1.Z, LB), r1.Z.locals;

            class PB extends Re {
                constructor(e) {
                    super(e), this.uploadStatusChange = (t, n, i) => {
                        const s = this.editor, l = n.item, d = l.getAttribute("uploadId");
                        if (!i.consumable.consume(n.item, t.name)) return;
                        const g = s.plugins.get("ImageUtils"), v = s.plugins.get(_o),
                            _ = d ? n.attributeNewValue : null, x = this.placeholder,
                            M = s.editing.mapper.toViewElement(l), O = i.writer;
                        if (_ == "reading") return i1(M, O), void o1(g, x, M, O);
                        if (_ == "uploading") {
                            const j = v.loaders.get(d);
                            return i1(M, O), void (j ? (s1(M, O), function (U, K, ne, pe) {
                                const Se = function (Je) {
                                    const wt = Je.createUIElement("div", {class: "ck-progress-bar"});
                                    return Je.setCustomProperty("progressBar", !0, wt), wt
                                }(K);
                                K.insert(K.createPositionAt(U, "end"), Se), ne.on("change:uploadedPercent", (Je, wt, qt) => {
                                    pe.change(Zt => {
                                        Zt.setStyle("width", qt + "%", Se)
                                    })
                                })
                            }(M, O, j, s.editing.view), function (U, K, ne, pe) {
                                if (pe.data) {
                                    const Se = U.findViewImgElement(K);
                                    ne.setAttribute("src", pe.data, Se)
                                }
                            }(g, M, O, j)) : o1(g, x, M, O))
                        }
                        _ == "complete" && v.loaders.get(d) && function (j, U, K) {
                            const ne = U.createUIElement("div", {class: "ck-image-upload-complete-icon"});
                            U.insert(U.createPositionAt(j, "end"), ne), setTimeout(() => {
                                K.change(pe => pe.remove(pe.createRangeOn(ne)))
                            }, 3e3)
                        }(M, O, s.editing.view), function (j, U) {
                            l1(j, U, "progressBar")
                        }(M, O), s1(M, O), function (j, U) {
                            U.removeClass("ck-appear", j)
                        }(M, O)
                    }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                }

                static get pluginName() {
                    return "ImageUploadProgress"
                }

                init() {
                    const e = this.editor;
                    e.plugins.has("ImageBlockEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), e.plugins.has("ImageInlineEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange)
                }
            }

            function i1(r, e) {
                r.hasClass("ck-appear") || e.addClass("ck-appear", r)
            }

            function o1(r, e, t, n) {
                t.hasClass("ck-image-upload-placeholder") || n.addClass("ck-image-upload-placeholder", t);
                const i = r.findViewImgElement(t);
                i.getAttribute("src") !== e && n.setAttribute("src", e, i), a1(t, "placeholder") || n.insert(n.createPositionAfter(i), function (s) {
                    const l = s.createUIElement("div", {class: "ck-upload-placeholder-loader"});
                    return s.setCustomProperty("placeholder", !0, l), l
                }(n))
            }

            function s1(r, e) {
                r.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", r), l1(r, e, "placeholder")
            }

            function a1(r, e) {
                for (const t of r.getChildren()) if (t.getCustomProperty(e)) return t
            }

            function l1(r, e, t) {
                const n = a1(r, t);
                n && e.remove(e.createRangeOn(n))
            }

            var OB = Object.defineProperty, FB = Object.defineProperties, RB = Object.getOwnPropertyDescriptors,
                c1 = Object.getOwnPropertySymbols, zB = Object.prototype.hasOwnProperty,
                jB = Object.prototype.propertyIsEnumerable, u1 = (r, e, t) => e in r ? OB(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t;

            class VB extends Ft {
                refresh() {
                    const e = this.editor, t = e.plugins.get("ImageUtils"),
                        n = e.model.document.selection.getSelectedElement();
                    this.isEnabled = t.isImageAllowed() || t.isImage(n)
                }

                execute(e) {
                    const t = qn(e.file), n = this.editor.model.document.selection,
                        i = this.editor.plugins.get("ImageUtils"), s = Object.fromEntries(n.getAttributes());
                    t.forEach((l, d) => {
                        const g = n.getSelectedElement();
                        if (d && g && i.isImage(g)) {
                            const v = this.editor.model.createPositionAfter(g);
                            this._uploadImage(l, s, v)
                        } else this._uploadImage(l, s)
                    })
                }

                _uploadImage(e, t, n) {
                    const i = this.editor, s = i.plugins.get(_o).createLoader(e), l = i.plugins.get("ImageUtils");
                    var d, g;
                    s && l.insertImage((d = ((v, _) => {
                        for (var x in _ || (_ = {})) zB.call(_, x) && u1(v, x, _[x]);
                        if (c1) for (var x of c1(_)) jB.call(_, x) && u1(v, x, _[x]);
                        return v
                    })({}, t), g = {uploadId: s.id}, FB(d, RB(g))), n)
                }
            }

            class HB extends Re {
                constructor(e) {
                    super(e), e.config.define("image", {upload: {types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]}}), this._uploadImageElements = new Map
                }

                static get requires() {
                    return [_o, Bb, es, hi]
                }

                static get pluginName() {
                    return "ImageUploadEditing"
                }

                init() {
                    const e = this.editor, t = e.model.document, n = e.conversion, i = e.plugins.get(_o),
                        s = e.plugins.get("ImageUtils"), l = e.plugins.get("ClipboardPipeline"),
                        d = X_(e.config.get("image.upload.types")), g = new VB(e);
                    e.commands.add("uploadImage", g), e.commands.add("imageUpload", g), n.for("upcast").attributeToAttribute({
                        view: {
                            name: "img",
                            key: "uploadId"
                        }, model: "uploadId"
                    }), this.listenTo(e.editing.view.document, "clipboardInput", (v, _) => {
                        if (x = _.dataTransfer, Array.from(x.types).includes("text/html") && x.getData("text/html") !== "") return;
                        var x;
                        const M = Array.from(_.dataTransfer.files).filter(O => !!O && d.test(O.type));
                        M.length && (v.stop(), e.model.change(O => {
                            _.targetRanges && O.setSelection(_.targetRanges.map(j => e.editing.mapper.toModelRange(j))), e.execute("uploadImage", {file: M})
                        }))
                    }), this.listenTo(l, "inputTransformation", (v, _) => {
                        const x = Array.from(e.editing.view.createRangeIn(_.content)).map(O => O.item).filter(O => function (j, U) {
                            return !(!j.isInlineImageView(U) || !U.getAttribute("src") || !U.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !U.getAttribute("src").match(/^blob:/g))
                        }(s, O) && !O.getAttribute("uploadProcessed")).map(O => ({promise: IB(O), imageElement: O}));
                        if (!x.length) return;
                        const M = new Ia(e.editing.view.document);
                        for (const O of x) {
                            M.setAttribute("uploadProcessed", !0, O.imageElement);
                            const j = i.createLoader(O.promise);
                            j && (M.setAttribute("src", "", O.imageElement), M.setAttribute("uploadId", j.id, O.imageElement))
                        }
                    }), e.editing.view.document.on("dragover", (v, _) => {
                        _.preventDefault()
                    }), t.on("change", () => {
                        const v = t.differ.getChanges({includeChangesInGraveyard: !0}).reverse(), _ = new Set;
                        for (const x of v) if (x.type == "insert" && x.name != "$text") {
                            const M = x.position.nodeAfter, O = x.position.root.rootName == "$graveyard";
                            for (const j of UB(e, M)) {
                                const U = j.getAttribute("uploadId");
                                if (!U) continue;
                                const K = i.loaders.get(U);
                                K && (O ? _.has(U) || K.abort() : (_.add(U), this._uploadImageElements.set(U, j), K.status == "idle" && this._readAndUpload(K)))
                            }
                        }
                    }), this.on("uploadComplete", (v, {imageElement: _, data: x}) => {
                        const M = x.urls ? x.urls : x;
                        this.editor.model.change(O => {
                            O.setAttribute("src", M.default, _), this._parseAndSetSrcsetAttributeOnImage(M, _, O), s.setImageNaturalSizeAttributes(_)
                        })
                    }, {priority: "low"})
                }

                afterInit() {
                    const e = this.editor.model.schema;
                    this.editor.plugins.has("ImageBlockEditing") && e.extend("imageBlock", {allowAttributes: ["uploadId", "uploadStatus"]}), this.editor.plugins.has("ImageInlineEditing") && e.extend("imageInline", {allowAttributes: ["uploadId", "uploadStatus"]})
                }

                _readAndUpload(e) {
                    const t = this.editor, n = t.model, i = t.locale.t, s = t.plugins.get(_o), l = t.plugins.get(Bb),
                        d = t.plugins.get("ImageUtils"), g = this._uploadImageElements;
                    return n.enqueueChange({isUndoable: !1}, _ => {
                        _.setAttribute("uploadStatus", "reading", g.get(e.id))
                    }), e.read().then(() => {
                        const _ = e.upload(), x = g.get(e.id);
                        if (T.isSafari) {
                            const M = t.editing.mapper.toViewElement(x), O = d.findViewImgElement(M);
                            t.editing.view.once("render", () => {
                                if (!O.parent) return;
                                const j = t.editing.view.domConverter.mapViewToDom(O.parent);
                                if (!j) return;
                                const U = j.style.display;
                                j.style.display = "none", j._ckHack = j.offsetHeight, j.style.display = U
                            })
                        }
                        return n.enqueueChange({isUndoable: !1}, M => {
                            M.setAttribute("uploadStatus", "uploading", x)
                        }), _
                    }).then(_ => {
                        n.enqueueChange({isUndoable: !1}, x => {
                            const M = g.get(e.id);
                            x.setAttribute("uploadStatus", "complete", M), this.fire("uploadComplete", {
                                data: _,
                                imageElement: M
                            })
                        }), v()
                    }).catch(_ => {
                        if (e.status !== "error" && e.status !== "aborted") throw _;
                        e.status == "error" && _ && l.showWarning(_, {
                            title: i("Upload failed"),
                            namespace: "upload"
                        }), n.enqueueChange({isUndoable: !1}, x => {
                            x.remove(g.get(e.id))
                        }), v()
                    });

                    function v() {
                        n.enqueueChange({isUndoable: !1}, _ => {
                            const x = g.get(e.id);
                            _.removeAttribute("uploadId", x), _.removeAttribute("uploadStatus", x), g.delete(e.id)
                        }), s.destroyLoader(e)
                    }
                }

                _parseAndSetSrcsetAttributeOnImage(e, t, n) {
                    let i = 0;
                    const s = Object.keys(e).filter(l => {
                        const d = parseInt(l, 10);
                        if (!isNaN(d)) return i = Math.max(i, d), !0
                    }).map(l => `${e[l]} ${l}w`).join(", ");
                    if (s != "") {
                        const l = {srcset: s};
                        t.hasAttribute("width") || t.hasAttribute("height") || (l.width = i), n.setAttributes(l, t)
                    }
                }
            }

            function UB(r, e) {
                const t = r.plugins.get("ImageUtils");
                return Array.from(r.model.createRangeOn(e)).filter(n => t.isImage(n.item)).map(n => n.item)
            }

            var d1 = C(6270),
                qB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(d1.Z, qB), d1.Z.locals;

            class WB extends Ft {
                constructor(e, t) {
                    super(e), this._defaultStyles = {
                        imageBlock: !1,
                        imageInline: !1
                    }, this._styles = new Map(t.map(n => {
                        if (n.isDefault) for (const i of n.modelElements) this._defaultStyles[i] = n.name;
                        return [n.name, n]
                    }))
                }

                refresh() {
                    const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
                    this.isEnabled = !!e, this.isEnabled ? e.hasAttribute("imageStyle") ? this.value = e.getAttribute("imageStyle") : this.value = this._defaultStyles[e.name] : this.value = !1
                }

                execute(e = {}) {
                    const t = this.editor, n = t.model, i = t.plugins.get("ImageUtils");
                    n.change(s => {
                        const l = e.value, {setImageSizes: d = !0} = e;
                        let g = i.getClosestSelectedImageElement(n.document.selection);
                        l && this.shouldConvertImageType(l, g) && (this.editor.execute(i.isBlockImage(g) ? "imageTypeInline" : "imageTypeBlock", {setImageSizes: d}), g = i.getClosestSelectedImageElement(n.document.selection)), !l || this._styles.get(l).isDefault ? s.removeAttribute("imageStyle", g) : s.setAttribute("imageStyle", l, g), d && i.setImageNaturalSizeAttributes(g)
                    })
                }

                shouldConvertImageType(e, t) {
                    return !this._styles.get(e).modelElements.includes(t.name)
                }
            }

            var $B = Object.defineProperty, h1 = Object.getOwnPropertySymbols, GB = Object.prototype.hasOwnProperty,
                KB = Object.prototype.propertyIsEnumerable, f1 = (r, e, t) => e in r ? $B(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, g1 = (r, e) => {
                    for (var t in e || (e = {})) GB.call(e, t) && f1(r, t, e[t]);
                    if (h1) for (var t of h1(e)) KB.call(e, t) && f1(r, t, e[t]);
                    return r
                };
            const {
                objectFullWidth: ZB,
                objectInline: p1,
                objectLeft: m1,
                objectRight: Yb,
                objectCenter: Qb,
                objectBlockLeft: b1,
                objectBlockRight: k1
            } = mn, np = {
                get inline() {
                    return {name: "inline", title: "In line", icon: p1, modelElements: ["imageInline"], isDefault: !0}
                }, get alignLeft() {
                    return {
                        name: "alignLeft",
                        title: "Left aligned image",
                        icon: m1,
                        modelElements: ["imageBlock", "imageInline"],
                        className: "image-style-align-left"
                    }
                }, get alignBlockLeft() {
                    return {
                        name: "alignBlockLeft",
                        title: "Left aligned image",
                        icon: b1,
                        modelElements: ["imageBlock"],
                        className: "image-style-block-align-left"
                    }
                }, get alignCenter() {
                    return {
                        name: "alignCenter",
                        title: "Centered image",
                        icon: Qb,
                        modelElements: ["imageBlock"],
                        className: "image-style-align-center"
                    }
                }, get alignRight() {
                    return {
                        name: "alignRight",
                        title: "Right aligned image",
                        icon: Yb,
                        modelElements: ["imageBlock", "imageInline"],
                        className: "image-style-align-right"
                    }
                }, get alignBlockRight() {
                    return {
                        name: "alignBlockRight",
                        title: "Right aligned image",
                        icon: k1,
                        modelElements: ["imageBlock"],
                        className: "image-style-block-align-right"
                    }
                }, get block() {
                    return {
                        name: "block",
                        title: "Centered image",
                        icon: Qb,
                        modelElements: ["imageBlock"],
                        isDefault: !0
                    }
                }, get side() {
                    return {
                        name: "side",
                        title: "Side image",
                        icon: Yb,
                        modelElements: ["imageBlock"],
                        className: "image-style-side"
                    }
                }
            }, v1 = {full: ZB, left: b1, right: k1, center: Qb, inlineLeft: m1, inlineRight: Yb, inline: p1}, w1 = [{
                name: "imageStyle:wrapText",
                title: "Wrap text",
                defaultItem: "imageStyle:alignLeft",
                items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
            }, {
                name: "imageStyle:breakText",
                title: "Break text",
                defaultItem: "imageStyle:block",
                items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
            }];

            function A1(r) {
                ae("image-style-configuration-definition-invalid", r)
            }

            const Jb = {
                normalizeStyles: function (r) {
                    return (r.configuredStyles.options || []).map(e => function (t) {
                        return t = typeof t == "string" ? np[t] ? g1({}, np[t]) : {name: t} : function (n, i) {
                            const s = g1({}, i);
                            for (const l in n) Object.prototype.hasOwnProperty.call(i, l) || (s[l] = n[l]);
                            return s
                        }(np[t.name], t), typeof t.icon == "string" && (t.icon = v1[t.icon] || t.icon), t
                    }(e)).filter(e => function (t, {isBlockPluginLoaded: n, isInlinePluginLoaded: i}) {
                        const {modelElements: s, name: l} = t;
                        if (!(s && s.length && l)) return A1({style: t}), !1;
                        {
                            const d = [n ? "imageBlock" : null, i ? "imageInline" : null];
                            if (!s.some(g => d.includes(g))) return ae("image-style-missing-dependency", {
                                style: t,
                                missingPlugins: s.map(g => g === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")
                            }), !1
                        }
                        return !0
                    }(e, r))
                }, getDefaultStylesConfiguration: function (r, e) {
                    return r && e ? {options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"]} : r ? {options: ["block", "side"]} : e ? {options: ["inline", "alignLeft", "alignRight"]} : {}
                }, getDefaultDropdownDefinitions: function (r) {
                    return r.has("ImageBlockEditing") && r.has("ImageInlineEditing") ? [...w1] : []
                }, warnInvalidStyle: A1, DEFAULT_OPTIONS: np, DEFAULT_ICONS: v1, DEFAULT_DROPDOWN_DEFINITIONS: w1
            };

            function C1(r, e) {
                for (const t of e) if (t.name === r) return t
            }

            class _1 extends Re {
                static get pluginName() {
                    return "ImageStyleEditing"
                }

                static get requires() {
                    return [hi]
                }

                init() {
                    const {normalizeStyles: e, getDefaultStylesConfiguration: t} = Jb, n = this.editor,
                        i = n.plugins.has("ImageBlockEditing"), s = n.plugins.has("ImageInlineEditing");
                    n.config.define("image.styles", t(i, s)), this.normalizedStyles = e({
                        configuredStyles: n.config.get("image.styles"),
                        isBlockPluginLoaded: i,
                        isInlinePluginLoaded: s
                    }), this._setupConversion(i, s), this._setupPostFixer(), n.commands.add("imageStyle", new WB(n, this.normalizedStyles))
                }

                _setupConversion(e, t) {
                    const n = this.editor, i = n.model.schema, s = (l = this.normalizedStyles, (g, v, _) => {
                        if (!_.consumable.consume(v.item, g.name)) return;
                        const x = C1(v.attributeNewValue, l), M = C1(v.attributeOldValue, l),
                            O = _.mapper.toViewElement(v.item), j = _.writer;
                        M && j.removeClass(M.className, O), x && j.addClass(x.className, O)
                    });
                    var l;
                    const d = function (g) {
                        const v = {
                            imageInline: g.filter(_ => !_.isDefault && _.modelElements.includes("imageInline")),
                            imageBlock: g.filter(_ => !_.isDefault && _.modelElements.includes("imageBlock"))
                        };
                        return (_, x, M) => {
                            if (!x.modelRange) return;
                            const O = x.viewItem, j = Wn(x.modelRange.getItems());
                            if (j && M.schema.checkAttribute(j, "imageStyle")) for (const U of v[j.name]) M.consumable.consume(O, {classes: U.className}) && M.writer.setAttribute("imageStyle", U.name, j)
                        }
                    }(this.normalizedStyles);
                    n.editing.downcastDispatcher.on("attribute:imageStyle", s), n.data.downcastDispatcher.on("attribute:imageStyle", s), e && (i.extend("imageBlock", {allowAttributes: "imageStyle"}), n.data.upcastDispatcher.on("element:figure", d, {priority: "low"})), t && (i.extend("imageInline", {allowAttributes: "imageStyle"}), n.data.upcastDispatcher.on("element:img", d, {priority: "low"}))
                }

                _setupPostFixer() {
                    const e = this.editor, t = e.model.document, n = e.plugins.get(hi),
                        i = new Map(this.normalizedStyles.map(s => [s.name, s]));
                    t.registerPostFixer(s => {
                        let l = !1;
                        for (const d of t.differ.getChanges()) if (d.type == "insert" || d.type == "attribute" && d.attributeKey == "imageStyle") {
                            let g = d.type == "insert" ? d.position.nodeAfter : d.range.start.nodeAfter;
                            if (g && g.is("element", "paragraph") && g.childCount > 0 && (g = g.getChild(0)), !n.isImage(g)) continue;
                            const v = g.getAttribute("imageStyle");
                            if (!v) continue;
                            const _ = i.get(v);
                            _ && _.modelElements.includes(g.name) || (s.removeAttribute("imageStyle", g), l = !0)
                        }
                        return l
                    })
                }
            }

            var y1 = C(5083),
                YB = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(y1.Z, YB), y1.Z.locals;

            class QB extends Re {
                static get requires() {
                    return [_1]
                }

                static get pluginName() {
                    return "ImageStyleUI"
                }

                get localizedDefaultStylesTitles() {
                    const e = this.editor.t;
                    return {
                        "Wrap text": e("Wrap text"),
                        "Break text": e("Break text"),
                        "In line": e("In line"),
                        "Full size image": e("Full size image"),
                        "Side image": e("Side image"),
                        "Left aligned image": e("Left aligned image"),
                        "Centered image": e("Centered image"),
                        "Right aligned image": e("Right aligned image")
                    }
                }

                init() {
                    const e = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [],
                        n = D1(e.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
                    for (const s of n) this._createButton(s);
                    const i = D1([...t.filter(Oe), ...Jb.getDefaultDropdownDefinitions(e)], this.localizedDefaultStylesTitles);
                    for (const s of i) this._createDropdown(s, n)
                }

                _createDropdown(e, t) {
                    const n = this.editor.ui.componentFactory;
                    n.add(e.name, i => {
                        let s;
                        const {defaultItem: l, items: d, title: g} = e,
                            v = d.filter(O => t.find(({name: j}) => x1(j) === O)).map(O => {
                                const j = n.create(O);
                                return O === l && (s = j), j
                            });
                        d.length !== v.length && Jb.warnInvalidStyle({dropdown: e});
                        const _ = Ns(i, Ng), x = _.buttonView, M = x.arrowView;
                        return Ab(_, v, {enableActiveItemFocusOnDropdownOpen: !0}), x.set({
                            label: E1(g, s.label),
                            class: null,
                            tooltip: !0
                        }), M.unbind("label"), M.set({label: g}), x.bind("icon").toMany(v, "isOn", (...O) => {
                            const j = O.findIndex(xs);
                            return j < 0 ? s.icon : v[j].icon
                        }), x.bind("label").toMany(v, "isOn", (...O) => {
                            const j = O.findIndex(xs);
                            return E1(g, j < 0 ? s.label : v[j].label)
                        }), x.bind("isOn").toMany(v, "isOn", (...O) => O.some(xs)), x.bind("class").toMany(v, "isOn", (...O) => O.some(xs) ? "ck-splitbutton_flatten" : void 0), x.on("execute", () => {
                            v.some(({isOn: O}) => O) ? _.isOpen = !_.isOpen : s.fire("execute")
                        }), _.bind("isEnabled").toMany(v, "isEnabled", (...O) => O.some(xs)), this.listenTo(_, "execute", () => {
                            this.editor.editing.view.focus()
                        }), _
                    })
                }

                _createButton(e) {
                    const t = e.name;
                    this.editor.ui.componentFactory.add(x1(t), n => {
                        const i = this.editor.commands.get("imageStyle"), s = new sn(n);
                        return s.set({
                            label: e.title,
                            icon: e.icon,
                            tooltip: !0,
                            isToggleable: !0
                        }), s.bind("isEnabled").to(i, "isEnabled"), s.bind("isOn").to(i, "value", l => l === t), s.on("execute", this._executeCommand.bind(this, t)), s
                    })
                }

                _executeCommand(e) {
                    this.editor.execute("imageStyle", {value: e}), this.editor.editing.view.focus()
                }
            }

            function D1(r, e) {
                for (const t of r) e[t.title] && (t.title = e[t.title]);
                return r
            }

            function x1(r) {
                return `imageStyle:${r}`
            }

            function E1(r, e) {
                return (r ? r + ": " : "") + e
            }

            class JB extends Re {
                static get pluginName() {
                    return "IndentEditing"
                }

                init() {
                    const e = this.editor;
                    e.commands.add("indent", new ag(e)), e.commands.add("outdent", new ag(e))
                }
            }

            const S1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
                T1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';

            class XB extends Re {
                static get pluginName() {
                    return "IndentUI"
                }

                init() {
                    const e = this.editor, t = e.locale, n = e.t, i = t.uiLanguageDirection == "ltr" ? S1 : T1,
                        s = t.uiLanguageDirection == "ltr" ? T1 : S1;
                    this._defineButton("indent", n("Increase indent"), i), this._defineButton("outdent", n("Decrease indent"), s)
                }

                _defineButton(e, t, n) {
                    const i = this.editor;
                    i.ui.componentFactory.add(e, s => {
                        const l = i.commands.get(e), d = new sn(s);
                        return d.set({
                            label: t,
                            icon: n,
                            tooltip: !0
                        }), d.bind("isEnabled").to(l, "isEnabled"), this.listenTo(d, "execute", () => {
                            i.execute(e), i.editing.view.focus()
                        }), d
                    })
                }
            }

            class e4 {
                constructor() {
                    this._definitions = new Set
                }

                get length() {
                    return this._definitions.size
                }

                add(e) {
                    Array.isArray(e) ? e.forEach(t => this._definitions.add(t)) : this._definitions.add(e)
                }

                getDispatcher() {
                    return e => {
                        e.on("attribute:linkHref", (t, n, i) => {
                            if (!i.consumable.test(n.item, "attribute:linkHref") || !n.item.is("selection") && !i.schema.isInline(n.item)) return;
                            const s = i.writer, l = s.document.selection;
                            for (const d of this._definitions) {
                                const g = s.createAttributeElement("a", d.attributes, {priority: 5});
                                d.classes && s.addClass(d.classes, g);
                                for (const v in d.styles) s.setStyle(v, d.styles[v], g);
                                s.setCustomProperty("link", !0, g), d.callback(n.attributeNewValue) ? n.item.is("selection") ? s.wrap(l.getFirstRange(), g) : s.wrap(i.mapper.toViewRange(n.range), g) : s.unwrap(i.mapper.toViewRange(n.range), g)
                            }
                        }, {priority: "high"})
                    }
                }

                getDispatcherForLinkedImage() {
                    return e => {
                        e.on("attribute:linkHref:imageBlock", (t, n, {writer: i, mapper: s}) => {
                            const l = s.toViewElement(n.item),
                                d = Array.from(l.getChildren()).find(g => g.is("element", "a"));
                            for (const g of this._definitions) {
                                const v = qi(g.attributes);
                                if (g.callback(n.attributeNewValue)) {
                                    for (const [_, x] of v) _ === "class" ? i.addClass(x, d) : i.setAttribute(_, x, d);
                                    g.classes && i.addClass(g.classes, d);
                                    for (const _ in g.styles) i.setStyle(_, g.styles[_], d)
                                } else {
                                    for (const [_, x] of v) _ === "class" ? i.removeClass(x, d) : i.removeAttribute(_, d);
                                    g.classes && i.removeClass(g.classes, d);
                                    for (const _ in g.styles) i.removeStyle(_, d)
                                }
                            }
                        })
                    }
                }
            }

            const t4 = function (r, e, t) {
                var n = r.length;
                return t = t === void 0 ? n : t, !e && t >= n ? r : Bl(r, e, t)
            };
            var n4 = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
            const I1 = function (r) {
                return n4.test(r)
            }, r4 = function (r) {
                return r.split("")
            };
            var M1 = "\\ud800-\\udfff", i4 = "[" + M1 + "]", Xb = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
                ek = "\\ud83c[\\udffb-\\udfff]", B1 = "[^" + M1 + "]", N1 = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                L1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", P1 = "(?:" + Xb + "|" + ek + ")?", O1 = "[\\ufe0e\\ufe0f]?",
                o4 = O1 + P1 + ("(?:\\u200d(?:" + [B1, N1, L1].join("|") + ")" + O1 + P1 + ")*"),
                s4 = "(?:" + [B1 + Xb + "?", Xb, N1, L1, i4].join("|") + ")",
                a4 = RegExp(ek + "(?=" + ek + ")|" + s4 + o4, "g");
            const l4 = function (r) {
                    return r.match(a4) || []
                }, c4 = function (r) {
                    return I1(r) ? l4(r) : r4(r)
                }, u4 = function (r) {
                    return function (e) {
                        e = Pd(e);
                        var t = I1(e) ? c4(e) : void 0, n = t ? t[0] : e.charAt(0), i = t ? t4(t, 1).join("") : e.slice(1);
                        return n[r]() + i
                    }
                }("toUpperCase"), d4 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
                h4 = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,
                f4 = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,
                g4 = /^((\w+:(\/{2,})?)|(\W))/i, tk = "Ctrl+K";

            function F1(r, {writer: e}) {
                const t = e.createAttributeElement("a", {href: r}, {priority: 5});
                return e.setCustomProperty("link", !0, t), t
            }

            function R1(r) {
                const e = String(r);
                return function (t) {
                    return !!t.replace(d4, "").match(h4)
                }(e) ? e : "#"
            }

            function nk(r, e) {
                return !!r && e.checkAttribute(r.name, "linkHref")
            }

            function rk(r, e) {
                const t = (n = r, f4.test(n) ? "mailto:" : e);
                var n;
                const i = !!t && !z1(r);
                return r && i ? t + r : r
            }

            function z1(r) {
                return g4.test(r)
            }

            function j1(r) {
                window.open(r, "_blank", "noopener")
            }

            class p4 extends Ft {
                constructor() {
                    super(...arguments), this.manualDecorators = new br, this.automaticDecorators = new e4
                }

                restoreManualDecoratorStates() {
                    for (const e of this.manualDecorators) e.value = this._getDecoratorStateFromModel(e.id)
                }

                refresh() {
                    const e = this.editor.model, t = e.document.selection,
                        n = t.getSelectedElement() || Wn(t.getSelectedBlocks());
                    nk(n, e.schema) ? (this.value = n.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttribute(n, "linkHref")) : (this.value = t.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
                    for (const i of this.manualDecorators) i.value = this._getDecoratorStateFromModel(i.id)
                }

                execute(e, t = {}) {
                    const n = this.editor.model, i = n.document.selection, s = [], l = [];
                    for (const d in t) t[d] ? s.push(d) : l.push(d);
                    n.change(d => {
                        if (i.isCollapsed) {
                            const g = i.getFirstPosition();
                            if (i.hasAttribute("linkHref")) {
                                const v = V1(i);
                                let _ = Wg(g, "linkHref", i.getAttribute("linkHref"), n);
                                i.getAttribute("linkHref") === v && (_ = this._updateLinkContent(n, d, _, e)), d.setAttribute("linkHref", e, _), s.forEach(x => {
                                    d.setAttribute(x, !0, _)
                                }), l.forEach(x => {
                                    d.removeAttribute(x, _)
                                }), d.setSelection(d.createPositionAfter(_.end.nodeBefore))
                            } else if (e !== "") {
                                const v = qi(i.getAttributes());
                                v.set("linkHref", e), s.forEach(x => {
                                    v.set(x, !0)
                                });
                                const {end: _} = n.insertContent(d.createText(e, v), g);
                                d.setSelection(_)
                            }
                            ["linkHref", ...s, ...l].forEach(v => {
                                d.removeSelectionAttribute(v)
                            })
                        } else {
                            const g = n.schema.getValidRanges(i.getRanges(), "linkHref"), v = [];
                            for (const x of i.getSelectedBlocks()) n.schema.checkAttribute(x, "linkHref") && v.push(d.createRangeOn(x));
                            const _ = v.slice();
                            for (const x of g) this._isRangeToUpdate(x, v) && _.push(x);
                            for (const x of _) {
                                let M = x;
                                if (_.length === 1) {
                                    const O = V1(i);
                                    i.getAttribute("linkHref") === O && (M = this._updateLinkContent(n, d, x, e), d.setSelection(d.createSelection(M)))
                                }
                                d.setAttribute("linkHref", e, M), s.forEach(O => {
                                    d.setAttribute(O, !0, M)
                                }), l.forEach(O => {
                                    d.removeAttribute(O, M)
                                })
                            }
                        }
                    })
                }

                _getDecoratorStateFromModel(e) {
                    const t = this.editor.model, n = t.document.selection, i = n.getSelectedElement();
                    return nk(i, t.schema) ? i.getAttribute(e) : n.getAttribute(e)
                }

                _isRangeToUpdate(e, t) {
                    for (const n of t) if (n.containsRange(e)) return !1;
                    return !0
                }

                _updateLinkContent(e, t, n, i) {
                    const s = t.createText(i, {linkHref: i});
                    return e.insertContent(s, n)
                }
            }

            function V1(r) {
                if (r.isCollapsed) {
                    const e = r.getFirstPosition();
                    return e.textNode && e.textNode.data
                }
                {
                    const e = Array.from(r.getFirstRange().getItems());
                    if (e.length > 1) return null;
                    const t = e[0];
                    return t.is("$text") || t.is("$textProxy") ? t.data : null
                }
            }

            class m4 extends Ft {
                refresh() {
                    const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement();
                    nk(n, e.schema) ? this.isEnabled = e.schema.checkAttribute(n, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref")
                }

                execute() {
                    const e = this.editor, t = this.editor.model, n = t.document.selection, i = e.commands.get("link");
                    t.change(s => {
                        const l = n.isCollapsed ? [Wg(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), t)] : t.schema.getValidRanges(n.getRanges(), "linkHref");
                        for (const d of l) if (s.removeAttribute("linkHref", d), i) for (const g of i.manualDecorators) s.removeAttribute(g.id, d)
                    })
                }
            }

            class b4 extends we() {
                constructor({id: e, label: t, attributes: n, classes: i, styles: s, defaultValue: l}) {
                    super(), this.id = e, this.set("value", void 0), this.defaultValue = l, this.label = t, this.attributes = n, this.classes = i, this.styles = s
                }

                _createPattern() {
                    return {attributes: this.attributes, classes: this.classes, styles: this.styles}
                }
            }

            var H1 = C(9773),
                k4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(H1.Z, k4), H1.Z.locals;
            var v4 = Object.defineProperty, U1 = Object.getOwnPropertySymbols, w4 = Object.prototype.hasOwnProperty,
                A4 = Object.prototype.propertyIsEnumerable, q1 = (r, e, t) => e in r ? v4(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, C4 = (r, e) => {
                    for (var t in e || (e = {})) w4.call(e, t) && q1(r, t, e[t]);
                    if (U1) for (var t of U1(e)) A4.call(e, t) && q1(r, t, e[t]);
                    return r
                };
            const W1 = "automatic", _4 = /^(https?:)?\/\//;

            class $1 extends Re {
                static get pluginName() {
                    return "LinkEditing"
                }

                static get requires() {
                    return [mC, cC, es]
                }

                constructor(e) {
                    super(e), e.config.define("link", {addTargetToExternalLinks: !1})
                }

                init() {
                    const e = this.editor;
                    e.model.schema.extend("$text", {allowAttributes: "linkHref"}), e.conversion.for("dataDowncast").attributeToElement({
                        model: "linkHref",
                        view: F1
                    }), e.conversion.for("editingDowncast").attributeToElement({
                        model: "linkHref",
                        view: (n, i) => F1(R1(n), i)
                    }), e.conversion.for("upcast").elementToAttribute({
                        view: {name: "a", attributes: {href: !0}},
                        model: {key: "linkHref", value: n => n.getAttribute("href")}
                    }), e.commands.add("link", new p4(e)), e.commands.add("unlink", new m4(e));
                    const t = function (n, i) {
                        const s = {"Open in a new tab": n("Open in a new tab"), Downloadable: n("Downloadable")};
                        return i.forEach(l => ("label" in l && s[l.label] && (l.label = s[l.label]), l)), i
                    }(e.t, function (n) {
                        const i = [];
                        if (n) for (const [s, l] of Object.entries(n)) {
                            const d = Object.assign({}, l, {id: `link${u4(s)}`});
                            i.push(d)
                        }
                        return i
                    }(e.config.get("link.decorators")));
                    this._enableAutomaticDecorators(t.filter(n => n.mode === W1)), this._enableManualDecorators(t.filter(n => n.mode === "manual")), e.plugins.get(mC).registerAttribute("linkHref"), function (n, i, s, l) {
                        const d = n.editing.view, g = new Set;
                        d.document.registerPostFixer(v => {
                            const _ = n.model.document.selection;
                            let x = !1;
                            if (_.hasAttribute(i)) {
                                const M = Wg(_.getFirstPosition(), i, _.getAttribute(i), n.model),
                                    O = n.editing.mapper.toViewRange(M);
                                for (const j of O.getItems()) j.is("element", s) && !j.hasClass(l) && (v.addClass(l, j), g.add(j), x = !0)
                            }
                            return x
                        }), n.conversion.for("editingDowncast").add(v => {
                            function _() {
                                d.change(x => {
                                    for (const M of g.values()) x.removeClass(l, M), g.delete(M)
                                })
                            }

                            v.on("insert", _, {priority: "highest"}), v.on("remove", _, {priority: "highest"}), v.on("attribute", _, {priority: "highest"}), v.on("selection", _, {priority: "highest"})
                        })
                    }(e, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableSelectionAttributesFixer(), this._enableClipboardIntegration()
                }

                _enableAutomaticDecorators(e) {
                    const t = this.editor, n = t.commands.get("link").automaticDecorators;
                    t.config.get("link.addTargetToExternalLinks") && n.add({
                        id: "linkIsExternal",
                        mode: W1,
                        callback: i => !!i && _4.test(i),
                        attributes: {target: "_blank", rel: "noopener noreferrer"}
                    }), n.add(e), n.length && t.conversion.for("downcast").add(n.getDispatcher())
                }

                _enableManualDecorators(e) {
                    if (!e.length) return;
                    const t = this.editor, n = t.commands.get("link").manualDecorators;
                    e.forEach(i => {
                        t.model.schema.extend("$text", {allowAttributes: i.id});
                        const s = new b4(i);
                        n.add(s), t.conversion.for("downcast").attributeToElement({
                            model: s.id,
                            view: (l, {writer: d, schema: g}, {item: v}) => {
                                if ((v.is("selection") || g.isInline(v)) && l) {
                                    const _ = d.createAttributeElement("a", s.attributes, {priority: 5});
                                    s.classes && d.addClass(s.classes, _);
                                    for (const x in s.styles) d.setStyle(x, s.styles[x], _);
                                    return d.setCustomProperty("link", !0, _), _
                                }
                            }
                        }), t.conversion.for("upcast").elementToAttribute({
                            view: C4({name: "a"}, s._createPattern()),
                            model: {key: s.id}
                        })
                    })
                }

                _enableLinkOpen() {
                    const e = this.editor, t = e.editing.view.document;
                    this.listenTo(t, "click", (n, i) => {
                        if (!(T.isMac ? i.domEvent.metaKey : i.domEvent.ctrlKey)) return;
                        let s = i.domTarget;
                        if (s.tagName.toLowerCase() != "a" && (s = s.closest("a")), !s) return;
                        const l = s.getAttribute("href");
                        l && (n.stop(), i.preventDefault(), j1(l))
                    }, {context: "$capture"}), this.listenTo(t, "keydown", (n, i) => {
                        const s = e.commands.get("link").value;
                        s && i.keyCode === Ut.enter && i.altKey && (n.stop(), j1(s))
                    })
                }

                _enableSelectionAttributesFixer() {
                    const e = this.editor.model, t = e.document.selection;
                    this.listenTo(t, "change:attribute", (n, {attributeKeys: i}) => {
                        i.includes("linkHref") && !t.hasAttribute("linkHref") && e.change(s => {
                            var l;
                            (function (d, g) {
                                d.removeSelectionAttribute("linkHref");
                                for (const v of g) d.removeSelectionAttribute(v)
                            })(s, (l = e.schema, l.getDefinition("$text").allowAttributes.filter(d => d.startsWith("link"))))
                        })
                    })
                }

                _enableClipboardIntegration() {
                    const e = this.editor, t = e.model, n = this.editor.config.get("link.defaultProtocol");
                    n && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (i, s) => {
                        t.change(l => {
                            const d = l.createRangeIn(s.content);
                            for (const g of d.getItems()) if (g.hasAttribute("linkHref")) {
                                const v = rk(g.getAttribute("linkHref"), n);
                                l.setAttribute("linkHref", v, g)
                            }
                        })
                    })
                }
            }

            var G1 = C(7754),
                y4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(G1.Z, y4), G1.Z.locals;

            class D4 extends It {
                constructor(e, t) {
                    super(e), this.focusTracker = new Nr, this.keystrokes = new si, this._focusables = new un;
                    const n = e.t;
                    this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n("Save"), mn.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n("Cancel"), mn.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t), this.children = this._createFormChildren(t.manualDecorators), this._focusCycler = new yn({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                    });
                    const i = ["ck", "ck-link-form", "ck-responsive-form"];
                    t.manualDecorators.length && i.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({
                        tag: "form",
                        attributes: {class: i, tabindex: "-1"},
                        children: this.children
                    })
                }

                getDecoratorSwitchesState() {
                    return Array.from(this._manualDecoratorSwitches).reduce((e, t) => (e[t.name] = t.isOn, e), {})
                }

                render() {
                    super.render(), w({view: this}), [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach(e => {
                        this._focusables.add(e), this.focusTracker.add(e.element)
                    }), this.keystrokes.listenTo(this.element)
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }

                focus() {
                    this._focusCycler.focusFirst()
                }

                _createUrlInput() {
                    const e = this.locale.t, t = new Xc(this.locale, Lg);
                    return t.label = e("Link URL"), t
                }

                _createButton(e, t, n, i) {
                    const s = new sn(this.locale);
                    return s.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }), s.extendTemplate({attributes: {class: n}}), i && s.delegate("execute").to(this, i), s
                }

                _createManualDecoratorSwitches(e) {
                    const t = this.createCollection();
                    for (const n of e.manualDecorators) {
                        const i = new _l(this.locale);
                        i.set({
                            name: n.id,
                            label: n.label,
                            withText: !0
                        }), i.bind("isOn").toMany([n, e], "value", (s, l) => l === void 0 && s === void 0 ? !!n.defaultValue : !!s), i.on("execute", () => {
                            n.set("value", !i.isOn)
                        }), t.add(i)
                    }
                    return t
                }

                _createFormChildren(e) {
                    const t = this.createCollection();
                    if (t.add(this.urlInputView), e.length) {
                        const n = new It;
                        n.setTemplate({
                            tag: "ul",
                            children: this._manualDecoratorSwitches.map(i => ({
                                tag: "li",
                                children: [i],
                                attributes: {class: ["ck", "ck-list__item"]}
                            })),
                            attributes: {class: ["ck", "ck-reset", "ck-list"]}
                        }), t.add(n)
                    }
                    return t.add(this.saveButtonView), t.add(this.cancelButtonView), t
                }
            }

            var K1 = C(2347),
                x4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(K1.Z, x4), K1.Z.locals;

            class E4 extends It {
                constructor(e) {
                    super(e), this.focusTracker = new Nr, this.keystrokes = new si, this._focusables = new un;
                    const t = e.t;
                    this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(t("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(t("Edit link"), mn.pencil, "edit"), this.set("href", void 0), this._focusCycler = new yn({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                    }), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1"},
                        children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
                    })
                }

                render() {
                    super.render(), [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach(e => {
                        this._focusables.add(e), this.focusTracker.add(e.element)
                    }), this.keystrokes.listenTo(this.element)
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }

                focus() {
                    this._focusCycler.focusFirst()
                }

                _createButton(e, t, n) {
                    const i = new sn(this.locale);
                    return i.set({label: e, icon: t, tooltip: !0}), i.delegate("execute").to(this, n), i
                }

                _createPreviewButton() {
                    const e = new sn(this.locale), t = this.bindTemplate, n = this.t;
                    return e.set({
                        withText: !0,
                        tooltip: n("Open link in new tab")
                    }), e.extendTemplate({
                        attributes: {
                            class: ["ck", "ck-link-actions__preview"],
                            href: t.to("href", i => i && R1(i)),
                            target: "_blank",
                            rel: "noopener noreferrer"
                        }
                    }), e.bind("label").to(this, "href", i => i || n("This link has no URL")), e.bind("isEnabled").to(this, "href", i => !!i), e.template.tag = "a", e.template.eventListeners = {}, e
                }
            }

            const ts = "link-ui";

            class S4 extends Re {
                constructor() {
                    super(...arguments), this.actionsView = null, this.formView = null
                }

                static get requires() {
                    return [jg]
                }

                static get pluginName() {
                    return "LinkUI"
                }

                init() {
                    const e = this.editor;
                    e.editing.view.addObserver(O3), this._balloon = e.plugins.get(jg), this._createToolbarLinkButton(), this._enableBalloonActivators(), e.conversion.for("editingDowncast").markerToHighlight({
                        model: ts,
                        view: {classes: ["ck-fake-link-selection"]}
                    }), e.conversion.for("editingDowncast").markerToElement({
                        model: ts,
                        view: {name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]}
                    })
                }

                destroy() {
                    super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy()
                }

                _createViews() {
                    this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions()
                }

                _createActionsView() {
                    const e = this.editor, t = new E4(e.locale), n = e.commands.get("link"),
                        i = e.commands.get("unlink");
                    return t.bind("href").to(n, "value"), t.editButtonView.bind("isEnabled").to(n), t.unlinkButtonView.bind("isEnabled").to(i), this.listenTo(t, "edit", () => {
                        this._addFormView()
                    }), this.listenTo(t, "unlink", () => {
                        e.execute("unlink"), this._hideUI()
                    }), t.keystrokes.set("Esc", (s, l) => {
                        this._hideUI(), l()
                    }), t.keystrokes.set(tk, (s, l) => {
                        this._addFormView(), l()
                    }), t
                }

                _createFormView() {
                    const e = this.editor, t = e.commands.get("link"), n = e.config.get("link.defaultProtocol"),
                        i = new (y(D4))(e.locale, t);
                    return i.urlInputView.fieldView.bind("value").to(t, "value"), i.urlInputView.bind("isEnabled").to(t, "isEnabled"), i.saveButtonView.bind("isEnabled").to(t), this.listenTo(i, "submit", () => {
                        const {value: s} = i.urlInputView.fieldView.element, l = rk(s, n);
                        e.execute("link", l, i.getDecoratorSwitchesState()), this._closeFormView()
                    }), this.listenTo(i, "cancel", () => {
                        this._closeFormView()
                    }), i.keystrokes.set("Esc", (s, l) => {
                        this._closeFormView(), l()
                    }), i
                }

                _createToolbarLinkButton() {
                    const e = this.editor, t = e.commands.get("link"), n = e.t;
                    e.ui.componentFactory.add("link", i => {
                        const s = new sn(i);
                        return s.isEnabled = !0, s.label = n("Link"), s.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', s.keystroke = tk, s.tooltip = !0, s.isToggleable = !0, s.bind("isEnabled").to(t, "isEnabled"), s.bind("isOn").to(t, "value", l => !!l), this.listenTo(s, "execute", () => this._showUI(!0)), s
                    })
                }

                _enableBalloonActivators() {
                    const e = this.editor, t = e.editing.view.document;
                    this.listenTo(t, "click", () => {
                        this._getSelectedLinkElement() && this._showUI()
                    }), e.keystrokes.set(tk, (n, i) => {
                        i(), e.commands.get("link").isEnabled && this._showUI(!0)
                    })
                }

                _enableUserBalloonInteractions() {
                    this.editor.keystrokes.set("Tab", (e, t) => {
                        this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), t())
                    }, {priority: "high"}), this.editor.keystrokes.set("Esc", (e, t) => {
                        this._isUIVisible && (this._hideUI(), t())
                    }), A({
                        emitter: this.formView,
                        activator: () => this._isUIInPanel,
                        contextElements: () => [this._balloon.view.element],
                        callback: () => this._hideUI()
                    })
                }

                _addActionsView() {
                    this.actionsView || this._createViews(), this._areActionsInPanel || this._balloon.add({
                        view: this.actionsView,
                        position: this._getBalloonPositionData()
                    })
                }

                _addFormView() {
                    if (this.formView || this._createViews(), this._isFormInPanel) return;
                    const e = this.editor.commands.get("link");
                    this.formView.disableCssTransitions(), this._balloon.add({
                        view: this.formView,
                        position: this._getBalloonPositionData()
                    }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = e.value || ""
                }

                _closeFormView() {
                    const e = this.editor.commands.get("link");
                    e.restoreManualDecoratorStates(), e.value !== void 0 ? this._removeFormView() : this._hideUI()
                }

                _removeFormView() {
                    this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection())
                }

                _showUI(e = !1) {
                    this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), e && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI()
                }

                _hideUI() {
                    if (!this._isUIInPanel) return;
                    const e = this.editor;
                    this.stopListening(e.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection()
                }

                _startUpdatingUI() {
                    const e = this.editor, t = e.editing.view.document;
                    let n = this._getSelectedLinkElement(), i = l();
                    const s = () => {
                        const d = this._getSelectedLinkElement(), g = l();
                        n && !d || !n && g !== i ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n = d, i = g
                    };

                    function l() {
                        return t.selection.focus.getAncestors().reverse().find(d => d.is("element"))
                    }

                    this.listenTo(e.ui, "update", s), this.listenTo(this._balloon, "change:visibleView", s)
                }

                get _isFormInPanel() {
                    return !!this.formView && this._balloon.hasView(this.formView)
                }

                get _areActionsInPanel() {
                    return !!this.actionsView && this._balloon.hasView(this.actionsView)
                }

                get _areActionsVisible() {
                    return !!this.actionsView && this._balloon.visibleView === this.actionsView
                }

                get _isUIInPanel() {
                    return this._isFormInPanel || this._areActionsInPanel
                }

                get _isUIVisible() {
                    const e = this._balloon.visibleView;
                    return !!this.formView && e == this.formView || this._areActionsVisible
                }

                _getBalloonPositionData() {
                    const e = this.editor.editing.view, t = this.editor.model, n = e.document;
                    let i;
                    if (t.markers.has(ts)) {
                        const s = Array.from(this.editor.editing.mapper.markerNameToElements(ts)),
                            l = e.createRange(e.createPositionBefore(s[0]), e.createPositionAfter(s[s.length - 1]));
                        i = e.domConverter.viewRangeToDom(l)
                    } else i = () => {
                        const s = this._getSelectedLinkElement();
                        return s ? e.domConverter.mapViewToDom(s) : e.domConverter.viewRangeToDom(n.selection.getFirstRange())
                    };
                    return {target: i}
                }

                _getSelectedLinkElement() {
                    const e = this.editor.editing.view, t = e.document.selection, n = t.getSelectedElement();
                    if (t.isCollapsed || n && wr(n)) return ik(t.getFirstPosition());
                    {
                        const i = t.getFirstRange().getTrimmed(), s = ik(i.start), l = ik(i.end);
                        return s && s == l && e.createRangeIn(s).getTrimmed().isEqual(i) ? s : null
                    }
                }

                _showFakeVisualSelection() {
                    const e = this.editor.model;
                    e.change(t => {
                        const n = e.document.selection.getFirstRange();
                        if (e.markers.has(ts)) t.updateMarker(ts, {range: n}); else if (n.start.isAtEnd) {
                            const i = n.start.getLastMatchingPosition(({item: s}) => !e.schema.isContent(s), {boundaries: n});
                            t.addMarker(ts, {usingOperation: !1, affectsData: !1, range: t.createRange(i, n.end)})
                        } else t.addMarker(ts, {usingOperation: !1, affectsData: !1, range: n})
                    })
                }

                _hideFakeVisualSelection() {
                    const e = this.editor.model;
                    e.markers.has(ts) && e.change(t => {
                        t.removeMarker(ts)
                    })
                }
            }

            function ik(r) {
                return r.getAncestors().find(e => {
                    return (t = e).is("attributeElement") && !!t.getCustomProperty("link");
                    var t
                }) || null
            }

            const Z1 = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");

            class T4 extends Re {
                static get requires() {
                    return [Ls, $1]
                }

                static get pluginName() {
                    return "AutoLink"
                }

                init() {
                    const e = this.editor.model.document.selection;
                    e.on("change:range", () => {
                        this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
                    }), this._enableTypingHandling()
                }

                afterInit() {
                    this._enableEnterHandling(), this._enableShiftEnterHandling(), this._enablePasteLinking()
                }

                _expandLinkRange(e, t) {
                    return t.textNode && t.textNode.hasAttribute("linkHref") ? Wg(t, "linkHref", t.textNode.getAttribute("linkHref"), e) : null
                }

                _selectEntireLinks(e, t) {
                    const n = this.editor.model, i = n.document.selection, s = i.getFirstPosition(),
                        l = i.getLastPosition();
                    let d = t.getJoined(this._expandLinkRange(n, s) || t);
                    d && (d = d.getJoined(this._expandLinkRange(n, l) || t)), d && (d.start.isBefore(s) || d.end.isAfter(l)) && e.setSelection(d)
                }

                _enablePasteLinking() {
                    const e = this.editor, t = e.model, n = t.document.selection,
                        i = e.plugins.get("ClipboardPipeline"), s = e.commands.get("link");
                    i.on("inputTransformation", (l, d) => {
                        if (!this.isEnabled || !s.isEnabled || n.isCollapsed || n.rangeCount > 1) return;
                        const g = n.getFirstRange(), v = d.dataTransfer.getData("text/plain");
                        if (!v) return;
                        const _ = v.match(Z1);
                        _ && _[2] === v && (t.change(x => {
                            this._selectEntireLinks(x, g), s.execute(v)
                        }), l.stop())
                    }, {priority: "high"})
                }

                _enableTypingHandling() {
                    const e = this.editor, t = new pC(e.model, n => {
                        if (!function (s) {
                            return s.length > 4 && s[s.length - 1] === " " && s[s.length - 2] !== " "
                        }(n)) return;
                        const i = Y1(n.substr(0, n.length - 1));
                        return i ? {url: i} : void 0
                    });
                    t.on("matched:data", (n, i) => {
                        const {batch: s, range: l, url: d} = i;
                        if (!s.isTyping) return;
                        const g = l.end.getShiftedBy(-1), v = g.getShiftedBy(-d.length), _ = e.model.createRange(v, g);
                        this._applyAutoLink(d, _)
                    }), t.bind("isEnabled").to(this)
                }

                _enableEnterHandling() {
                    const e = this.editor, t = e.model, n = e.commands.get("enter");
                    n && n.on("execute", () => {
                        const i = t.document.selection.getFirstPosition();
                        if (!i.parent.previousSibling) return;
                        const s = t.createRangeIn(i.parent.previousSibling);
                        this._checkAndApplyAutoLinkOnRange(s)
                    })
                }

                _enableShiftEnterHandling() {
                    const e = this.editor, t = e.model, n = e.commands.get("shiftEnter");
                    n && n.on("execute", () => {
                        const i = t.document.selection.getFirstPosition(),
                            s = t.createRange(t.createPositionAt(i.parent, 0), i.getShiftedBy(-1));
                        this._checkAndApplyAutoLinkOnRange(s)
                    })
                }

                _checkAndApplyAutoLinkOnRange(e) {
                    const t = this.editor.model, {text: n, range: i} = gC(e, t), s = Y1(n);
                    if (s) {
                        const l = t.createRange(i.end.getShiftedBy(-s.length), i.end);
                        this._applyAutoLink(s, l)
                    }
                }

                _applyAutoLink(e, t) {
                    const n = this.editor.model, i = rk(e, this.editor.config.get("link.defaultProtocol"));
                    this.isEnabled && function (s, l) {
                        return l.schema.checkAttributeInSelection(l.createSelection(s), "linkHref")
                    }(t, n) && z1(i) && !function (s) {
                        const l = s.start.nodeAfter;
                        return !!l && l.hasAttribute("linkHref")
                    }(t) && this._persistAutoLink(i, t)
                }

                _persistAutoLink(e, t) {
                    const n = this.editor.model, i = this.editor.plugins.get("Delete");
                    n.enqueueChange(s => {
                        s.setAttribute("linkHref", e, t), n.enqueueChange(() => {
                            i.requestUndoOnBackspace()
                        })
                    })
                }
            }

            function Y1(r) {
                const e = Z1.exec(r);
                return e ? e[2] : null
            }

            var Q1 = C(111),
                I4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Q1.Z, I4), Q1.Z.locals;
            var J1 = C(5730),
                M4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(J1.Z, M4), J1.Z.locals;
            var X1 = C(4564),
                B4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(X1.Z, B4), X1.Z.locals;

            function N4(r, e) {
                const t = e.mapper, n = e.writer, i = r.getAttribute("listType") == "numbered" ? "ol" : "ul",
                    s = function (d) {
                        const g = d.createContainerElement("li");
                        return g.getFillerOffset = O4, g
                    }(n), l = n.createContainerElement(i, null);
                return n.insert(n.createPositionAt(l, 0), s), t.bindElements(r, s), s
            }

            function ey(r, e, t, n) {
                const i = e.parent, s = t.mapper, l = t.writer;
                let d = s.toViewPosition(n.createPositionBefore(r));
                const g = ny(r.previousSibling, {
                    sameIndent: !0,
                    smallerIndent: !0,
                    listIndent: r.getAttribute("listIndent")
                }), v = r.previousSibling;
                if (g && g.getAttribute("listIndent") == r.getAttribute("listIndent")) {
                    const _ = s.toViewElement(g);
                    d = l.breakContainer(l.createPositionAfter(_))
                } else if (v && v.name == "listItem") {
                    d = s.toViewPosition(n.createPositionAt(v, "end"));
                    const _ = s.findMappedViewAncestor(d), x = function (M) {
                        for (const O of M.getChildren()) if (O.name == "ul" || O.name == "ol") return O;
                        return null
                    }(_);
                    d = x ? l.createPositionBefore(x) : l.createPositionAt(_, "end")
                } else d = s.toViewPosition(n.createPositionBefore(r));
                if (d = ty(d), l.insert(d, i), v && v.name == "listItem") {
                    const _ = s.toViewElement(v),
                        x = l.createRange(l.createPositionAt(_, 0), d).getWalker({ignoreElementEnd: !0});
                    for (const M of x) if (M.item.is("element", "li")) {
                        const O = l.breakContainer(l.createPositionBefore(M.item)), j = M.item.parent,
                            U = l.createPositionAt(e, "end");
                        Ji(l, U.nodeBefore, U.nodeAfter), l.move(l.createRangeOn(j), U), x._position = O
                    }
                } else {
                    const _ = i.nextSibling;
                    if (_ && (_.is("element", "ul") || _.is("element", "ol"))) {
                        let x = null;
                        for (const M of _.getChildren()) {
                            const O = s.toModelElement(M);
                            if (!(O && O.getAttribute("listIndent") > r.getAttribute("listIndent"))) break;
                            x = M
                        }
                        x && (l.breakContainer(l.createPositionAfter(x)), l.move(l.createRangeOn(x.parent), l.createPositionAt(e, "end")))
                    }
                }
                Ji(l, i, i.nextSibling), Ji(l, i.previousSibling, i)
            }

            function Ji(r, e, t) {
                return !e || !t || e.name != "ul" && e.name != "ol" || e.name != t.name || e.getAttribute("class") !== t.getAttribute("class") ? null : r.mergeContainers(r.createPositionAfter(e))
            }

            function ty(r) {
                return r.getLastMatchingPosition(e => e.item.is("uiElement"))
            }

            function ny(r, e) {
                const t = !!e.sameIndent, n = !!e.smallerIndent, i = e.listIndent;
                let s = r;
                for (; s && s.name == "listItem";) {
                    const l = s.getAttribute("listIndent");
                    if (t && i == l || n && i > l) return s;
                    s = e.direction === "forward" ? s.nextSibling : s.previousSibling
                }
                return null
            }

            function ry(r, e, t, n) {
                r.ui.componentFactory.add(e, i => {
                    const s = r.commands.get(e), l = new sn(i);
                    return l.set({
                        label: t,
                        icon: n,
                        tooltip: !0,
                        isToggleable: !0
                    }), l.bind("isOn", "isEnabled").to(s, "value", "isEnabled"), l.on("execute", () => {
                        r.execute(e), r.editing.view.focus()
                    }), l
                })
            }

            function ok(r, e) {
                const t = [], n = r.parent, i = {ignoreElementEnd: !1, startPosition: r, shallow: !0, direction: e},
                    s = n.getAttribute("listIndent"),
                    l = [...new Ao(i)].filter(d => d.item.is("element")).map(d => d.item);
                for (const d of l) {
                    if (!d.is("element", "listItem") || d.getAttribute("listIndent") < s) break;
                    if (!(d.getAttribute("listIndent") > s)) {
                        if (d.getAttribute("listType") !== n.getAttribute("listType") || d.getAttribute("listStyle") !== n.getAttribute("listStyle") || d.getAttribute("listReversed") !== n.getAttribute("listReversed") || d.getAttribute("listStart") !== n.getAttribute("listStart")) break;
                        e === "backward" ? t.unshift(d) : t.push(d)
                    }
                }
                return t
            }

            const L4 = ["disc", "circle", "square"],
                P4 = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];

            function O4() {
                const r = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
                return this.isEmpty || r ? 0 : wg.call(this)
            }

            class F4 extends Re {
                static get pluginName() {
                    return "ListUI"
                }

                init() {
                    const e = this.editor.t;
                    ry(this.editor, "numberedList", e("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), ry(this.editor, "bulletedList", e("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>')
                }
            }

            const R4 = [{listStyle: "disc", typeAttribute: "disc", listType: "bulleted"}, {
                listStyle: "circle",
                typeAttribute: "circle",
                listType: "bulleted"
            }, {listStyle: "square", typeAttribute: "square", listType: "bulleted"}, {
                listStyle: "decimal",
                typeAttribute: "1",
                listType: "numbered"
            }, {
                listStyle: "decimal-leading-zero",
                typeAttribute: null,
                listType: "numbered"
            }, {listStyle: "lower-roman", typeAttribute: "i", listType: "numbered"}, {
                listStyle: "upper-roman",
                typeAttribute: "I",
                listType: "numbered"
            }, {listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered"}, {
                listStyle: "upper-alpha",
                typeAttribute: "A",
                listType: "numbered"
            }, {listStyle: "lower-latin", typeAttribute: "a", listType: "numbered"}, {
                listStyle: "upper-latin",
                typeAttribute: "A",
                listType: "numbered"
            }];
            for (const {listStyle: r, typeAttribute: e, listType: t} of R4) ;
            var iy = C(6082),
                z4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(iy.Z, z4), iy.Z.locals;
            var oy = C(2417),
                j4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(oy.Z, j4), oy.Z.locals;

            class sy extends Ft {
                constructor(e, t) {
                    super(e), this._indentBy = t == "forward" ? 1 : -1
                }

                refresh() {
                    this.isEnabled = this._checkEnabled()
                }

                execute() {
                    const e = this.editor.model, t = e.document;
                    let n = Array.from(t.selection.getSelectedBlocks());
                    e.change(i => {
                        const s = n[n.length - 1];
                        let l = s.nextSibling;
                        for (; l && l.name == "listItem" && l.getAttribute("listIndent") > s.getAttribute("listIndent");) n.push(l), l = l.nextSibling;
                        this._indentBy < 0 && (n = n.reverse());
                        for (const d of n) {
                            const g = d.getAttribute("listIndent") + this._indentBy;
                            g < 0 ? i.rename(d, "paragraph") : i.setAttribute("listIndent", g, d)
                        }
                        this.fire("_executeCleanup", n)
                    })
                }

                _checkEnabled() {
                    const e = Wn(this.editor.model.document.selection.getSelectedBlocks());
                    if (!e || !e.is("element", "listItem")) return !1;
                    if (this._indentBy > 0) {
                        const t = e.getAttribute("listIndent"), n = e.getAttribute("listType");
                        let i = e.previousSibling;
                        for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= t;) {
                            if (i.getAttribute("listIndent") == t) return i.getAttribute("listType") == n;
                            i = i.previousSibling
                        }
                        return !1
                    }
                    return !0
                }
            }

            class ay extends Ft {
                constructor(e, t) {
                    super(e), this.type = t
                }

                refresh() {
                    this.value = this._getValue(), this.isEnabled = this._checkEnabled()
                }

                execute(e = {}) {
                    const t = this.editor.model, n = t.document,
                        i = Array.from(n.selection.getSelectedBlocks()).filter(l => cy(l, t.schema)),
                        s = e.forceValue !== void 0 ? !e.forceValue : this.value;
                    t.change(l => {
                        if (s) {
                            let d = i[i.length - 1].nextSibling, g = Number.POSITIVE_INFINITY, v = [];
                            for (; d && d.name == "listItem" && d.getAttribute("listIndent") !== 0;) {
                                const _ = d.getAttribute("listIndent");
                                _ < g && (g = _);
                                const x = _ - g;
                                v.push({element: d, listIndent: x}), d = d.nextSibling
                            }
                            v = v.reverse();
                            for (const _ of v) l.setAttribute("listIndent", _.listIndent, _.element)
                        }
                        if (!s) {
                            let d = Number.POSITIVE_INFINITY;
                            for (const g of i) g.is("element", "listItem") && g.getAttribute("listIndent") < d && (d = g.getAttribute("listIndent"));
                            d = d === 0 ? 1 : d, ly(i, !0, d), ly(i, !1, d)
                        }
                        for (const d of i.reverse()) s && d.name == "listItem" ? l.rename(d, "paragraph") : s || d.name == "listItem" ? s || d.name != "listItem" || d.getAttribute("listType") == this.type || l.setAttribute("listType", this.type, d) : (l.setAttributes({
                            listType: this.type,
                            listIndent: 0
                        }, d), l.rename(d, "listItem"));
                        this.fire("_executeCleanup", i)
                    })
                }

                _getValue() {
                    const e = Wn(this.editor.model.document.selection.getSelectedBlocks());
                    return !!e && e.is("element", "listItem") && e.getAttribute("listType") == this.type
                }

                _checkEnabled() {
                    if (this.value) return !0;
                    const e = this.editor.model.document.selection, t = this.editor.model.schema,
                        n = Wn(e.getSelectedBlocks());
                    return !!n && cy(n, t)
                }
            }

            function ly(r, e, t) {
                const n = e ? r[0] : r[r.length - 1];
                if (n.is("element", "listItem")) {
                    let i = n[e ? "previousSibling" : "nextSibling"], s = n.getAttribute("listIndent");
                    for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= t;) s > i.getAttribute("listIndent") && (s = i.getAttribute("listIndent")), i.getAttribute("listIndent") == s && r[e ? "unshift" : "push"](i), i = i[e ? "previousSibling" : "nextSibling"]
                }
            }

            function cy(r, e) {
                return e.checkChild(r.parent, "listItem") && !e.isObject(r)
            }

            class V4 extends Re {
                static get pluginName() {
                    return "ListUtils"
                }

                getListTypeFromListStyleType(e) {
                    return function (t) {
                        return L4.includes(t) ? "bulleted" : P4.includes(t) ? "numbered" : null
                    }(e)
                }

                getSelectedListItems(e) {
                    return function (t) {
                        let n = [...t.document.selection.getSelectedBlocks()].filter(i => i.is("element", "listItem")).map(i => {
                            const s = t.change(l => l.createPositionAt(i, 0));
                            return [...ok(s, "backward"), ...ok(s, "forward")]
                        }).flat();
                        return n = [...new Set(n)], n
                    }(e)
                }

                getSiblingNodes(e, t) {
                    return ok(e, t)
                }
            }

            function uy(r) {
                return (e, t, n) => {
                    const i = n.consumable;
                    if (!i.test(t.item, "insert") || !i.test(t.item, "attribute:listType") || !i.test(t.item, "attribute:listIndent")) return;
                    i.consume(t.item, "insert"), i.consume(t.item, "attribute:listType"), i.consume(t.item, "attribute:listIndent");
                    const s = t.item;
                    ey(s, N4(s, n), n, r)
                }
            }

            const H4 = (r, e, t) => {
                if (!t.consumable.test(e.item, r.name)) return;
                const n = t.mapper.toViewElement(e.item), i = t.writer;
                i.breakContainer(i.createPositionBefore(n)), i.breakContainer(i.createPositionAfter(n));
                const s = n.parent, l = e.attributeNewValue == "numbered" ? "ol" : "ul";
                i.rename(l, s)
            }, U4 = (r, e, t) => {
                t.consumable.consume(e.item, r.name);
                const n = t.mapper.toViewElement(e.item).parent, i = t.writer;
                Ji(i, n, n.nextSibling), Ji(i, n.previousSibling, n)
            }, dy = (r, e, t) => {
                if (t.consumable.test(e.item, r.name) && e.item.name != "listItem") {
                    let n = t.mapper.toViewPosition(e.range.start);
                    const i = t.writer, s = [];
                    for (; (n.parent.name == "ul" || n.parent.name == "ol") && (n = i.breakContainer(n), n.parent.name == "li");) {
                        const l = n, d = i.createPositionAt(n.parent, "end");
                        if (!l.isEqual(d)) {
                            const g = i.remove(i.createRange(l, d));
                            s.push(g)
                        }
                        n = i.createPositionAfter(n.parent)
                    }
                    if (s.length > 0) {
                        for (let l = 0; l < s.length; l++) {
                            const d = n.nodeBefore;
                            if (n = i.insert(n, s[l]).end, l > 0) {
                                const g = Ji(i, d, d.nextSibling);
                                g && g.parent == d && n.offset--
                            }
                        }
                        Ji(i, n.nodeBefore, n.nodeAfter)
                    }
                }
            }, q4 = (r, e, t) => {
                const n = t.mapper.toViewPosition(e.position), i = n.nodeBefore, s = n.nodeAfter;
                Ji(t.writer, i, s)
            }, W4 = (r, e, t) => {
                if (t.consumable.consume(e.viewItem, {name: !0})) {
                    const n = t.writer, i = n.createElement("listItem"), s = function (g) {
                        let v = 0, _ = g.parent;
                        for (; _;) {
                            if (_.is("element", "li")) v++; else {
                                const x = _.previousSibling;
                                x && x.is("element", "li") && v++
                            }
                            _ = _.parent
                        }
                        return v
                    }(e.viewItem);
                    n.setAttribute("listIndent", s, i);
                    const l = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
                    if (n.setAttribute("listType", l, i), !t.safeInsert(i, e.modelCursor)) return;
                    const d = function (g, v, _) {
                        const {writer: x, schema: M} = _;
                        let O = x.createPositionAfter(g);
                        for (const j of v) if (j.name == "ul" || j.name == "ol") O = _.convertItem(j, O).modelCursor; else {
                            const U = _.convertItem(j, x.createPositionAt(g, "end")), K = U.modelRange.start.nodeAfter;
                            K && K.is("element") && !M.checkChild(g, K.name) && (g = U.modelCursor.parent.is("element", "listItem") ? U.modelCursor.parent : K4(U.modelCursor), O = x.createPositionAfter(g))
                        }
                        return O
                    }(i, e.viewItem.getChildren(), t);
                    e.modelRange = n.createRange(e.modelCursor, d), t.updateConversionResult(i, e)
                }
            }, hy = (r, e, t) => {
                if (t.consumable.test(e.viewItem, {name: !0})) {
                    const n = Array.from(e.viewItem.getChildren());
                    for (const i of n) !(i.is("element", "li") || yu(i)) && i._remove()
                }
            }, $4 = (r, e, t) => {
                if (t.consumable.test(e.viewItem, {name: !0})) {
                    if (e.viewItem.childCount === 0) return;
                    const n = [...e.viewItem.getChildren()];
                    let i = !1;
                    for (const s of n) i && !yu(s) && s._remove(), yu(s) && (i = !0)
                }
            };

            function fy(r) {
                return (e, t) => {
                    if (t.isPhantom) return;
                    const n = t.modelPosition.nodeBefore;
                    if (n && n.is("element", "listItem")) {
                        const i = t.mapper.toViewElement(n), s = i.getAncestors().find(yu),
                            l = r.createPositionAt(i, 0).getWalker();
                        for (const d of l) {
                            if (d.type == "elementStart" && d.item.is("element", "li")) {
                                t.viewPosition = d.previousPosition;
                                break
                            }
                            if (d.type == "elementEnd" && d.item == s) {
                                t.viewPosition = d.nextPosition;
                                break
                            }
                        }
                    }
                }
            }

            const G4 = function (r, [e, t]) {
                const n = this;
                let i, s = e.is("documentFragment") ? e.getChild(0) : e;
                if (i = t ? n.createSelection(t) : n.document.selection, s && s.is("element", "listItem")) {
                    const l = i.getFirstPosition();
                    let d = null;
                    if (l.parent.is("element", "listItem") ? d = l.parent : l.nodeBefore && l.nodeBefore.is("element", "listItem") && (d = l.nodeBefore), d) {
                        const g = d.getAttribute("listIndent");
                        if (g > 0) for (; s && s.is("element", "listItem");) s._setAttribute("listIndent", s.getAttribute("listIndent") + g), s = s.nextSibling
                    }
                }
            };

            function K4(r) {
                const e = new Ao({startPosition: r});
                let t;
                do t = e.next(); while (!t.value.item.is("element", "listItem"));
                return t.value.item
            }

            function gy(r, e, t, n, i, s) {
                const l = ny(e.nodeBefore, {sameIndent: !0, smallerIndent: !0, listIndent: r}), d = i.mapper,
                    g = i.writer, v = l ? l.getAttribute("listIndent") : null;
                let _;
                if (l) if (v == r) {
                    const x = d.toViewElement(l).parent;
                    _ = g.createPositionAfter(x)
                } else {
                    const x = s.createPositionAt(l, "end");
                    _ = d.toViewPosition(x)
                } else _ = t;
                _ = ty(_);
                for (const x of [...n.getChildren()]) yu(x) && (_ = g.move(g.createRangeOn(x), _).end, Ji(g, x, x.nextSibling), Ji(g, x.previousSibling, x))
            }

            function yu(r) {
                return r.is("element", "ol") || r.is("element", "ul")
            }

            class Z4 extends Re {
                static get pluginName() {
                    return "ListEditing"
                }

                static get requires() {
                    return [$g, Ls, V4]
                }

                init() {
                    const e = this.editor;
                    e.model.schema.register("listItem", {
                        inheritAllFrom: "$block",
                        allowAttributes: ["listType", "listIndent"]
                    });
                    const t = e.data, n = e.editing;
                    var i;
                    e.model.document.registerPostFixer(l => function (d, g) {
                        const v = d.document.differ.getChanges(), _ = new Map;
                        let x = !1;
                        for (const U of v) if (U.type == "insert" && U.name == "listItem") M(U.position); else if (U.type == "insert" && U.name != "listItem") {
                            if (U.name != "$text") {
                                const K = U.position.nodeAfter;
                                K.hasAttribute("listIndent") && (g.removeAttribute("listIndent", K), x = !0), K.hasAttribute("listType") && (g.removeAttribute("listType", K), x = !0), K.hasAttribute("listStyle") && (g.removeAttribute("listStyle", K), x = !0), K.hasAttribute("listReversed") && (g.removeAttribute("listReversed", K), x = !0), K.hasAttribute("listStart") && (g.removeAttribute("listStart", K), x = !0);
                                for (const ne of Array.from(d.createRangeIn(K)).filter(pe => pe.item.is("element", "listItem"))) M(ne.previousPosition)
                            }
                            M(U.position.getShiftedBy(U.length))
                        } else U.type == "remove" && U.name == "listItem" ? M(U.position) : (U.type == "attribute" && U.attributeKey == "listIndent" || U.type == "attribute" && U.attributeKey == "listType") && M(U.range.start);
                        for (const U of _.values()) O(U), j(U);
                        return x;

                        function M(U) {
                            const K = U.nodeBefore;
                            if (K && K.is("element", "listItem")) {
                                let ne = K;
                                if (_.has(ne)) return;
                                for (let pe = ne.previousSibling; pe && pe.is("element", "listItem"); pe = ne.previousSibling) if (ne = pe, _.has(ne)) return;
                                _.set(K, ne)
                            } else {
                                const ne = U.nodeAfter;
                                ne && ne.is("element", "listItem") && _.set(ne, ne)
                            }
                        }

                        function O(U) {
                            let K = 0, ne = null;
                            for (; U && U.is("element", "listItem");) {
                                const pe = U.getAttribute("listIndent");
                                if (pe > K) {
                                    let Se;
                                    ne === null ? (ne = pe - K, Se = K) : (ne > pe && (ne = pe), Se = pe - ne), g.setAttribute("listIndent", Se, U), x = !0
                                } else ne = null, K = U.getAttribute("listIndent") + 1;
                                U = U.nextSibling
                            }
                        }

                        function j(U) {
                            let K = [], ne = null;
                            for (; U && U.is("element", "listItem");) {
                                const pe = U.getAttribute("listIndent");
                                if (ne && ne.getAttribute("listIndent") > pe && (K = K.slice(0, pe + 1)), pe != 0) if (K[pe]) {
                                    const Se = K[pe];
                                    U.getAttribute("listType") != Se && (g.setAttribute("listType", Se, U), x = !0)
                                } else K[pe] = U.getAttribute("listType");
                                ne = U, U = U.nextSibling
                            }
                        }
                    }(e.model, l)), n.mapper.registerViewToModelLength("li", sk), t.mapper.registerViewToModelLength("li", sk), n.mapper.on("modelToViewPosition", fy(n.view)), n.mapper.on("viewToModelPosition", (i = e.model, (l, d) => {
                        const g = d.viewPosition, v = g.parent, _ = d.mapper;
                        if (v.name == "ul" || v.name == "ol") {
                            if (g.isAtEnd) {
                                const x = _.toModelElement(g.nodeBefore), M = _.getModelLength(g.nodeBefore);
                                d.modelPosition = i.createPositionBefore(x).getShiftedBy(M)
                            } else {
                                const x = _.toModelElement(g.nodeAfter);
                                d.modelPosition = i.createPositionBefore(x)
                            }
                            l.stop()
                        } else if (v.name == "li" && g.nodeBefore && (g.nodeBefore.name == "ul" || g.nodeBefore.name == "ol")) {
                            const x = _.toModelElement(v);
                            let M = 1, O = g.nodeBefore;
                            for (; O && yu(O);) M += _.getModelLength(O), O = O.previousSibling;
                            d.modelPosition = i.createPositionBefore(x).getShiftedBy(M), l.stop()
                        }
                    })), t.mapper.on("modelToViewPosition", fy(n.view)), e.conversion.for("editingDowncast").add(l => {
                        l.on("insert", dy, {priority: "high"}), l.on("insert:listItem", uy(e.model)), l.on("attribute:listType:listItem", H4, {priority: "high"}), l.on("attribute:listType:listItem", U4, {priority: "low"}), l.on("attribute:listIndent:listItem", function (d) {
                            return (g, v, _) => {
                                if (!_.consumable.consume(v.item, "attribute:listIndent")) return;
                                const x = _.mapper.toViewElement(v.item), M = _.writer;
                                M.breakContainer(M.createPositionBefore(x)), M.breakContainer(M.createPositionAfter(x));
                                const O = x.parent, j = O.previousSibling, U = M.createRangeOn(O);
                                M.remove(U), j && j.nextSibling && Ji(M, j, j.nextSibling), gy(v.attributeOldValue + 1, v.range.start, U.start, x, _, d), ey(v.item, x, _, d);
                                for (const K of v.item.getChildren()) _.consumable.consume(K, "insert")
                            }
                        }(e.model)), l.on("remove:listItem", function (d) {
                            return (g, v, _) => {
                                const x = _.mapper.toViewPosition(v.position).getLastMatchingPosition(ne => !ne.item.is("element", "li")).nodeAfter,
                                    M = _.writer;
                                M.breakContainer(M.createPositionBefore(x)), M.breakContainer(M.createPositionAfter(x));
                                const O = x.parent, j = O.previousSibling, U = M.createRangeOn(O), K = M.remove(U);
                                j && j.nextSibling && Ji(M, j, j.nextSibling), gy(_.mapper.toModelElement(x).getAttribute("listIndent") + 1, v.position, U.start, x, _, d);
                                for (const ne of M.createRangeIn(K).getItems()) _.mapper.unbindViewElement(ne);
                                g.stop()
                            }
                        }(e.model)), l.on("remove", q4, {priority: "low"})
                    }), e.conversion.for("dataDowncast").add(l => {
                        l.on("insert", dy, {priority: "high"}), l.on("insert:listItem", uy(e.model))
                    }), e.conversion.for("upcast").add(l => {
                        l.on("element:ul", hy, {priority: "high"}), l.on("element:ol", hy, {priority: "high"}), l.on("element:li", $4, {priority: "high"}), l.on("element:li", W4)
                    }), e.model.on("insertContent", G4, {priority: "high"}), e.commands.add("numberedList", new ay(e, "numbered")), e.commands.add("bulletedList", new ay(e, "bulleted")), e.commands.add("indentList", new sy(e, "forward")), e.commands.add("outdentList", new sy(e, "backward"));
                    const s = n.view.document;
                    this.listenTo(s, "enter", (l, d) => {
                        const g = this.editor.model.document, v = g.selection.getLastPosition().parent;
                        g.selection.isCollapsed && v.name == "listItem" && v.isEmpty && (this.editor.execute("outdentList"), d.preventDefault(), l.stop())
                    }, {context: "li"}), this.listenTo(s, "delete", (l, d) => {
                        if (d.direction !== "backward") return;
                        const g = this.editor.model.document.selection;
                        if (!g.isCollapsed) return;
                        const v = g.getFirstPosition();
                        if (!v.isAtStart) return;
                        const _ = v.parent;
                        _.name === "listItem" && (_.previousSibling && _.previousSibling.name === "listItem" || (this.editor.execute("outdentList"), d.preventDefault(), l.stop()))
                    }, {context: "li"}), this.listenTo(e.editing.view.document, "tab", (l, d) => {
                        const g = d.shiftKey ? "outdentList" : "indentList";
                        this.editor.commands.get(g).isEnabled && (e.execute(g), d.stopPropagation(), d.preventDefault(), l.stop())
                    }, {context: "li"})
                }

                afterInit() {
                    const e = this.editor.commands, t = e.get("indent"), n = e.get("outdent");
                    t && t.registerChildCommand(e.get("indentList")), n && n.registerChildCommand(e.get("outdentList"))
                }
            }

            function sk(r) {
                let e = 1;
                for (const t of r.getChildren()) if (t.name == "ul" || t.name == "ol") for (const n of t.getChildren()) e += sk(n);
                return e
            }

            Di("Ctrl+Enter");
            var py = C(1199),
                Y4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(py.Z, Y4), py.Z.locals, Di("Ctrl+Enter");

            function my(r, e) {
                const t = (n, i, s) => {
                    if (!s.consumable.consume(i.item, n.name)) return;
                    const l = i.attributeNewValue, d = s.writer, g = s.mapper.toViewElement(i.item),
                        v = [...g.getChildren()].find(x => x.getCustomProperty("media-content"));
                    d.remove(v);
                    const _ = r.getMediaViewElement(d, l, e);
                    d.insert(d.createPositionAt(g, 0), _)
                };
                return n => {
                    n.on("attribute:url:media", t)
                }
            }

            function by(r, e, t, n) {
                return r.createContainerElement("figure", {class: "media"}, [e.getMediaViewElement(r, t, n), r.createSlot()])
            }

            function ky(r) {
                const e = r.getSelectedElement();
                return e && e.is("element", "media") ? e : null
            }

            function vy(r, e, t, n) {
                r.change(i => {
                    const s = i.createElement("media", {url: e});
                    r.insertObject(s, t, null, {setSelection: "on", findOptimalPosition: n ? "auto" : void 0})
                })
            }

            class Q4 extends Ft {
                refresh() {
                    const e = this.editor.model, t = e.document.selection, n = ky(t);
                    this.value = n ? n.getAttribute("url") : void 0, this.isEnabled = function (i) {
                        const s = i.getSelectedElement();
                        return !!s && s.name === "media"
                    }(t) || function (i, s) {
                        let d = SC(i, s).start.parent;
                        return d.isEmpty && !s.schema.isLimit(d) && (d = d.parent), s.schema.checkChild(d, "media")
                    }(t, e)
                }

                execute(e) {
                    const t = this.editor.model, n = t.document.selection, i = ky(n);
                    i ? t.change(s => {
                        s.setAttribute("url", e, i)
                    }) : vy(t, e, n, !0)
                }
            }

            class J4 {
                constructor(e, t) {
                    const n = t.providers, i = t.extraProviders || [], s = new Set(t.removeProviders),
                        l = n.concat(i).filter(d => {
                            const g = d.name;
                            return g ? !s.has(g) : (ae("media-embed-no-provider-name", {provider: d}), !1)
                        });
                    this.locale = e, this.providerDefinitions = l
                }

                hasMedia(e) {
                    return !!this._getMedia(e)
                }

                getMediaViewElement(e, t, n) {
                    return this._getMedia(t).getViewElement(e, n)
                }

                _getMedia(e) {
                    if (!e) return new wy(this.locale);
                    e = e.trim();
                    for (const t of this.providerDefinitions) {
                        const n = t.html, i = qn(t.url);
                        for (const s of i) {
                            const l = this._getUrlMatches(e, s);
                            if (l) return new wy(this.locale, e, l, n)
                        }
                    }
                    return null
                }

                _getUrlMatches(e, t) {
                    let n = e.match(t);
                    if (n) return n;
                    let i = e.replace(/^https?:\/\//, "");
                    return n = i.match(t), n || (i = i.replace(/^www\./, ""), n = i.match(t), n || null)
                }
            }

            class wy {
                constructor(e, t, n, i) {
                    this.url = this._getValidUrl(t), this._locale = e, this._match = n, this._previewRenderer = i
                }

                getViewElement(e, t) {
                    const n = {};
                    let i;
                    if (t.renderForEditingView || t.renderMediaPreview && this.url && this._previewRenderer) {
                        this.url && (n["data-oembed-url"] = this.url), t.renderForEditingView && (n.class = "ck-media__wrapper");
                        const s = this._getPreviewHtml(t);
                        i = e.createRawElement("div", n, (l, d) => {
                            d.setContentOf(l, s)
                        })
                    } else this.url && (n.url = this.url), i = e.createEmptyElement(t.elementName, n);
                    return e.setCustomProperty("media-content", !0, i), i
                }

                _getPreviewHtml(e) {
                    return this._previewRenderer ? this._previewRenderer(this._match) : this.url && e.renderForEditingView ? this._getPlaceholderHtml() : ""
                }

                _getPlaceholderHtml() {
                    const e = new Ho, t = this._locale.t;
                    return e.content = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>', e.viewBox = "0 0 64 42", new xi({
                        tag: "div",
                        attributes: {class: "ck ck-reset_all ck-media__placeholder"},
                        children: [{
                            tag: "div",
                            attributes: {class: "ck-media__placeholder__icon"},
                            children: [e]
                        }, {
                            tag: "a",
                            attributes: {
                                class: "ck-media__placeholder__url",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                href: this.url,
                                "data-cke-tooltip-text": t("Open media in new tab")
                            },
                            children: [{
                                tag: "span",
                                attributes: {class: "ck-media__placeholder__url__text"},
                                children: [this.url]
                            }]
                        }]
                    }).render().outerHTML
                }

                _getValidUrl(e) {
                    return e ? e.match(/^https?/) ? e : "https://" + e : null
                }
            }

            var Ay = C(7442),
                X4 = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Ay.Z, X4), Ay.Z.locals;

            class rp extends Re {
                constructor(e) {
                    super(e), e.config.define("mediaEmbed", {
                        elementName: "oembed",
                        providers: [{
                            name: "dailymotion",
                            url: [/^dailymotion\.com\/video\/(\w+)/, /^dai.ly\/(\w+)/],
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`
                        }, {
                            name: "spotify",
                            url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/],
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`
                        }, {
                            name: "youtube",
                            url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/],
                            html: t => {
                                const n = t[1], i = t[2];
                                return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${n}${i ? `?start=${i}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`
                            }
                        }, {
                            name: "vimeo",
                            url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/],
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`
                        }, {name: "instagram", url: /^instagram\.com\/p\/(\w+)/}, {
                            name: "twitter",
                            url: /^twitter\.com/
                        }, {
                            name: "googleMaps",
                            url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/]
                        }, {name: "flickr", url: /^flickr\.com/}, {name: "facebook", url: /^facebook\.com/}]
                    }), this.registry = new J4(e.locale, e.config.get("mediaEmbed"))
                }

                static get pluginName() {
                    return "MediaEmbedEditing"
                }

                init() {
                    const e = this.editor, t = e.model.schema, n = e.t, i = e.conversion,
                        s = e.config.get("mediaEmbed.previewsInData"), l = e.config.get("mediaEmbed.elementName"),
                        d = this.registry;
                    e.commands.add("mediaEmbed", new Q4(e)), t.register("media", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["url"]
                    }), i.for("dataDowncast").elementToStructure({
                        model: "media", view: (g, {writer: v}) => {
                            const _ = g.getAttribute("url");
                            return by(v, d, _, {elementName: l, renderMediaPreview: !!_ && s})
                        }
                    }), i.for("dataDowncast").add(my(d, {
                        elementName: l,
                        renderMediaPreview: s
                    })), i.for("editingDowncast").elementToStructure({
                        model: "media", view: (g, {writer: v}) => {
                            const _ = g.getAttribute("url");
                            return function (x, M, O) {
                                return M.setCustomProperty("media", !0, x), Rb(x, M, {label: O})
                            }(by(v, d, _, {elementName: l, renderForEditingView: !0}), v, n("media widget"))
                        }
                    }), i.for("editingDowncast").add(my(d, {
                        elementName: l,
                        renderForEditingView: !0
                    })), i.for("upcast").elementToElement({
                        view: g => ["oembed", l].includes(g.name) && g.getAttribute("url") ? {name: !0} : null,
                        model: (g, {writer: v}) => {
                            const _ = g.getAttribute("url");
                            return d.hasMedia(_) ? v.createElement("media", {url: _}) : null
                        }
                    }).elementToElement({
                        view: {name: "div", attributes: {"data-oembed-url": !0}},
                        model: (g, {writer: v}) => {
                            const _ = g.getAttribute("data-oembed-url");
                            return d.hasMedia(_) ? v.createElement("media", {url: _}) : null
                        }
                    }).add(g => {
                        g.on("element:figure", (v, _, x) => {
                            if (!x.consumable.consume(_.viewItem, {name: !0, classes: "media"})) return;
                            const {modelRange: M, modelCursor: O} = x.convertChildren(_.viewItem, _.modelCursor);
                            _.modelRange = M, _.modelCursor = O, Wn(M.getItems()) || x.consumable.revert(_.viewItem, {
                                name: !0,
                                classes: "media"
                            })
                        })
                    })
                }
            }

            const eN = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;

            class tN extends Re {
                constructor(e) {
                    super(e), this._timeoutId = null, this._positionToInsert = null
                }

                static get requires() {
                    return [GC, Ls, e_]
                }

                static get pluginName() {
                    return "AutoMediaEmbed"
                }

                init() {
                    const e = this.editor, t = e.model.document, n = e.plugins.get("ClipboardPipeline");
                    this.listenTo(n, "inputTransformation", () => {
                        const i = t.selection.getFirstRange(), s = Fr.fromPosition(i.start);
                        s.stickiness = "toPrevious";
                        const l = Fr.fromPosition(i.end);
                        l.stickiness = "toNext", t.once("change:data", () => {
                            this._embedMediaBetweenPositions(s, l), s.detach(), l.detach()
                        }, {priority: "high"})
                    }), e.commands.get("undo").on("execute", () => {
                        this._timeoutId && (bt.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null)
                    }, {priority: "high"})
                }

                _embedMediaBetweenPositions(e, t) {
                    const n = this.editor, i = n.plugins.get(rp).registry, s = new Ii(e, t),
                        l = s.getWalker({ignoreElementEnd: !0});
                    let d = "";
                    for (const g of l) g.item.is("$textProxy") && (d += g.item.data);
                    if (d = d.trim(), !d.match(eN) || !i.hasMedia(d)) return void s.detach();
                    n.commands.get("mediaEmbed").isEnabled ? (this._positionToInsert = Fr.fromPosition(e), this._timeoutId = bt.window.setTimeout(() => {
                        n.model.change(g => {
                            this._timeoutId = null, g.remove(s), s.detach();
                            let v = null;
                            this._positionToInsert.root.rootName !== "$graveyard" && (v = this._positionToInsert), vy(n.model, d, v, !1), this._positionToInsert.detach(), this._positionToInsert = null
                        }), n.plugins.get(Ls).requestUndoOnBackspace()
                    }, 100)) : s.detach()
                }
            }

            var Cy = C(9292),
                nN = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Cy.Z, nN), Cy.Z.locals;

            class rN extends It {
                constructor(e, t) {
                    super(t);
                    const n = t.t;
                    this.focusTracker = new Nr, this.keystrokes = new si, this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n("Save"), mn.check, "ck-button-save"), this.saveButtonView.type = "submit", this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", i => !!i), this.cancelButtonView = this._createButton(n("Cancel"), mn.cancel, "ck-button-cancel", "cancel"), this._focusables = new un, this._focusCycler = new yn({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                    }), this._validators = e, this.setTemplate({
                        tag: "form",
                        attributes: {class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1"},
                        children: [this.urlInputView, this.saveButtonView, this.cancelButtonView]
                    })
                }

                render() {
                    super.render(), w({view: this}), [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach(t => {
                        this._focusables.add(t), this.focusTracker.add(t.element)
                    }), this.keystrokes.listenTo(this.element);
                    const e = t => t.stopPropagation();
                    this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e)
                }

                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }

                focus() {
                    this._focusCycler.focusFirst()
                }

                get url() {
                    return this.urlInputView.fieldView.element.value.trim()
                }

                set url(e) {
                    this.urlInputView.fieldView.element.value = e.trim()
                }

                isValid() {
                    this.resetFormStatus();
                    for (const e of this._validators) {
                        const t = e(this);
                        if (t) return this.urlInputView.errorText = t, !1
                    }
                    return !0
                }

                resetFormStatus() {
                    this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault
                }

                _createUrlInput() {
                    const e = this.locale.t, t = new Xc(this.locale, Lg), n = t.fieldView;
                    return this._urlInputViewInfoDefault = e("Paste the media URL in the input."), this._urlInputViewInfoTip = e("Tip: Paste the URL into the content to embed faster."), t.label = e("Media URL"), t.infoText = this._urlInputViewInfoDefault, n.on("input", () => {
                        t.infoText = n.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = n.element.value.trim()
                    }), t
                }

                _createButton(e, t, n, i) {
                    const s = new sn(this.locale);
                    return s.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }), s.extendTemplate({attributes: {class: n}}), i && s.delegate("execute").to(this, i), s
                }
            }

            class iN extends Re {
                static get requires() {
                    return [rp]
                }

                static get pluginName() {
                    return "MediaEmbedUI"
                }

                init() {
                    const e = this.editor, t = e.commands.get("mediaEmbed");
                    e.ui.componentFactory.add("mediaEmbed", n => {
                        const i = Ns(n);
                        return this._setUpDropdown(i, t), i
                    })
                }

                _setUpDropdown(e, t) {
                    const n = this.editor, i = n.t, s = e.buttonView, l = n.plugins.get(rp).registry;
                    e.once("change:isOpen", () => {
                        const d = new (y(rN))(function (g, v) {
                            return [_ => {
                                if (!_.url.length) return g("The URL must not be empty.")
                            }, _ => {
                                if (!v.hasMedia(_.url)) return g("This media URL is not supported.")
                            }]
                        }(n.t, l), n.locale);
                        e.panelView.children.add(d), s.on("open", () => {
                            d.disableCssTransitions(), d.url = t.value || "", d.urlInputView.fieldView.select(), d.enableCssTransitions()
                        }, {priority: "low"}), e.on("submit", () => {
                            d.isValid() && (n.execute("mediaEmbed", d.url), n.editing.view.focus())
                        }), e.on("change:isOpen", () => d.resetFormStatus()), e.on("cancel", () => {
                            n.editing.view.focus()
                        }), d.delegate("submit", "cancel").to(e), d.urlInputView.fieldView.bind("value").to(t, "value"), d.urlInputView.bind("isEnabled").to(t, "isEnabled")
                    }), e.bind("isEnabled").to(t), s.set({
                        label: i("Insert media"),
                        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>',
                        tooltip: !0
                    })
                }
            }

            var _y = C(4652),
                oN = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(_y.Z, oN), _y.Z.locals;

            function sN(r, e) {
                if (!r.childCount) return;
                const t = new Ia(r.document), n = function (l, d) {
                    const g = d.createRangeIn(l), v = new Si({name: /^p|h\d+$/, styles: {"mso-list": /.*/}}), _ = [];
                    for (const x of g) if (x.type === "elementStart" && v.match(x.item)) {
                        const M = lN(x.item);
                        _.push({element: x.item, id: M.id, order: M.order, indent: M.indent})
                    }
                    return _
                }(r, t);
                if (!n.length) return;
                let i = null, s = 1;
                n.forEach((l, d) => {
                    const g = function (j, U) {
                        if (!j) return !0;
                        if (j.id !== U.id) return U.indent - j.indent != 1;
                        const K = U.element.previousSibling;
                        if (!K) return !0;
                        return ne = K, !(ne.is("element", "ol") || ne.is("element", "ul"));
                        var ne
                    }(n[d - 1], l), v = g ? null : n[d - 1], _ = (M = l, (x = v) ? M.indent - x.indent : M.indent - 1);
                    var x, M;
                    if (g && (i = null, s = 1), !i || _ !== 0) {
                        const j = function (U, K) {
                            const ne = new RegExp(`@list l${U.id}:level${U.indent}\\s*({[^}]*)`, "gi"),
                                pe = /mso-level-number-format:([^;]{0,100});/gi,
                                Se = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi, Je = ne.exec(K);
                            let wt = "decimal", qt = "ol", Zt = null;
                            if (Je && Je[1]) {
                                const Jn = pe.exec(Je[1]);
                                if (Jn && Jn[1] && (wt = Jn[1].trim(), qt = wt !== "bullet" && wt !== "image" ? "ol" : "ul"), wt === "bullet") {
                                    const Xn = function (xu) {
                                        const ns = function (Fs) {
                                            if (Fs.getChild(0).is("$text")) return null;
                                            for (const Rs of Fs.getChildren()) {
                                                if (!Rs.is("element", "span")) continue;
                                                const Yl = Rs.getChild(0);
                                                if (Yl) return Yl.is("$text") ? Yl : Yl.getChild(0)
                                            }
                                            return null
                                        }(xu);
                                        if (!ns) return null;
                                        const Xi = ns._data;
                                        return Xi === "o" ? "circle" : Xi === "·" ? "disc" : Xi === "§" ? "square" : null
                                    }(U.element);
                                    Xn && (wt = Xn)
                                } else {
                                    const Xn = Se.exec(Je[1]);
                                    Xn && Xn[1] && (Zt = parseInt(Xn[1]))
                                }
                            }
                            return {type: qt, startIndex: Zt, style: aN(wt)}
                        }(l, e);
                        if (i) {
                            if (l.indent > s) {
                                const U = i.getChild(i.childCount - 1), K = U.getChild(U.childCount - 1);
                                i = yy(j, K, t), s += 1
                            } else if (l.indent < s) {
                                const U = s - l.indent;
                                i = function (K, ne) {
                                    const pe = K.getAncestors({parentFirst: !0});
                                    let Se = null, Je = 0;
                                    for (const wt of pe) if ((wt.is("element", "ul") || wt.is("element", "ol")) && Je++, Je === ne) {
                                        Se = wt;
                                        break
                                    }
                                    return Se
                                }(i, U), s = l.indent
                            }
                        } else i = yy(j, l.element, t);
                        l.indent <= s && (i.is("element", j.type) || (i = t.rename(j.type, i)))
                    }
                    const O = function (j, U) {
                        return function (K, ne) {
                            const pe = new Si({name: "span", styles: {"mso-list": "Ignore"}}), Se = ne.createRangeIn(K);
                            for (const Je of Se) Je.type === "elementStart" && pe.match(Je.item) && ne.remove(Je.item)
                        }(j, U), U.removeStyle("text-indent", j), U.rename("li", j)
                    }(l.element, t);
                    t.appendChild(O, i)
                })
            }

            function aN(r) {
                if (r.startsWith("arabic-leading-zero")) return "decimal-leading-zero";
                switch (r) {
                    case"alpha-upper":
                        return "upper-alpha";
                    case"alpha-lower":
                        return "lower-alpha";
                    case"roman-upper":
                        return "upper-roman";
                    case"roman-lower":
                        return "lower-roman";
                    case"circle":
                    case"disc":
                    case"square":
                        return r;
                    default:
                        return null
                }
            }

            function yy(r, e, t) {
                const n = e.parent, i = t.createElement(r.type), s = n.getChildIndex(e) + 1;
                return t.insertChild(s, i, n), r.style && t.setStyle("list-style-type", r.style, i), r.startIndex && r.startIndex > 1 && t.setAttribute("start", r.startIndex, i), i
            }

            function lN(r) {
                const e = {}, t = r.getStyle("mso-list");
                if (t) {
                    const n = t.match(/(^|\s{1,100})l(\d+)/i), i = t.match(/\s{0,100}lfo(\d+)/i),
                        s = t.match(/\s{0,100}level(\d+)/i);
                    n && i && s && (e.id = n[2], e.order = i[1], e.indent = parseInt(s[1]))
                }
                return e
            }

            function cN(r, e) {
                if (!r.childCount) return;
                const t = new Ia(r.document), n = function (s, l) {
                    const d = l.createRangeIn(s), g = new Si({name: /v:(.+)/}), v = [];
                    for (const _ of d) {
                        if (_.type != "elementStart") continue;
                        const x = _.item, M = x.previousSibling, O = M && M.is("element") ? M.name : null;
                        g.match(x) && x.getAttribute("o:gfxdata") && O !== "v:shapetype" && v.push(_.item.getAttribute("id"))
                    }
                    return v
                }(r, t);
                (function (s, l, d) {
                    const g = d.createRangeIn(l), v = new Si({name: "img"}), _ = [];
                    for (const x of g) if (x.item.is("element") && v.match(x.item)) {
                        const M = x.item, O = M.getAttribute("v:shapes") ? M.getAttribute("v:shapes").split(" ") : [];
                        O.length && O.every(j => s.indexOf(j) > -1) ? _.push(M) : M.getAttribute("src") || _.push(M)
                    }
                    for (const x of _) d.remove(x)
                })(n, r, t), function (s, l, d) {
                    const g = d.createRangeIn(l), v = [];
                    for (const M of g) if (M.type == "elementStart" && M.item.is("element", "v:shape")) {
                        const O = M.item.getAttribute("id");
                        if (s.includes(O)) continue;
                        _(M.item.parent.getChildren(), O) || v.push(M.item)
                    }
                    for (const M of v) {
                        const O = {src: x(M)};
                        M.hasAttribute("alt") && (O.alt = M.getAttribute("alt"));
                        const j = d.createElement("img", O);
                        d.insertChild(M.index + 1, j, M.parent)
                    }

                    function _(M, O) {
                        for (const j of M) if (j.is("element") && (j.name == "img" && j.getAttribute("v:shapes") == O || _(j.getChildren(), O))) return !0;
                        return !1
                    }

                    function x(M) {
                        for (const O of M.getChildren()) if (O.is("element") && O.getAttribute("src")) return O.getAttribute("src")
                    }
                }(n, r, t), function (s, l) {
                    const d = l.createRangeIn(s), g = new Si({name: /v:(.+)/}), v = [];
                    for (const _ of d) _.type == "elementStart" && g.match(_.item) && v.push(_.item);
                    for (const _ of v) l.remove(_)
                }(r, t);
                const i = function (s, l) {
                    const d = l.createRangeIn(s), g = new Si({name: "img"}), v = [];
                    for (const _ of d) _.item.is("element") && g.match(_.item) && _.item.getAttribute("src").startsWith("file://") && v.push(_.item);
                    return v
                }(r, t);
                i.length && function (s, l, d) {
                    if (s.length === l.length) for (let g = 0; g < s.length; g++) {
                        const v = `data:${l[g].type};base64,${uN(l[g].hex)}`;
                        d.setAttribute("src", v, s[g])
                    }
                }(i, function (s) {
                    if (!s) return [];
                    const l = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,
                        d = new RegExp("(?:(" + l.source + "))([\\da-fA-F\\s]+)\\}", "g"), g = s.match(d), v = [];
                    if (g) for (const _ of g) {
                        let x = !1;
                        _.includes("\\pngblip") ? x = "image/png" : _.includes("\\jpegblip") && (x = "image/jpeg"), x && v.push({
                            hex: _.replace(l, "").replace(/[^\da-fA-F]/g, ""),
                            type: x
                        })
                    }
                    return v
                }(e), t)
            }

            function uN(r) {
                return btoa(r.match(/\w{2}/g).map(e => String.fromCharCode(parseInt(e, 16))).join(""))
            }

            const dN = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,
                hN = /xmlns:o="urn:schemas-microsoft-com/i;

            class fN {
                constructor(e) {
                    this.document = e
                }

                isActive(e) {
                    return dN.test(e) || hN.test(e)
                }

                execute(e) {
                    const {body: t, stylesString: n} = e._parsedData;
                    sN(t, n), cN(t, e.dataTransfer.getData("text/rtf")), function (i) {
                        const s = [], l = new Ia(i.document);
                        for (const {item: d} of l.createRangeIn(i)) if (d.is("element")) {
                            for (const g of d.getClassNames()) /\bmso/gi.exec(g) && l.removeClass(g, d);
                            for (const g of d.getStyleNames()) /\bmso/gi.exec(g) && l.removeStyle(g, d);
                            d.is("element", "w:sdt") && s.push(d)
                        }
                        for (const d of s) {
                            const g = d.parent, v = g.getChildIndex(d);
                            l.insertChild(v, d.getChildren(), g), l.remove(d)
                        }
                    }(t), e.content = t
                }
            }

            function Dy(r, e, t, {blockElements: n, inlineObjectElements: i}) {
                let s = t.createPositionAt(r, e == "forward" ? "after" : "before");
                return s = s.getLastMatchingPosition(({item: l}) => l.is("element") && !n.includes(l.name) && !i.includes(l.name), {direction: e}), e == "forward" ? s.nodeAfter : s.nodeBefore
            }

            function xy(r, e) {
                return !!r && r.is("element") && e.includes(r.name)
            }

            const gN = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;

            class pN {
                constructor(e) {
                    this.document = e
                }

                isActive(e) {
                    return gN.test(e)
                }

                execute(e) {
                    const t = new Ia(this.document), {body: n} = e._parsedData;
                    (function (i, s) {
                        for (const l of i.getChildren()) if (l.is("element", "b") && l.getStyle("font-weight") === "normal") {
                            const d = i.getChildIndex(l);
                            s.remove(l), s.insertChild(d, l.getChildren(), i)
                        }
                    })(n, t), function (i, s) {
                        for (const l of s.createRangeIn(i)) {
                            const d = l.item;
                            if (d.is("element", "li")) {
                                const g = d.getChild(0);
                                g && g.is("element", "p") && s.unwrapElement(g)
                            }
                        }
                    }(n, t), function (i, s) {
                        const l = new Ss(s.document.stylesProcessor), d = new Mt(l, {renderingMode: "data"}),
                            g = d.blockElements, v = d.inlineObjectElements, _ = [];
                        for (const x of s.createRangeIn(i)) {
                            const M = x.item;
                            if (M.is("element", "br")) {
                                const O = Dy(M, "forward", s, {blockElements: g, inlineObjectElements: v}),
                                    j = Dy(M, "backward", s, {blockElements: g, inlineObjectElements: v}), U = xy(O, g);
                                (xy(j, g) || U) && _.push(M)
                            }
                        }
                        for (const x of _) x.hasClass("Apple-interchange-newline") ? s.remove(x) : s.replace(x, s.createElement("p"))
                    }(n, t), e.content = n
                }
            }

            const mN = /<google-sheets-html-origin/i;

            class bN {
                constructor(e) {
                    this.document = e
                }

                isActive(e) {
                    return mN.test(e)
                }

                execute(e) {
                    const t = new Ia(this.document), {body: n} = e._parsedData;
                    (function (i, s) {
                        for (const l of i.getChildren()) if (l.is("element", "google-sheets-html-origin")) {
                            const d = i.getChildIndex(l);
                            s.remove(l), s.insertChild(d, l.getChildren(), i)
                        }
                    })(n, t), function (i, s) {
                        for (const l of i.getChildren()) l.is("element", "table") && l.hasAttribute("xmlns") && s.removeAttribute("xmlns", l)
                    }(n, t), function (i, s) {
                        for (const l of i.getChildren()) l.is("element", "table") && l.getStyle("width") === "0px" && s.removeStyle("width", l)
                    }(n, t), function (i, s) {
                        for (const l of Array.from(i.getChildren())) l.is("element", "style") && s.remove(l)
                    }(n, t), e.content = n
                }
            }

            function Ey(r) {
                return r.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length === 1 ? " " : Array(t.length + 1).join("  ").substr(0, t.length))
            }

            function kN(r, e) {
                const t = new DOMParser, n = function (g) {
                        return Ey(Ey(g)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><")
                    }(function (g) {
                        const v = "</body>", _ = "</html>", x = g.indexOf(v);
                        if (x < 0) return g;
                        const M = g.indexOf(_, x + v.length);
                        return g.substring(0, x + v.length) + (M >= 0 ? g.substring(M) : "")
                    }(r = (r = r.replace(/<!--\[if gte vml 1]>/g, "")).replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, ""))),
                    i = t.parseFromString(n, "text/html");
                (function (g) {
                    g.querySelectorAll("span[style*=spacerun]").forEach(v => {
                        const _ = v, x = _.innerText.length || 0;
                        _.innerText = Array(x + 1).join("  ").substr(0, x)
                    })
                })(i);
                const s = i.body.innerHTML, l = function (g, v) {
                    const _ = new Ss(v), x = new Mt(_, {renderingMode: "data"}), M = g.createDocumentFragment(),
                        O = g.body.childNodes;
                    for (; O.length > 0;) M.appendChild(O[0]);
                    return x.domToView(M, {skipComments: !0})
                }(i, e), d = function (g) {
                    const v = [], _ = [], x = Array.from(g.getElementsByTagName("style"));
                    for (const M of x) M.sheet && M.sheet.cssRules && M.sheet.cssRules.length && (v.push(M.sheet), _.push(M.innerHTML));
                    return {styles: v, stylesString: _.join(" ")}
                }(i);
                return {body: l, bodyString: s, styles: d.styles, stylesString: d.stylesString}
            }

            function Qn(r, e, t, n, i = 1) {
                e != null && i != null && e > i ? n.setAttribute(r, e, t) : n.removeAttribute(r, t)
            }

            function Gl(r, e, t = {}) {
                const n = r.createElement("tableCell", t);
                return r.insertElement("paragraph", n), r.insert(n, e), n
            }

            function ak(r, e) {
                const t = e.parent.parent,
                    n = parseInt(t.getAttribute("headingColumns") || "0"), {column: i} = r.getCellLocation(e);
                return !!n && i < n
            }

            function vN() {
                return r => {
                    r.on("element:table", (e, t, n) => {
                        const i = t.viewItem;
                        if (!n.consumable.test(i, {name: !0})) return;
                        const {rows: s, headingRows: l, headingColumns: d} = function (_) {
                            let x, M = 0;
                            const O = [], j = [];
                            let U;
                            for (const K of Array.from(_.getChildren())) {
                                if (K.name !== "tbody" && K.name !== "thead" && K.name !== "tfoot") continue;
                                K.name !== "thead" || U || (U = K);
                                const ne = Array.from(K.getChildren()).filter(pe => pe.is("element", "tr"));
                                for (const pe of ne) if (U && K === U || K.name === "tbody" && Array.from(pe.getChildren()).length && Array.from(pe.getChildren()).every(Se => Se.is("element", "th"))) M++, O.push(pe); else {
                                    j.push(pe);
                                    const Se = wN(pe);
                                    (!x || Se < x) && (x = Se)
                                }
                            }
                            return {headingRows: M, headingColumns: x || 0, rows: [...O, ...j]}
                        }(i), g = {};
                        d && (g.headingColumns = d), l && (g.headingRows = l);
                        const v = n.writer.createElement("table", g);
                        if (n.safeInsert(v, t.modelCursor)) {
                            if (n.consumable.consume(i, {name: !0}), s.forEach(_ => n.convertItem(_, n.writer.createPositionAt(v, "end"))), n.convertChildren(i, n.writer.createPositionAt(v, "end")), v.isEmpty) {
                                const _ = n.writer.createElement("tableRow");
                                n.writer.insert(_, n.writer.createPositionAt(v, "end")), Gl(n.writer, n.writer.createPositionAt(_, "end"))
                            }
                            n.updateConversionResult(v, t)
                        }
                    })
                }
            }

            function Sy(r) {
                return e => {
                    e.on(`element:${r}`, (t, n, {writer: i}) => {
                        if (!n.modelRange) return;
                        const s = n.modelRange.start.nodeAfter, l = i.createPositionAt(s, 0);
                        if (n.viewItem.isEmpty) return void i.insertElement("paragraph", l);
                        const d = Array.from(s.getChildren());
                        if (d.every(g => g.is("element", "$marker"))) {
                            const g = i.createElement("paragraph");
                            i.insert(g, i.createPositionAt(s, 0));
                            for (const v of d) i.move(i.createRangeOn(v), i.createPositionAt(g, "end"))
                        }
                    }, {priority: "low"})
                }
            }

            function wN(r) {
                let e = 0, t = 0;
                const n = Array.from(r.getChildren()).filter(i => i.name === "th" || i.name === "td");
                for (; t < n.length && n[t].name === "th";) {
                    const i = n[t];
                    e += parseInt(i.getAttribute("colspan") || "1"), t++
                }
                return e
            }

            class bn {
                constructor(e, t = {}) {
                    this._jumpedToStartRow = !1, this._table = e, this._startRow = t.row !== void 0 ? t.row : t.startRow || 0, this._endRow = t.row !== void 0 ? t.row : t.endRow, this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0, this._endColumn = t.column !== void 0 ? t.column : t.endColumn, this._includeAllSlots = !!t.includeAllSlots, this._skipRows = new Set, this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = new Map, this._nextCellAtColumn = -1
                }

                [Symbol.iterator]() {
                    return this
                }

                next() {
                    this._canJumpToStartRow() && this._jumpToNonSpannedRowClosestToStartRow();
                    const e = this._table.getChild(this._rowIndex);
                    if (!e || this._isOverEndRow()) return {done: !0, value: void 0};
                    if (!e.is("element", "tableRow")) return this._rowIndex++, this.next();
                    if (this._isOverEndColumn()) return this._advanceToNextRow();
                    let t = null;
                    const n = this._getSpanned();
                    if (n) this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(n.cell, n.row, n.column)); else {
                        const i = e.getChild(this._cellIndex);
                        if (!i) return this._advanceToNextRow();
                        const s = parseInt(i.getAttribute("colspan") || "1"),
                            l = parseInt(i.getAttribute("rowspan") || "1");
                        (s > 1 || l > 1) && this._recordSpans(i, l, s), this._shouldSkipSlot() || (t = this._formatOutValue(i)), this._nextCellAtColumn = this._column + s
                    }
                    return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t || this.next()
                }

                skipRow(e) {
                    this._skipRows.add(e)
                }

                _advanceToNextRow() {
                    return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next()
                }

                _isOverEndRow() {
                    return this._endRow !== void 0 && this._row > this._endRow
                }

                _isOverEndColumn() {
                    return this._endColumn !== void 0 && this._column > this._endColumn
                }

                _formatOutValue(e, t = this._row, n = this._column) {
                    return {done: !1, value: new AN(this, e, t, n)}
                }

                _shouldSkipSlot() {
                    const e = this._skipRows.has(this._row), t = this._row < this._startRow,
                        n = this._column < this._startColumn,
                        i = this._endColumn !== void 0 && this._column > this._endColumn;
                    return e || t || n || i
                }

                _getSpanned() {
                    const e = this._spannedCells.get(this._row);
                    return e && e.get(this._column) || null
                }

                _recordSpans(e, t, n) {
                    const i = {cell: e, row: this._row, column: this._column};
                    for (let s = this._row; s < this._row + t; s++) for (let l = this._column; l < this._column + n; l++) s == this._row && l == this._column || this._markSpannedCell(s, l, i)
                }

                _markSpannedCell(e, t, n) {
                    this._spannedCells.has(e) || this._spannedCells.set(e, new Map), this._spannedCells.get(e).set(t, n)
                }

                _canJumpToStartRow() {
                    return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow
                }

                _jumpToNonSpannedRowClosestToStartRow() {
                    const e = this._getRowLength(0);
                    for (let t = this._startRow; !this._jumpedToStartRow; t--) e === this._getRowLength(t) && (this._row = t, this._rowIndex = t, this._jumpedToStartRow = !0)
                }

                _getRowLength(e) {
                    return [...this._table.getChild(e).getChildren()].reduce((t, n) => t + parseInt(n.getAttribute("colspan") || "1"), 0)
                }
            }

            class AN {
                constructor(e, t, n, i) {
                    this.cell = t, this.row = e._row, this.column = e._column, this.cellAnchorRow = n, this.cellAnchorColumn = i, this._cellIndex = e._cellIndex, this._rowIndex = e._rowIndex, this._table = e._table
                }

                get isAnchor() {
                    return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn
                }

                get cellWidth() {
                    return parseInt(this.cell.getAttribute("colspan") || "1")
                }

                get cellHeight() {
                    return parseInt(this.cell.getAttribute("rowspan") || "1")
                }

                get rowIndex() {
                    return this._rowIndex
                }

                getPositionBefore() {
                    return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex)
                }
            }

            function Ty(r, e) {
                return (t, {writer: n}) => {
                    const i = t.getAttribute("headingRows") || 0, s = n.createContainerElement("table", null, []),
                        l = n.createContainerElement("figure", {class: "table"}, s);
                    i > 0 && n.insert(n.createPositionAt(s, "end"), n.createContainerElement("thead", null, n.createSlot(d => d.is("element", "tableRow") && d.index < i))), i < r.getRows(t) && n.insert(n.createPositionAt(s, "end"), n.createContainerElement("tbody", null, n.createSlot(d => d.is("element", "tableRow") && d.index >= i)));
                    for (const {
                        positionOffset: d,
                        filter: g
                    } of e.additionalSlots) n.insert(n.createPositionAt(s, d), n.createSlot(g));
                    return n.insert(n.createPositionAt(s, "after"), n.createSlot(d => !d.is("element", "tableRow") && !e.additionalSlots.some(({filter: g}) => g(d)))), e.asWidget ? function (d, g) {
                        return g.setCustomProperty("table", !0, d), Rb(d, g, {hasSelectionHandle: !0})
                    }(l, n) : l
                }
            }

            function Iy(r = {}) {
                return (e, {writer: t}) => {
                    const n = e.parent, i = n.parent, s = i.getChildIndex(n), l = new bn(i, {row: s}),
                        d = i.getAttribute("headingRows") || 0, g = i.getAttribute("headingColumns") || 0;
                    let v = null;
                    for (const _ of l) if (_.cell == e) {
                        const x = _.row < d || _.column < g ? "th" : "td";
                        v = r.asWidget ? EC(t.createEditableElement(x), t) : t.createContainerElement(x);
                        break
                    }
                    return v
                }
            }

            function My(r = {}) {
                return (e, {writer: t}) => {
                    if (!e.parent.is("element", "tableCell") || !By(e)) return null;
                    if (r.asWidget) return t.createContainerElement("span", {class: "ck-table-bogus-paragraph"});
                    {
                        const n = t.createContainerElement("p");
                        return t.setCustomProperty("dataPipeline:transparentRendering", !0, n), n
                    }
                }
            }

            function By(r) {
                return r.parent.childCount == 1 && !!r.getAttributeKeys().next().done
            }

            class CN extends Ft {
                refresh() {
                    const e = this.editor.model, t = e.document.selection, n = e.schema;
                    this.isEnabled = function (i, s) {
                        const l = i.getFirstPosition().parent, d = l === l.root ? l : l.parent;
                        return s.checkChild(d, "table")
                    }(t, n)
                }

                execute(e = {}) {
                    const t = this.editor, n = t.model, i = t.plugins.get("TableUtils"),
                        s = t.config.get("table.defaultHeadings.rows"),
                        l = t.config.get("table.defaultHeadings.columns");
                    e.headingRows === void 0 && s && (e.headingRows = s), e.headingColumns === void 0 && l && (e.headingColumns = l), n.change(d => {
                        const g = i.createTable(d, e);
                        n.insertObject(g, null, null, {findOptimalPosition: "auto"}), d.setSelection(d.createPositionAt(g.getNodeByPath([0, 0, 0]), 0))
                    })
                }
            }

            class Ny extends Ft {
                constructor(e, t = {}) {
                    super(e), this.order = t.order || "below"
                }

                refresh() {
                    const e = this.editor.model.document.selection,
                        t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
                    this.isEnabled = t
                }

                execute() {
                    const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"),
                        i = this.order === "above", s = n.getSelectionAffectedTableCells(t), l = n.getRowIndexes(s),
                        d = i ? l.first : l.last, g = s[0].findAncestor("table");
                    n.insertRows(g, {at: i ? d : d + 1, copyStructureFromAbove: !i})
                }
            }

            class Ly extends Ft {
                constructor(e, t = {}) {
                    super(e), this.order = t.order || "right"
                }

                refresh() {
                    const e = this.editor.model.document.selection,
                        t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
                    this.isEnabled = t
                }

                execute() {
                    const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"),
                        i = this.order === "left", s = n.getSelectionAffectedTableCells(t), l = n.getColumnIndexes(s),
                        d = i ? l.first : l.last, g = s[0].findAncestor("table");
                    n.insertColumns(g, {columns: 1, at: i ? d : d + 1})
                }
            }

            class Py extends Ft {
                constructor(e, t = {}) {
                    super(e), this.direction = t.direction || "horizontally"
                }

                refresh() {
                    const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = e.length === 1
                }

                execute() {
                    const e = this.editor.plugins.get("TableUtils"),
                        t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
                    this.direction === "horizontally" ? e.splitCellHorizontally(t, 2) : e.splitCellVertically(t, 2)
                }
            }

            function Oy(r, e, t) {
                const {startRow: n, startColumn: i, endRow: s, endColumn: l} = e, d = t.createElement("table"),
                    g = s - n + 1;
                for (let _ = 0; _ < g; _++) t.insertElement("tableRow", d, "end");
                const v = [...new bn(r, {startRow: n, endRow: s, startColumn: i, endColumn: l, includeAllSlots: !0})];
                for (const {row: _, column: x, cell: M, isAnchor: O, cellAnchorRow: j, cellAnchorColumn: U} of v) {
                    const K = _ - n, ne = d.getChild(K);
                    if (O) {
                        const pe = t.cloneElement(M);
                        t.append(pe, ne), Vy(pe, _, x, s, l, t)
                    } else (j < n || U < i) && Gl(t, t.createPositionAt(ne, "end"))
                }
                return function (_, x, M, O, j) {
                    const U = parseInt(x.getAttribute("headingRows") || "0");
                    U > 0 && Qn("headingRows", U - M, _, j, 0);
                    const K = parseInt(x.getAttribute("headingColumns") || "0");
                    K > 0 && Qn("headingColumns", K - O, _, j, 0)
                }(d, r, n, i, t), d
            }

            function Fy(r, e, t = 0) {
                const n = [], i = new bn(r, {startRow: t, endRow: e - 1});
                for (const s of i) {
                    const {row: l, cellHeight: d} = s;
                    l < e && e <= l + d - 1 && n.push(s)
                }
                return n
            }

            function Ry(r, e, t) {
                const n = r.parent, i = n.parent, s = n.index, l = e - s, d = {},
                    g = parseInt(r.getAttribute("rowspan")) - l;
                g > 1 && (d.rowspan = g);
                const v = parseInt(r.getAttribute("colspan") || "1");
                v > 1 && (d.colspan = v);
                const _ = s + l, x = [...new bn(i, {startRow: s, endRow: _, includeAllSlots: !0})];
                let M, O = null;
                for (const j of x) {
                    const {row: U, column: K, cell: ne} = j;
                    ne === r && M === void 0 && (M = K), M !== void 0 && M === K && U === _ && (O = Gl(t, j.getPositionBefore(), d))
                }
                return Qn("rowspan", l, r, t), O
            }

            function zy(r, e) {
                const t = [], n = new bn(r);
                for (const i of n) {
                    const {column: s, cellWidth: l} = i;
                    s < e && e <= s + l - 1 && t.push(i)
                }
                return t
            }

            function jy(r, e, t, n) {
                const i = t - e, s = {}, l = parseInt(r.getAttribute("colspan")) - i;
                l > 1 && (s.colspan = l);
                const d = parseInt(r.getAttribute("rowspan") || "1");
                d > 1 && (s.rowspan = d);
                const g = Gl(n, n.createPositionAfter(r), s);
                return Qn("colspan", i, r, n), g
            }

            function Vy(r, e, t, n, i, s) {
                const l = parseInt(r.getAttribute("colspan") || "1"), d = parseInt(r.getAttribute("rowspan") || "1");
                t + l - 1 > i && Qn("colspan", i - t + 1, r, s, 1), e + d - 1 > n && Qn("rowspan", n - e + 1, r, s, 1)
            }

            function lk(r, e) {
                const t = e.getColumns(r), n = new Array(t).fill(0);
                for (const {column: s} of new bn(r)) n[s]++;
                const i = n.reduce((s, l, d) => l ? s : [...s, d], []);
                if (i.length > 0) {
                    const s = i[i.length - 1];
                    return e.removeColumns(r, {at: s}), !0
                }
                return !1
            }

            function ck(r, e) {
                const t = [], n = e.getRows(r);
                for (let i = 0; i < n; i++) r.getChild(i).isEmpty && t.push(i);
                if (t.length > 0) {
                    const i = t[t.length - 1];
                    return e.removeRows(r, {at: i}), !0
                }
                return !1
            }

            function uk(r, e) {
                lk(r, e) || ck(r, e)
            }

            function Hy(r, e) {
                const t = Array.from(new bn(r, {startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow}));
                if (t.every(({cellHeight: i}) => i === 1)) return e.lastRow;
                const n = t[0].cellHeight - 1;
                return e.lastRow + n
            }

            function Uy(r, e) {
                const t = Array.from(new bn(r, {startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn}));
                if (t.every(({cellWidth: i}) => i === 1)) return e.lastColumn;
                const n = t[0].cellWidth - 1;
                return e.lastColumn + n
            }

            class ip extends Ft {
                constructor(e, t) {
                    super(e), this.direction = t.direction, this.isHorizontal = this.direction == "right" || this.direction == "left"
                }

                refresh() {
                    const e = this._getMergeableCell();
                    this.value = e, this.isEnabled = !!e
                }

                execute() {
                    const e = this.editor.model, t = e.document,
                        n = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(t.selection)[0],
                        i = this.value, s = this.direction;
                    e.change(l => {
                        const d = s == "right" || s == "down", g = d ? n : i, v = d ? i : n, _ = v.parent;
                        (function (U, K, ne) {
                            qy(U) || (qy(K) && ne.remove(ne.createRangeIn(K)), ne.move(ne.createRangeIn(U), ne.createPositionAt(K, "end"))), ne.remove(U)
                        })(v, g, l);
                        const x = this.isHorizontal ? "colspan" : "rowspan", M = parseInt(n.getAttribute(x) || "1"),
                            O = parseInt(i.getAttribute(x) || "1");
                        l.setAttribute(x, M + O, g), l.setSelection(l.createRangeIn(g));
                        const j = this.editor.plugins.get("TableUtils");
                        uk(_.findAncestor("table"), j)
                    })
                }

                _getMergeableCell() {
                    const e = this.editor.model.document, t = this.editor.plugins.get("TableUtils"),
                        n = t.getTableCellsContainingSelection(e.selection)[0];
                    if (!n) return;
                    const i = this.isHorizontal ? function (d, g, v) {
                        const _ = d.parent, x = _.parent, M = g == "right" ? d.nextSibling : d.previousSibling,
                            O = (x.getAttribute("headingColumns") || 0) > 0;
                        if (!M) return;
                        const j = g == "right" ? d : M,
                            U = g == "right" ? M : d, {column: K} = v.getCellLocation(j), {column: ne} = v.getCellLocation(U),
                            pe = parseInt(j.getAttribute("colspan") || "1"), Se = ak(v, j), Je = ak(v, U);
                        if (!(O && Se != Je)) return K + pe === ne ? M : void 0
                    }(n, this.direction, t) : function (d, g, v) {
                        const _ = d.parent, x = _.parent, M = x.getChildIndex(_);
                        if (g == "down" && M === v.getRows(x) - 1 || g == "up" && M === 0) return null;
                        const O = parseInt(d.getAttribute("rowspan") || "1"), j = x.getAttribute("headingRows") || 0,
                            U = g == "down" && M + O === j, K = g == "up" && M === j;
                        if (j && (U || K)) return null;
                        const ne = parseInt(d.getAttribute("rowspan") || "1"), pe = g == "down" ? M + ne : M,
                            Se = [...new bn(x, {endRow: pe})], Je = Se.find(Zt => Zt.cell === d), wt = Je.column,
                            qt = Se.find(({
                                              row: Zt,
                                              cellHeight: Jn,
                                              column: Xn
                                          }) => Xn === wt && (g == "down" ? Zt === pe : pe === Zt + Jn));
                        return qt && qt.cell ? qt.cell : null
                    }(n, this.direction, t);
                    if (!i) return;
                    const s = this.isHorizontal ? "rowspan" : "colspan", l = parseInt(n.getAttribute(s) || "1");
                    return parseInt(i.getAttribute(s) || "1") === l ? i : void 0
                }
            }

            function qy(r) {
                const e = r.getChild(0);
                return r.childCount == 1 && e.is("element", "paragraph") && e.isEmpty
            }

            class _N extends Ft {
                refresh() {
                    const e = this.editor.plugins.get("TableUtils"),
                        t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
                    if (n) {
                        const i = n.findAncestor("table"), s = e.getRows(i) - 1, l = e.getRowIndexes(t),
                            d = l.first === 0 && l.last === s;
                        this.isEnabled = !d
                    } else this.isEnabled = !1
                }

                execute() {
                    const e = this.editor.model, t = this.editor.plugins.get("TableUtils"),
                        n = t.getSelectionAffectedTableCells(e.document.selection), i = t.getRowIndexes(n), s = n[0],
                        l = s.findAncestor("table"), d = t.getCellLocation(s).column;
                    e.change(g => {
                        const v = i.last - i.first + 1;
                        t.removeRows(l, {at: i.first, rows: v});
                        const _ = function (x, M, O, j) {
                            const U = x.getChild(Math.min(M, j - 1));
                            let K = U.getChild(0), ne = 0;
                            for (const pe of U.getChildren()) {
                                if (ne > O) return K;
                                K = pe, ne += parseInt(pe.getAttribute("colspan") || "1")
                            }
                            return K
                        }(l, i.first, d, t.getRows(l));
                        g.setSelection(g.createPositionAt(_, 0))
                    })
                }
            }

            class yN extends Ft {
                refresh() {
                    const e = this.editor.plugins.get("TableUtils"),
                        t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
                    if (n) {
                        const i = n.findAncestor("table"), s = e.getColumns(i), {
                            first: l,
                            last: d
                        } = e.getColumnIndexes(t);
                        this.isEnabled = d - l < s - 1
                    } else this.isEnabled = !1
                }

                execute() {
                    const e = this.editor.plugins.get("TableUtils"), [t, n] = function (g, v) {
                            const _ = v.getSelectionAffectedTableCells(g), x = _[0], M = _.pop(), O = [x, M];
                            return x.isBefore(M) ? O : O.reverse()
                        }(this.editor.model.document.selection, e), i = t.parent.parent, s = [...new bn(i)],
                        l = {first: s.find(g => g.cell === t).column, last: s.find(g => g.cell === n).column},
                        d = function (g, v, _, x) {
                            return parseInt(_.getAttribute("colspan") || "1") > 1 ? _ : v.previousSibling || _.nextSibling ? _.nextSibling || v.previousSibling : x.first ? g.reverse().find(({column: O}) => O < x.first).cell : g.reverse().find(({column: O}) => O > x.last).cell
                        }(s, t, n, l);
                    this.editor.model.change(g => {
                        const v = l.last - l.first + 1;
                        e.removeColumns(i, {at: l.first, columns: v}), g.setSelection(g.createPositionAt(d, 0))
                    })
                }
            }

            class DN extends Ft {
                refresh() {
                    const e = this.editor.plugins.get("TableUtils"), t = this.editor.model,
                        n = e.getSelectionAffectedTableCells(t.document.selection), i = n.length > 0;
                    this.isEnabled = i, this.value = i && n.every(s => this._isInHeading(s, s.parent.parent))
                }

                execute(e = {}) {
                    if (e.forceValue === this.value) return;
                    const t = this.editor.plugins.get("TableUtils"), n = this.editor.model,
                        i = t.getSelectionAffectedTableCells(n.document.selection),
                        s = i[0].findAncestor("table"), {first: l, last: d} = t.getRowIndexes(i),
                        g = this.value ? l : d + 1, v = s.getAttribute("headingRows") || 0;
                    n.change(_ => {
                        if (g) {
                            const x = Fy(s, g, g > v ? v : 0);
                            for (const {cell: M} of x) Ry(M, g, _)
                        }
                        Qn("headingRows", g, s, _, 0)
                    })
                }

                _isInHeading(e, t) {
                    const n = parseInt(t.getAttribute("headingRows") || "0");
                    return !!n && e.parent.index < n
                }
            }

            class xN extends Ft {
                refresh() {
                    const e = this.editor.model, t = this.editor.plugins.get("TableUtils"),
                        n = t.getSelectionAffectedTableCells(e.document.selection), i = n.length > 0;
                    this.isEnabled = i, this.value = i && n.every(s => ak(t, s))
                }

                execute(e = {}) {
                    if (e.forceValue === this.value) return;
                    const t = this.editor.plugins.get("TableUtils"), n = this.editor.model,
                        i = t.getSelectionAffectedTableCells(n.document.selection),
                        s = i[0].findAncestor("table"), {first: l, last: d} = t.getColumnIndexes(i),
                        g = this.value ? l : d + 1;
                    n.change(v => {
                        if (g) {
                            const _ = zy(s, g);
                            for (const {cell: x, column: M} of _) jy(x, M, g, v)
                        }
                        Qn("headingColumns", g, s, v, 0)
                    })
                }
            }

            function EN(r) {
                if (r.is("element", "tableColumnGroup")) return r;
                const e = r.getChildren();
                return Array.from(e).find(t => t.is("element", "tableColumnGroup"))
            }

            function SN(r) {
                const e = EN(r);
                return e ? Array.from(e.getChildren()) : []
            }

            class qr extends Re {
                static get pluginName() {
                    return "TableUtils"
                }

                init() {
                    this.decorate("insertColumns"), this.decorate("insertRows")
                }

                getCellLocation(e) {
                    const t = e.parent, n = t.parent, i = n.getChildIndex(t), s = new bn(n, {row: i});
                    for (const {cell: l, row: d, column: g} of s) if (l === e) return {row: d, column: g}
                }

                createTable(e, t) {
                    const n = e.createElement("table"), i = t.rows || 2, s = t.columns || 2;
                    return dk(e, n, 0, i, s), t.headingRows && Qn("headingRows", Math.min(t.headingRows, i), n, e, 0), t.headingColumns && Qn("headingColumns", Math.min(t.headingColumns, s), n, e, 0), n
                }

                insertRows(e, t = {}) {
                    const n = this.editor.model, i = t.at || 0, s = t.rows || 1,
                        l = t.copyStructureFromAbove !== void 0, d = t.copyStructureFromAbove ? i - 1 : i,
                        g = this.getRows(e), v = this.getColumns(e);
                    if (i > g) throw new R("tableutils-insertrows-insert-out-of-range", this, {options: t});
                    n.change(_ => {
                        const x = e.getAttribute("headingRows") || 0;
                        if (x > i && Qn("headingRows", x + s, e, _, 0), !l && (i === 0 || i === g)) return void dk(_, e, i, s, v);
                        const M = l ? Math.max(i, d) : i, O = new bn(e, {endRow: M}), j = new Array(v).fill(1);
                        for (const {row: U, column: K, cellHeight: ne, cellWidth: pe, cell: Se} of O) {
                            const Je = U + ne - 1, wt = U <= d && d <= Je;
                            U < i && i <= Je ? (_.setAttribute("rowspan", ne + s, Se), j[K] = -pe) : l && wt && (j[K] = pe)
                        }
                        for (let U = 0; U < s; U++) {
                            const K = _.createElement("tableRow");
                            _.insert(K, e, i);
                            for (let ne = 0; ne < j.length; ne++) {
                                const pe = j[ne], Se = _.createPositionAt(K, "end");
                                pe > 0 && Gl(_, Se, pe > 1 ? {colspan: pe} : void 0), ne += Math.abs(pe) - 1
                            }
                        }
                    })
                }

                insertColumns(e, t = {}) {
                    const n = this.editor.model, i = t.at || 0, s = t.columns || 1;
                    n.change(l => {
                        const d = e.getAttribute("headingColumns");
                        i < d && l.setAttribute("headingColumns", d + s, e);
                        const g = this.getColumns(e);
                        if (i === 0 || g === i) {
                            for (const _ of e.getChildren()) _.is("element", "tableRow") && Du(s, l, l.createPositionAt(_, i ? "end" : 0));
                            return
                        }
                        const v = new bn(e, {column: i, includeAllSlots: !0});
                        for (const _ of v) {
                            const {
                                row: x,
                                cell: M,
                                cellAnchorColumn: O,
                                cellAnchorRow: j,
                                cellWidth: U,
                                cellHeight: K
                            } = _;
                            if (O < i) {
                                l.setAttribute("colspan", U + s, M);
                                const ne = j + K - 1;
                                for (let pe = x; pe <= ne; pe++) v.skipRow(pe)
                            } else Du(s, l, _.getPositionBefore())
                        }
                    })
                }

                removeRows(e, t) {
                    const n = this.editor.model, i = t.rows || 1, s = this.getRows(e), l = t.at, d = l + i - 1;
                    if (d > s - 1) throw new R("tableutils-removerows-row-index-out-of-range", this, {
                        table: e,
                        options: t
                    });
                    n.change(g => {
                        const v = {first: l, last: d}, {cellsToMove: _, cellsToTrim: x} = function (M, {
                            first: O,
                            last: j
                        }) {
                            const U = new Map, K = [];
                            for (const {row: ne, column: pe, cellHeight: Se, cell: Je} of new bn(M, {endRow: j})) {
                                const wt = ne + Se - 1;
                                if (ne >= O && ne <= j && wt > j) {
                                    const qt = Se - (j - ne + 1);
                                    U.set(pe, {cell: Je, rowspan: qt})
                                }
                                if (ne < O && wt >= O) {
                                    let qt;
                                    qt = wt >= j ? j - O + 1 : wt - O + 1, K.push({cell: Je, rowspan: Se - qt})
                                }
                            }
                            return {cellsToMove: U, cellsToTrim: K}
                        }(e, v);
                        _.size && function (M, O, j, U) {
                            const K = new bn(M, {includeAllSlots: !0, row: O}), ne = [...K], pe = M.getChild(O);
                            let Se;
                            for (const {column: Je, cell: wt, isAnchor: qt} of ne) if (j.has(Je)) {
                                const {cell: Zt, rowspan: Jn} = j.get(Je),
                                    Xn = Se ? U.createPositionAfter(Se) : U.createPositionAt(pe, 0);
                                U.move(U.createRangeOn(Zt), Xn), Qn("rowspan", Jn, Zt, U), Se = Zt
                            } else qt && (Se = wt)
                        }(e, d + 1, _, g);
                        for (let M = d; M >= l; M--) g.remove(e.getChild(M));
                        for (const {rowspan: M, cell: O} of x) Qn("rowspan", M, O, g);
                        (function (M, {first: O, last: j}, U) {
                            const K = M.getAttribute("headingRows") || 0;
                            O < K && Qn("headingRows", j < K ? K - (j - O + 1) : O, M, U, 0)
                        })(e, v, g), lk(e, this) || ck(e, this)
                    })
                }

                removeColumns(e, t) {
                    const n = this.editor.model, i = t.at, s = t.columns || 1, l = t.at + s - 1;
                    n.change(d => {
                        (function (v, _, x) {
                            const M = v.getAttribute("headingColumns") || 0;
                            if (M && _.first < M) {
                                const O = Math.min(M - 1, _.last) - _.first + 1;
                                x.setAttribute("headingColumns", M - O, v)
                            }
                        })(e, {first: i, last: l}, d);
                        const g = SN(e);
                        for (let v = l; v >= i; v--) {
                            for (const {
                                cell: _,
                                column: x,
                                cellWidth: M
                            } of [...new bn(e)]) x <= v && M > 1 && x + M > v ? Qn("colspan", M - 1, _, d) : x === v && d.remove(_);
                            if (g[v]) {
                                const _ = v === 0 ? g[1] : g[v - 1], x = parseFloat(g[v].getAttribute("columnWidth")),
                                    M = parseFloat(_.getAttribute("columnWidth"));
                                d.remove(g[v]), d.setAttribute("columnWidth", x + M + "%", _)
                            }
                        }
                        ck(e, this) || lk(e, this)
                    })
                }

                splitCellVertically(e, t = 2) {
                    const n = this.editor.model, i = e.parent.parent, s = parseInt(e.getAttribute("rowspan") || "1"),
                        l = parseInt(e.getAttribute("colspan") || "1");
                    n.change(d => {
                        if (l > 1) {
                            const {newCellsSpan: g, updatedSpan: v} = Wy(l, t);
                            Qn("colspan", v, e, d);
                            const _ = {};
                            g > 1 && (_.colspan = g), s > 1 && (_.rowspan = s), Du(l > t ? t - 1 : l - 1, d, d.createPositionAfter(e), _)
                        }
                        if (l < t) {
                            const g = t - l, v = [...new bn(i)], {column: _} = v.find(({cell: j}) => j === e),
                                x = v.filter(({
                                                  cell: j,
                                                  cellWidth: U,
                                                  column: K
                                              }) => j !== e && K === _ || K < _ && K + U > _);
                            for (const {cell: j, cellWidth: U} of x) d.setAttribute("colspan", U + g, j);
                            const M = {};
                            s > 1 && (M.rowspan = s), Du(g, d, d.createPositionAfter(e), M);
                            const O = i.getAttribute("headingColumns") || 0;
                            O > _ && Qn("headingColumns", O + g, i, d)
                        }
                    })
                }

                splitCellHorizontally(e, t = 2) {
                    const n = this.editor.model, i = e.parent, s = i.parent, l = s.getChildIndex(i),
                        d = parseInt(e.getAttribute("rowspan") || "1"), g = parseInt(e.getAttribute("colspan") || "1");
                    n.change(v => {
                        if (d > 1) {
                            const _ = [...new bn(s, {
                                startRow: l,
                                endRow: l + d - 1,
                                includeAllSlots: !0
                            })], {newCellsSpan: x, updatedSpan: M} = Wy(d, t);
                            Qn("rowspan", M, e, v);
                            const {column: O} = _.find(({cell: U}) => U === e), j = {};
                            x > 1 && (j.rowspan = x), g > 1 && (j.colspan = g);
                            for (const U of _) {
                                const {column: K, row: ne} = U;
                                ne >= l + M && K === O && (ne + l + M) % x == 0 && Du(1, v, U.getPositionBefore(), j)
                            }
                        }
                        if (d < t) {
                            const _ = t - d, x = [...new bn(s, {startRow: 0, endRow: l})];
                            for (const {cell: j, cellHeight: U, row: K} of x) if (j !== e && K + U > l) {
                                const ne = U + _;
                                v.setAttribute("rowspan", ne, j)
                            }
                            const M = {};
                            g > 1 && (M.colspan = g), dk(v, s, l + 1, _, 1, M);
                            const O = s.getAttribute("headingRows") || 0;
                            O > l && Qn("headingRows", O + _, s, v)
                        }
                    })
                }

                getColumns(e) {
                    return [...e.getChild(0).getChildren()].reduce((t, n) => t + parseInt(n.getAttribute("colspan") || "1"), 0)
                }

                getRows(e) {
                    return Array.from(e.getChildren()).reduce((t, n) => n.is("element", "tableRow") ? t + 1 : t, 0)
                }

                createTableWalker(e, t = {}) {
                    return new bn(e, t)
                }

                getSelectedTableCells(e) {
                    const t = [];
                    for (const n of this.sortRanges(e.getRanges())) {
                        const i = n.getContainedElement();
                        i && i.is("element", "tableCell") && t.push(i)
                    }
                    return t
                }

                getTableCellsContainingSelection(e) {
                    const t = [];
                    for (const n of e.getRanges()) {
                        const i = n.start.findAncestor("tableCell");
                        i && t.push(i)
                    }
                    return t
                }

                getSelectionAffectedTableCells(e) {
                    const t = this.getSelectedTableCells(e);
                    return t.length ? t : this.getTableCellsContainingSelection(e)
                }

                getRowIndexes(e) {
                    const t = e.map(n => n.parent.index);
                    return this._getFirstLastIndexesObject(t)
                }

                getColumnIndexes(e) {
                    const t = e[0].findAncestor("table"),
                        n = [...new bn(t)].filter(i => e.includes(i.cell)).map(i => i.column);
                    return this._getFirstLastIndexesObject(n)
                }

                isSelectionRectangular(e) {
                    if (e.length < 2 || !this._areCellInTheSameTableSection(e)) return !1;
                    const t = new Set, n = new Set;
                    let i = 0;
                    for (const l of e) {
                        const {row: d, column: g} = this.getCellLocation(l),
                            v = parseInt(l.getAttribute("rowspan")) || 1, _ = parseInt(l.getAttribute("colspan")) || 1;
                        t.add(d), n.add(g), v > 1 && t.add(d + v - 1), _ > 1 && n.add(g + _ - 1), i += v * _
                    }
                    return function (l, d) {
                        const g = Array.from(l.values()), v = Array.from(d.values()), _ = Math.max(...g),
                            x = Math.min(...g), M = Math.max(...v), O = Math.min(...v);
                        return (_ - x + 1) * (M - O + 1)
                    }(t, n) == i
                }

                sortRanges(e) {
                    return Array.from(e).sort(TN)
                }

                _getFirstLastIndexesObject(e) {
                    const t = e.sort((n, i) => n - i);
                    return {first: t[0], last: t[t.length - 1]}
                }

                _areCellInTheSameTableSection(e) {
                    const t = e[0].findAncestor("table"), n = this.getRowIndexes(e),
                        i = parseInt(t.getAttribute("headingRows")) || 0;
                    if (!this._areIndexesInSameSection(n, i)) return !1;
                    const s = this.getColumnIndexes(e), l = parseInt(t.getAttribute("headingColumns")) || 0;
                    return this._areIndexesInSameSection(s, l)
                }

                _areIndexesInSameSection({first: e, last: t}, n) {
                    return e < n == t < n
                }
            }

            function dk(r, e, t, n, i, s = {}) {
                for (let l = 0; l < n; l++) {
                    const d = r.createElement("tableRow");
                    r.insert(d, e, t), Du(i, r, r.createPositionAt(d, "end"), s)
                }
            }

            function Du(r, e, t, n = {}) {
                for (let i = 0; i < r; i++) Gl(e, t, n)
            }

            function Wy(r, e) {
                if (r < e) return {newCellsSpan: 1, updatedSpan: 1};
                const t = Math.floor(r / e);
                return {newCellsSpan: t, updatedSpan: r - t * e + t}
            }

            function TN(r, e) {
                const t = r.start, n = e.start;
                return t.isBefore(n) ? -1 : 1
            }

            class IN extends Ft {
                refresh() {
                    const e = this.editor.plugins.get(qr),
                        t = e.getSelectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = e.isSelectionRectangular(t)
                }

                execute() {
                    const e = this.editor.model, t = this.editor.plugins.get(qr);
                    e.change(n => {
                        const i = t.getSelectedTableCells(e.document.selection), s = i.shift(), {
                            mergeWidth: l,
                            mergeHeight: d
                        } = function (g, v, _) {
                            let x = 0, M = 0;
                            for (const ne of v) {
                                const {row: pe, column: Se} = _.getCellLocation(ne);
                                x = Gy(ne, Se, x, "colspan"), M = Gy(ne, pe, M, "rowspan")
                            }
                            const {row: O, column: j} = _.getCellLocation(g), U = x - j, K = M - O;
                            return {mergeWidth: U, mergeHeight: K}
                        }(s, i, t);
                        Qn("colspan", l, s, n), Qn("rowspan", d, s, n);
                        for (const g of i) MN(g, s, n);
                        uk(s.findAncestor("table"), t), n.setSelection(s, "in")
                    })
                }
            }

            function MN(r, e, t) {
                $y(r) || ($y(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(r), t.createPositionAt(e, "end"))), t.remove(r)
            }

            function $y(r) {
                const e = r.getChild(0);
                return r.childCount == 1 && e.is("element", "paragraph") && e.isEmpty
            }

            function Gy(r, e, t, n) {
                const i = parseInt(r.getAttribute(n) || "1");
                return Math.max(t, e + i)
            }

            class BN extends Ft {
                constructor(e) {
                    super(e), this.affectsData = !1
                }

                refresh() {
                    const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = e.length > 0
                }

                execute() {
                    const e = this.editor.model, t = this.editor.plugins.get("TableUtils"),
                        n = t.getSelectionAffectedTableCells(e.document.selection), i = t.getRowIndexes(n),
                        s = n[0].findAncestor("table"), l = [];
                    for (let d = i.first; d <= i.last; d++) for (const g of s.getChild(d).getChildren()) l.push(e.createRangeOn(g));
                    e.change(d => {
                        d.setSelection(l)
                    })
                }
            }

            class NN extends Ft {
                constructor(e) {
                    super(e), this.affectsData = !1
                }

                refresh() {
                    const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = e.length > 0
                }

                execute() {
                    const e = this.editor.plugins.get("TableUtils"), t = this.editor.model,
                        n = e.getSelectionAffectedTableCells(t.document.selection), i = n[0], s = n.pop(),
                        l = i.findAncestor("table"), d = e.getCellLocation(i), g = e.getCellLocation(s),
                        v = Math.min(d.column, g.column), _ = Math.max(d.column, g.column), x = [];
                    for (const M of new bn(l, {startColumn: v, endColumn: _})) x.push(t.createRangeOn(M.cell));
                    t.change(M => {
                        M.setSelection(x)
                    })
                }
            }

            function LN(r) {
                r.document.registerPostFixer(e => function (t, n) {
                    const i = n.document.differ.getChanges();
                    let s = !1;
                    const l = new Set;
                    for (const d of i) {
                        let g = null;
                        d.type == "insert" && d.name == "table" && (g = d.position.nodeAfter), d.type != "insert" && d.type != "remove" || d.name != "tableRow" && d.name != "tableCell" || (g = d.position.findAncestor("table")), FN(d) && (g = d.range.start.findAncestor("table")), g && !l.has(g) && (s = PN(g, t) || s, s = ON(g, t) || s, l.add(g))
                    }
                    return s
                }(e, r))
            }

            function PN(r, e) {
                let t = !1;
                const n = function (i) {
                    const s = parseInt(i.getAttribute("headingRows") || "0"),
                        l = Array.from(i.getChildren()).reduce((g, v) => v.is("element", "tableRow") ? g + 1 : g, 0),
                        d = [];
                    for (const {row: g, cell: v, cellHeight: _} of new bn(i)) {
                        if (_ < 2) continue;
                        const x = g < s ? s : l;
                        if (g + _ > x) {
                            const M = x - g;
                            d.push({cell: v, rowspan: M})
                        }
                    }
                    return d
                }(r);
                if (n.length) {
                    t = !0;
                    for (const i of n) Qn("rowspan", i.rowspan, i.cell, e, 1)
                }
                return t
            }

            function ON(r, e) {
                let t = !1;
                const n = function (d) {
                    const g = new Array(d.childCount).fill(0);
                    for (const {rowIndex: v} of new bn(d, {includeAllSlots: !0})) g[v]++;
                    return g
                }(r), i = [];
                for (const [d, g] of n.entries()) !g && r.getChild(d).is("element", "tableRow") && i.push(d);
                if (i.length) {
                    t = !0;
                    for (const d of i.reverse()) e.remove(r.getChild(d)), n.splice(d, 1)
                }
                const s = n.filter((d, g) => r.getChild(g).is("element", "tableRow")), l = s[0];
                if (!s.every(d => d === l)) {
                    const d = s.reduce((g, v) => v > g ? v : g, 0);
                    for (const [g, v] of s.entries()) {
                        const _ = d - v;
                        if (_) {
                            for (let x = 0; x < _; x++) Gl(e, e.createPositionAt(r.getChild(g), "end"));
                            t = !0
                        }
                    }
                }
                return t
            }

            function FN(r) {
                if (r.type !== "attribute") return !1;
                const e = r.attributeKey;
                return e === "headingRows" || e === "colspan" || e === "rowspan"
            }

            function RN(r) {
                r.document.registerPostFixer(e => function (t, n) {
                    const i = n.document.differ.getChanges();
                    let s = !1;
                    for (const l of i) l.type == "insert" && l.name == "table" && (s = zN(l.position.nodeAfter, t) || s), l.type == "insert" && l.name == "tableRow" && (s = Ky(l.position.nodeAfter, t) || s), l.type == "insert" && l.name == "tableCell" && (s = hk(l.position.nodeAfter, t) || s), l.type != "remove" && l.type != "insert" || !jN(l) || (s = hk(l.position.parent, t) || s);
                    return s
                }(e, r))
            }

            function zN(r, e) {
                let t = !1;
                for (const n of r.getChildren()) n.is("element", "tableRow") && (t = Ky(n, e) || t);
                return t
            }

            function Ky(r, e) {
                let t = !1;
                for (const n of r.getChildren()) t = hk(n, e) || t;
                return t
            }

            function hk(r, e) {
                if (r.childCount == 0) return e.insertElement("paragraph", r), !0;
                const t = Array.from(r.getChildren()).filter(n => n.is("$text"));
                for (const n of t) e.wrap(e.createRangeOn(n), "paragraph");
                return !!t.length
            }

            function jN(r) {
                return !!r.position.parent.is("element", "tableCell") && (r.type == "insert" && r.name == "$text" || r.type == "remove")
            }

            function VN(r, e) {
                if (!r.is("element", "paragraph")) return !1;
                const t = e.toViewElement(r);
                return !!t && By(r) !== t.is("element", "span")
            }

            var Zy = C(3881),
                HN = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Zy.Z, HN), Zy.Z.locals;

            class UN extends Re {
                constructor(e) {
                    super(e), this._additionalSlots = []
                }

                static get pluginName() {
                    return "TableEditing"
                }

                static get requires() {
                    return [qr]
                }

                init() {
                    const e = this.editor, t = e.model, n = t.schema, i = e.conversion, s = e.plugins.get(qr);
                    n.register("table", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["headingRows", "headingColumns"]
                    }), n.register("tableRow", {
                        allowIn: "table",
                        isLimit: !0
                    }), n.register("tableCell", {
                        allowContentOf: "$container",
                        allowIn: "tableRow",
                        allowAttributes: ["colspan", "rowspan"],
                        isLimit: !0,
                        isSelectable: !0
                    }), i.for("upcast").add(l => {
                        l.on("element:figure", (d, g, v) => {
                            if (!v.consumable.test(g.viewItem, {name: !0, classes: "table"})) return;
                            const _ = function (M) {
                                for (const O of M.getChildren()) if (O.is("element", "table")) return O
                            }(g.viewItem);
                            if (!_ || !v.consumable.test(_, {name: !0})) return;
                            v.consumable.consume(g.viewItem, {name: !0, classes: "table"});
                            const x = Wn(v.convertItem(_, g.modelCursor).modelRange.getItems());
                            x ? (v.convertChildren(g.viewItem, v.writer.createPositionAt(x, "end")), v.updateConversionResult(x, g)) : v.consumable.revert(g.viewItem, {
                                name: !0,
                                classes: "table"
                            })
                        })
                    }), i.for("upcast").add(vN()), i.for("editingDowncast").elementToStructure({
                        model: {
                            name: "table",
                            attributes: ["headingRows"]
                        }, view: Ty(s, {asWidget: !0, additionalSlots: this._additionalSlots})
                    }), i.for("dataDowncast").elementToStructure({
                        model: {name: "table", attributes: ["headingRows"]},
                        view: Ty(s, {additionalSlots: this._additionalSlots})
                    }), i.for("upcast").elementToElement({model: "tableRow", view: "tr"}), i.for("upcast").add(l => {
                        l.on("element:tr", (d, g) => {
                            g.viewItem.isEmpty && g.modelCursor.index == 0 && d.stop()
                        }, {priority: "high"})
                    }), i.for("downcast").elementToElement({
                        model: "tableRow",
                        view: (l, {writer: d}) => l.isEmpty ? d.createEmptyElement("tr") : d.createContainerElement("tr")
                    }), i.for("upcast").elementToElement({
                        model: "tableCell",
                        view: "td"
                    }), i.for("upcast").elementToElement({
                        model: "tableCell",
                        view: "th"
                    }), i.for("upcast").add(Sy("td")), i.for("upcast").add(Sy("th")), i.for("editingDowncast").elementToElement({
                        model: "tableCell",
                        view: Iy({asWidget: !0})
                    }), i.for("dataDowncast").elementToElement({
                        model: "tableCell",
                        view: Iy()
                    }), i.for("editingDowncast").elementToElement({
                        model: "paragraph",
                        view: My({asWidget: !0}),
                        converterPriority: "high"
                    }), i.for("dataDowncast").elementToElement({
                        model: "paragraph",
                        view: My(),
                        converterPriority: "high"
                    }), i.for("downcast").attributeToAttribute({
                        model: "colspan",
                        view: "colspan"
                    }), i.for("upcast").attributeToAttribute({
                        model: {key: "colspan", value: Yy("colspan")},
                        view: "colspan"
                    }), i.for("downcast").attributeToAttribute({
                        model: "rowspan",
                        view: "rowspan"
                    }), i.for("upcast").attributeToAttribute({
                        model: {key: "rowspan", value: Yy("rowspan")},
                        view: "rowspan"
                    }), e.config.define("table.defaultHeadings.rows", 0), e.config.define("table.defaultHeadings.columns", 0), e.commands.add("insertTable", new CN(e)), e.commands.add("insertTableRowAbove", new Ny(e, {order: "above"})), e.commands.add("insertTableRowBelow", new Ny(e, {order: "below"})), e.commands.add("insertTableColumnLeft", new Ly(e, {order: "left"})), e.commands.add("insertTableColumnRight", new Ly(e, {order: "right"})), e.commands.add("removeTableRow", new _N(e)), e.commands.add("removeTableColumn", new yN(e)), e.commands.add("splitTableCellVertically", new Py(e, {direction: "vertically"})), e.commands.add("splitTableCellHorizontally", new Py(e, {direction: "horizontally"})), e.commands.add("mergeTableCells", new IN(e)), e.commands.add("mergeTableCellRight", new ip(e, {direction: "right"})), e.commands.add("mergeTableCellLeft", new ip(e, {direction: "left"})), e.commands.add("mergeTableCellDown", new ip(e, {direction: "down"})), e.commands.add("mergeTableCellUp", new ip(e, {direction: "up"})), e.commands.add("setTableColumnHeader", new xN(e)), e.commands.add("setTableRowHeader", new DN(e)), e.commands.add("selectTableRow", new BN(e)), e.commands.add("selectTableColumn", new NN(e)), LN(t), RN(t), this.listenTo(t.document, "change:data", () => {
                        (function (l, d) {
                            const g = l.document.differ;
                            for (const v of g.getChanges()) {
                                let _, x = !1;
                                if (v.type == "attribute") {
                                    const U = v.range.start.nodeAfter;
                                    if (!U || !U.is("element", "table") || v.attributeKey != "headingRows" && v.attributeKey != "headingColumns") continue;
                                    _ = U, x = v.attributeKey == "headingRows"
                                } else v.name != "tableRow" && v.name != "tableCell" || (_ = v.position.findAncestor("table"), x = v.name == "tableRow");
                                if (!_) continue;
                                const M = _.getAttribute("headingRows") || 0, O = _.getAttribute("headingColumns") || 0,
                                    j = new bn(_);
                                for (const U of j) {
                                    const K = U.row < M || U.column < O ? "th" : "td",
                                        ne = d.mapper.toViewElement(U.cell);
                                    ne && ne.is("element") && ne.name != K && d.reconvertItem(x ? U.cell.parent : U.cell)
                                }
                            }
                        })(t, e.editing), function (l, d) {
                            const g = l.document.differ, v = new Set;
                            for (const _ of g.getChanges()) {
                                const x = _.type == "attribute" ? _.range.start.parent : _.position.parent;
                                x.is("element", "tableCell") && v.add(x)
                            }
                            for (const _ of v.values()) {
                                const x = Array.from(_.getChildren()).filter(M => VN(M, d.mapper));
                                for (const M of x) d.reconvertItem(M)
                            }
                        }(t, e.editing)
                    })
                }

                registerAdditionalSlot(e) {
                    this._additionalSlots.push(e)
                }
            }

            function Yy(r) {
                return e => {
                    const t = parseInt(e.getAttribute(r));
                    return Number.isNaN(t) || t <= 0 ? null : t
                }
            }

            var Qy = C(1613),
                qN = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Qy.Z, qN), Qy.Z.locals;

            class WN extends It {
                constructor(e) {
                    super(e);
                    const t = this.bindTemplate;
                    this.items = this._createGridCollection(), this.keystrokes = new si, this.focusTracker = new Nr, this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (n, i) => `${i} × ${n}`), this.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck"]},
                        children: [{
                            tag: "div",
                            attributes: {class: ["ck-insert-table-dropdown__grid"]},
                            on: {"mouseover@.ck-insert-table-dropdown-grid-box": t.to("boxover")},
                            children: this.items
                        }, {
                            tag: "div",
                            attributes: {class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": !0},
                            children: [{text: t.to("label")}]
                        }],
                        on: {
                            mousedown: t.to(n => {
                                n.preventDefault()
                            }), click: t.to(() => {
                                this.fire("execute")
                            })
                        }
                    }), this.on("boxover", (n, i) => {
                        const {row: s, column: l} = i.target.dataset;
                        this.items.get(10 * (parseInt(s, 10) - 1) + (parseInt(l, 10) - 1)).focus()
                    }), this.focusTracker.on("change:focusedElement", (n, i, s) => {
                        if (!s) return;
                        const {row: l, column: d} = s.dataset;
                        this.set({rows: parseInt(l), columns: parseInt(d)})
                    }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes())
                }

                render() {
                    super.render(), function ({
                                                  keystrokeHandler: e,
                                                  focusTracker: t,
                                                  gridItems: n,
                                                  numberOfColumns: i,
                                                  uiLanguageDirection: s
                                              }) {
                        const l = typeof i == "number" ? () => i : i;

                        function d(_) {
                            return x => {
                                const M = n.find(U => U.element === t.focusedElement), O = n.getIndex(M), j = _(O, n);
                                n.get(j).focus(), x.stopPropagation(), x.preventDefault()
                            }
                        }

                        function g(_, x) {
                            return _ === x - 1 ? 0 : _ + 1
                        }

                        function v(_, x) {
                            return _ === 0 ? x - 1 : _ - 1
                        }

                        e.set("arrowright", d((_, x) => s === "rtl" ? v(_, x.length) : g(_, x.length))), e.set("arrowleft", d((_, x) => s === "rtl" ? g(_, x.length) : v(_, x.length))), e.set("arrowup", d((_, x) => {
                            let M = _ - l();
                            return M < 0 && (M = _ + l() * Math.floor(x.length / l()), M > x.length - 1 && (M -= l())), M
                        })), e.set("arrowdown", d((_, x) => {
                            let M = _ + l();
                            return M > x.length - 1 && (M = _ % l()), M
                        }))
                    }({
                        keystrokeHandler: this.keystrokes,
                        focusTracker: this.focusTracker,
                        gridItems: this.items,
                        numberOfColumns: 10,
                        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                    });
                    for (const e of this.items) this.focusTracker.add(e.element);
                    this.keystrokes.listenTo(this.element)
                }

                focus() {
                    this.items.get(0).focus()
                }

                focusLast() {
                    this.items.get(0).focus()
                }

                _highlightGridBoxes() {
                    const e = this.rows, t = this.columns;
                    this.items.map((n, i) => {
                        const s = Math.floor(i / 10) < e && i % 10 < t;
                        n.set("isOn", s)
                    })
                }

                _createGridButton(e, t, n, i) {
                    const s = new sn(e);
                    return s.set({
                        label: i,
                        class: "ck-insert-table-dropdown-grid-box"
                    }), s.extendTemplate({attributes: {"data-row": t, "data-column": n}}), s
                }

                _createGridCollection() {
                    const e = [];
                    for (let t = 0; t < 100; t++) {
                        const n = Math.floor(t / 10), i = t % 10, s = `${n + 1} × ${i + 1}`;
                        e.push(this._createGridButton(this.locale, n + 1, i + 1, s))
                    }
                    return this.createCollection(e)
                }
            }

            class $N extends Re {
                static get pluginName() {
                    return "TableUI"
                }

                init() {
                    const e = this.editor, t = this.editor.t, n = e.locale.contentLanguageDirection === "ltr";
                    e.ui.componentFactory.add("insertTable", i => {
                        const s = e.commands.get("insertTable"), l = Ns(i);
                        let d;
                        return l.bind("isEnabled").to(s), l.buttonView.set({
                            icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>',
                            label: t("Insert table"),
                            tooltip: !0
                        }), l.on("change:isOpen", () => {
                            d || (d = new WN(i), l.panelView.children.add(d), d.delegate("execute").to(l), l.on("execute", () => {
                                e.execute("insertTable", {rows: d.rows, columns: d.columns}), e.editing.view.focus()
                            }))
                        }), l
                    }), e.ui.componentFactory.add("tableColumn", i => {
                        const s = [{
                            type: "switchbutton",
                            model: {commandName: "setTableColumnHeader", label: t("Header column"), bindIsOn: !0}
                        }, {type: "separator"}, {
                            type: "button",
                            model: {
                                commandName: n ? "insertTableColumnLeft" : "insertTableColumnRight",
                                label: t("Insert column left")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: n ? "insertTableColumnRight" : "insertTableColumnLeft",
                                label: t("Insert column right")
                            }
                        }, {
                            type: "button",
                            model: {commandName: "removeTableColumn", label: t("Delete column")}
                        }, {type: "button", model: {commandName: "selectTableColumn", label: t("Select column")}}];
                        return this._prepareDropdown(t("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', s, i)
                    }), e.ui.componentFactory.add("tableRow", i => {
                        const s = [{
                            type: "switchbutton",
                            model: {commandName: "setTableRowHeader", label: t("Header row"), bindIsOn: !0}
                        }, {type: "separator"}, {
                            type: "button",
                            model: {commandName: "insertTableRowAbove", label: t("Insert row above")}
                        }, {
                            type: "button",
                            model: {commandName: "insertTableRowBelow", label: t("Insert row below")}
                        }, {
                            type: "button",
                            model: {commandName: "removeTableRow", label: t("Delete row")}
                        }, {type: "button", model: {commandName: "selectTableRow", label: t("Select row")}}];
                        return this._prepareDropdown(t("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', s, i)
                    }), e.ui.componentFactory.add("mergeTableCells", i => {
                        const s = [{
                            type: "button",
                            model: {commandName: "mergeTableCellUp", label: t("Merge cell up")}
                        }, {
                            type: "button",
                            model: {
                                commandName: n ? "mergeTableCellRight" : "mergeTableCellLeft",
                                label: t("Merge cell right")
                            }
                        }, {
                            type: "button",
                            model: {commandName: "mergeTableCellDown", label: t("Merge cell down")}
                        }, {
                            type: "button",
                            model: {
                                commandName: n ? "mergeTableCellLeft" : "mergeTableCellRight",
                                label: t("Merge cell left")
                            }
                        }, {type: "separator"}, {
                            type: "button",
                            model: {commandName: "splitTableCellVertically", label: t("Split cell vertically")}
                        }, {
                            type: "button",
                            model: {commandName: "splitTableCellHorizontally", label: t("Split cell horizontally")}
                        }];
                        return this._prepareMergeSplitButtonDropdown(t("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', s, i)
                    })
                }

                _prepareDropdown(e, t, n, i) {
                    const s = this.editor, l = Ns(i), d = this._fillDropdownWithListOptions(l, n);
                    return l.buttonView.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }), l.bind("isEnabled").toMany(d, "isEnabled", (...g) => g.some(v => v)), this.listenTo(l, "execute", g => {
                        s.execute(g.source.commandName), g.source instanceof _l || s.editing.view.focus()
                    }), l
                }

                _prepareMergeSplitButtonDropdown(e, t, n, i) {
                    const s = this.editor, l = Ns(i, Ng), d = "mergeTableCells", g = s.commands.get(d),
                        v = this._fillDropdownWithListOptions(l, n);
                    return l.buttonView.set({
                        label: e,
                        icon: t,
                        tooltip: !0,
                        isEnabled: !0
                    }), l.bind("isEnabled").toMany([g, ...v], "isEnabled", (..._) => _.some(x => x)), this.listenTo(l.buttonView, "execute", () => {
                        s.execute(d), s.editing.view.focus()
                    }), this.listenTo(l, "execute", _ => {
                        s.execute(_.source.commandName), s.editing.view.focus()
                    }), l
                }

                _fillDropdownWithListOptions(e, t) {
                    const n = this.editor, i = [], s = new br;
                    for (const l of t) GN(l, n, i, s);
                    return nA(e, s), i
                }
            }

            function GN(r, e, t, n) {
                if (r.type === "button" || r.type === "switchbutton") {
                    const i = r.model = new PA(r.model), {commandName: s, bindIsOn: l} = r.model, d = e.commands.get(s);
                    t.push(d), i.set({commandName: s}), i.bind("isEnabled").to(d), l && i.bind("isOn").to(d, "value"), i.set({withText: !0})
                }
                n.add(r)
            }

            var Jy = C(6945),
                KN = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(Jy.Z, KN), Jy.Z.locals;

            class Kl extends Re {
                static get pluginName() {
                    return "TableSelection"
                }

                static get requires() {
                    return [qr, qr]
                }

                init() {
                    const e = this.editor, t = e.model, n = e.editing.view;
                    this.listenTo(t, "deleteContent", (i, s) => this._handleDeleteContent(i, s), {priority: "high"}), this.listenTo(n.document, "insertText", (i, s) => this._handleInsertTextEvent(i, s), {priority: "high"}), this._defineSelectionConverter(), this._enablePluginDisabling()
                }

                getSelectedTableCells() {
                    const e = this.editor.plugins.get(qr), t = this.editor.model.document.selection,
                        n = e.getSelectedTableCells(t);
                    return n.length == 0 ? null : n
                }

                getSelectionAsFragment() {
                    const e = this.editor.plugins.get(qr), t = this.getSelectedTableCells();
                    return t ? this.editor.model.change(n => {
                        const i = n.createDocumentFragment(), {first: s, last: l} = e.getColumnIndexes(t), {
                            first: d,
                            last: g
                        } = e.getRowIndexes(t), v = t[0].findAncestor("table");
                        let _ = g, x = l;
                        if (e.isSelectionRectangular(t)) {
                            const O = {firstColumn: s, lastColumn: l, firstRow: d, lastRow: g};
                            _ = Hy(v, O), x = Uy(v, O)
                        }
                        const M = Oy(v, {startRow: d, startColumn: s, endRow: _, endColumn: x}, n);
                        return n.insert(M, i, 0), i
                    }) : null
                }

                setCellSelection(e, t) {
                    const n = this._getCellsToSelect(e, t);
                    this.editor.model.change(i => {
                        i.setSelection(n.cells.map(s => i.createRangeOn(s)), {backward: n.backward})
                    })
                }

                getFocusCell() {
                    const e = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
                    return e && e.is("element", "tableCell") ? e : null
                }

                getAnchorCell() {
                    const e = Wn(this.editor.model.document.selection.getRanges()).getContainedElement();
                    return e && e.is("element", "tableCell") ? e : null
                }

                _defineSelectionConverter() {
                    const e = this.editor, t = new Set;
                    e.conversion.for("editingDowncast").add(n => n.on("selection", (i, s, l) => {
                        const d = l.writer;
                        (function (_) {
                            for (const x of t) _.removeClass("ck-editor__editable_selected", x);
                            t.clear()
                        })(d);
                        const g = this.getSelectedTableCells();
                        if (!g) return;
                        for (const _ of g) {
                            const x = l.mapper.toViewElement(_);
                            d.addClass("ck-editor__editable_selected", x), t.add(x)
                        }
                        const v = l.mapper.toViewElement(g[g.length - 1]);
                        d.setSelection(v, 0)
                    }, {priority: "lowest"}))
                }

                _enablePluginDisabling() {
                    const e = this.editor;
                    this.on("change:isEnabled", () => {
                        if (!this.isEnabled) {
                            const t = this.getSelectedTableCells();
                            if (!t) return;
                            e.model.change(n => {
                                const i = n.createPositionAt(t[0], 0), s = e.model.schema.getNearestSelectionRange(i);
                                n.setSelection(s)
                            })
                        }
                    })
                }

                _handleDeleteContent(e, t) {
                    const n = this.editor.plugins.get(qr), i = t[0], s = t[1], l = this.editor.model,
                        d = !s || s.direction == "backward", g = n.getSelectedTableCells(i);
                    g.length && (e.stop(), l.change(v => {
                        const _ = g[d ? g.length - 1 : 0];
                        l.change(M => {
                            for (const O of g) l.deleteContent(M.createSelection(O, "in"))
                        });
                        const x = l.schema.getNearestSelectionRange(v.createPositionAt(_, 0));
                        i.is("documentSelection") ? v.setSelection(x) : i.setTo(x)
                    }))
                }

                _handleInsertTextEvent(e, t) {
                    const n = this.editor, i = this.getSelectedTableCells();
                    if (!i) return;
                    const s = n.editing.view, l = n.editing.mapper, d = i.map(g => s.createRangeOn(l.toViewElement(g)));
                    t.selection = s.createSelection(d)
                }

                _getCellsToSelect(e, t) {
                    const n = this.editor.plugins.get("TableUtils"), i = n.getCellLocation(e), s = n.getCellLocation(t),
                        l = Math.min(i.row, s.row), d = Math.max(i.row, s.row), g = Math.min(i.column, s.column),
                        v = Math.max(i.column, s.column), _ = new Array(d - l + 1).fill(null).map(() => []),
                        x = {startRow: l, endRow: d, startColumn: g, endColumn: v};
                    for (const {row: j, cell: U} of new bn(e.findAncestor("table"), x)) _[j - l].push(U);
                    const M = s.row < i.row, O = s.column < i.column;
                    return M && _.reverse(), O && _.forEach(j => j.reverse()), {cells: _.flat(), backward: M || O}
                }
            }

            class ZN extends Re {
                static get pluginName() {
                    return "TableClipboard"
                }

                static get requires() {
                    return [Kl, qr]
                }

                init() {
                    const e = this.editor, t = e.editing.view.document;
                    this.listenTo(t, "copy", (n, i) => this._onCopyCut(n, i)), this.listenTo(t, "cut", (n, i) => this._onCopyCut(n, i)), this.listenTo(e.model, "insertContent", (n, [i, s]) => this._onInsertContent(n, i, s), {priority: "high"}), this.decorate("_replaceTableSlotCell")
                }

                _onCopyCut(e, t) {
                    const n = this.editor.plugins.get(Kl);
                    if (!n.getSelectedTableCells() || e.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection)) return;
                    t.preventDefault(), e.stop();
                    const i = this.editor.data, s = this.editor.editing.view.document,
                        l = i.toView(n.getSelectionAsFragment());
                    s.fire("clipboardOutput", {dataTransfer: t.dataTransfer, content: l, method: e.name})
                }

                _onInsertContent(e, t, n) {
                    if (n && !n.is("documentSelection")) return;
                    const i = this.editor.model, s = this.editor.plugins.get(qr);
                    let l = this.getTableIfOnlyTableInContent(t, i);
                    if (!l) return;
                    const d = s.getSelectionAffectedTableCells(i.document.selection);
                    d.length ? (e.stop(), i.change(g => {
                        const v = {width: s.getColumns(l), height: s.getRows(l)}, _ = function (K, ne, pe, Se) {
                            const Je = K[0].findAncestor("table"), wt = Se.getColumnIndexes(K),
                                qt = Se.getRowIndexes(K),
                                Zt = {firstColumn: wt.first, lastColumn: wt.last, firstRow: qt.first, lastRow: qt.last},
                                Jn = K.length === 1;
                            return Jn && (Zt.lastRow += ne.height - 1, Zt.lastColumn += ne.width - 1, function (Xn, xu, ns, Xi) {
                                const Fs = Xi.getColumns(Xn), Rs = Xi.getRows(Xn);
                                ns > Fs && Xi.insertColumns(Xn, {
                                    at: Fs,
                                    columns: ns - Fs
                                }), xu > Rs && Xi.insertRows(Xn, {at: Rs, rows: xu - Rs})
                            }(Je, Zt.lastRow + 1, Zt.lastColumn + 1, Se)), Jn || !Se.isSelectionRectangular(K) ? function (Xn, xu, ns) {
                                const {firstRow: Xi, lastRow: Fs, firstColumn: Rs, lastColumn: Yl} = xu,
                                    m2 = {first: Xi, last: Fs}, b2 = {first: Rs, last: Yl};
                                gk(Xn, Rs, m2, ns), gk(Xn, Yl + 1, m2, ns), fk(Xn, Xi, b2, ns), fk(Xn, Fs + 1, b2, ns, Xi)
                            }(Je, Zt, pe) : (Zt.lastRow = Hy(Je, Zt), Zt.lastColumn = Uy(Je, Zt)), Zt
                        }(d, v, g, s), x = _.lastRow - _.firstRow + 1, M = _.lastColumn - _.firstColumn + 1, O = {
                            startRow: 0,
                            startColumn: 0,
                            endRow: Math.min(x, v.height) - 1,
                            endColumn: Math.min(M, v.width) - 1
                        };
                        l = Oy(l, O, g);
                        const j = d[0].findAncestor("table"), U = this._replaceSelectedCellsWithPasted(l, v, j, _, g);
                        if (this.editor.plugins.get("TableSelection").isEnabled) {
                            const K = s.sortRanges(U.map(ne => g.createRangeOn(ne)));
                            g.setSelection(K)
                        } else g.setSelection(U[0], 0)
                    })) : uk(l, s)
                }

                _replaceSelectedCellsWithPasted(e, t, n, i, s) {
                    const {width: l, height: d} = t, g = function (K, ne, pe) {
                        const Se = new Array(pe).fill(null).map(() => new Array(ne).fill(null));
                        for (const {column: Je, row: wt, cell: qt} of new bn(K)) Se[wt][Je] = qt;
                        return Se
                    }(e, l, d), v = [...new bn(n, {
                        startRow: i.firstRow,
                        endRow: i.lastRow,
                        startColumn: i.firstColumn,
                        endColumn: i.lastColumn,
                        includeAllSlots: !0
                    })], _ = [];
                    let x;
                    for (const K of v) {
                        const {row: ne, column: pe} = K;
                        pe === i.firstColumn && (x = K.getPositionBefore());
                        const Se = ne - i.firstRow, Je = pe - i.firstColumn, wt = g[Se % d][Je % l],
                            qt = wt ? s.cloneElement(wt) : null, Zt = this._replaceTableSlotCell(K, qt, x, s);
                        Zt && (Vy(Zt, ne, pe, i.lastRow, i.lastColumn, s), _.push(Zt), x = s.createPositionAfter(Zt))
                    }
                    const M = parseInt(n.getAttribute("headingRows") || "0"),
                        O = parseInt(n.getAttribute("headingColumns") || "0"), j = i.firstRow < M && M <= i.lastRow,
                        U = i.firstColumn < O && O <= i.lastColumn;
                    if (j) {
                        const K = fk(n, M, {first: i.firstColumn, last: i.lastColumn}, s, i.firstRow);
                        _.push(...K)
                    }
                    if (U) {
                        const K = gk(n, O, {first: i.firstRow, last: i.lastRow}, s);
                        _.push(...K)
                    }
                    return _
                }

                _replaceTableSlotCell(e, t, n, i) {
                    const {cell: s, isAnchor: l} = e;
                    return l && i.remove(s), t ? (i.insert(t, n), t) : null
                }

                getTableIfOnlyTableInContent(e, t) {
                    if (!e.is("documentFragment") && !e.is("element")) return null;
                    if (e.is("element", "table")) return e;
                    if (e.childCount == 1 && e.getChild(0).is("element", "table")) return e.getChild(0);
                    const n = t.createRangeIn(e);
                    for (const i of n.getItems()) if (i.is("element", "table")) {
                        const s = t.createRange(n.start, t.createPositionBefore(i));
                        if (t.hasContent(s, {ignoreWhitespaces: !0})) return null;
                        const l = t.createRange(t.createPositionAfter(i), n.end);
                        return t.hasContent(l, {ignoreWhitespaces: !0}) ? null : i
                    }
                    return null
                }
            }

            function fk(r, e, t, n, i = 0) {
                if (!(e < 1)) return Fy(r, e, i).filter(({
                                                             column: s,
                                                             cellWidth: l
                                                         }) => Xy(s, l, t)).map(({cell: s}) => Ry(s, e, n))
            }

            function gk(r, e, t, n) {
                if (!(e < 1)) return zy(r, e).filter(({row: i, cellHeight: s}) => Xy(i, s, t)).map(({
                                                                                                        cell: i,
                                                                                                        column: s
                                                                                                    }) => jy(i, s, e, n))
            }

            function Xy(r, e, t) {
                const n = r + e - 1, {first: i, last: s} = t;
                return r >= i && r <= s || r < i && n >= i
            }

            class YN extends Re {
                static get pluginName() {
                    return "TableKeyboard"
                }

                static get requires() {
                    return [Kl, qr]
                }

                init() {
                    const e = this.editor.editing.view.document;
                    this.listenTo(e, "arrowKey", (...t) => this._onArrowKey(...t), {context: "table"}), this.listenTo(e, "tab", (...t) => this._handleTabOnSelectedTable(...t), {context: "figure"}), this.listenTo(e, "tab", (...t) => this._handleTab(...t), {context: ["th", "td"]})
                }

                _handleTabOnSelectedTable(e, t) {
                    const n = this.editor, i = n.model.document.selection.getSelectedElement();
                    i && i.is("element", "table") && (t.preventDefault(), t.stopPropagation(), e.stop(), n.model.change(s => {
                        s.setSelection(s.createRangeIn(i.getChild(0).getChild(0)))
                    }))
                }

                _handleTab(e, t) {
                    const n = this.editor, i = this.editor.plugins.get(qr),
                        s = this.editor.plugins.get("TableSelection"), l = n.model.document.selection, d = !t.shiftKey;
                    let g = i.getTableCellsContainingSelection(l)[0];
                    if (g || (g = s.getFocusCell()), !g) return;
                    t.preventDefault(), t.stopPropagation(), e.stop();
                    const v = g.parent, _ = v.parent, x = _.getChildIndex(v), M = v.getChildIndex(g), O = M === 0;
                    if (!d && O && x === 0) return void n.model.change(ne => {
                        ne.setSelection(ne.createRangeOn(_))
                    });
                    const j = M === v.childCount - 1, U = x === i.getRows(_) - 1;
                    if (d && U && j && (n.execute("insertTableRowBelow"), x === i.getRows(_) - 1)) return void n.model.change(ne => {
                        ne.setSelection(ne.createRangeOn(_))
                    });
                    let K;
                    if (d && j) K = _.getChild(x + 1).getChild(0); else if (!d && O) {
                        const ne = _.getChild(x - 1);
                        K = ne.getChild(ne.childCount - 1)
                    } else K = v.getChild(M + (d ? 1 : -1));
                    n.model.change(ne => {
                        ne.setSelection(ne.createRangeIn(K))
                    })
                }

                _onArrowKey(e, t) {
                    const n = this.editor, i = jo(t.keyCode, n.locale.contentLanguageDirection);
                    this._handleArrowKeys(i, t.shiftKey) && (t.preventDefault(), t.stopPropagation(), e.stop())
                }

                _handleArrowKeys(e, t) {
                    const n = this.editor.plugins.get(qr), i = this.editor.plugins.get("TableSelection"),
                        s = this.editor.model, l = s.document.selection, d = ["right", "down"].includes(e),
                        g = n.getSelectedTableCells(l);
                    if (g.length) {
                        let _;
                        return _ = t ? i.getFocusCell() : d ? g[g.length - 1] : g[0], this._navigateFromCellInDirection(_, e, t), !0
                    }
                    const v = l.focus.findAncestor("tableCell");
                    if (!v) return !1;
                    if (!l.isCollapsed) if (t) {
                        if (l.isBackward == d && !l.containsEntireContent(v)) return !1
                    } else {
                        const _ = l.getSelectedElement();
                        if (!_ || !s.schema.isObject(_)) return !1
                    }
                    return !!this._isSelectionAtCellEdge(l, v, d) && (this._navigateFromCellInDirection(v, e, t), !0)
                }

                _isSelectionAtCellEdge(e, t, n) {
                    const i = this.editor.model, s = this.editor.model.schema,
                        l = n ? e.getLastPosition() : e.getFirstPosition();
                    if (!s.getLimitElement(l).is("element", "tableCell")) return i.createPositionAt(t, n ? "end" : 0).isTouching(l);
                    const d = i.createSelection(l);
                    return i.modifySelection(d, {direction: n ? "forward" : "backward"}), l.isEqual(d.focus)
                }

                _navigateFromCellInDirection(e, t, n = !1) {
                    const i = this.editor.model, s = e.findAncestor("table"),
                        l = [...new bn(s, {includeAllSlots: !0})], {row: d, column: g} = l[l.length - 1],
                        v = l.find(({cell: U}) => U == e);
                    let {row: _, column: x} = v;
                    switch (t) {
                        case"left":
                            x--;
                            break;
                        case"up":
                            _--;
                            break;
                        case"right":
                            x += v.cellWidth;
                            break;
                        case"down":
                            _ += v.cellHeight
                    }
                    if (_ < 0 || _ > d || x < 0 && _ <= 0 || x > g && _ >= d) return void i.change(U => {
                        U.setSelection(U.createRangeOn(s))
                    });
                    x < 0 ? (x = n ? 0 : g, _--) : x > g && (x = n ? g : 0, _++);
                    const M = l.find(U => U.row == _ && U.column == x).cell, O = ["right", "down"].includes(t),
                        j = this.editor.plugins.get("TableSelection");
                    if (n && j.isEnabled) {
                        const U = j.getAnchorCell() || e;
                        j.setCellSelection(U, M)
                    } else {
                        const U = i.createPositionAt(M, O ? 0 : "end");
                        i.change(K => {
                            K.setSelection(U)
                        })
                    }
                }
            }

            class QN extends xn {
                constructor() {
                    super(...arguments), this.domEventType = ["mousemove", "mouseleave"]
                }

                onDomEvent(e) {
                    this.fire(e.type, e)
                }
            }

            class JN extends Re {
                static get pluginName() {
                    return "TableMouse"
                }

                static get requires() {
                    return [Kl, qr]
                }

                init() {
                    this.editor.editing.view.addObserver(QN), this._enableShiftClickSelection(), this._enableMouseDragSelection()
                }

                _enableShiftClickSelection() {
                    const e = this.editor, t = e.plugins.get(qr);
                    let n = !1;
                    const i = e.plugins.get(Kl);
                    this.listenTo(e.editing.view.document, "mousedown", (s, l) => {
                        const d = e.model.document.selection;
                        if (!this.isEnabled || !i.isEnabled || !l.domEvent.shiftKey) return;
                        const g = i.getAnchorCell() || t.getTableCellsContainingSelection(d)[0];
                        if (!g) return;
                        const v = this._getModelTableCellFromDomEvent(l);
                        v && e2(g, v) && (n = !0, i.setCellSelection(g, v), l.preventDefault())
                    }), this.listenTo(e.editing.view.document, "mouseup", () => {
                        n = !1
                    }), this.listenTo(e.editing.view.document, "selectionChange", s => {
                        n && s.stop()
                    }, {priority: "highest"})
                }

                _enableMouseDragSelection() {
                    const e = this.editor;
                    let t, n, i = !1, s = !1;
                    const l = e.plugins.get(Kl);
                    this.listenTo(e.editing.view.document, "mousedown", (d, g) => {
                        this.isEnabled && l.isEnabled && (g.domEvent.shiftKey || g.domEvent.ctrlKey || g.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(g)))
                    }), this.listenTo(e.editing.view.document, "mousemove", (d, g) => {
                        if (!g.domEvent.buttons || !t) return;
                        const v = this._getModelTableCellFromDomEvent(g);
                        v && e2(t, v) && (n = v, i || n == t || (i = !0)), i && (s = !0, l.setCellSelection(t, n), g.preventDefault())
                    }), this.listenTo(e.editing.view.document, "mouseup", () => {
                        i = !1, s = !1, t = null, n = null
                    }), this.listenTo(e.editing.view.document, "selectionChange", d => {
                        s && d.stop()
                    }, {priority: "highest"})
                }

                _getModelTableCellFromDomEvent(e) {
                    const t = e.target, n = this.editor.editing.view.createPositionAt(t, 0);
                    return this.editor.editing.mapper.toModelPosition(n).parent.findAncestor("tableCell", {includeSelf: !0})
                }
            }

            function e2(r, e) {
                return r.parent.parent == e.parent.parent
            }

            var t2 = C(6306),
                XN = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(t2.Z, XN), t2.Z.locals;

            function eL(r) {
                const e = r.getSelectedElement();
                return e && n2(e) ? e : null
            }

            function tL(r) {
                const e = r.getFirstPosition();
                if (!e) return null;
                let t = e.parent;
                for (; t;) {
                    if (t.is("element") && n2(t)) return t;
                    t = t.parent
                }
                return null
            }

            function n2(r) {
                return !!r.getCustomProperty("table") && wr(r)
            }

            var r2 = C(7368),
                nL = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(r2.Z, nL), r2.Z.locals;
            var i2 = C(9247),
                rL = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(i2.Z, rL), i2.Z.locals;
            var o2 = C(4070),
                iL = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(o2.Z, iL), o2.Z.locals;
            var s2 = C(6237),
                oL = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(s2.Z, oL), s2.Z.locals;
            var a2 = C(5087),
                sL = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(a2.Z, sL), a2.Z.locals;
            const Zl = ui.defaultPositions;
            Zl.northArrowSouth, Zl.northArrowSouthWest, Zl.northArrowSouthEast, Zl.southArrowNorth, Zl.southArrowNorthWest, Zl.southArrowNorthEast, Zl.viewportStickyNorth;
            var l2 = C(7341),
                aL = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(l2.Z, aL), l2.Z.locals;
            var c2 = C(2128),
                lL = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(c2.Z, lL), c2.Z.locals;
            var u2 = C(4101),
                cL = {injectType: "singletonStyleTag", attributes: {"data-cke": !0}, insert: "head", singleton: !0};
            rt()(u2.Z, cL), u2.Z.locals;
            var uL = Object.defineProperty, d2 = Object.getOwnPropertySymbols, dL = Object.prototype.hasOwnProperty,
                hL = Object.prototype.propertyIsEnumerable, h2 = (r, e, t) => e in r ? uL(r, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }) : r[e] = t, f2 = (r, e) => {
                    for (var t in e || (e = {})) dL.call(e, t) && h2(r, t, e[t]);
                    if (d2) for (var t of d2(e)) hL.call(e, t) && h2(r, t, e[t]);
                    return r
                };
            const fL = {autoRefresh: !0}, g2 = 36e5;

            class pk extends we() {
                constructor(e, t = {}) {
                    if (super(), !e) throw new R("token-missing-token-url", this);
                    t.initValue && this._validateTokenValue(t.initValue), this.set("value", t.initValue), this._refresh = typeof e == "function" ? e : () => {
                        return n = e, new Promise((i, s) => {
                            const l = new XMLHttpRequest;
                            l.open("GET", n), l.addEventListener("load", () => {
                                const d = l.status, g = l.response;
                                return d < 200 || d > 299 ? s(new R("token-cannot-download-new-token", null)) : i(g)
                            }), l.addEventListener("error", () => s(new Error("Network Error"))), l.addEventListener("abort", () => s(new Error("Abort"))), l.send()
                        });
                        var n
                    }, this._options = f2(f2({}, fL), t)
                }

                init() {
                    return new Promise((e, t) => {
                        this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(), e(this)) : this.refreshToken().then(e).catch(t)
                    })
                }

                refreshToken() {
                    return this._refresh().then(e => (this._validateTokenValue(e), this.set("value", e), this._options.autoRefresh && this._registerRefreshTokenTimeout(), this))
                }

                destroy() {
                    clearTimeout(this._tokenRefreshTimeout)
                }

                _validateTokenValue(e) {
                    const t = typeof e == "string", n = !/^".*"$/.test(e), i = t && e.split(".").length === 3;
                    if (!n || !i) throw new R("token-not-in-jwt-format", this)
                }

                _registerRefreshTokenTimeout() {
                    const e = this._getTokenRefreshTimeoutTime();
                    clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
                        this.refreshToken()
                    }, e)
                }

                _getTokenRefreshTimeoutTime() {
                    try {
                        const [, e] = this.value.split("."), {exp: t} = JSON.parse(atob(e));
                        return t ? Math.floor((1e3 * t - Date.now()) / 2) : g2
                    } catch {
                        return g2
                    }
                }

                static create(e, t = {}) {
                    return new pk(e, t).init()
                }
            }

            const mk = /^data:(\S*?);base64,/;

            class gL extends Le() {
                constructor(e, t, n) {
                    if (super(), !e) throw new R("fileuploader-missing-file", null);
                    if (!t) throw new R("fileuploader-missing-token", null);
                    if (!n) throw new R("fileuploader-missing-api-address", null);
                    this.file = function (i) {
                        if (typeof i != "string") return !1;
                        const s = i.match(mk);
                        return !(!s || !s.length)
                    }(e) ? function (i, s = 512) {
                        try {
                            const l = i.match(mk)[1], d = atob(i.replace(mk, "")), g = [];
                            for (let v = 0; v < d.length; v += s) {
                                const _ = d.slice(v, v + s), x = new Array(_.length);
                                for (let M = 0; M < _.length; M++) x[M] = _.charCodeAt(M);
                                g.push(new Uint8Array(x))
                            }
                            return new Blob(g, {type: l})
                        } catch {
                            throw new R("fileuploader-decoding-image-data-error", null)
                        }
                    }(e) : e, this._token = t, this._apiAddress = n
                }

                onProgress(e) {
                    return this.on("progress", (t, n) => e(n)), this
                }

                onError(e) {
                    return this.once("error", (t, n) => e(n)), this
                }

                abort() {
                    this.xhr.abort()
                }

                send() {
                    return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest()
                }

                _prepareRequest() {
                    const e = new XMLHttpRequest;
                    e.open("POST", this._apiAddress), e.setRequestHeader("Authorization", this._token.value), e.responseType = "json", this.xhr = e
                }

                _attachXHRListeners() {
                    const e = this.xhr, t = n => () => this.fire("error", n);
                    e.addEventListener("error", t("Network Error")), e.addEventListener("abort", t("Abort")), e.upload && e.upload.addEventListener("progress", n => {
                        n.lengthComputable && this.fire("progress", {total: n.total, uploaded: n.loaded})
                    }), e.addEventListener("load", () => {
                        const n = e.status, i = e.response;
                        if (n < 200 || n > 299) return this.fire("error", i.message || i.error)
                    })
                }

                _sendRequest() {
                    const e = new FormData, t = this.xhr;
                    return e.append("file", this.file), new Promise((n, i) => {
                        t.addEventListener("load", () => {
                            const s = t.status, l = t.response;
                            return s < 200 || s > 299 ? l.message ? i(new R("fileuploader-uploading-data-failed", this, {message: l.message})) : i(l.error) : n(l)
                        }), t.addEventListener("error", () => i(new Error("Network Error"))), t.addEventListener("abort", () => i(new Error("Abort"))), t.send(e)
                    })
                }
            }

            class pL {
                constructor(e, t) {
                    if (!e) throw new R("uploadgateway-missing-token", null);
                    if (!t) throw new R("uploadgateway-missing-api-address", null);
                    this._token = e, this._apiAddress = t
                }

                upload(e) {
                    return new gL(e, this._token, this._apiAddress)
                }
            }

            class mL extends Tl {
                static get pluginName() {
                    return "CloudServicesCore"
                }

                createToken(e, t) {
                    return new pk(e, t)
                }

                createUploadGateway(e, t) {
                    return new pL(e, t)
                }
            }

            var p2 = (r, e, t) => new Promise((n, i) => {
                var s = g => {
                    try {
                        d(t.next(g))
                    } catch (v) {
                        i(v)
                    }
                }, l = g => {
                    try {
                        d(t.throw(g))
                    } catch (v) {
                        i(v)
                    }
                }, d = g => g.done ? n(g.value) : Promise.resolve(g.value).then(s, l);
                d((t = t.apply(r, e)).next())
            });

            class bk extends Hg {
            }

            bk.builtinPlugins = [class extends Re {
                static get requires() {
                    return [GC, $g, XI, _I, pI, e_]
                }

                static get pluginName() {
                    return "Essentials"
                }
            }, class extends Re {
                static get requires() {
                    return [_o]
                }

                static get pluginName() {
                    return "CKFinderUploadAdapter"
                }

                init() {
                    const r = this.editor.config.get("ckfinder.uploadUrl");
                    r && (this.editor.plugins.get(_o).createUploadAdapter = e => new fM(e, r, this.editor.t))
                }
            }, class extends Re {
                static get requires() {
                    return [Ls]
                }

                static get pluginName() {
                    return "Autoformat"
                }

                afterInit() {
                    this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats()
                }

                _addListAutoformats() {
                    const r = this.editor.commands;
                    r.get("bulletedList") && Na(this.editor, this, /^[*-]\s$/, "bulletedList"), r.get("numberedList") && Na(this.editor, this, /^1[.|)]\s$/, "numberedList"), r.get("todoList") && Na(this.editor, this, /^\[\s?\]\s$/, "todoList"), r.get("checkTodoList") && Na(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
                        this.editor.execute("todoList"), this.editor.execute("checkTodoList")
                    })
                }

                _addBasicStylesAutoformats() {
                    const r = this.editor.commands;
                    if (r.get("bold")) {
                        const e = Qg(this.editor, "bold");
                        Au(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, e), Au(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, e)
                    }
                    if (r.get("italic")) {
                        const e = Qg(this.editor, "italic");
                        Au(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, e), Au(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, e)
                    }
                    if (r.get("code")) {
                        const e = Qg(this.editor, "code");
                        Au(this.editor, this, /(`)([^`]+)(`)$/g, e)
                    }
                    if (r.get("strikethrough")) {
                        const e = Qg(this.editor, "strikethrough");
                        Au(this.editor, this, /(~~)([^~]+)(~~)$/g, e)
                    }
                }

                _addHeadingAutoformats() {
                    const r = this.editor.commands.get("heading");
                    r && r.modelElements.filter(e => e.match(/^heading[1-6]$/)).forEach(e => {
                        const t = e[7], n = new RegExp(`^(#{${t}})\\s$`);
                        Na(this.editor, this, n, () => {
                            if (!r.isEnabled || r.value === e) return !1;
                            this.editor.execute("heading", {value: e})
                        })
                    })
                }

                _addBlockQuoteAutoformats() {
                    this.editor.commands.get("blockQuote") && Na(this.editor, this, /^>\s$/, "blockQuote")
                }

                _addCodeBlockAutoformats() {
                    const r = this.editor, e = r.model.document.selection;
                    r.commands.get("codeBlock") && Na(r, this, /^```$/, () => {
                        if (e.getFirstPosition().parent.is("element", "listItem")) return !1;
                        this.editor.execute("codeBlock", {usePreviousLanguageChoice: !0})
                    })
                }

                _addHorizontalLineAutoformats() {
                    this.editor.commands.get("horizontalLine") && Na(this.editor, this, /^---$/, "horizontalLine")
                }
            }, class extends Re {
                static get requires() {
                    return [gM, pM]
                }

                static get pluginName() {
                    return "Bold"
                }
            }, class extends Re {
                static get requires() {
                    return [bM, kM]
                }

                static get pluginName() {
                    return "Italic"
                }
            }, class extends Re {
                static get requires() {
                    return [wM, CM]
                }

                static get pluginName() {
                    return "BlockQuote"
                }
            }, class extends Re {
                static get pluginName() {
                    return "CKBox"
                }

                static get requires() {
                    return [v_, _M]
                }
            }, class extends Re {
                static get pluginName() {
                    return "CKFinder"
                }

                static get requires() {
                    return ["Link", "CKFinderUploadAdapter", KM, $M]
                }
            }, class extends Tl {
                constructor() {
                    super(...arguments), this.token = null, this._tokens = new Map
                }

                static get pluginName() {
                    return "CloudServices"
                }

                static get requires() {
                    return [mL]
                }

                init() {
                    return p2(this, null, function* () {
                        const r = this.context.config.get("cloudServices") || {};
                        for (const [t, n] of Object.entries(r)) this[t] = n;
                        if (!this.tokenUrl) return void (this.token = null);
                        const e = this.context.plugins.get("CloudServicesCore");
                        this.token = yield e.createToken(this.tokenUrl).init(), this._tokens.set(this.tokenUrl, this.token)
                    })
                }

                registerTokenUrl(r) {
                    return p2(this, null, function* () {
                        if (this._tokens.has(r)) return this.getTokenFor(r);
                        const e = this.context.plugins.get("CloudServicesCore"), t = yield e.createToken(r).init();
                        return this._tokens.set(r, t), t
                    })
                }

                getTokenFor(r) {
                    const e = this._tokens.get(r);
                    if (!e) throw new R("cloudservices-token-not-registered", this);
                    return e
                }

                destroy() {
                    super.destroy();
                    for (const r of this._tokens.values()) r.destroy()
                }
            }, class extends Re {
                static get pluginName() {
                    return "EasyImage"
                }

                static get requires() {
                    return [ZM, "ImageUpload"]
                }

                init() {
                    const r = this.editor;
                    r.plugins.has("ImageBlockEditing") || r.plugins.has("ImageInlineEditing") || ae("easy-image-image-feature-missing", r)
                }
            }, class extends Re {
                static get requires() {
                    return [eB, nB]
                }

                static get pluginName() {
                    return "Heading"
                }
            }, class extends Re {
                static get requires() {
                    return [_B, DB]
                }

                static get pluginName() {
                    return "Image"
                }
            }, class extends Re {
                static get requires() {
                    return [EB, SB]
                }

                static get pluginName() {
                    return "ImageCaption"
                }
            }, class extends Re {
                static get requires() {
                    return [_1, QB]
                }

                static get pluginName() {
                    return "ImageStyle"
                }
            }, class extends Re {
                static get requires() {
                    return [Kg, hi]
                }

                static get pluginName() {
                    return "ImageToolbar"
                }

                afterInit() {
                    const r = this.editor, e = r.t, t = r.plugins.get(Kg), n = r.plugins.get("ImageUtils");
                    var i;
                    t.register("image", {
                        ariaLabel: e("Image toolbar"),
                        items: (i = r.config.get("image.toolbar") || [], i.map(s => Oe(s) ? s.name : s)),
                        getRelatedElement: s => n.getClosestSelectedImageWidget(s)
                    })
                }
            }, class extends Re {
                static get pluginName() {
                    return "ImageUpload"
                }

                static get requires() {
                    return [HB, MB, PB]
                }
            }, class extends Re {
                static get pluginName() {
                    return "Indent"
                }

                static get requires() {
                    return [JB, XB]
                }
            }, class extends Re {
                static get requires() {
                    return [$1, S4, T4]
                }

                static get pluginName() {
                    return "Link"
                }
            }, class extends Re {
                static get requires() {
                    return [Z4, F4]
                }

                static get pluginName() {
                    return "List"
                }
            }, class extends Re {
                static get requires() {
                    return [rp, iN, tN, mh]
                }

                static get pluginName() {
                    return "MediaEmbed"
                }
            }, Gb, class extends Re {
                static get pluginName() {
                    return "PasteFromOffice"
                }

                static get requires() {
                    return [es]
                }

                init() {
                    const r = this.editor, e = r.plugins.get("ClipboardPipeline"), t = r.editing.view.document, n = [];
                    n.push(new fN(t)), n.push(new pN(t)), n.push(new bN(t)), e.on("inputTransformation", (i, s) => {
                        if (s._isTransformedWithPasteFromOffice || r.model.document.selection.getFirstPosition().parent.is("element", "codeBlock")) return;
                        const l = s.dataTransfer.getData("text/html"), d = n.find(g => g.isActive(l));
                        d && (s._parsedData || (s._parsedData = kN(l, t.stylesProcessor)), d.execute(s), s._isTransformedWithPasteFromOffice = !0)
                    }, {priority: "high"})
                }
            }, class extends Re {
                static get requires() {
                    return [Zb, hi]
                }

                static get pluginName() {
                    return "PictureEditing"
                }

                afterInit() {
                    const r = this.editor;
                    r.plugins.has("ImageBlockEditing") && r.model.schema.extend("imageBlock", {allowAttributes: ["sources"]}), r.plugins.has("ImageInlineEditing") && r.model.schema.extend("imageInline", {allowAttributes: ["sources"]}), this._setupConversion(), this._setupImageUploadEditingIntegration()
                }

                _setupConversion() {
                    const r = this.editor, e = r.conversion, t = r.plugins.get("ImageUtils");
                    e.for("upcast").add(function (n) {
                        const i = ["srcset", "media", "type", "sizes"], s = (l, d, g) => {
                            const v = d.viewItem;
                            if (!g.consumable.test(v, {name: !0})) return;
                            const _ = new Map;
                            for (const O of v.getChildren()) if (O.is("element", "source")) {
                                const j = {};
                                for (const U of i) O.hasAttribute(U) && g.consumable.test(O, {attributes: U}) && (j[U] = O.getAttribute(U));
                                Object.keys(j).length && _.set(O, j)
                            }
                            const x = n.findViewImgElement(v);
                            if (!x) return;
                            let M = d.modelCursor.parent;
                            if (!M.is("element", "imageBlock")) {
                                const O = g.convertItem(x, d.modelCursor);
                                d.modelRange = O.modelRange, d.modelCursor = O.modelCursor, M = Wn(O.modelRange.getItems())
                            }
                            g.consumable.consume(v, {name: !0});
                            for (const [O, j] of _) g.consumable.consume(O, {attributes: Object.keys(j)});
                            _.size && g.writer.setAttribute("sources", Array.from(_.values()), M), g.convertChildren(v, M)
                        };
                        return l => {
                            l.on("element:picture", s)
                        }
                    }(t)), e.for("downcast").add(function (n) {
                        const i = (s, l, d) => {
                            if (!d.consumable.consume(l.item, s.name)) return;
                            const g = d.writer, v = d.mapper.toViewElement(l.item), _ = n.findViewImgElement(v),
                                x = l.attributeNewValue;
                            if (x && x.length) {
                                const M = g.createContainerElement("picture", null, x.map(U => g.createEmptyElement("source", U))),
                                    O = [];
                                let j = _.parent;
                                for (; j && j.is("attributeElement");) {
                                    const U = j.parent;
                                    g.unwrap(g.createRangeOn(_), j), O.unshift(j), j = U
                                }
                                g.insert(g.createPositionBefore(_), M), g.move(g.createRangeOn(_), g.createPositionAt(M, "end"));
                                for (const U of O) g.wrap(g.createRangeOn(M), U)
                            } else if (_.parent.is("element", "picture")) {
                                const M = _.parent;
                                g.move(g.createRangeOn(_), g.createPositionBefore(M)), g.remove(M)
                            }
                        };
                        return s => {
                            s.on("attribute:sources:imageBlock", i), s.on("attribute:sources:imageInline", i)
                        }
                    }(t))
                }

                _setupImageUploadEditingIntegration() {
                    const r = this.editor;
                    if (!r.plugins.has("ImageUploadEditing")) return;
                    const e = r.plugins.get("ImageUploadEditing");
                    this.listenTo(e, "uploadComplete", (t, {imageElement: n, data: i}) => {
                        const s = i.sources;
                        s && r.model.change(l => {
                            l.setAttributes({sources: s}, n)
                        })
                    })
                }
            }, class extends Re {
                static get requires() {
                    return [UN, $N, Kl, JN, YN, ZN, mh]
                }

                static get pluginName() {
                    return "Table"
                }
            }, class extends Re {
                static get requires() {
                    return [Kg]
                }

                static get pluginName() {
                    return "TableToolbar"
                }

                afterInit() {
                    const r = this.editor, e = r.t, t = r.plugins.get(Kg), n = r.config.get("table.contentToolbar"),
                        i = r.config.get("table.tableToolbar");
                    n && t.register("tableContent", {
                        ariaLabel: e("Table toolbar"),
                        items: n,
                        getRelatedElement: tL
                    }), i && t.register("table", {ariaLabel: e("Table toolbar"), items: i, getRelatedElement: eL})
                }
            }, class extends Re {
                static get requires() {
                    return ["Delete", "Input"]
                }

                static get pluginName() {
                    return "TextTransformation"
                }

                constructor(r) {
                    super(r), r.config.define("typing", {transformations: {include: mI}})
                }

                init() {
                    const r = this.editor.model.document.selection;
                    r.on("change:range", () => {
                        this.isEnabled = !r.anchor.parent.is("element", "codeBlock")
                    }), this._enableTransformationWatchers()
                }

                _enableTransformationWatchers() {
                    const r = this.editor, e = r.model, t = r.plugins.get("Delete"), n = function (s) {
                        const l = s.extra || [], d = s.remove || [], g = v => !d.includes(v);
                        return function (v) {
                            const _ = new Set;
                            for (const x of v) if (typeof x == "string" && vC[x]) for (const M of vC[x]) _.add(M); else _.add(x);
                            return Array.from(_)
                        }(s.include.concat(l).filter(g)).filter(g).map(v => typeof v == "string" && kC[v] ? kC[v] : v).filter(v => typeof v == "object").map(v => ({
                            from: bI(v.from),
                            to: kI(v.to)
                        }))
                    }(r.config.get("typing.transformations")), i = new pC(r.model, s => {
                        for (const l of n) if (l.from.test(s)) return {normalizedTransformation: l}
                    });
                    i.on("matched:data", (s, l) => {
                        if (!l.batch.isTyping) return;
                        const {from: d, to: g} = l.normalizedTransformation, v = d.exec(l.text), _ = g(v.slice(1)),
                            x = l.range;
                        let M = v.index;
                        e.enqueueChange(O => {
                            for (let j = 1; j < v.length; j++) {
                                const U = v[j], K = _[j - 1];
                                if (K == null) {
                                    M += U.length;
                                    continue
                                }
                                const ne = x.start.getShiftedBy(M), pe = e.createRange(ne, ne.getShiftedBy(U.length)),
                                    Se = vI(ne);
                                e.insertContent(O.createText(K, Se), pe), M += K.length
                            }
                            e.enqueueChange(() => {
                                t.requestUndoOnBackspace()
                            })
                        })
                    }), i.bind("isEnabled").to(this)
                }
            }], bk.defaultConfig = {
                toolbar: {items: ["undo", "redo", "|", "heading", "|", "bold", "italic", "|", "link", "uploadImage", "insertTable", "blockQuote", "mediaEmbed", "|", "bulletedList", "numberedList", "outdent", "indent"]},
                image: {toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "toggleImageCaption", "imageTextAlternative"]},
                table: {contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"]},
                language: "en"
            }
        })(), k = k.default
    })())
})(Zp, Zp.exports);
var n7 = Zp.exports;
const Av = of(n7), r7 = {
        data() {
            return {
                isEditable: !this.isAdvanced,
                editor: Av,
                editorConfig: {toolbar: ["bold", "italic", "link"], language: "en"}
            }
        },
        props: {title: String, modelValue: String, error: Boolean, errorMessage: String, isAdvanced: Boolean},
        emits: ["update:modelValue"],
        methods: {
            updateValue(a) {
                this.$emit("update:modelValue", a)
            }
        },
        watch: {
            isAdvanced(a) {
                console.log(a), this.isEditable = !a
            }
        }
    }, i7 = {class: "cf-configurator-modal-form-block-item"},
    o7 = {class: "cf-configurator-modal-form-block-item-title", style: {display: "flex"}},
    s7 = {key: 0, style: {display: "flex", "align-items": "center", "margin-left": "10px"}}, a7 = J("div", {
        style: {
            "margin-left": "5px",
            "font-size": "0.7rem",
            "font-weight": "normal"
        }
    }, "advanced settings", -1), l7 = {class: "cf-ck-editor"}, c7 = {key: 0};

function u7(a, c, h, b, C, k) {
    const A = Nn("ckeditor");
    return He(), tt("div", i7, [J("span", o7, [Yt(Fn(h.title) + " ", 1), h.isAdvanced ? (He(), tt("div", s7, [Bt(J("input", {
        type: "checkbox",
        "onUpdate:modelValue": c[0] || (c[0] = y => C.isEditable = y)
    }, null, 512), [[vc, C.isEditable]]), a7])) : Rt("", !0)]), J("div", l7, [lt(A, {
        editor: C.editor,
        class: On({"cf-input-disabled": !C.isEditable}),
        modelValue: h.modelValue,
        "onUpdate:modelValue": c[1] || (c[1] = y => k.updateValue(y)),
        config: C.editorConfig
    }, null, 8, ["editor", "class", "modelValue", "config"]), h.error ? (He(), tt("span", c7, Fn(h.errorMessage), 1)) : Rt("", !0)])])
}

const Cv = Tr(r7, [["render", u7]]), d7 = {
        data() {
            return {
                uniqueId: this.generateUniqueId(),
                isEditable: !this.isAdvanced,
                cmOptions: {lineNumbers: !0, mode: "javascript", autoRefresh: !0, readOnly: !this.isEditable}
            }
        },
        props: {title: String, modelValue: String, error: Boolean, errorMessage: String, isAdvanced: Boolean},
        emits: ["update:modelValue"],
        methods: {
            generateUniqueId() {
                return Math.random().toString(36).substring(2, 15)
            }, updateValue(a) {
                this.$emit("update:modelValue", a)
            }
        },
        watch: {
            isEditable(a) {
                this.cmOptions.readOnly = !a
            }, isAdvanced(a) {
                this.isEditable = !a, this.cmOptions.readOnly = !this.isEditable
            }
        }
    }, h7 = {class: "cf-configurator-modal-form-block-item"},
    f7 = {class: "cf-configurator-modal-form-block-item-title", style: {display: "flex"}},
    g7 = {key: 0, style: {display: "flex", "align-items": "center", "margin-left": "10px"}}, p7 = ["id"], m7 = ["for"],
    b7 = {key: 0};

function k7(a, c, h, b, C, k) {
    const A = Nn("Codemirror");
    return He(), tt("div", h7, [J("span", f7, [Yt(Fn(h.title) + " ", 1), h.isAdvanced ? (He(), tt("div", g7, [Bt(J("input", {
        type: "checkbox",
        "onUpdate:modelValue": c[0] || (c[0] = y => C.isEditable = y),
        id: "advanced-setting-" + C.uniqueId
    }, null, 8, p7), [[vc, C.isEditable]]), J("label", {
        for: "advanced-setting-" + C.uniqueId,
        style: {"margin-left": "5px", "font-size": "0.7rem", "font-weight": "normal"}
    }, "advanced settings", 8, m7)])) : Rt("", !0)]), lt(A, {
        value: h.modelValue,
        onInput: k.updateValue,
        options: C.cmOptions,
        border: "",
        placeholder: "test placeholder",
        height: 150,
        class: On({"cf-input-disabled": !C.isEditable})
    }, null, 8, ["value", "onInput", "options", "class"]), h.error ? (He(), tt("span", b7, Fn(h.errorMessage), 1)) : Rt("", !0)])
}

const v7 = Tr(d7, [["render", k7]]);
var Yp = {exports: {}};/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
Yp.exports;
(function (a, c) {
    (function (h) {
        var b = c, C = a && a.exports == b && a, k = typeof oo == "object" && oo;
        (k.global === k || k.window === k) && (h = k);
        var A = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, y = /[\x01-\x7F]/g,
            w = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
            S = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g,
            I = {
                "­": "shy",
                "‌": "zwnj",
                "‍": "zwj",
                "‎": "lrm",
                "⁣": "ic",
                "⁢": "it",
                "⁡": "af",
                "‏": "rlm",
                "​": "ZeroWidthSpace",
                "⁠": "NoBreak",
                "̑": "DownBreve",
                "⃛": "tdot",
                "⃜": "DotDot",
                "	": "Tab",
                "\n": "NewLine",
                " ": "puncsp",
                " ": "MediumSpace",
                " ": "thinsp",
                " ": "hairsp",
                " ": "emsp13",
                " ": "ensp",
                " ": "emsp14",
                " ": "emsp",
                " ": "numsp",
                " ": "nbsp",
                "  ": "ThickSpace",
                "‾": "oline",
                _: "lowbar",
                "‐": "dash",
                "–": "ndash",
                "—": "mdash",
                "―": "horbar",
                ",": "comma",
                ";": "semi",
                "⁏": "bsemi",
                ":": "colon",
                "⩴": "Colone",
                "!": "excl",
                "¡": "iexcl",
                "?": "quest",
                "¿": "iquest",
                ".": "period",
                "‥": "nldr",
                "…": "mldr",
                "·": "middot",
                "'": "apos",
                "‘": "lsquo",
                "’": "rsquo",
                "‚": "sbquo",
                "‹": "lsaquo",
                "›": "rsaquo",
                '"': "quot",
                "“": "ldquo",
                "”": "rdquo",
                "„": "bdquo",
                "«": "laquo",
                "»": "raquo",
                "(": "lpar",
                ")": "rpar",
                "[": "lsqb",
                "]": "rsqb",
                "{": "lcub",
                "}": "rcub",
                "⌈": "lceil",
                "⌉": "rceil",
                "⌊": "lfloor",
                "⌋": "rfloor",
                "⦅": "lopar",
                "⦆": "ropar",
                "⦋": "lbrke",
                "⦌": "rbrke",
                "⦍": "lbrkslu",
                "⦎": "rbrksld",
                "⦏": "lbrksld",
                "⦐": "rbrkslu",
                "⦑": "langd",
                "⦒": "rangd",
                "⦓": "lparlt",
                "⦔": "rpargt",
                "⦕": "gtlPar",
                "⦖": "ltrPar",
                "⟦": "lobrk",
                "⟧": "robrk",
                "⟨": "lang",
                "⟩": "rang",
                "⟪": "Lang",
                "⟫": "Rang",
                "⟬": "loang",
                "⟭": "roang",
                "❲": "lbbrk",
                "❳": "rbbrk",
                "‖": "Vert",
                "§": "sect",
                "¶": "para",
                "@": "commat",
                "*": "ast",
                "/": "sol",
                undefined: null,
                "&": "amp",
                "#": "num",
                "%": "percnt",
                "‰": "permil",
                "‱": "pertenk",
                "†": "dagger",
                "‡": "Dagger",
                "•": "bull",
                "⁃": "hybull",
                "′": "prime",
                "″": "Prime",
                "‴": "tprime",
                "⁗": "qprime",
                "‵": "bprime",
                "⁁": "caret",
                "`": "grave",
                "´": "acute",
                "˜": "tilde",
                "^": "Hat",
                "¯": "macr",
                "˘": "breve",
                "˙": "dot",
                "¨": "die",
                "˚": "ring",
                "˝": "dblac",
                "¸": "cedil",
                "˛": "ogon",
                "ˆ": "circ",
                "ˇ": "caron",
                "°": "deg",
                "©": "copy",
                "®": "reg",
                "℗": "copysr",
                "℘": "wp",
                "℞": "rx",
                "℧": "mho",
                "℩": "iiota",
                "←": "larr",
                "↚": "nlarr",
                "→": "rarr",
                "↛": "nrarr",
                "↑": "uarr",
                "↓": "darr",
                "↔": "harr",
                "↮": "nharr",
                "↕": "varr",
                "↖": "nwarr",
                "↗": "nearr",
                "↘": "searr",
                "↙": "swarr",
                "↝": "rarrw",
                "↝̸": "nrarrw",
                "↞": "Larr",
                "↟": "Uarr",
                "↠": "Rarr",
                "↡": "Darr",
                "↢": "larrtl",
                "↣": "rarrtl",
                "↤": "mapstoleft",
                "↥": "mapstoup",
                "↦": "map",
                "↧": "mapstodown",
                "↩": "larrhk",
                "↪": "rarrhk",
                "↫": "larrlp",
                "↬": "rarrlp",
                "↭": "harrw",
                "↰": "lsh",
                "↱": "rsh",
                "↲": "ldsh",
                "↳": "rdsh",
                "↵": "crarr",
                "↶": "cularr",
                "↷": "curarr",
                "↺": "olarr",
                "↻": "orarr",
                "↼": "lharu",
                "↽": "lhard",
                "↾": "uharr",
                "↿": "uharl",
                "⇀": "rharu",
                "⇁": "rhard",
                "⇂": "dharr",
                "⇃": "dharl",
                "⇄": "rlarr",
                "⇅": "udarr",
                "⇆": "lrarr",
                "⇇": "llarr",
                "⇈": "uuarr",
                "⇉": "rrarr",
                "⇊": "ddarr",
                "⇋": "lrhar",
                "⇌": "rlhar",
                "⇐": "lArr",
                "⇍": "nlArr",
                "⇑": "uArr",
                "⇒": "rArr",
                "⇏": "nrArr",
                "⇓": "dArr",
                "⇔": "iff",
                "⇎": "nhArr",
                "⇕": "vArr",
                "⇖": "nwArr",
                "⇗": "neArr",
                "⇘": "seArr",
                "⇙": "swArr",
                "⇚": "lAarr",
                "⇛": "rAarr",
                "⇝": "zigrarr",
                "⇤": "larrb",
                "⇥": "rarrb",
                "⇵": "duarr",
                "⇽": "loarr",
                "⇾": "roarr",
                "⇿": "hoarr",
                "∀": "forall",
                "∁": "comp",
                "∂": "part",
                "∂̸": "npart",
                "∃": "exist",
                "∄": "nexist",
                "∅": "empty",
                "∇": "Del",
                "∈": "in",
                "∉": "notin",
                "∋": "ni",
                "∌": "notni",
                "϶": "bepsi",
                "∏": "prod",
                "∐": "coprod",
                "∑": "sum",
                "+": "plus",
                "±": "pm",
                "÷": "div",
                "×": "times",
                "<": "lt",
                "≮": "nlt",
                "<⃒": "nvlt",
                "=": "equals",
                "≠": "ne",
                "=⃥": "bne",
                "⩵": "Equal",
                ">": "gt",
                "≯": "ngt",
                ">⃒": "nvgt",
                "¬": "not",
                "|": "vert",
                "¦": "brvbar",
                "−": "minus",
                "∓": "mp",
                "∔": "plusdo",
                "⁄": "frasl",
                "∖": "setmn",
                "∗": "lowast",
                "∘": "compfn",
                "√": "Sqrt",
                "∝": "prop",
                "∞": "infin",
                "∟": "angrt",
                "∠": "ang",
                "∠⃒": "nang",
                "∡": "angmsd",
                "∢": "angsph",
                "∣": "mid",
                "∤": "nmid",
                "∥": "par",
                "∦": "npar",
                "∧": "and",
                "∨": "or",
                "∩": "cap",
                "∩︀": "caps",
                "∪": "cup",
                "∪︀": "cups",
                "∫": "int",
                "∬": "Int",
                "∭": "tint",
                "⨌": "qint",
                "∮": "oint",
                "∯": "Conint",
                "∰": "Cconint",
                "∱": "cwint",
                "∲": "cwconint",
                "∳": "awconint",
                "∴": "there4",
                "∵": "becaus",
                "∶": "ratio",
                "∷": "Colon",
                "∸": "minusd",
                "∺": "mDDot",
                "∻": "homtht",
                "∼": "sim",
                "≁": "nsim",
                "∼⃒": "nvsim",
                "∽": "bsim",
                "∽̱": "race",
                "∾": "ac",
                "∾̳": "acE",
                "∿": "acd",
                "≀": "wr",
                "≂": "esim",
                "≂̸": "nesim",
                "≃": "sime",
                "≄": "nsime",
                "≅": "cong",
                "≇": "ncong",
                "≆": "simne",
                "≈": "ap",
                "≉": "nap",
                "≊": "ape",
                "≋": "apid",
                "≋̸": "napid",
                "≌": "bcong",
                "≍": "CupCap",
                "≭": "NotCupCap",
                "≍⃒": "nvap",
                "≎": "bump",
                "≎̸": "nbump",
                "≏": "bumpe",
                "≏̸": "nbumpe",
                "≐": "doteq",
                "≐̸": "nedot",
                "≑": "eDot",
                "≒": "efDot",
                "≓": "erDot",
                "≔": "colone",
                "≕": "ecolon",
                "≖": "ecir",
                "≗": "cire",
                "≙": "wedgeq",
                "≚": "veeeq",
                "≜": "trie",
                "≟": "equest",
                "≡": "equiv",
                "≢": "nequiv",
                "≡⃥": "bnequiv",
                "≤": "le",
                "≰": "nle",
                "≤⃒": "nvle",
                "≥": "ge",
                "≱": "nge",
                "≥⃒": "nvge",
                "≦": "lE",
                "≦̸": "nlE",
                "≧": "gE",
                "≧̸": "ngE",
                "≨︀": "lvnE",
                "≨": "lnE",
                "≩": "gnE",
                "≩︀": "gvnE",
                "≪": "ll",
                "≪̸": "nLtv",
                "≪⃒": "nLt",
                "≫": "gg",
                "≫̸": "nGtv",
                "≫⃒": "nGt",
                "≬": "twixt",
                "≲": "lsim",
                "≴": "nlsim",
                "≳": "gsim",
                "≵": "ngsim",
                "≶": "lg",
                "≸": "ntlg",
                "≷": "gl",
                "≹": "ntgl",
                "≺": "pr",
                "⊀": "npr",
                "≻": "sc",
                "⊁": "nsc",
                "≼": "prcue",
                "⋠": "nprcue",
                "≽": "sccue",
                "⋡": "nsccue",
                "≾": "prsim",
                "≿": "scsim",
                "≿̸": "NotSucceedsTilde",
                "⊂": "sub",
                "⊄": "nsub",
                "⊂⃒": "vnsub",
                "⊃": "sup",
                "⊅": "nsup",
                "⊃⃒": "vnsup",
                "⊆": "sube",
                "⊈": "nsube",
                "⊇": "supe",
                "⊉": "nsupe",
                "⊊︀": "vsubne",
                "⊊": "subne",
                "⊋︀": "vsupne",
                "⊋": "supne",
                "⊍": "cupdot",
                "⊎": "uplus",
                "⊏": "sqsub",
                "⊏̸": "NotSquareSubset",
                "⊐": "sqsup",
                "⊐̸": "NotSquareSuperset",
                "⊑": "sqsube",
                "⋢": "nsqsube",
                "⊒": "sqsupe",
                "⋣": "nsqsupe",
                "⊓": "sqcap",
                "⊓︀": "sqcaps",
                "⊔": "sqcup",
                "⊔︀": "sqcups",
                "⊕": "oplus",
                "⊖": "ominus",
                "⊗": "otimes",
                "⊘": "osol",
                "⊙": "odot",
                "⊚": "ocir",
                "⊛": "oast",
                "⊝": "odash",
                "⊞": "plusb",
                "⊟": "minusb",
                "⊠": "timesb",
                "⊡": "sdotb",
                "⊢": "vdash",
                "⊬": "nvdash",
                "⊣": "dashv",
                "⊤": "top",
                "⊥": "bot",
                "⊧": "models",
                "⊨": "vDash",
                "⊭": "nvDash",
                "⊩": "Vdash",
                "⊮": "nVdash",
                "⊪": "Vvdash",
                "⊫": "VDash",
                "⊯": "nVDash",
                "⊰": "prurel",
                "⊲": "vltri",
                "⋪": "nltri",
                "⊳": "vrtri",
                "⋫": "nrtri",
                "⊴": "ltrie",
                "⋬": "nltrie",
                "⊴⃒": "nvltrie",
                "⊵": "rtrie",
                "⋭": "nrtrie",
                "⊵⃒": "nvrtrie",
                "⊶": "origof",
                "⊷": "imof",
                "⊸": "mumap",
                "⊹": "hercon",
                "⊺": "intcal",
                "⊻": "veebar",
                "⊽": "barvee",
                "⊾": "angrtvb",
                "⊿": "lrtri",
                "⋀": "Wedge",
                "⋁": "Vee",
                "⋂": "xcap",
                "⋃": "xcup",
                "⋄": "diam",
                "⋅": "sdot",
                "⋆": "Star",
                "⋇": "divonx",
                "⋈": "bowtie",
                "⋉": "ltimes",
                "⋊": "rtimes",
                "⋋": "lthree",
                "⋌": "rthree",
                "⋍": "bsime",
                "⋎": "cuvee",
                "⋏": "cuwed",
                "⋐": "Sub",
                "⋑": "Sup",
                "⋒": "Cap",
                "⋓": "Cup",
                "⋔": "fork",
                "⋕": "epar",
                "⋖": "ltdot",
                "⋗": "gtdot",
                "⋘": "Ll",
                "⋘̸": "nLl",
                "⋙": "Gg",
                "⋙̸": "nGg",
                "⋚︀": "lesg",
                "⋚": "leg",
                "⋛": "gel",
                "⋛︀": "gesl",
                "⋞": "cuepr",
                "⋟": "cuesc",
                "⋦": "lnsim",
                "⋧": "gnsim",
                "⋨": "prnsim",
                "⋩": "scnsim",
                "⋮": "vellip",
                "⋯": "ctdot",
                "⋰": "utdot",
                "⋱": "dtdot",
                "⋲": "disin",
                "⋳": "isinsv",
                "⋴": "isins",
                "⋵": "isindot",
                "⋵̸": "notindot",
                "⋶": "notinvc",
                "⋷": "notinvb",
                "⋹": "isinE",
                "⋹̸": "notinE",
                "⋺": "nisd",
                "⋻": "xnis",
                "⋼": "nis",
                "⋽": "notnivc",
                "⋾": "notnivb",
                "⌅": "barwed",
                "⌆": "Barwed",
                "⌌": "drcrop",
                "⌍": "dlcrop",
                "⌎": "urcrop",
                "⌏": "ulcrop",
                "⌐": "bnot",
                "⌒": "profline",
                "⌓": "profsurf",
                "⌕": "telrec",
                "⌖": "target",
                "⌜": "ulcorn",
                "⌝": "urcorn",
                "⌞": "dlcorn",
                "⌟": "drcorn",
                "⌢": "frown",
                "⌣": "smile",
                "⌭": "cylcty",
                "⌮": "profalar",
                "⌶": "topbot",
                "⌽": "ovbar",
                "⌿": "solbar",
                "⍼": "angzarr",
                "⎰": "lmoust",
                "⎱": "rmoust",
                "⎴": "tbrk",
                "⎵": "bbrk",
                "⎶": "bbrktbrk",
                "⏜": "OverParenthesis",
                "⏝": "UnderParenthesis",
                "⏞": "OverBrace",
                "⏟": "UnderBrace",
                "⏢": "trpezium",
                "⏧": "elinters",
                "␣": "blank",
                "─": "boxh",
                "│": "boxv",
                "┌": "boxdr",
                "┐": "boxdl",
                "└": "boxur",
                "┘": "boxul",
                "├": "boxvr",
                "┤": "boxvl",
                "┬": "boxhd",
                "┴": "boxhu",
                "┼": "boxvh",
                "═": "boxH",
                "║": "boxV",
                "╒": "boxdR",
                "╓": "boxDr",
                "╔": "boxDR",
                "╕": "boxdL",
                "╖": "boxDl",
                "╗": "boxDL",
                "╘": "boxuR",
                "╙": "boxUr",
                "╚": "boxUR",
                "╛": "boxuL",
                "╜": "boxUl",
                "╝": "boxUL",
                "╞": "boxvR",
                "╟": "boxVr",
                "╠": "boxVR",
                "╡": "boxvL",
                "╢": "boxVl",
                "╣": "boxVL",
                "╤": "boxHd",
                "╥": "boxhD",
                "╦": "boxHD",
                "╧": "boxHu",
                "╨": "boxhU",
                "╩": "boxHU",
                "╪": "boxvH",
                "╫": "boxVh",
                "╬": "boxVH",
                "▀": "uhblk",
                "▄": "lhblk",
                "█": "block",
                "░": "blk14",
                "▒": "blk12",
                "▓": "blk34",
                "□": "squ",
                "▪": "squf",
                "▫": "EmptyVerySmallSquare",
                "▭": "rect",
                "▮": "marker",
                "▱": "fltns",
                "△": "xutri",
                "▴": "utrif",
                "▵": "utri",
                "▸": "rtrif",
                "▹": "rtri",
                "▽": "xdtri",
                "▾": "dtrif",
                "▿": "dtri",
                "◂": "ltrif",
                "◃": "ltri",
                "◊": "loz",
                "○": "cir",
                "◬": "tridot",
                "◯": "xcirc",
                "◸": "ultri",
                "◹": "urtri",
                "◺": "lltri",
                "◻": "EmptySmallSquare",
                "◼": "FilledSmallSquare",
                "★": "starf",
                "☆": "star",
                "☎": "phone",
                "♀": "female",
                "♂": "male",
                "♠": "spades",
                "♣": "clubs",
                "♥": "hearts",
                "♦": "diams",
                "♪": "sung",
                "✓": "check",
                "✗": "cross",
                "✠": "malt",
                "✶": "sext",
                "❘": "VerticalSeparator",
                "⟈": "bsolhsub",
                "⟉": "suphsol",
                "⟵": "xlarr",
                "⟶": "xrarr",
                "⟷": "xharr",
                "⟸": "xlArr",
                "⟹": "xrArr",
                "⟺": "xhArr",
                "⟼": "xmap",
                "⟿": "dzigrarr",
                "⤂": "nvlArr",
                "⤃": "nvrArr",
                "⤄": "nvHarr",
                "⤅": "Map",
                "⤌": "lbarr",
                "⤍": "rbarr",
                "⤎": "lBarr",
                "⤏": "rBarr",
                "⤐": "RBarr",
                "⤑": "DDotrahd",
                "⤒": "UpArrowBar",
                "⤓": "DownArrowBar",
                "⤖": "Rarrtl",
                "⤙": "latail",
                "⤚": "ratail",
                "⤛": "lAtail",
                "⤜": "rAtail",
                "⤝": "larrfs",
                "⤞": "rarrfs",
                "⤟": "larrbfs",
                "⤠": "rarrbfs",
                "⤣": "nwarhk",
                "⤤": "nearhk",
                "⤥": "searhk",
                "⤦": "swarhk",
                "⤧": "nwnear",
                "⤨": "toea",
                "⤩": "tosa",
                "⤪": "swnwar",
                "⤳": "rarrc",
                "⤳̸": "nrarrc",
                "⤵": "cudarrr",
                "⤶": "ldca",
                "⤷": "rdca",
                "⤸": "cudarrl",
                "⤹": "larrpl",
                "⤼": "curarrm",
                "⤽": "cularrp",
                "⥅": "rarrpl",
                "⥈": "harrcir",
                "⥉": "Uarrocir",
                "⥊": "lurdshar",
                "⥋": "ldrushar",
                "⥎": "LeftRightVector",
                "⥏": "RightUpDownVector",
                "⥐": "DownLeftRightVector",
                "⥑": "LeftUpDownVector",
                "⥒": "LeftVectorBar",
                "⥓": "RightVectorBar",
                "⥔": "RightUpVectorBar",
                "⥕": "RightDownVectorBar",
                "⥖": "DownLeftVectorBar",
                "⥗": "DownRightVectorBar",
                "⥘": "LeftUpVectorBar",
                "⥙": "LeftDownVectorBar",
                "⥚": "LeftTeeVector",
                "⥛": "RightTeeVector",
                "⥜": "RightUpTeeVector",
                "⥝": "RightDownTeeVector",
                "⥞": "DownLeftTeeVector",
                "⥟": "DownRightTeeVector",
                "⥠": "LeftUpTeeVector",
                "⥡": "LeftDownTeeVector",
                "⥢": "lHar",
                "⥣": "uHar",
                "⥤": "rHar",
                "⥥": "dHar",
                "⥦": "luruhar",
                "⥧": "ldrdhar",
                "⥨": "ruluhar",
                "⥩": "rdldhar",
                "⥪": "lharul",
                "⥫": "llhard",
                "⥬": "rharul",
                "⥭": "lrhard",
                "⥮": "udhar",
                "⥯": "duhar",
                "⥰": "RoundImplies",
                "⥱": "erarr",
                "⥲": "simrarr",
                "⥳": "larrsim",
                "⥴": "rarrsim",
                "⥵": "rarrap",
                "⥶": "ltlarr",
                "⥸": "gtrarr",
                "⥹": "subrarr",
                "⥻": "suplarr",
                "⥼": "lfisht",
                "⥽": "rfisht",
                "⥾": "ufisht",
                "⥿": "dfisht",
                "⦚": "vzigzag",
                "⦜": "vangrt",
                "⦝": "angrtvbd",
                "⦤": "ange",
                "⦥": "range",
                "⦦": "dwangle",
                "⦧": "uwangle",
                "⦨": "angmsdaa",
                "⦩": "angmsdab",
                "⦪": "angmsdac",
                "⦫": "angmsdad",
                "⦬": "angmsdae",
                "⦭": "angmsdaf",
                "⦮": "angmsdag",
                "⦯": "angmsdah",
                "⦰": "bemptyv",
                "⦱": "demptyv",
                "⦲": "cemptyv",
                "⦳": "raemptyv",
                "⦴": "laemptyv",
                "⦵": "ohbar",
                "⦶": "omid",
                "⦷": "opar",
                "⦹": "operp",
                "⦻": "olcross",
                "⦼": "odsold",
                "⦾": "olcir",
                "⦿": "ofcir",
                "⧀": "olt",
                "⧁": "ogt",
                "⧂": "cirscir",
                "⧃": "cirE",
                "⧄": "solb",
                "⧅": "bsolb",
                "⧉": "boxbox",
                "⧍": "trisb",
                "⧎": "rtriltri",
                "⧏": "LeftTriangleBar",
                "⧏̸": "NotLeftTriangleBar",
                "⧐": "RightTriangleBar",
                "⧐̸": "NotRightTriangleBar",
                "⧜": "iinfin",
                "⧝": "infintie",
                "⧞": "nvinfin",
                "⧣": "eparsl",
                "⧤": "smeparsl",
                "⧥": "eqvparsl",
                "⧫": "lozf",
                "⧴": "RuleDelayed",
                "⧶": "dsol",
                "⨀": "xodot",
                "⨁": "xoplus",
                "⨂": "xotime",
                "⨄": "xuplus",
                "⨆": "xsqcup",
                "⨍": "fpartint",
                "⨐": "cirfnint",
                "⨑": "awint",
                "⨒": "rppolint",
                "⨓": "scpolint",
                "⨔": "npolint",
                "⨕": "pointint",
                "⨖": "quatint",
                "⨗": "intlarhk",
                "⨢": "pluscir",
                "⨣": "plusacir",
                "⨤": "simplus",
                "⨥": "plusdu",
                "⨦": "plussim",
                "⨧": "plustwo",
                "⨩": "mcomma",
                "⨪": "minusdu",
                "⨭": "loplus",
                "⨮": "roplus",
                "⨯": "Cross",
                "⨰": "timesd",
                "⨱": "timesbar",
                "⨳": "smashp",
                "⨴": "lotimes",
                "⨵": "rotimes",
                "⨶": "otimesas",
                "⨷": "Otimes",
                "⨸": "odiv",
                "⨹": "triplus",
                "⨺": "triminus",
                "⨻": "tritime",
                "⨼": "iprod",
                "⨿": "amalg",
                "⩀": "capdot",
                "⩂": "ncup",
                "⩃": "ncap",
                "⩄": "capand",
                "⩅": "cupor",
                "⩆": "cupcap",
                "⩇": "capcup",
                "⩈": "cupbrcap",
                "⩉": "capbrcup",
                "⩊": "cupcup",
                "⩋": "capcap",
                "⩌": "ccups",
                "⩍": "ccaps",
                "⩐": "ccupssm",
                "⩓": "And",
                "⩔": "Or",
                "⩕": "andand",
                "⩖": "oror",
                "⩗": "orslope",
                "⩘": "andslope",
                "⩚": "andv",
                "⩛": "orv",
                "⩜": "andd",
                "⩝": "ord",
                "⩟": "wedbar",
                "⩦": "sdote",
                "⩪": "simdot",
                "⩭": "congdot",
                "⩭̸": "ncongdot",
                "⩮": "easter",
                "⩯": "apacir",
                "⩰": "apE",
                "⩰̸": "napE",
                "⩱": "eplus",
                "⩲": "pluse",
                "⩳": "Esim",
                "⩷": "eDDot",
                "⩸": "equivDD",
                "⩹": "ltcir",
                "⩺": "gtcir",
                "⩻": "ltquest",
                "⩼": "gtquest",
                "⩽": "les",
                "⩽̸": "nles",
                "⩾": "ges",
                "⩾̸": "nges",
                "⩿": "lesdot",
                "⪀": "gesdot",
                "⪁": "lesdoto",
                "⪂": "gesdoto",
                "⪃": "lesdotor",
                "⪄": "gesdotol",
                "⪅": "lap",
                "⪆": "gap",
                "⪇": "lne",
                "⪈": "gne",
                "⪉": "lnap",
                "⪊": "gnap",
                "⪋": "lEg",
                "⪌": "gEl",
                "⪍": "lsime",
                "⪎": "gsime",
                "⪏": "lsimg",
                "⪐": "gsiml",
                "⪑": "lgE",
                "⪒": "glE",
                "⪓": "lesges",
                "⪔": "gesles",
                "⪕": "els",
                "⪖": "egs",
                "⪗": "elsdot",
                "⪘": "egsdot",
                "⪙": "el",
                "⪚": "eg",
                "⪝": "siml",
                "⪞": "simg",
                "⪟": "simlE",
                "⪠": "simgE",
                "⪡": "LessLess",
                "⪡̸": "NotNestedLessLess",
                "⪢": "GreaterGreater",
                "⪢̸": "NotNestedGreaterGreater",
                "⪤": "glj",
                "⪥": "gla",
                "⪦": "ltcc",
                "⪧": "gtcc",
                "⪨": "lescc",
                "⪩": "gescc",
                "⪪": "smt",
                "⪫": "lat",
                "⪬": "smte",
                "⪬︀": "smtes",
                "⪭": "late",
                "⪭︀": "lates",
                "⪮": "bumpE",
                "⪯": "pre",
                "⪯̸": "npre",
                "⪰": "sce",
                "⪰̸": "nsce",
                "⪳": "prE",
                "⪴": "scE",
                "⪵": "prnE",
                "⪶": "scnE",
                "⪷": "prap",
                "⪸": "scap",
                "⪹": "prnap",
                "⪺": "scnap",
                "⪻": "Pr",
                "⪼": "Sc",
                "⪽": "subdot",
                "⪾": "supdot",
                "⪿": "subplus",
                "⫀": "supplus",
                "⫁": "submult",
                "⫂": "supmult",
                "⫃": "subedot",
                "⫄": "supedot",
                "⫅": "subE",
                "⫅̸": "nsubE",
                "⫆": "supE",
                "⫆̸": "nsupE",
                "⫇": "subsim",
                "⫈": "supsim",
                "⫋︀": "vsubnE",
                "⫋": "subnE",
                "⫌︀": "vsupnE",
                "⫌": "supnE",
                "⫏": "csub",
                "⫐": "csup",
                "⫑": "csube",
                "⫒": "csupe",
                "⫓": "subsup",
                "⫔": "supsub",
                "⫕": "subsub",
                "⫖": "supsup",
                "⫗": "suphsub",
                "⫘": "supdsub",
                "⫙": "forkv",
                "⫚": "topfork",
                "⫛": "mlcp",
                "⫤": "Dashv",
                "⫦": "Vdashl",
                "⫧": "Barv",
                "⫨": "vBar",
                "⫩": "vBarv",
                "⫫": "Vbar",
                "⫬": "Not",
                "⫭": "bNot",
                "⫮": "rnmid",
                "⫯": "cirmid",
                "⫰": "midcir",
                "⫱": "topcir",
                "⫲": "nhpar",
                "⫳": "parsim",
                "⫽": "parsl",
                "⫽⃥": "nparsl",
                "♭": "flat",
                "♮": "natur",
                "♯": "sharp",
                "¤": "curren",
                "¢": "cent",
                $: "dollar",
                "£": "pound",
                "¥": "yen",
                "€": "euro",
                "¹": "sup1",
                "½": "half",
                "⅓": "frac13",
                "¼": "frac14",
                "⅕": "frac15",
                "⅙": "frac16",
                "⅛": "frac18",
                "²": "sup2",
                "⅔": "frac23",
                "⅖": "frac25",
                "³": "sup3",
                "¾": "frac34",
                "⅗": "frac35",
                "⅜": "frac38",
                "⅘": "frac45",
                "⅚": "frac56",
                "⅝": "frac58",
                "⅞": "frac78",
                "𝒶": "ascr",
                "𝕒": "aopf",
                "𝔞": "afr",
                "𝔸": "Aopf",
                "𝔄": "Afr",
                "𝒜": "Ascr",
                ª: "ordf",
                á: "aacute",
                Á: "Aacute",
                à: "agrave",
                À: "Agrave",
                ă: "abreve",
                Ă: "Abreve",
                â: "acirc",
                Â: "Acirc",
                å: "aring",
                Å: "angst",
                ä: "auml",
                Ä: "Auml",
                ã: "atilde",
                Ã: "Atilde",
                ą: "aogon",
                Ą: "Aogon",
                ā: "amacr",
                Ā: "Amacr",
                æ: "aelig",
                Æ: "AElig",
                "𝒷": "bscr",
                "𝕓": "bopf",
                "𝔟": "bfr",
                "𝔹": "Bopf",
                ℬ: "Bscr",
                "𝔅": "Bfr",
                "𝔠": "cfr",
                "𝒸": "cscr",
                "𝕔": "copf",
                ℭ: "Cfr",
                "𝒞": "Cscr",
                ℂ: "Copf",
                ć: "cacute",
                Ć: "Cacute",
                ĉ: "ccirc",
                Ĉ: "Ccirc",
                č: "ccaron",
                Č: "Ccaron",
                ċ: "cdot",
                Ċ: "Cdot",
                ç: "ccedil",
                Ç: "Ccedil",
                "℅": "incare",
                "𝔡": "dfr",
                "ⅆ": "dd",
                "𝕕": "dopf",
                "𝒹": "dscr",
                "𝒟": "Dscr",
                "𝔇": "Dfr",
                "ⅅ": "DD",
                "𝔻": "Dopf",
                ď: "dcaron",
                Ď: "Dcaron",
                đ: "dstrok",
                Đ: "Dstrok",
                ð: "eth",
                Ð: "ETH",
                "ⅇ": "ee",
                ℯ: "escr",
                "𝔢": "efr",
                "𝕖": "eopf",
                ℰ: "Escr",
                "𝔈": "Efr",
                "𝔼": "Eopf",
                é: "eacute",
                É: "Eacute",
                è: "egrave",
                È: "Egrave",
                ê: "ecirc",
                Ê: "Ecirc",
                ě: "ecaron",
                Ě: "Ecaron",
                ë: "euml",
                Ë: "Euml",
                ė: "edot",
                Ė: "Edot",
                ę: "eogon",
                Ę: "Eogon",
                ē: "emacr",
                Ē: "Emacr",
                "𝔣": "ffr",
                "𝕗": "fopf",
                "𝒻": "fscr",
                "𝔉": "Ffr",
                "𝔽": "Fopf",
                ℱ: "Fscr",
                ﬀ: "fflig",
                ﬃ: "ffilig",
                ﬄ: "ffllig",
                ﬁ: "filig",
                fj: "fjlig",
                ﬂ: "fllig",
                ƒ: "fnof",
                ℊ: "gscr",
                "𝕘": "gopf",
                "𝔤": "gfr",
                "𝒢": "Gscr",
                "𝔾": "Gopf",
                "𝔊": "Gfr",
                ǵ: "gacute",
                ğ: "gbreve",
                Ğ: "Gbreve",
                ĝ: "gcirc",
                Ĝ: "Gcirc",
                ġ: "gdot",
                Ġ: "Gdot",
                Ģ: "Gcedil",
                "𝔥": "hfr",
                ℎ: "planckh",
                "𝒽": "hscr",
                "𝕙": "hopf",
                ℋ: "Hscr",
                ℌ: "Hfr",
                ℍ: "Hopf",
                ĥ: "hcirc",
                Ĥ: "Hcirc",
                ℏ: "hbar",
                ħ: "hstrok",
                Ħ: "Hstrok",
                "𝕚": "iopf",
                "𝔦": "ifr",
                "𝒾": "iscr",
                "ⅈ": "ii",
                "𝕀": "Iopf",
                ℐ: "Iscr",
                ℑ: "Im",
                í: "iacute",
                Í: "Iacute",
                ì: "igrave",
                Ì: "Igrave",
                î: "icirc",
                Î: "Icirc",
                ï: "iuml",
                Ï: "Iuml",
                ĩ: "itilde",
                Ĩ: "Itilde",
                İ: "Idot",
                į: "iogon",
                Į: "Iogon",
                ī: "imacr",
                Ī: "Imacr",
                ĳ: "ijlig",
                Ĳ: "IJlig",
                ı: "imath",
                "𝒿": "jscr",
                "𝕛": "jopf",
                "𝔧": "jfr",
                "𝒥": "Jscr",
                "𝔍": "Jfr",
                "𝕁": "Jopf",
                ĵ: "jcirc",
                Ĵ: "Jcirc",
                "ȷ": "jmath",
                "𝕜": "kopf",
                "𝓀": "kscr",
                "𝔨": "kfr",
                "𝒦": "Kscr",
                "𝕂": "Kopf",
                "𝔎": "Kfr",
                ķ: "kcedil",
                Ķ: "Kcedil",
                "𝔩": "lfr",
                "𝓁": "lscr",
                ℓ: "ell",
                "𝕝": "lopf",
                ℒ: "Lscr",
                "𝔏": "Lfr",
                "𝕃": "Lopf",
                ĺ: "lacute",
                Ĺ: "Lacute",
                ľ: "lcaron",
                Ľ: "Lcaron",
                ļ: "lcedil",
                Ļ: "Lcedil",
                ł: "lstrok",
                Ł: "Lstrok",
                ŀ: "lmidot",
                Ŀ: "Lmidot",
                "𝔪": "mfr",
                "𝕞": "mopf",
                "𝓂": "mscr",
                "𝔐": "Mfr",
                "𝕄": "Mopf",
                ℳ: "Mscr",
                "𝔫": "nfr",
                "𝕟": "nopf",
                "𝓃": "nscr",
                ℕ: "Nopf",
                "𝒩": "Nscr",
                "𝔑": "Nfr",
                ń: "nacute",
                Ń: "Nacute",
                ň: "ncaron",
                Ň: "Ncaron",
                ñ: "ntilde",
                Ñ: "Ntilde",
                ņ: "ncedil",
                Ņ: "Ncedil",
                "№": "numero",
                ŋ: "eng",
                Ŋ: "ENG",
                "𝕠": "oopf",
                "𝔬": "ofr",
                ℴ: "oscr",
                "𝒪": "Oscr",
                "𝔒": "Ofr",
                "𝕆": "Oopf",
                º: "ordm",
                ó: "oacute",
                Ó: "Oacute",
                ò: "ograve",
                Ò: "Ograve",
                ô: "ocirc",
                Ô: "Ocirc",
                ö: "ouml",
                Ö: "Ouml",
                ő: "odblac",
                Ő: "Odblac",
                õ: "otilde",
                Õ: "Otilde",
                ø: "oslash",
                Ø: "Oslash",
                ō: "omacr",
                Ō: "Omacr",
                œ: "oelig",
                Œ: "OElig",
                "𝔭": "pfr",
                "𝓅": "pscr",
                "𝕡": "popf",
                ℙ: "Popf",
                "𝔓": "Pfr",
                "𝒫": "Pscr",
                "𝕢": "qopf",
                "𝔮": "qfr",
                "𝓆": "qscr",
                "𝒬": "Qscr",
                "𝔔": "Qfr",
                ℚ: "Qopf",
                ĸ: "kgreen",
                "𝔯": "rfr",
                "𝕣": "ropf",
                "𝓇": "rscr",
                ℛ: "Rscr",
                ℜ: "Re",
                ℝ: "Ropf",
                ŕ: "racute",
                Ŕ: "Racute",
                ř: "rcaron",
                Ř: "Rcaron",
                ŗ: "rcedil",
                Ŗ: "Rcedil",
                "𝕤": "sopf",
                "𝓈": "sscr",
                "𝔰": "sfr",
                "𝕊": "Sopf",
                "𝔖": "Sfr",
                "𝒮": "Sscr",
                "Ⓢ": "oS",
                ś: "sacute",
                Ś: "Sacute",
                ŝ: "scirc",
                Ŝ: "Scirc",
                š: "scaron",
                Š: "Scaron",
                ş: "scedil",
                Ş: "Scedil",
                ß: "szlig",
                "𝔱": "tfr",
                "𝓉": "tscr",
                "𝕥": "topf",
                "𝒯": "Tscr",
                "𝔗": "Tfr",
                "𝕋": "Topf",
                ť: "tcaron",
                Ť: "Tcaron",
                ţ: "tcedil",
                Ţ: "Tcedil",
                "™": "trade",
                ŧ: "tstrok",
                Ŧ: "Tstrok",
                "𝓊": "uscr",
                "𝕦": "uopf",
                "𝔲": "ufr",
                "𝕌": "Uopf",
                "𝔘": "Ufr",
                "𝒰": "Uscr",
                ú: "uacute",
                Ú: "Uacute",
                ù: "ugrave",
                Ù: "Ugrave",
                ŭ: "ubreve",
                Ŭ: "Ubreve",
                û: "ucirc",
                Û: "Ucirc",
                ů: "uring",
                Ů: "Uring",
                ü: "uuml",
                Ü: "Uuml",
                ű: "udblac",
                Ű: "Udblac",
                ũ: "utilde",
                Ũ: "Utilde",
                ų: "uogon",
                Ų: "Uogon",
                ū: "umacr",
                Ū: "Umacr",
                "𝔳": "vfr",
                "𝕧": "vopf",
                "𝓋": "vscr",
                "𝔙": "Vfr",
                "𝕍": "Vopf",
                "𝒱": "Vscr",
                "𝕨": "wopf",
                "𝓌": "wscr",
                "𝔴": "wfr",
                "𝒲": "Wscr",
                "𝕎": "Wopf",
                "𝔚": "Wfr",
                ŵ: "wcirc",
                Ŵ: "Wcirc",
                "𝔵": "xfr",
                "𝓍": "xscr",
                "𝕩": "xopf",
                "𝕏": "Xopf",
                "𝔛": "Xfr",
                "𝒳": "Xscr",
                "𝔶": "yfr",
                "𝓎": "yscr",
                "𝕪": "yopf",
                "𝒴": "Yscr",
                "𝔜": "Yfr",
                "𝕐": "Yopf",
                ý: "yacute",
                Ý: "Yacute",
                ŷ: "ycirc",
                Ŷ: "Ycirc",
                ÿ: "yuml",
                Ÿ: "Yuml",
                "𝓏": "zscr",
                "𝔷": "zfr",
                "𝕫": "zopf",
                ℨ: "Zfr",
                ℤ: "Zopf",
                "𝒵": "Zscr",
                ź: "zacute",
                Ź: "Zacute",
                ž: "zcaron",
                Ž: "Zcaron",
                ż: "zdot",
                Ż: "Zdot",
                Ƶ: "imped",
                þ: "thorn",
                Þ: "THORN",
                ŉ: "napos",
                α: "alpha",
                Α: "Alpha",
                β: "beta",
                Β: "Beta",
                γ: "gamma",
                Γ: "Gamma",
                δ: "delta",
                Δ: "Delta",
                ε: "epsi",
                "ϵ": "epsiv",
                Ε: "Epsilon",
                ϝ: "gammad",
                Ϝ: "Gammad",
                ζ: "zeta",
                Ζ: "Zeta",
                η: "eta",
                Η: "Eta",
                θ: "theta",
                ϑ: "thetav",
                Θ: "Theta",
                ι: "iota",
                Ι: "Iota",
                κ: "kappa",
                ϰ: "kappav",
                Κ: "Kappa",
                λ: "lambda",
                Λ: "Lambda",
                μ: "mu",
                µ: "micro",
                Μ: "Mu",
                ν: "nu",
                Ν: "Nu",
                ξ: "xi",
                Ξ: "Xi",
                ο: "omicron",
                Ο: "Omicron",
                π: "pi",
                ϖ: "piv",
                Π: "Pi",
                ρ: "rho",
                ϱ: "rhov",
                Ρ: "Rho",
                σ: "sigma",
                Σ: "Sigma",
                ς: "sigmaf",
                τ: "tau",
                Τ: "Tau",
                υ: "upsi",
                Υ: "Upsilon",
                ϒ: "Upsi",
                φ: "phi",
                ϕ: "phiv",
                Φ: "Phi",
                χ: "chi",
                Χ: "Chi",
                ψ: "psi",
                Ψ: "Psi",
                ω: "omega",
                Ω: "ohm",
                а: "acy",
                А: "Acy",
                б: "bcy",
                Б: "Bcy",
                в: "vcy",
                В: "Vcy",
                г: "gcy",
                Г: "Gcy",
                ѓ: "gjcy",
                Ѓ: "GJcy",
                д: "dcy",
                Д: "Dcy",
                ђ: "djcy",
                Ђ: "DJcy",
                е: "iecy",
                Е: "IEcy",
                ё: "iocy",
                Ё: "IOcy",
                є: "jukcy",
                Є: "Jukcy",
                ж: "zhcy",
                Ж: "ZHcy",
                з: "zcy",
                З: "Zcy",
                ѕ: "dscy",
                Ѕ: "DScy",
                и: "icy",
                И: "Icy",
                і: "iukcy",
                І: "Iukcy",
                ї: "yicy",
                Ї: "YIcy",
                й: "jcy",
                Й: "Jcy",
                ј: "jsercy",
                Ј: "Jsercy",
                к: "kcy",
                К: "Kcy",
                ќ: "kjcy",
                Ќ: "KJcy",
                л: "lcy",
                Л: "Lcy",
                љ: "ljcy",
                Љ: "LJcy",
                м: "mcy",
                М: "Mcy",
                н: "ncy",
                Н: "Ncy",
                њ: "njcy",
                Њ: "NJcy",
                о: "ocy",
                О: "Ocy",
                п: "pcy",
                П: "Pcy",
                р: "rcy",
                Р: "Rcy",
                с: "scy",
                С: "Scy",
                т: "tcy",
                Т: "Tcy",
                ћ: "tshcy",
                Ћ: "TSHcy",
                у: "ucy",
                У: "Ucy",
                ў: "ubrcy",
                Ў: "Ubrcy",
                ф: "fcy",
                Ф: "Fcy",
                х: "khcy",
                Х: "KHcy",
                ц: "tscy",
                Ц: "TScy",
                ч: "chcy",
                Ч: "CHcy",
                џ: "dzcy",
                Џ: "DZcy",
                ш: "shcy",
                Ш: "SHcy",
                щ: "shchcy",
                Щ: "SHCHcy",
                ъ: "hardcy",
                Ъ: "HARDcy",
                ы: "ycy",
                Ы: "Ycy",
                ь: "softcy",
                Ь: "SOFTcy",
                э: "ecy",
                Э: "Ecy",
                ю: "yucy",
                Ю: "YUcy",
                я: "yacy",
                Я: "YAcy",
                ℵ: "aleph",
                ℶ: "beth",
                ℷ: "gimel",
                ℸ: "daleth"
            }, T = /["&'<>`]/g,
            D = {'"': "&quot;", "&": "&amp;", "'": "&#x27;", "<": "&lt;", ">": "&gt;", "`": "&#x60;"},
            B = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/,
            L = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
            z = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g,
            q = {
                aacute: "á",
                Aacute: "Á",
                abreve: "ă",
                Abreve: "Ă",
                ac: "∾",
                acd: "∿",
                acE: "∾̳",
                acirc: "â",
                Acirc: "Â",
                acute: "´",
                acy: "а",
                Acy: "А",
                aelig: "æ",
                AElig: "Æ",
                af: "⁡",
                afr: "𝔞",
                Afr: "𝔄",
                agrave: "à",
                Agrave: "À",
                alefsym: "ℵ",
                aleph: "ℵ",
                alpha: "α",
                Alpha: "Α",
                amacr: "ā",
                Amacr: "Ā",
                amalg: "⨿",
                amp: "&",
                AMP: "&",
                and: "∧",
                And: "⩓",
                andand: "⩕",
                andd: "⩜",
                andslope: "⩘",
                andv: "⩚",
                ang: "∠",
                ange: "⦤",
                angle: "∠",
                angmsd: "∡",
                angmsdaa: "⦨",
                angmsdab: "⦩",
                angmsdac: "⦪",
                angmsdad: "⦫",
                angmsdae: "⦬",
                angmsdaf: "⦭",
                angmsdag: "⦮",
                angmsdah: "⦯",
                angrt: "∟",
                angrtvb: "⊾",
                angrtvbd: "⦝",
                angsph: "∢",
                angst: "Å",
                angzarr: "⍼",
                aogon: "ą",
                Aogon: "Ą",
                aopf: "𝕒",
                Aopf: "𝔸",
                ap: "≈",
                apacir: "⩯",
                ape: "≊",
                apE: "⩰",
                apid: "≋",
                apos: "'",
                ApplyFunction: "⁡",
                approx: "≈",
                approxeq: "≊",
                aring: "å",
                Aring: "Å",
                ascr: "𝒶",
                Ascr: "𝒜",
                Assign: "≔",
                ast: "*",
                asymp: "≈",
                asympeq: "≍",
                atilde: "ã",
                Atilde: "Ã",
                auml: "ä",
                Auml: "Ä",
                awconint: "∳",
                awint: "⨑",
                backcong: "≌",
                backepsilon: "϶",
                backprime: "‵",
                backsim: "∽",
                backsimeq: "⋍",
                Backslash: "∖",
                Barv: "⫧",
                barvee: "⊽",
                barwed: "⌅",
                Barwed: "⌆",
                barwedge: "⌅",
                bbrk: "⎵",
                bbrktbrk: "⎶",
                bcong: "≌",
                bcy: "б",
                Bcy: "Б",
                bdquo: "„",
                becaus: "∵",
                because: "∵",
                Because: "∵",
                bemptyv: "⦰",
                bepsi: "϶",
                bernou: "ℬ",
                Bernoullis: "ℬ",
                beta: "β",
                Beta: "Β",
                beth: "ℶ",
                between: "≬",
                bfr: "𝔟",
                Bfr: "𝔅",
                bigcap: "⋂",
                bigcirc: "◯",
                bigcup: "⋃",
                bigodot: "⨀",
                bigoplus: "⨁",
                bigotimes: "⨂",
                bigsqcup: "⨆",
                bigstar: "★",
                bigtriangledown: "▽",
                bigtriangleup: "△",
                biguplus: "⨄",
                bigvee: "⋁",
                bigwedge: "⋀",
                bkarow: "⤍",
                blacklozenge: "⧫",
                blacksquare: "▪",
                blacktriangle: "▴",
                blacktriangledown: "▾",
                blacktriangleleft: "◂",
                blacktriangleright: "▸",
                blank: "␣",
                blk12: "▒",
                blk14: "░",
                blk34: "▓",
                block: "█",
                bne: "=⃥",
                bnequiv: "≡⃥",
                bnot: "⌐",
                bNot: "⫭",
                bopf: "𝕓",
                Bopf: "𝔹",
                bot: "⊥",
                bottom: "⊥",
                bowtie: "⋈",
                boxbox: "⧉",
                boxdl: "┐",
                boxdL: "╕",
                boxDl: "╖",
                boxDL: "╗",
                boxdr: "┌",
                boxdR: "╒",
                boxDr: "╓",
                boxDR: "╔",
                boxh: "─",
                boxH: "═",
                boxhd: "┬",
                boxhD: "╥",
                boxHd: "╤",
                boxHD: "╦",
                boxhu: "┴",
                boxhU: "╨",
                boxHu: "╧",
                boxHU: "╩",
                boxminus: "⊟",
                boxplus: "⊞",
                boxtimes: "⊠",
                boxul: "┘",
                boxuL: "╛",
                boxUl: "╜",
                boxUL: "╝",
                boxur: "└",
                boxuR: "╘",
                boxUr: "╙",
                boxUR: "╚",
                boxv: "│",
                boxV: "║",
                boxvh: "┼",
                boxvH: "╪",
                boxVh: "╫",
                boxVH: "╬",
                boxvl: "┤",
                boxvL: "╡",
                boxVl: "╢",
                boxVL: "╣",
                boxvr: "├",
                boxvR: "╞",
                boxVr: "╟",
                boxVR: "╠",
                bprime: "‵",
                breve: "˘",
                Breve: "˘",
                brvbar: "¦",
                bscr: "𝒷",
                Bscr: "ℬ",
                bsemi: "⁏",
                bsim: "∽",
                bsime: "⋍",
                bsol: "\\",
                bsolb: "⧅",
                bsolhsub: "⟈",
                bull: "•",
                bullet: "•",
                bump: "≎",
                bumpe: "≏",
                bumpE: "⪮",
                bumpeq: "≏",
                Bumpeq: "≎",
                cacute: "ć",
                Cacute: "Ć",
                cap: "∩",
                Cap: "⋒",
                capand: "⩄",
                capbrcup: "⩉",
                capcap: "⩋",
                capcup: "⩇",
                capdot: "⩀",
                CapitalDifferentialD: "ⅅ",
                caps: "∩︀",
                caret: "⁁",
                caron: "ˇ",
                Cayleys: "ℭ",
                ccaps: "⩍",
                ccaron: "č",
                Ccaron: "Č",
                ccedil: "ç",
                Ccedil: "Ç",
                ccirc: "ĉ",
                Ccirc: "Ĉ",
                Cconint: "∰",
                ccups: "⩌",
                ccupssm: "⩐",
                cdot: "ċ",
                Cdot: "Ċ",
                cedil: "¸",
                Cedilla: "¸",
                cemptyv: "⦲",
                cent: "¢",
                centerdot: "·",
                CenterDot: "·",
                cfr: "𝔠",
                Cfr: "ℭ",
                chcy: "ч",
                CHcy: "Ч",
                check: "✓",
                checkmark: "✓",
                chi: "χ",
                Chi: "Χ",
                cir: "○",
                circ: "ˆ",
                circeq: "≗",
                circlearrowleft: "↺",
                circlearrowright: "↻",
                circledast: "⊛",
                circledcirc: "⊚",
                circleddash: "⊝",
                CircleDot: "⊙",
                circledR: "®",
                circledS: "Ⓢ",
                CircleMinus: "⊖",
                CirclePlus: "⊕",
                CircleTimes: "⊗",
                cire: "≗",
                cirE: "⧃",
                cirfnint: "⨐",
                cirmid: "⫯",
                cirscir: "⧂",
                ClockwiseContourIntegral: "∲",
                CloseCurlyDoubleQuote: "”",
                CloseCurlyQuote: "’",
                clubs: "♣",
                clubsuit: "♣",
                colon: ":",
                Colon: "∷",
                colone: "≔",
                Colone: "⩴",
                coloneq: "≔",
                comma: ",",
                commat: "@",
                comp: "∁",
                compfn: "∘",
                complement: "∁",
                complexes: "ℂ",
                cong: "≅",
                congdot: "⩭",
                Congruent: "≡",
                conint: "∮",
                Conint: "∯",
                ContourIntegral: "∮",
                copf: "𝕔",
                Copf: "ℂ",
                coprod: "∐",
                Coproduct: "∐",
                copy: "©",
                COPY: "©",
                copysr: "℗",
                CounterClockwiseContourIntegral: "∳",
                crarr: "↵",
                cross: "✗",
                Cross: "⨯",
                cscr: "𝒸",
                Cscr: "𝒞",
                csub: "⫏",
                csube: "⫑",
                csup: "⫐",
                csupe: "⫒",
                ctdot: "⋯",
                cudarrl: "⤸",
                cudarrr: "⤵",
                cuepr: "⋞",
                cuesc: "⋟",
                cularr: "↶",
                cularrp: "⤽",
                cup: "∪",
                Cup: "⋓",
                cupbrcap: "⩈",
                cupcap: "⩆",
                CupCap: "≍",
                cupcup: "⩊",
                cupdot: "⊍",
                cupor: "⩅",
                cups: "∪︀",
                curarr: "↷",
                curarrm: "⤼",
                curlyeqprec: "⋞",
                curlyeqsucc: "⋟",
                curlyvee: "⋎",
                curlywedge: "⋏",
                curren: "¤",
                curvearrowleft: "↶",
                curvearrowright: "↷",
                cuvee: "⋎",
                cuwed: "⋏",
                cwconint: "∲",
                cwint: "∱",
                cylcty: "⌭",
                dagger: "†",
                Dagger: "‡",
                daleth: "ℸ",
                darr: "↓",
                dArr: "⇓",
                Darr: "↡",
                dash: "‐",
                dashv: "⊣",
                Dashv: "⫤",
                dbkarow: "⤏",
                dblac: "˝",
                dcaron: "ď",
                Dcaron: "Ď",
                dcy: "д",
                Dcy: "Д",
                dd: "ⅆ",
                DD: "ⅅ",
                ddagger: "‡",
                ddarr: "⇊",
                DDotrahd: "⤑",
                ddotseq: "⩷",
                deg: "°",
                Del: "∇",
                delta: "δ",
                Delta: "Δ",
                demptyv: "⦱",
                dfisht: "⥿",
                dfr: "𝔡",
                Dfr: "𝔇",
                dHar: "⥥",
                dharl: "⇃",
                dharr: "⇂",
                DiacriticalAcute: "´",
                DiacriticalDot: "˙",
                DiacriticalDoubleAcute: "˝",
                DiacriticalGrave: "`",
                DiacriticalTilde: "˜",
                diam: "⋄",
                diamond: "⋄",
                Diamond: "⋄",
                diamondsuit: "♦",
                diams: "♦",
                die: "¨",
                DifferentialD: "ⅆ",
                digamma: "ϝ",
                disin: "⋲",
                div: "÷",
                divide: "÷",
                divideontimes: "⋇",
                divonx: "⋇",
                djcy: "ђ",
                DJcy: "Ђ",
                dlcorn: "⌞",
                dlcrop: "⌍",
                dollar: "$",
                dopf: "𝕕",
                Dopf: "𝔻",
                dot: "˙",
                Dot: "¨",
                DotDot: "⃜",
                doteq: "≐",
                doteqdot: "≑",
                DotEqual: "≐",
                dotminus: "∸",
                dotplus: "∔",
                dotsquare: "⊡",
                doublebarwedge: "⌆",
                DoubleContourIntegral: "∯",
                DoubleDot: "¨",
                DoubleDownArrow: "⇓",
                DoubleLeftArrow: "⇐",
                DoubleLeftRightArrow: "⇔",
                DoubleLeftTee: "⫤",
                DoubleLongLeftArrow: "⟸",
                DoubleLongLeftRightArrow: "⟺",
                DoubleLongRightArrow: "⟹",
                DoubleRightArrow: "⇒",
                DoubleRightTee: "⊨",
                DoubleUpArrow: "⇑",
                DoubleUpDownArrow: "⇕",
                DoubleVerticalBar: "∥",
                downarrow: "↓",
                Downarrow: "⇓",
                DownArrow: "↓",
                DownArrowBar: "⤓",
                DownArrowUpArrow: "⇵",
                DownBreve: "̑",
                downdownarrows: "⇊",
                downharpoonleft: "⇃",
                downharpoonright: "⇂",
                DownLeftRightVector: "⥐",
                DownLeftTeeVector: "⥞",
                DownLeftVector: "↽",
                DownLeftVectorBar: "⥖",
                DownRightTeeVector: "⥟",
                DownRightVector: "⇁",
                DownRightVectorBar: "⥗",
                DownTee: "⊤",
                DownTeeArrow: "↧",
                drbkarow: "⤐",
                drcorn: "⌟",
                drcrop: "⌌",
                dscr: "𝒹",
                Dscr: "𝒟",
                dscy: "ѕ",
                DScy: "Ѕ",
                dsol: "⧶",
                dstrok: "đ",
                Dstrok: "Đ",
                dtdot: "⋱",
                dtri: "▿",
                dtrif: "▾",
                duarr: "⇵",
                duhar: "⥯",
                dwangle: "⦦",
                dzcy: "џ",
                DZcy: "Џ",
                dzigrarr: "⟿",
                eacute: "é",
                Eacute: "É",
                easter: "⩮",
                ecaron: "ě",
                Ecaron: "Ě",
                ecir: "≖",
                ecirc: "ê",
                Ecirc: "Ê",
                ecolon: "≕",
                ecy: "э",
                Ecy: "Э",
                eDDot: "⩷",
                edot: "ė",
                eDot: "≑",
                Edot: "Ė",
                ee: "ⅇ",
                efDot: "≒",
                efr: "𝔢",
                Efr: "𝔈",
                eg: "⪚",
                egrave: "è",
                Egrave: "È",
                egs: "⪖",
                egsdot: "⪘",
                el: "⪙",
                Element: "∈",
                elinters: "⏧",
                ell: "ℓ",
                els: "⪕",
                elsdot: "⪗",
                emacr: "ē",
                Emacr: "Ē",
                empty: "∅",
                emptyset: "∅",
                EmptySmallSquare: "◻",
                emptyv: "∅",
                EmptyVerySmallSquare: "▫",
                emsp: " ",
                emsp13: " ",
                emsp14: " ",
                eng: "ŋ",
                ENG: "Ŋ",
                ensp: " ",
                eogon: "ę",
                Eogon: "Ę",
                eopf: "𝕖",
                Eopf: "𝔼",
                epar: "⋕",
                eparsl: "⧣",
                eplus: "⩱",
                epsi: "ε",
                epsilon: "ε",
                Epsilon: "Ε",
                epsiv: "ϵ",
                eqcirc: "≖",
                eqcolon: "≕",
                eqsim: "≂",
                eqslantgtr: "⪖",
                eqslantless: "⪕",
                Equal: "⩵",
                equals: "=",
                EqualTilde: "≂",
                equest: "≟",
                Equilibrium: "⇌",
                equiv: "≡",
                equivDD: "⩸",
                eqvparsl: "⧥",
                erarr: "⥱",
                erDot: "≓",
                escr: "ℯ",
                Escr: "ℰ",
                esdot: "≐",
                esim: "≂",
                Esim: "⩳",
                eta: "η",
                Eta: "Η",
                eth: "ð",
                ETH: "Ð",
                euml: "ë",
                Euml: "Ë",
                euro: "€",
                excl: "!",
                exist: "∃",
                Exists: "∃",
                expectation: "ℰ",
                exponentiale: "ⅇ",
                ExponentialE: "ⅇ",
                fallingdotseq: "≒",
                fcy: "ф",
                Fcy: "Ф",
                female: "♀",
                ffilig: "ﬃ",
                fflig: "ﬀ",
                ffllig: "ﬄ",
                ffr: "𝔣",
                Ffr: "𝔉",
                filig: "ﬁ",
                FilledSmallSquare: "◼",
                FilledVerySmallSquare: "▪",
                fjlig: "fj",
                flat: "♭",
                fllig: "ﬂ",
                fltns: "▱",
                fnof: "ƒ",
                fopf: "𝕗",
                Fopf: "𝔽",
                forall: "∀",
                ForAll: "∀",
                fork: "⋔",
                forkv: "⫙",
                Fouriertrf: "ℱ",
                fpartint: "⨍",
                frac12: "½",
                frac13: "⅓",
                frac14: "¼",
                frac15: "⅕",
                frac16: "⅙",
                frac18: "⅛",
                frac23: "⅔",
                frac25: "⅖",
                frac34: "¾",
                frac35: "⅗",
                frac38: "⅜",
                frac45: "⅘",
                frac56: "⅚",
                frac58: "⅝",
                frac78: "⅞",
                frasl: "⁄",
                frown: "⌢",
                fscr: "𝒻",
                Fscr: "ℱ",
                gacute: "ǵ",
                gamma: "γ",
                Gamma: "Γ",
                gammad: "ϝ",
                Gammad: "Ϝ",
                gap: "⪆",
                gbreve: "ğ",
                Gbreve: "Ğ",
                Gcedil: "Ģ",
                gcirc: "ĝ",
                Gcirc: "Ĝ",
                gcy: "г",
                Gcy: "Г",
                gdot: "ġ",
                Gdot: "Ġ",
                ge: "≥",
                gE: "≧",
                gel: "⋛",
                gEl: "⪌",
                geq: "≥",
                geqq: "≧",
                geqslant: "⩾",
                ges: "⩾",
                gescc: "⪩",
                gesdot: "⪀",
                gesdoto: "⪂",
                gesdotol: "⪄",
                gesl: "⋛︀",
                gesles: "⪔",
                gfr: "𝔤",
                Gfr: "𝔊",
                gg: "≫",
                Gg: "⋙",
                ggg: "⋙",
                gimel: "ℷ",
                gjcy: "ѓ",
                GJcy: "Ѓ",
                gl: "≷",
                gla: "⪥",
                glE: "⪒",
                glj: "⪤",
                gnap: "⪊",
                gnapprox: "⪊",
                gne: "⪈",
                gnE: "≩",
                gneq: "⪈",
                gneqq: "≩",
                gnsim: "⋧",
                gopf: "𝕘",
                Gopf: "𝔾",
                grave: "`",
                GreaterEqual: "≥",
                GreaterEqualLess: "⋛",
                GreaterFullEqual: "≧",
                GreaterGreater: "⪢",
                GreaterLess: "≷",
                GreaterSlantEqual: "⩾",
                GreaterTilde: "≳",
                gscr: "ℊ",
                Gscr: "𝒢",
                gsim: "≳",
                gsime: "⪎",
                gsiml: "⪐",
                gt: ">",
                Gt: "≫",
                GT: ">",
                gtcc: "⪧",
                gtcir: "⩺",
                gtdot: "⋗",
                gtlPar: "⦕",
                gtquest: "⩼",
                gtrapprox: "⪆",
                gtrarr: "⥸",
                gtrdot: "⋗",
                gtreqless: "⋛",
                gtreqqless: "⪌",
                gtrless: "≷",
                gtrsim: "≳",
                gvertneqq: "≩︀",
                gvnE: "≩︀",
                Hacek: "ˇ",
                hairsp: " ",
                half: "½",
                hamilt: "ℋ",
                hardcy: "ъ",
                HARDcy: "Ъ",
                harr: "↔",
                hArr: "⇔",
                harrcir: "⥈",
                harrw: "↭",
                Hat: "^",
                hbar: "ℏ",
                hcirc: "ĥ",
                Hcirc: "Ĥ",
                hearts: "♥",
                heartsuit: "♥",
                hellip: "…",
                hercon: "⊹",
                hfr: "𝔥",
                Hfr: "ℌ",
                HilbertSpace: "ℋ",
                hksearow: "⤥",
                hkswarow: "⤦",
                hoarr: "⇿",
                homtht: "∻",
                hookleftarrow: "↩",
                hookrightarrow: "↪",
                hopf: "𝕙",
                Hopf: "ℍ",
                horbar: "―",
                HorizontalLine: "─",
                hscr: "𝒽",
                Hscr: "ℋ",
                hslash: "ℏ",
                hstrok: "ħ",
                Hstrok: "Ħ",
                HumpDownHump: "≎",
                HumpEqual: "≏",
                hybull: "⁃",
                hyphen: "‐",
                iacute: "í",
                Iacute: "Í",
                ic: "⁣",
                icirc: "î",
                Icirc: "Î",
                icy: "и",
                Icy: "И",
                Idot: "İ",
                iecy: "е",
                IEcy: "Е",
                iexcl: "¡",
                iff: "⇔",
                ifr: "𝔦",
                Ifr: "ℑ",
                igrave: "ì",
                Igrave: "Ì",
                ii: "ⅈ",
                iiiint: "⨌",
                iiint: "∭",
                iinfin: "⧜",
                iiota: "℩",
                ijlig: "ĳ",
                IJlig: "Ĳ",
                Im: "ℑ",
                imacr: "ī",
                Imacr: "Ī",
                image: "ℑ",
                ImaginaryI: "ⅈ",
                imagline: "ℐ",
                imagpart: "ℑ",
                imath: "ı",
                imof: "⊷",
                imped: "Ƶ",
                Implies: "⇒",
                in: "∈",
                incare: "℅",
                infin: "∞",
                infintie: "⧝",
                inodot: "ı",
                int: "∫",
                Int: "∬",
                intcal: "⊺",
                integers: "ℤ",
                Integral: "∫",
                intercal: "⊺",
                Intersection: "⋂",
                intlarhk: "⨗",
                intprod: "⨼",
                InvisibleComma: "⁣",
                InvisibleTimes: "⁢",
                iocy: "ё",
                IOcy: "Ё",
                iogon: "į",
                Iogon: "Į",
                iopf: "𝕚",
                Iopf: "𝕀",
                iota: "ι",
                Iota: "Ι",
                iprod: "⨼",
                iquest: "¿",
                iscr: "𝒾",
                Iscr: "ℐ",
                isin: "∈",
                isindot: "⋵",
                isinE: "⋹",
                isins: "⋴",
                isinsv: "⋳",
                isinv: "∈",
                it: "⁢",
                itilde: "ĩ",
                Itilde: "Ĩ",
                iukcy: "і",
                Iukcy: "І",
                iuml: "ï",
                Iuml: "Ï",
                jcirc: "ĵ",
                Jcirc: "Ĵ",
                jcy: "й",
                Jcy: "Й",
                jfr: "𝔧",
                Jfr: "𝔍",
                jmath: "ȷ",
                jopf: "𝕛",
                Jopf: "𝕁",
                jscr: "𝒿",
                Jscr: "𝒥",
                jsercy: "ј",
                Jsercy: "Ј",
                jukcy: "є",
                Jukcy: "Є",
                kappa: "κ",
                Kappa: "Κ",
                kappav: "ϰ",
                kcedil: "ķ",
                Kcedil: "Ķ",
                kcy: "к",
                Kcy: "К",
                kfr: "𝔨",
                Kfr: "𝔎",
                kgreen: "ĸ",
                khcy: "х",
                KHcy: "Х",
                kjcy: "ќ",
                KJcy: "Ќ",
                kopf: "𝕜",
                Kopf: "𝕂",
                kscr: "𝓀",
                Kscr: "𝒦",
                lAarr: "⇚",
                lacute: "ĺ",
                Lacute: "Ĺ",
                laemptyv: "⦴",
                lagran: "ℒ",
                lambda: "λ",
                Lambda: "Λ",
                lang: "⟨",
                Lang: "⟪",
                langd: "⦑",
                langle: "⟨",
                lap: "⪅",
                Laplacetrf: "ℒ",
                laquo: "«",
                larr: "←",
                lArr: "⇐",
                Larr: "↞",
                larrb: "⇤",
                larrbfs: "⤟",
                larrfs: "⤝",
                larrhk: "↩",
                larrlp: "↫",
                larrpl: "⤹",
                larrsim: "⥳",
                larrtl: "↢",
                lat: "⪫",
                latail: "⤙",
                lAtail: "⤛",
                late: "⪭",
                lates: "⪭︀",
                lbarr: "⤌",
                lBarr: "⤎",
                lbbrk: "❲",
                lbrace: "{",
                lbrack: "[",
                lbrke: "⦋",
                lbrksld: "⦏",
                lbrkslu: "⦍",
                lcaron: "ľ",
                Lcaron: "Ľ",
                lcedil: "ļ",
                Lcedil: "Ļ",
                lceil: "⌈",
                lcub: "{",
                lcy: "л",
                Lcy: "Л",
                ldca: "⤶",
                ldquo: "“",
                ldquor: "„",
                ldrdhar: "⥧",
                ldrushar: "⥋",
                ldsh: "↲",
                le: "≤",
                lE: "≦",
                LeftAngleBracket: "⟨",
                leftarrow: "←",
                Leftarrow: "⇐",
                LeftArrow: "←",
                LeftArrowBar: "⇤",
                LeftArrowRightArrow: "⇆",
                leftarrowtail: "↢",
                LeftCeiling: "⌈",
                LeftDoubleBracket: "⟦",
                LeftDownTeeVector: "⥡",
                LeftDownVector: "⇃",
                LeftDownVectorBar: "⥙",
                LeftFloor: "⌊",
                leftharpoondown: "↽",
                leftharpoonup: "↼",
                leftleftarrows: "⇇",
                leftrightarrow: "↔",
                Leftrightarrow: "⇔",
                LeftRightArrow: "↔",
                leftrightarrows: "⇆",
                leftrightharpoons: "⇋",
                leftrightsquigarrow: "↭",
                LeftRightVector: "⥎",
                LeftTee: "⊣",
                LeftTeeArrow: "↤",
                LeftTeeVector: "⥚",
                leftthreetimes: "⋋",
                LeftTriangle: "⊲",
                LeftTriangleBar: "⧏",
                LeftTriangleEqual: "⊴",
                LeftUpDownVector: "⥑",
                LeftUpTeeVector: "⥠",
                LeftUpVector: "↿",
                LeftUpVectorBar: "⥘",
                LeftVector: "↼",
                LeftVectorBar: "⥒",
                leg: "⋚",
                lEg: "⪋",
                leq: "≤",
                leqq: "≦",
                leqslant: "⩽",
                les: "⩽",
                lescc: "⪨",
                lesdot: "⩿",
                lesdoto: "⪁",
                lesdotor: "⪃",
                lesg: "⋚︀",
                lesges: "⪓",
                lessapprox: "⪅",
                lessdot: "⋖",
                lesseqgtr: "⋚",
                lesseqqgtr: "⪋",
                LessEqualGreater: "⋚",
                LessFullEqual: "≦",
                LessGreater: "≶",
                lessgtr: "≶",
                LessLess: "⪡",
                lesssim: "≲",
                LessSlantEqual: "⩽",
                LessTilde: "≲",
                lfisht: "⥼",
                lfloor: "⌊",
                lfr: "𝔩",
                Lfr: "𝔏",
                lg: "≶",
                lgE: "⪑",
                lHar: "⥢",
                lhard: "↽",
                lharu: "↼",
                lharul: "⥪",
                lhblk: "▄",
                ljcy: "љ",
                LJcy: "Љ",
                ll: "≪",
                Ll: "⋘",
                llarr: "⇇",
                llcorner: "⌞",
                Lleftarrow: "⇚",
                llhard: "⥫",
                lltri: "◺",
                lmidot: "ŀ",
                Lmidot: "Ŀ",
                lmoust: "⎰",
                lmoustache: "⎰",
                lnap: "⪉",
                lnapprox: "⪉",
                lne: "⪇",
                lnE: "≨",
                lneq: "⪇",
                lneqq: "≨",
                lnsim: "⋦",
                loang: "⟬",
                loarr: "⇽",
                lobrk: "⟦",
                longleftarrow: "⟵",
                Longleftarrow: "⟸",
                LongLeftArrow: "⟵",
                longleftrightarrow: "⟷",
                Longleftrightarrow: "⟺",
                LongLeftRightArrow: "⟷",
                longmapsto: "⟼",
                longrightarrow: "⟶",
                Longrightarrow: "⟹",
                LongRightArrow: "⟶",
                looparrowleft: "↫",
                looparrowright: "↬",
                lopar: "⦅",
                lopf: "𝕝",
                Lopf: "𝕃",
                loplus: "⨭",
                lotimes: "⨴",
                lowast: "∗",
                lowbar: "_",
                LowerLeftArrow: "↙",
                LowerRightArrow: "↘",
                loz: "◊",
                lozenge: "◊",
                lozf: "⧫",
                lpar: "(",
                lparlt: "⦓",
                lrarr: "⇆",
                lrcorner: "⌟",
                lrhar: "⇋",
                lrhard: "⥭",
                lrm: "‎",
                lrtri: "⊿",
                lsaquo: "‹",
                lscr: "𝓁",
                Lscr: "ℒ",
                lsh: "↰",
                Lsh: "↰",
                lsim: "≲",
                lsime: "⪍",
                lsimg: "⪏",
                lsqb: "[",
                lsquo: "‘",
                lsquor: "‚",
                lstrok: "ł",
                Lstrok: "Ł",
                lt: "<",
                Lt: "≪",
                LT: "<",
                ltcc: "⪦",
                ltcir: "⩹",
                ltdot: "⋖",
                lthree: "⋋",
                ltimes: "⋉",
                ltlarr: "⥶",
                ltquest: "⩻",
                ltri: "◃",
                ltrie: "⊴",
                ltrif: "◂",
                ltrPar: "⦖",
                lurdshar: "⥊",
                luruhar: "⥦",
                lvertneqq: "≨︀",
                lvnE: "≨︀",
                macr: "¯",
                male: "♂",
                malt: "✠",
                maltese: "✠",
                map: "↦",
                Map: "⤅",
                mapsto: "↦",
                mapstodown: "↧",
                mapstoleft: "↤",
                mapstoup: "↥",
                marker: "▮",
                mcomma: "⨩",
                mcy: "м",
                Mcy: "М",
                mdash: "—",
                mDDot: "∺",
                measuredangle: "∡",
                MediumSpace: " ",
                Mellintrf: "ℳ",
                mfr: "𝔪",
                Mfr: "𝔐",
                mho: "℧",
                micro: "µ",
                mid: "∣",
                midast: "*",
                midcir: "⫰",
                middot: "·",
                minus: "−",
                minusb: "⊟",
                minusd: "∸",
                minusdu: "⨪",
                MinusPlus: "∓",
                mlcp: "⫛",
                mldr: "…",
                mnplus: "∓",
                models: "⊧",
                mopf: "𝕞",
                Mopf: "𝕄",
                mp: "∓",
                mscr: "𝓂",
                Mscr: "ℳ",
                mstpos: "∾",
                mu: "μ",
                Mu: "Μ",
                multimap: "⊸",
                mumap: "⊸",
                nabla: "∇",
                nacute: "ń",
                Nacute: "Ń",
                nang: "∠⃒",
                nap: "≉",
                napE: "⩰̸",
                napid: "≋̸",
                napos: "ŉ",
                napprox: "≉",
                natur: "♮",
                natural: "♮",
                naturals: "ℕ",
                nbsp: " ",
                nbump: "≎̸",
                nbumpe: "≏̸",
                ncap: "⩃",
                ncaron: "ň",
                Ncaron: "Ň",
                ncedil: "ņ",
                Ncedil: "Ņ",
                ncong: "≇",
                ncongdot: "⩭̸",
                ncup: "⩂",
                ncy: "н",
                Ncy: "Н",
                ndash: "–",
                ne: "≠",
                nearhk: "⤤",
                nearr: "↗",
                neArr: "⇗",
                nearrow: "↗",
                nedot: "≐̸",
                NegativeMediumSpace: "​",
                NegativeThickSpace: "​",
                NegativeThinSpace: "​",
                NegativeVeryThinSpace: "​",
                nequiv: "≢",
                nesear: "⤨",
                nesim: "≂̸",
                NestedGreaterGreater: "≫",
                NestedLessLess: "≪",
                NewLine: `
`,
                nexist: "∄",
                nexists: "∄",
                nfr: "𝔫",
                Nfr: "𝔑",
                nge: "≱",
                ngE: "≧̸",
                ngeq: "≱",
                ngeqq: "≧̸",
                ngeqslant: "⩾̸",
                nges: "⩾̸",
                nGg: "⋙̸",
                ngsim: "≵",
                ngt: "≯",
                nGt: "≫⃒",
                ngtr: "≯",
                nGtv: "≫̸",
                nharr: "↮",
                nhArr: "⇎",
                nhpar: "⫲",
                ni: "∋",
                nis: "⋼",
                nisd: "⋺",
                niv: "∋",
                njcy: "њ",
                NJcy: "Њ",
                nlarr: "↚",
                nlArr: "⇍",
                nldr: "‥",
                nle: "≰",
                nlE: "≦̸",
                nleftarrow: "↚",
                nLeftarrow: "⇍",
                nleftrightarrow: "↮",
                nLeftrightarrow: "⇎",
                nleq: "≰",
                nleqq: "≦̸",
                nleqslant: "⩽̸",
                nles: "⩽̸",
                nless: "≮",
                nLl: "⋘̸",
                nlsim: "≴",
                nlt: "≮",
                nLt: "≪⃒",
                nltri: "⋪",
                nltrie: "⋬",
                nLtv: "≪̸",
                nmid: "∤",
                NoBreak: "⁠",
                NonBreakingSpace: " ",
                nopf: "𝕟",
                Nopf: "ℕ",
                not: "¬",
                Not: "⫬",
                NotCongruent: "≢",
                NotCupCap: "≭",
                NotDoubleVerticalBar: "∦",
                NotElement: "∉",
                NotEqual: "≠",
                NotEqualTilde: "≂̸",
                NotExists: "∄",
                NotGreater: "≯",
                NotGreaterEqual: "≱",
                NotGreaterFullEqual: "≧̸",
                NotGreaterGreater: "≫̸",
                NotGreaterLess: "≹",
                NotGreaterSlantEqual: "⩾̸",
                NotGreaterTilde: "≵",
                NotHumpDownHump: "≎̸",
                NotHumpEqual: "≏̸",
                notin: "∉",
                notindot: "⋵̸",
                notinE: "⋹̸",
                notinva: "∉",
                notinvb: "⋷",
                notinvc: "⋶",
                NotLeftTriangle: "⋪",
                NotLeftTriangleBar: "⧏̸",
                NotLeftTriangleEqual: "⋬",
                NotLess: "≮",
                NotLessEqual: "≰",
                NotLessGreater: "≸",
                NotLessLess: "≪̸",
                NotLessSlantEqual: "⩽̸",
                NotLessTilde: "≴",
                NotNestedGreaterGreater: "⪢̸",
                NotNestedLessLess: "⪡̸",
                notni: "∌",
                notniva: "∌",
                notnivb: "⋾",
                notnivc: "⋽",
                NotPrecedes: "⊀",
                NotPrecedesEqual: "⪯̸",
                NotPrecedesSlantEqual: "⋠",
                NotReverseElement: "∌",
                NotRightTriangle: "⋫",
                NotRightTriangleBar: "⧐̸",
                NotRightTriangleEqual: "⋭",
                NotSquareSubset: "⊏̸",
                NotSquareSubsetEqual: "⋢",
                NotSquareSuperset: "⊐̸",
                NotSquareSupersetEqual: "⋣",
                NotSubset: "⊂⃒",
                NotSubsetEqual: "⊈",
                NotSucceeds: "⊁",
                NotSucceedsEqual: "⪰̸",
                NotSucceedsSlantEqual: "⋡",
                NotSucceedsTilde: "≿̸",
                NotSuperset: "⊃⃒",
                NotSupersetEqual: "⊉",
                NotTilde: "≁",
                NotTildeEqual: "≄",
                NotTildeFullEqual: "≇",
                NotTildeTilde: "≉",
                NotVerticalBar: "∤",
                npar: "∦",
                nparallel: "∦",
                nparsl: "⫽⃥",
                npart: "∂̸",
                npolint: "⨔",
                npr: "⊀",
                nprcue: "⋠",
                npre: "⪯̸",
                nprec: "⊀",
                npreceq: "⪯̸",
                nrarr: "↛",
                nrArr: "⇏",
                nrarrc: "⤳̸",
                nrarrw: "↝̸",
                nrightarrow: "↛",
                nRightarrow: "⇏",
                nrtri: "⋫",
                nrtrie: "⋭",
                nsc: "⊁",
                nsccue: "⋡",
                nsce: "⪰̸",
                nscr: "𝓃",
                Nscr: "𝒩",
                nshortmid: "∤",
                nshortparallel: "∦",
                nsim: "≁",
                nsime: "≄",
                nsimeq: "≄",
                nsmid: "∤",
                nspar: "∦",
                nsqsube: "⋢",
                nsqsupe: "⋣",
                nsub: "⊄",
                nsube: "⊈",
                nsubE: "⫅̸",
                nsubset: "⊂⃒",
                nsubseteq: "⊈",
                nsubseteqq: "⫅̸",
                nsucc: "⊁",
                nsucceq: "⪰̸",
                nsup: "⊅",
                nsupe: "⊉",
                nsupE: "⫆̸",
                nsupset: "⊃⃒",
                nsupseteq: "⊉",
                nsupseteqq: "⫆̸",
                ntgl: "≹",
                ntilde: "ñ",
                Ntilde: "Ñ",
                ntlg: "≸",
                ntriangleleft: "⋪",
                ntrianglelefteq: "⋬",
                ntriangleright: "⋫",
                ntrianglerighteq: "⋭",
                nu: "ν",
                Nu: "Ν",
                num: "#",
                numero: "№",
                numsp: " ",
                nvap: "≍⃒",
                nvdash: "⊬",
                nvDash: "⊭",
                nVdash: "⊮",
                nVDash: "⊯",
                nvge: "≥⃒",
                nvgt: ">⃒",
                nvHarr: "⤄",
                nvinfin: "⧞",
                nvlArr: "⤂",
                nvle: "≤⃒",
                nvlt: "<⃒",
                nvltrie: "⊴⃒",
                nvrArr: "⤃",
                nvrtrie: "⊵⃒",
                nvsim: "∼⃒",
                nwarhk: "⤣",
                nwarr: "↖",
                nwArr: "⇖",
                nwarrow: "↖",
                nwnear: "⤧",
                oacute: "ó",
                Oacute: "Ó",
                oast: "⊛",
                ocir: "⊚",
                ocirc: "ô",
                Ocirc: "Ô",
                ocy: "о",
                Ocy: "О",
                odash: "⊝",
                odblac: "ő",
                Odblac: "Ő",
                odiv: "⨸",
                odot: "⊙",
                odsold: "⦼",
                oelig: "œ",
                OElig: "Œ",
                ofcir: "⦿",
                ofr: "𝔬",
                Ofr: "𝔒",
                ogon: "˛",
                ograve: "ò",
                Ograve: "Ò",
                ogt: "⧁",
                ohbar: "⦵",
                ohm: "Ω",
                oint: "∮",
                olarr: "↺",
                olcir: "⦾",
                olcross: "⦻",
                oline: "‾",
                olt: "⧀",
                omacr: "ō",
                Omacr: "Ō",
                omega: "ω",
                Omega: "Ω",
                omicron: "ο",
                Omicron: "Ο",
                omid: "⦶",
                ominus: "⊖",
                oopf: "𝕠",
                Oopf: "𝕆",
                opar: "⦷",
                OpenCurlyDoubleQuote: "“",
                OpenCurlyQuote: "‘",
                operp: "⦹",
                oplus: "⊕",
                or: "∨",
                Or: "⩔",
                orarr: "↻",
                ord: "⩝",
                order: "ℴ",
                orderof: "ℴ",
                ordf: "ª",
                ordm: "º",
                origof: "⊶",
                oror: "⩖",
                orslope: "⩗",
                orv: "⩛",
                oS: "Ⓢ",
                oscr: "ℴ",
                Oscr: "𝒪",
                oslash: "ø",
                Oslash: "Ø",
                osol: "⊘",
                otilde: "õ",
                Otilde: "Õ",
                otimes: "⊗",
                Otimes: "⨷",
                otimesas: "⨶",
                ouml: "ö",
                Ouml: "Ö",
                ovbar: "⌽",
                OverBar: "‾",
                OverBrace: "⏞",
                OverBracket: "⎴",
                OverParenthesis: "⏜",
                par: "∥",
                para: "¶",
                parallel: "∥",
                parsim: "⫳",
                parsl: "⫽",
                part: "∂",
                PartialD: "∂",
                pcy: "п",
                Pcy: "П",
                percnt: "%",
                period: ".",
                permil: "‰",
                perp: "⊥",
                pertenk: "‱",
                pfr: "𝔭",
                Pfr: "𝔓",
                phi: "φ",
                Phi: "Φ",
                phiv: "ϕ",
                phmmat: "ℳ",
                phone: "☎",
                pi: "π",
                Pi: "Π",
                pitchfork: "⋔",
                piv: "ϖ",
                planck: "ℏ",
                planckh: "ℎ",
                plankv: "ℏ",
                plus: "+",
                plusacir: "⨣",
                plusb: "⊞",
                pluscir: "⨢",
                plusdo: "∔",
                plusdu: "⨥",
                pluse: "⩲",
                PlusMinus: "±",
                plusmn: "±",
                plussim: "⨦",
                plustwo: "⨧",
                pm: "±",
                Poincareplane: "ℌ",
                pointint: "⨕",
                popf: "𝕡",
                Popf: "ℙ",
                pound: "£",
                pr: "≺",
                Pr: "⪻",
                prap: "⪷",
                prcue: "≼",
                pre: "⪯",
                prE: "⪳",
                prec: "≺",
                precapprox: "⪷",
                preccurlyeq: "≼",
                Precedes: "≺",
                PrecedesEqual: "⪯",
                PrecedesSlantEqual: "≼",
                PrecedesTilde: "≾",
                preceq: "⪯",
                precnapprox: "⪹",
                precneqq: "⪵",
                precnsim: "⋨",
                precsim: "≾",
                prime: "′",
                Prime: "″",
                primes: "ℙ",
                prnap: "⪹",
                prnE: "⪵",
                prnsim: "⋨",
                prod: "∏",
                Product: "∏",
                profalar: "⌮",
                profline: "⌒",
                profsurf: "⌓",
                prop: "∝",
                Proportion: "∷",
                Proportional: "∝",
                propto: "∝",
                prsim: "≾",
                prurel: "⊰",
                pscr: "𝓅",
                Pscr: "𝒫",
                psi: "ψ",
                Psi: "Ψ",
                puncsp: " ",
                qfr: "𝔮",
                Qfr: "𝔔",
                qint: "⨌",
                qopf: "𝕢",
                Qopf: "ℚ",
                qprime: "⁗",
                qscr: "𝓆",
                Qscr: "𝒬",
                quaternions: "ℍ",
                quatint: "⨖",
                quest: "?",
                questeq: "≟",
                quot: '"',
                QUOT: '"',
                rAarr: "⇛",
                race: "∽̱",
                racute: "ŕ",
                Racute: "Ŕ",
                radic: "√",
                raemptyv: "⦳",
                rang: "⟩",
                Rang: "⟫",
                rangd: "⦒",
                range: "⦥",
                rangle: "⟩",
                raquo: "»",
                rarr: "→",
                rArr: "⇒",
                Rarr: "↠",
                rarrap: "⥵",
                rarrb: "⇥",
                rarrbfs: "⤠",
                rarrc: "⤳",
                rarrfs: "⤞",
                rarrhk: "↪",
                rarrlp: "↬",
                rarrpl: "⥅",
                rarrsim: "⥴",
                rarrtl: "↣",
                Rarrtl: "⤖",
                rarrw: "↝",
                ratail: "⤚",
                rAtail: "⤜",
                ratio: "∶",
                rationals: "ℚ",
                rbarr: "⤍",
                rBarr: "⤏",
                RBarr: "⤐",
                rbbrk: "❳",
                rbrace: "}",
                rbrack: "]",
                rbrke: "⦌",
                rbrksld: "⦎",
                rbrkslu: "⦐",
                rcaron: "ř",
                Rcaron: "Ř",
                rcedil: "ŗ",
                Rcedil: "Ŗ",
                rceil: "⌉",
                rcub: "}",
                rcy: "р",
                Rcy: "Р",
                rdca: "⤷",
                rdldhar: "⥩",
                rdquo: "”",
                rdquor: "”",
                rdsh: "↳",
                Re: "ℜ",
                real: "ℜ",
                realine: "ℛ",
                realpart: "ℜ",
                reals: "ℝ",
                rect: "▭",
                reg: "®",
                REG: "®",
                ReverseElement: "∋",
                ReverseEquilibrium: "⇋",
                ReverseUpEquilibrium: "⥯",
                rfisht: "⥽",
                rfloor: "⌋",
                rfr: "𝔯",
                Rfr: "ℜ",
                rHar: "⥤",
                rhard: "⇁",
                rharu: "⇀",
                rharul: "⥬",
                rho: "ρ",
                Rho: "Ρ",
                rhov: "ϱ",
                RightAngleBracket: "⟩",
                rightarrow: "→",
                Rightarrow: "⇒",
                RightArrow: "→",
                RightArrowBar: "⇥",
                RightArrowLeftArrow: "⇄",
                rightarrowtail: "↣",
                RightCeiling: "⌉",
                RightDoubleBracket: "⟧",
                RightDownTeeVector: "⥝",
                RightDownVector: "⇂",
                RightDownVectorBar: "⥕",
                RightFloor: "⌋",
                rightharpoondown: "⇁",
                rightharpoonup: "⇀",
                rightleftarrows: "⇄",
                rightleftharpoons: "⇌",
                rightrightarrows: "⇉",
                rightsquigarrow: "↝",
                RightTee: "⊢",
                RightTeeArrow: "↦",
                RightTeeVector: "⥛",
                rightthreetimes: "⋌",
                RightTriangle: "⊳",
                RightTriangleBar: "⧐",
                RightTriangleEqual: "⊵",
                RightUpDownVector: "⥏",
                RightUpTeeVector: "⥜",
                RightUpVector: "↾",
                RightUpVectorBar: "⥔",
                RightVector: "⇀",
                RightVectorBar: "⥓",
                ring: "˚",
                risingdotseq: "≓",
                rlarr: "⇄",
                rlhar: "⇌",
                rlm: "‏",
                rmoust: "⎱",
                rmoustache: "⎱",
                rnmid: "⫮",
                roang: "⟭",
                roarr: "⇾",
                robrk: "⟧",
                ropar: "⦆",
                ropf: "𝕣",
                Ropf: "ℝ",
                roplus: "⨮",
                rotimes: "⨵",
                RoundImplies: "⥰",
                rpar: ")",
                rpargt: "⦔",
                rppolint: "⨒",
                rrarr: "⇉",
                Rrightarrow: "⇛",
                rsaquo: "›",
                rscr: "𝓇",
                Rscr: "ℛ",
                rsh: "↱",
                Rsh: "↱",
                rsqb: "]",
                rsquo: "’",
                rsquor: "’",
                rthree: "⋌",
                rtimes: "⋊",
                rtri: "▹",
                rtrie: "⊵",
                rtrif: "▸",
                rtriltri: "⧎",
                RuleDelayed: "⧴",
                ruluhar: "⥨",
                rx: "℞",
                sacute: "ś",
                Sacute: "Ś",
                sbquo: "‚",
                sc: "≻",
                Sc: "⪼",
                scap: "⪸",
                scaron: "š",
                Scaron: "Š",
                sccue: "≽",
                sce: "⪰",
                scE: "⪴",
                scedil: "ş",
                Scedil: "Ş",
                scirc: "ŝ",
                Scirc: "Ŝ",
                scnap: "⪺",
                scnE: "⪶",
                scnsim: "⋩",
                scpolint: "⨓",
                scsim: "≿",
                scy: "с",
                Scy: "С",
                sdot: "⋅",
                sdotb: "⊡",
                sdote: "⩦",
                searhk: "⤥",
                searr: "↘",
                seArr: "⇘",
                searrow: "↘",
                sect: "§",
                semi: ";",
                seswar: "⤩",
                setminus: "∖",
                setmn: "∖",
                sext: "✶",
                sfr: "𝔰",
                Sfr: "𝔖",
                sfrown: "⌢",
                sharp: "♯",
                shchcy: "щ",
                SHCHcy: "Щ",
                shcy: "ш",
                SHcy: "Ш",
                ShortDownArrow: "↓",
                ShortLeftArrow: "←",
                shortmid: "∣",
                shortparallel: "∥",
                ShortRightArrow: "→",
                ShortUpArrow: "↑",
                shy: "­",
                sigma: "σ",
                Sigma: "Σ",
                sigmaf: "ς",
                sigmav: "ς",
                sim: "∼",
                simdot: "⩪",
                sime: "≃",
                simeq: "≃",
                simg: "⪞",
                simgE: "⪠",
                siml: "⪝",
                simlE: "⪟",
                simne: "≆",
                simplus: "⨤",
                simrarr: "⥲",
                slarr: "←",
                SmallCircle: "∘",
                smallsetminus: "∖",
                smashp: "⨳",
                smeparsl: "⧤",
                smid: "∣",
                smile: "⌣",
                smt: "⪪",
                smte: "⪬",
                smtes: "⪬︀",
                softcy: "ь",
                SOFTcy: "Ь",
                sol: "/",
                solb: "⧄",
                solbar: "⌿",
                sopf: "𝕤",
                Sopf: "𝕊",
                spades: "♠",
                spadesuit: "♠",
                spar: "∥",
                sqcap: "⊓",
                sqcaps: "⊓︀",
                sqcup: "⊔",
                sqcups: "⊔︀",
                Sqrt: "√",
                sqsub: "⊏",
                sqsube: "⊑",
                sqsubset: "⊏",
                sqsubseteq: "⊑",
                sqsup: "⊐",
                sqsupe: "⊒",
                sqsupset: "⊐",
                sqsupseteq: "⊒",
                squ: "□",
                square: "□",
                Square: "□",
                SquareIntersection: "⊓",
                SquareSubset: "⊏",
                SquareSubsetEqual: "⊑",
                SquareSuperset: "⊐",
                SquareSupersetEqual: "⊒",
                SquareUnion: "⊔",
                squarf: "▪",
                squf: "▪",
                srarr: "→",
                sscr: "𝓈",
                Sscr: "𝒮",
                ssetmn: "∖",
                ssmile: "⌣",
                sstarf: "⋆",
                star: "☆",
                Star: "⋆",
                starf: "★",
                straightepsilon: "ϵ",
                straightphi: "ϕ",
                strns: "¯",
                sub: "⊂",
                Sub: "⋐",
                subdot: "⪽",
                sube: "⊆",
                subE: "⫅",
                subedot: "⫃",
                submult: "⫁",
                subne: "⊊",
                subnE: "⫋",
                subplus: "⪿",
                subrarr: "⥹",
                subset: "⊂",
                Subset: "⋐",
                subseteq: "⊆",
                subseteqq: "⫅",
                SubsetEqual: "⊆",
                subsetneq: "⊊",
                subsetneqq: "⫋",
                subsim: "⫇",
                subsub: "⫕",
                subsup: "⫓",
                succ: "≻",
                succapprox: "⪸",
                succcurlyeq: "≽",
                Succeeds: "≻",
                SucceedsEqual: "⪰",
                SucceedsSlantEqual: "≽",
                SucceedsTilde: "≿",
                succeq: "⪰",
                succnapprox: "⪺",
                succneqq: "⪶",
                succnsim: "⋩",
                succsim: "≿",
                SuchThat: "∋",
                sum: "∑",
                Sum: "∑",
                sung: "♪",
                sup: "⊃",
                Sup: "⋑",
                sup1: "¹",
                sup2: "²",
                sup3: "³",
                supdot: "⪾",
                supdsub: "⫘",
                supe: "⊇",
                supE: "⫆",
                supedot: "⫄",
                Superset: "⊃",
                SupersetEqual: "⊇",
                suphsol: "⟉",
                suphsub: "⫗",
                suplarr: "⥻",
                supmult: "⫂",
                supne: "⊋",
                supnE: "⫌",
                supplus: "⫀",
                supset: "⊃",
                Supset: "⋑",
                supseteq: "⊇",
                supseteqq: "⫆",
                supsetneq: "⊋",
                supsetneqq: "⫌",
                supsim: "⫈",
                supsub: "⫔",
                supsup: "⫖",
                swarhk: "⤦",
                swarr: "↙",
                swArr: "⇙",
                swarrow: "↙",
                swnwar: "⤪",
                szlig: "ß",
                Tab: "	",
                target: "⌖",
                tau: "τ",
                Tau: "Τ",
                tbrk: "⎴",
                tcaron: "ť",
                Tcaron: "Ť",
                tcedil: "ţ",
                Tcedil: "Ţ",
                tcy: "т",
                Tcy: "Т",
                tdot: "⃛",
                telrec: "⌕",
                tfr: "𝔱",
                Tfr: "𝔗",
                there4: "∴",
                therefore: "∴",
                Therefore: "∴",
                theta: "θ",
                Theta: "Θ",
                thetasym: "ϑ",
                thetav: "ϑ",
                thickapprox: "≈",
                thicksim: "∼",
                ThickSpace: "  ",
                thinsp: " ",
                ThinSpace: " ",
                thkap: "≈",
                thksim: "∼",
                thorn: "þ",
                THORN: "Þ",
                tilde: "˜",
                Tilde: "∼",
                TildeEqual: "≃",
                TildeFullEqual: "≅",
                TildeTilde: "≈",
                times: "×",
                timesb: "⊠",
                timesbar: "⨱",
                timesd: "⨰",
                tint: "∭",
                toea: "⤨",
                top: "⊤",
                topbot: "⌶",
                topcir: "⫱",
                topf: "𝕥",
                Topf: "𝕋",
                topfork: "⫚",
                tosa: "⤩",
                tprime: "‴",
                trade: "™",
                TRADE: "™",
                triangle: "▵",
                triangledown: "▿",
                triangleleft: "◃",
                trianglelefteq: "⊴",
                triangleq: "≜",
                triangleright: "▹",
                trianglerighteq: "⊵",
                tridot: "◬",
                trie: "≜",
                triminus: "⨺",
                TripleDot: "⃛",
                triplus: "⨹",
                trisb: "⧍",
                tritime: "⨻",
                trpezium: "⏢",
                tscr: "𝓉",
                Tscr: "𝒯",
                tscy: "ц",
                TScy: "Ц",
                tshcy: "ћ",
                TSHcy: "Ћ",
                tstrok: "ŧ",
                Tstrok: "Ŧ",
                twixt: "≬",
                twoheadleftarrow: "↞",
                twoheadrightarrow: "↠",
                uacute: "ú",
                Uacute: "Ú",
                uarr: "↑",
                uArr: "⇑",
                Uarr: "↟",
                Uarrocir: "⥉",
                ubrcy: "ў",
                Ubrcy: "Ў",
                ubreve: "ŭ",
                Ubreve: "Ŭ",
                ucirc: "û",
                Ucirc: "Û",
                ucy: "у",
                Ucy: "У",
                udarr: "⇅",
                udblac: "ű",
                Udblac: "Ű",
                udhar: "⥮",
                ufisht: "⥾",
                ufr: "𝔲",
                Ufr: "𝔘",
                ugrave: "ù",
                Ugrave: "Ù",
                uHar: "⥣",
                uharl: "↿",
                uharr: "↾",
                uhblk: "▀",
                ulcorn: "⌜",
                ulcorner: "⌜",
                ulcrop: "⌏",
                ultri: "◸",
                umacr: "ū",
                Umacr: "Ū",
                uml: "¨",
                UnderBar: "_",
                UnderBrace: "⏟",
                UnderBracket: "⎵",
                UnderParenthesis: "⏝",
                Union: "⋃",
                UnionPlus: "⊎",
                uogon: "ų",
                Uogon: "Ų",
                uopf: "𝕦",
                Uopf: "𝕌",
                uparrow: "↑",
                Uparrow: "⇑",
                UpArrow: "↑",
                UpArrowBar: "⤒",
                UpArrowDownArrow: "⇅",
                updownarrow: "↕",
                Updownarrow: "⇕",
                UpDownArrow: "↕",
                UpEquilibrium: "⥮",
                upharpoonleft: "↿",
                upharpoonright: "↾",
                uplus: "⊎",
                UpperLeftArrow: "↖",
                UpperRightArrow: "↗",
                upsi: "υ",
                Upsi: "ϒ",
                upsih: "ϒ",
                upsilon: "υ",
                Upsilon: "Υ",
                UpTee: "⊥",
                UpTeeArrow: "↥",
                upuparrows: "⇈",
                urcorn: "⌝",
                urcorner: "⌝",
                urcrop: "⌎",
                uring: "ů",
                Uring: "Ů",
                urtri: "◹",
                uscr: "𝓊",
                Uscr: "𝒰",
                utdot: "⋰",
                utilde: "ũ",
                Utilde: "Ũ",
                utri: "▵",
                utrif: "▴",
                uuarr: "⇈",
                uuml: "ü",
                Uuml: "Ü",
                uwangle: "⦧",
                vangrt: "⦜",
                varepsilon: "ϵ",
                varkappa: "ϰ",
                varnothing: "∅",
                varphi: "ϕ",
                varpi: "ϖ",
                varpropto: "∝",
                varr: "↕",
                vArr: "⇕",
                varrho: "ϱ",
                varsigma: "ς",
                varsubsetneq: "⊊︀",
                varsubsetneqq: "⫋︀",
                varsupsetneq: "⊋︀",
                varsupsetneqq: "⫌︀",
                vartheta: "ϑ",
                vartriangleleft: "⊲",
                vartriangleright: "⊳",
                vBar: "⫨",
                Vbar: "⫫",
                vBarv: "⫩",
                vcy: "в",
                Vcy: "В",
                vdash: "⊢",
                vDash: "⊨",
                Vdash: "⊩",
                VDash: "⊫",
                Vdashl: "⫦",
                vee: "∨",
                Vee: "⋁",
                veebar: "⊻",
                veeeq: "≚",
                vellip: "⋮",
                verbar: "|",
                Verbar: "‖",
                vert: "|",
                Vert: "‖",
                VerticalBar: "∣",
                VerticalLine: "|",
                VerticalSeparator: "❘",
                VerticalTilde: "≀",
                VeryThinSpace: " ",
                vfr: "𝔳",
                Vfr: "𝔙",
                vltri: "⊲",
                vnsub: "⊂⃒",
                vnsup: "⊃⃒",
                vopf: "𝕧",
                Vopf: "𝕍",
                vprop: "∝",
                vrtri: "⊳",
                vscr: "𝓋",
                Vscr: "𝒱",
                vsubne: "⊊︀",
                vsubnE: "⫋︀",
                vsupne: "⊋︀",
                vsupnE: "⫌︀",
                Vvdash: "⊪",
                vzigzag: "⦚",
                wcirc: "ŵ",
                Wcirc: "Ŵ",
                wedbar: "⩟",
                wedge: "∧",
                Wedge: "⋀",
                wedgeq: "≙",
                weierp: "℘",
                wfr: "𝔴",
                Wfr: "𝔚",
                wopf: "𝕨",
                Wopf: "𝕎",
                wp: "℘",
                wr: "≀",
                wreath: "≀",
                wscr: "𝓌",
                Wscr: "𝒲",
                xcap: "⋂",
                xcirc: "◯",
                xcup: "⋃",
                xdtri: "▽",
                xfr: "𝔵",
                Xfr: "𝔛",
                xharr: "⟷",
                xhArr: "⟺",
                xi: "ξ",
                Xi: "Ξ",
                xlarr: "⟵",
                xlArr: "⟸",
                xmap: "⟼",
                xnis: "⋻",
                xodot: "⨀",
                xopf: "𝕩",
                Xopf: "𝕏",
                xoplus: "⨁",
                xotime: "⨂",
                xrarr: "⟶",
                xrArr: "⟹",
                xscr: "𝓍",
                Xscr: "𝒳",
                xsqcup: "⨆",
                xuplus: "⨄",
                xutri: "△",
                xvee: "⋁",
                xwedge: "⋀",
                yacute: "ý",
                Yacute: "Ý",
                yacy: "я",
                YAcy: "Я",
                ycirc: "ŷ",
                Ycirc: "Ŷ",
                ycy: "ы",
                Ycy: "Ы",
                yen: "¥",
                yfr: "𝔶",
                Yfr: "𝔜",
                yicy: "ї",
                YIcy: "Ї",
                yopf: "𝕪",
                Yopf: "𝕐",
                yscr: "𝓎",
                Yscr: "𝒴",
                yucy: "ю",
                YUcy: "Ю",
                yuml: "ÿ",
                Yuml: "Ÿ",
                zacute: "ź",
                Zacute: "Ź",
                zcaron: "ž",
                Zcaron: "Ž",
                zcy: "з",
                Zcy: "З",
                zdot: "ż",
                Zdot: "Ż",
                zeetrf: "ℨ",
                ZeroWidthSpace: "​",
                zeta: "ζ",
                Zeta: "Ζ",
                zfr: "𝔷",
                Zfr: "ℨ",
                zhcy: "ж",
                ZHcy: "Ж",
                zigrarr: "⇝",
                zopf: "𝕫",
                Zopf: "ℤ",
                zscr: "𝓏",
                Zscr: "𝒵",
                zwj: "‍",
                zwnj: "‌"
            }, Q = {
                aacute: "á",
                Aacute: "Á",
                acirc: "â",
                Acirc: "Â",
                acute: "´",
                aelig: "æ",
                AElig: "Æ",
                agrave: "à",
                Agrave: "À",
                amp: "&",
                AMP: "&",
                aring: "å",
                Aring: "Å",
                atilde: "ã",
                Atilde: "Ã",
                auml: "ä",
                Auml: "Ä",
                brvbar: "¦",
                ccedil: "ç",
                Ccedil: "Ç",
                cedil: "¸",
                cent: "¢",
                copy: "©",
                COPY: "©",
                curren: "¤",
                deg: "°",
                divide: "÷",
                eacute: "é",
                Eacute: "É",
                ecirc: "ê",
                Ecirc: "Ê",
                egrave: "è",
                Egrave: "È",
                eth: "ð",
                ETH: "Ð",
                euml: "ë",
                Euml: "Ë",
                frac12: "½",
                frac14: "¼",
                frac34: "¾",
                gt: ">",
                GT: ">",
                iacute: "í",
                Iacute: "Í",
                icirc: "î",
                Icirc: "Î",
                iexcl: "¡",
                igrave: "ì",
                Igrave: "Ì",
                iquest: "¿",
                iuml: "ï",
                Iuml: "Ï",
                laquo: "«",
                lt: "<",
                LT: "<",
                macr: "¯",
                micro: "µ",
                middot: "·",
                nbsp: " ",
                not: "¬",
                ntilde: "ñ",
                Ntilde: "Ñ",
                oacute: "ó",
                Oacute: "Ó",
                ocirc: "ô",
                Ocirc: "Ô",
                ograve: "ò",
                Ograve: "Ò",
                ordf: "ª",
                ordm: "º",
                oslash: "ø",
                Oslash: "Ø",
                otilde: "õ",
                Otilde: "Õ",
                ouml: "ö",
                Ouml: "Ö",
                para: "¶",
                plusmn: "±",
                pound: "£",
                quot: '"',
                QUOT: '"',
                raquo: "»",
                reg: "®",
                REG: "®",
                sect: "§",
                shy: "­",
                sup1: "¹",
                sup2: "²",
                sup3: "³",
                szlig: "ß",
                thorn: "þ",
                THORN: "Þ",
                times: "×",
                uacute: "ú",
                Uacute: "Ú",
                ucirc: "û",
                Ucirc: "Û",
                ugrave: "ù",
                Ugrave: "Ù",
                uml: "¨",
                uuml: "ü",
                Uuml: "Ü",
                yacute: "ý",
                Yacute: "Ý",
                yen: "¥",
                yuml: "ÿ"
            }, G = {
                0: "�",
                128: "€",
                130: "‚",
                131: "ƒ",
                132: "„",
                133: "…",
                134: "†",
                135: "‡",
                136: "ˆ",
                137: "‰",
                138: "Š",
                139: "‹",
                140: "Œ",
                142: "Ž",
                145: "‘",
                146: "’",
                147: "“",
                148: "”",
                149: "•",
                150: "–",
                151: "—",
                152: "˜",
                153: "™",
                154: "š",
                155: "›",
                156: "œ",
                158: "ž",
                159: "Ÿ"
            },
            Z = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111],
            Y = String.fromCharCode, ce = {}, Ce = ce.hasOwnProperty, me = function (Le, it) {
                return Ce.call(Le, it)
            }, R = function (Le, it) {
                for (var _t = -1, Tt = Le.length; ++_t < Tt;) if (Le[_t] == it) return !0;
                return !1
            }, ae = function (Le, it) {
                if (!Le) return it;
                var _t = {}, Tt;
                for (Tt in it) _t[Tt] = me(Le, Tt) ? Le[Tt] : it[Tt];
                return _t
            }, ue = function (Le, it) {
                var _t = "";
                return Le >= 55296 && Le <= 57343 || Le > 1114111 ? (it && le("character reference outside the permissible Unicode range"), "�") : me(G, Le) ? (it && le("disallowed character reference"), G[Le]) : (it && R(Z, Le) && le("disallowed character reference"), Le > 65535 && (Le -= 65536, _t += Y(Le >>> 10 & 1023 | 55296), Le = 56320 | Le & 1023), _t += Y(Le), _t)
            }, ve = function (Le) {
                return "&#x" + Le.toString(16).toUpperCase() + ";"
            }, ke = function (Le) {
                return "&#" + Le + ";"
            }, le = function (Le) {
                throw Error("Parse error: " + Le)
            }, ye = function (Le, it) {
                it = ae(it, ye.options);
                var _t = it.strict;
                _t && L.test(Le) && le("forbidden code point");
                var Tt = it.encodeEverything, Pe = it.useNamedReferences, At = it.allowUnsafeSymbols,
                    mt = it.decimal ? ke : ve, Ye = function (Oe) {
                        return mt(Oe.charCodeAt(0))
                    };
                return Tt ? (Le = Le.replace(y, function (Oe) {
                    return Pe && me(I, Oe) ? "&" + I[Oe] + ";" : Ye(Oe)
                }), Pe && (Le = Le.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;")), Pe && (Le = Le.replace(S, function (Oe) {
                    return "&" + I[Oe] + ";"
                }))) : Pe ? (At || (Le = Le.replace(T, function (Oe) {
                    return "&" + I[Oe] + ";"
                })), Le = Le.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;"), Le = Le.replace(S, function (Oe) {
                    return "&" + I[Oe] + ";"
                })) : At || (Le = Le.replace(T, Ye)), Le.replace(A, function (Oe) {
                    var ht = Oe.charCodeAt(0), vt = Oe.charCodeAt(1), Vt = (ht - 55296) * 1024 + vt - 56320 + 65536;
                    return mt(Vt)
                }).replace(w, Ye)
            };
        ye.options = {allowUnsafeSymbols: !1, encodeEverything: !1, strict: !1, useNamedReferences: !1, decimal: !1};
        var ee = function (Le, it) {
            it = ae(it, ee.options);
            var _t = it.strict;
            return _t && B.test(Le) && le("malformed character reference"), Le.replace(z, function (Tt, Pe, At, mt, Ye, Oe, ht, vt, Vt) {
                var ct, se, ge, we, Me, Be;
                return Pe ? (Me = Pe, q[Me]) : At ? (Me = At, Be = mt, Be && it.isAttributeValue ? (_t && Be == "=" && le("`&` did not start a character reference"), Tt) : (_t && le("named character reference was not terminated by a semicolon"), Q[Me] + (Be || ""))) : Ye ? (ge = Ye, se = Oe, _t && !se && le("character reference was not terminated by a semicolon"), ct = parseInt(ge, 10), ue(ct, _t)) : ht ? (we = ht, se = vt, _t && !se && le("character reference was not terminated by a semicolon"), ct = parseInt(we, 16), ue(ct, _t)) : (_t && le("named character reference was not terminated by a semicolon"), Tt)
            })
        };
        ee.options = {isAttributeValue: !1, strict: !1};
        var qe = function (Le) {
            return Le.replace(T, function (it) {
                return D[it]
            })
        }, Ze = {version: "1.2.0", encode: ye, decode: ee, escape: qe, unescape: ee};
        if (b && !b.nodeType) if (C) C.exports = Ze; else for (var Xe in Ze) me(Ze, Xe) && (b[Xe] = Ze[Xe]); else h.he = Ze
    })(oo)
})(Yp, Yp.exports);
var w7 = Yp.exports;
const A7 = of(w7), C7 = {
        props: {modelValue: [Object, String]}, setup(a) {
            const c = yt(!1), h = new DOMParser;
            console.log(a);
            const C = h.parseFromString(a.modelValue, "text/html").querySelector("a");
            let k = "https://example.com", A = "Example title", y = "_self";
            return C !== null && (k = C.attributes.href.value, A = C.textContent, y = C.target || "_self"), {
                showPopover: c,
                linkInternal: {url: k, title: A, target: y}
            }
        }, methods: {
            submit() {
                const a = this.linkInternal.url, c = encodeURIComponent(this.linkInternal.target),
                    h = A7.escape(this.linkInternal.title);
                let b = `<a href="${a}" target="${c}">${h}</a>`;
                this.showPopover = !1, this.$emit("update:modelValue", b)
            }
        }
    }, _7 = {class: "cf-link-wizard"}, y7 = {href: "#"}, D7 = {key: 0, class: "cf-link-wizard-popover"},
    x7 = J("label", {for: "url"}, "URL", -1), E7 = J("label", {for: "title"}, "Title", -1),
    S7 = J("label", {class: "form-label", for: "target"}, "Target", -1),
    T7 = J("option", {value: "_blank"}, "_blank", -1), I7 = J("option", {value: "_self"}, "_self", -1), M7 = [T7, I7],
    B7 = J("button", {type: "submit"}, "Save", -1);

function N7(a, c, h, b, C, k) {
    return He(), tt("div", _7, [J("div", {
        class: "cf-link-wizard-title",
        onClick: c[0] || (c[0] = A => b.showPopover = !0)
    }, [J("a", y7, Fn(b.linkInternal.title), 1)]), b.showPopover ? (He(), tt("div", D7, [J("button", {
        class: "cf-link-wizard-close",
        onClick: c[1] || (c[1] = A => b.showPopover = !1)
    }, "X"), J("form", {onSubmit: c[5] || (c[5] = vm((...A) => k.submit && k.submit(...A), ["prevent"]))}, [x7, Bt(J("input", {
        id: "url",
        type: "url",
        "onUpdate:modelValue": c[2] || (c[2] = A => b.linkInternal.url = A),
        required: ""
    }, null, 512), [[Vn, b.linkInternal.url]]), E7, Bt(J("input", {
        id: "title",
        "onUpdate:modelValue": c[3] || (c[3] = A => b.linkInternal.title = A),
        required: ""
    }, null, 512), [[Vn, b.linkInternal.title]]), S7, Bt(J("select", {
        id: "target",
        class: "form-control",
        "onUpdate:modelValue": c[4] || (c[4] = A => b.linkInternal.target = A)
    }, M7, 512), [[xr, b.linkInternal.target]]), B7], 32)])) : Rt("", !0)])
}

const s0 = Tr(C7, [["render", N7]]), L7 = {
        components: {
            LinkComponent: s0,
            IconDelete: B5,
            IconEdit: r0,
            Buttonwithicon: Ws,
            Codemirror: i0,
            IconWarning: o0,
            cfinput: wv,
            cfckeditor: Cv,
            cfcodemirror: v7,
            cflink: s0
        }, mounted() {
        }, data() {
            return {
                activeTab: "block",
                newCookie: {
                    additional_information: {
                        description: {title: "Beschreibung", value: ""},
                        domain: {title: "Domain", value: ""},
                        expiry: {title: "Ablauf", value: 0},
                        name: {title: "Name", value: ""},
                        path: {title: "Pfad", value: "/"},
                        provider: {title: "Anbieter", value: "Anbieter"},
                        secure: {title: "Sicher", value: 0}
                    }, col1: "", col2: "", col3: "", is_regex: 0
                },
                cmOptions: {mode: "text/javascript", autoRefresh: !0},
                editor: Av,
                editorConfig: {toolbar: ["bold", "italic", "link"], language: "en"}
            }
        }, props: ["block", "iframeManager", "config"], emits: ["save", "close"], setup() {
            return {v$: M5()}
        }, validations() {
            return {
                block: {
                    title: {required: to},
                    description: {required: to},
                    toggle: {value: {required: to}},
                    category: {required: to},
                    provider: {required: to}
                },
                iframeManager: {
                    iframe: {allow: {required: to}},
                    languages: {en: {notice: {required: to}, loadBtn: {required: to}, loadAllBtn: {required: to}}}
                }
            }
        }, computed: {
            isBlockTabInvalid() {
                return this.v$.block.$error
            }, isScriptManagerTabInvalid() {
                return Gh(this.block)
            }, isIframeManagerTabInvalid() {
                return this.v$.iframeManager.$error
            }, variableInputs() {
                const a = [...this.block.opt_in_code ? [...this.block.opt_in_code.matchAll(/\[##(.*?)##\]/g)] : [], ...this.block.opt_out_code ? [...this.block.opt_out_code.matchAll(/\[##(.*?)##\]/g)] : []];
                for (const c of a) {
                    const h = c[1];
                    this.block.variables === void 0 && (this.block.variables = {}), this.block.variables[h] === void 0 && (this.block.variables[h] = "")
                }
                for (const c in this.block.variables) a.some(h => h[1] === c) || delete this.block.variables[c];
                return this.block.variables
            }
        }, methods: {
            isVariableEmpty(a) {
                return !a || a.trim() === ""
            }, saveChanges() {
                if (this.v$.$touch(), this.v$.$error || !y5(this.block)) console.log("Please correct the form errors before saving."); else {
                    const a = [...this.block.opt_in_code ? [...this.block.opt_in_code.matchAll(/\[##(.*?)##\]/g)] : [], ...this.block.opt_out_code ? [...this.block.opt_out_code.matchAll(/\[##(.*?)##\]/g)] : []];
                    a.length > 0 && a.forEach(c => {
                        const h = c[1];
                        let b = "";
                        this.block.variables !== void 0 && this.block.variables[h] !== void 0 && (b = this.block.variables[h]), this.block.variables[h] !== void 0 && (this.block.variables[h] = b)
                    }), this.$emit("save", this.block, this.iframeManager)
                }
            }, toggleAdditional(a) {
                this.block.cookie_table[a].showAdditional = !this.block.cookie_table[a].showAdditional
            }, closeModal() {
                this.$emit("close", this.block)
            }, addCookie() {
                this.block.cookie_table.push({...this.newCookie}), this.newCookie = {
                    additional_information: {
                        description: {
                            title: "Beschreibung",
                            value: ""
                        },
                        domain: {title: "Domain", value: ""},
                        expiry: {title: "Ablauf", value: 0},
                        name: {title: "Name", value: ""},
                        path: {title: "Pfad", value: "/"},
                        provider: {title: "Anbieter", value: "Anbieter"},
                        secure: {title: "Sicher", value: 0}
                    }, col1: "", col2: "", col3: "", is_regex: 0
                }
            }, editCookie(a) {
                this.block.cookie_table[a] = {...this.block.cookie_table[a]}
            }, removeCookie(a) {
                this.block.cookie_table.splice(a, 1)
            }
        }
    }, P7 = {class: "cf-configurator-modal"}, O7 = {class: "cf-configurator-modal-content"},
    F7 = J("div", {class: "cf-configurator-modal-form-block-header"}, [J("h2", null, "Edit Service")], -1),
    R7 = {class: "cf-configurator-modal-body"}, z7 = {class: "cf-configurator-tab-menu"},
    j7 = {key: 0, class: "cf-badge"}, V7 = {key: 0}, H7 = {class: "cf-configurator-modal-form-block"},
    U7 = J("div", {class: "cf-configurator-modal-form-block-header"}, [J("h2", null, "Edit Service")], -1),
    q7 = {class: "cf-configurator-modal-form-block-body"},
    W7 = {class: "cf-configurator-modal-form-block-item", style: {"margin-bottom": "30px"}},
    $7 = J("span", {class: "cf-configurator-modal-form-block-item-title"}, "Kategorie: ", -1), G7 = ["value"],
    K7 = {key: 0}, Z7 = J("h2", null, "Current Cookies:", -1), Y7 = {class: "cf-cookie-preview"},
    Q7 = {class: "cf-cookie-preview-inner"}, J7 = {class: "cf-cookie-preview-inner-input"},
    X7 = {class: "cf-cookie-preview-inner-actions"}, eF = ["onClick"], tF = ["onClick"],
    nF = {class: "cf-cookie-preview-additional cf-configurator-modal-form-block"},
    rF = {class: "cf-configurator-modal-form-block-item"}, iF = J("strong", null, "Cookie information link:", -1),
    oF = {class: "cf-configurator-modal-form-block-item"}, sF = J("strong", null, "Description:", -1),
    aF = ["onUpdate:modelValue"], lF = {class: "cf-configurator-modal-form-block-item"}, cF = ["onUpdate:modelValue"],
    uF = {class: "cf-configurator-modal-form-block-item"}, dF = ["onUpdate:modelValue"],
    hF = {class: "cf-configurator-modal-form-block-item"}, fF = ["onUpdate:modelValue"], gF = {class: "cf-btn-bar"},
    pF = {class: "cf-configurator-modal-form-block"},
    mF = J("div", {class: "cf-configurator-modal-form-block-header"}, [J("h2", null, "Script Manager")], -1),
    bF = {class: "cf-configurator-modal-form-block-body"}, kF = {key: 0},
    vF = {class: "cf-configurator-modal-form-block"}, wF = J("h3", null, "Variable manager:", -1),
    AF = {class: "cf-configurator-modal-form-block-item"}, CF = ["for"], _F = ["onUpdate:modelValue", "id"],
    yF = {class: "cf-configurator-modal-form-block"},
    DF = J("div", {class: "cf-configurator-modal-form-block-header"}, [J("h2", null, "Iframe Manager Einstellungen")], -1),
    xF = {class: "cf-configurator-modal-form-block-body"}, EF = {class: "cf-btn-bar"}, SF = J("div", null, null, -1);

function TF(a, c, h, b, C, k) {
    const A = Nn("IconWarning"), y = Nn("cfinput"), w = Nn("cfckeditor"), S = Nn("icon-edit"), I = Nn("icon-delete"),
        T = Nn("cflink"), D = Nn("buttonwithicon"), B = Nn("cfcodemirror");
    return He(), tt("div", P7, [J("div", O7, [J("div", null, [J("span", {
        class: "cf-configurator-close",
        onClick: c[0] || (c[0] = (...L) => k.closeModal && k.closeModal(...L))
    }, "×")]), F7, J("div", R7, [J("div", z7, [J("div", {
        onClick: c[1] || (c[1] = L => C.activeTab = "block"),
        class: On({active: C.activeTab === "block", "error-tab": k.isBlockTabInvalid})
    }, "Block ", 2), J("div", {
        onClick: c[2] || (c[2] = L => C.activeTab = "scriptManager"),
        class: On({active: C.activeTab === "scriptManager", "error-tab": k.isScriptManagerTabInvalid})
    }, [Yt("Script Manager "), k.isScriptManagerTabInvalid ? (He(), tt("span", j7, [lt(A)])) : Rt("", !0)], 2), J("div", {
        onClick: c[3] || (c[3] = L => C.activeTab = "iframeManager"),
        class: On({active: C.activeTab === "iframeManager", "error-tab": k.isIframeManagerTabInvalid})
    }, "Iframe Manager ", 2)]), Bt(J("div", null, [h.block ? (He(), tt("div", V7, [J("div", H7, [U7, J("div", q7, [lt(y, {
        title: "Title",
        modelValue: h.block.title,
        "onUpdate:modelValue": c[4] || (c[4] = L => h.block.title = L),
        error: b.v$.block.title.$error,
        errorMessage: "title is required"
    }, null, 8, ["modelValue", "error"]), lt(w, {
        title: "Beschreibung",
        modelValue: h.block.description,
        "onUpdate:modelValue": c[5] || (c[5] = L => h.block.description = L),
        error: b.v$.block.description.$error,
        errorMessage: "Description is required"
    }, null, 8, ["modelValue", "error"]), lt(y, {
        title: "Providers",
        modelValue: h.block.provider,
        "onUpdate:modelValue": c[6] || (c[6] = L => h.block.provider = L),
        error: b.v$.block.provider.$error,
        description: "Url of the providers seperated by comma, eg. https://www.youtube.com, https://www.youtube-nocookie.com",
        errorMessage: "provider is required"
    }, null, 8, ["modelValue", "error"]), lt(y, {
        title: "is required",
        description: "Allows continuation, confirming selected services as required. User acknowledges that these cookies are necessary and will be consistently used.",
        modelValue: h.block.toggle.readonly,
        "onUpdate:modelValue": c[7] || (c[7] = L => h.block.toggle.readonly = L),
        type: "checkbox"
    }, null, 8, ["modelValue"]), lt(y, {
        title: "is checked by default",
        description: "Confirms pre-selected options, making them the default. All cookies marked as required will be activated by default.",
        modelValue: h.block.toggle.enabled,
        "onUpdate:modelValue": c[8] || (c[8] = L => h.block.toggle.enabled = L),
        type: "checkbox"
    }, null, 8, ["modelValue"]), J("div", W7, [J("label", null, [$7, Bt(J("select", {"onUpdate:modelValue": c[9] || (c[9] = L => h.block.category = L)}, [(He(!0), tt(ln, null, so(h.config.languages.en.categories_all, (L, z) => (He(), tt("option", {
        key: z,
        value: L.category
    }, Fn(L.title), 9, G7))), 128))], 512), [[xr, h.block.category]]), b.v$.block.category.$error ? (He(), tt("span", K7, "Category is required")) : Rt("", !0)])]), lt(y, {
        title: "Identifier",
        modelValue: h.block.toggle.value,
        "onUpdate:modelValue": c[10] || (c[10] = L => h.block.toggle.value = L),
        error: b.v$.block.toggle.value.$error,
        isAdvanced: "",
        description: "Identifier for the System, (eg. youtube) this is used for the opt-in and opt-out script and should only changed if you know what you are doing.",
        errorMessage: "Identifier is required"
    }, null, 8, ["modelValue", "error"])])]), Z7, (He(!0), tt(ln, null, so(h.block.cookie_table, (L, z) => (He(), tt("div", {key: z}, [J("div", Y7, [J("div", Q7, [J("div", J7, [J("label", null, [Yt(" Cookie: "), J("strong", null, Fn(L.col1), 1)])]), J("div", X7, [J("div", {
        class: "cf-category-circle cf-category-circle-bg",
        onClick: q => k.toggleAdditional(z),
        title: "Edit"
    }, [lt(S)], 8, eF), J("div", {
        class: "cf-category-circle cf-category-circle-bg",
        onClick: q => k.removeCookie(z),
        title: "Delete"
    }, [lt(I)], 8, tF)])]), Bt(J("div", nF, [lt(y, {
        title: "Name or Regex",
        modelValue: L.col1,
        "onUpdate:modelValue": q => L.col1 = q
    }, null, 8, ["modelValue", "onUpdate:modelValue"]), J("div", rF, [J("div", null, [J("label", null, [iF, lt(T, {
        modelValue: L.col2,
        "onUpdate:modelValue": q => L.col2 = q
    }, null, 8, ["modelValue", "onUpdate:modelValue"])])])]), J("div", oF, [J("div", null, [J("label", null, [sF, Yt(), Bt(J("textarea", {
        "onUpdate:modelValue": q => L.additional_information.description.value = q,
        placeholder: "description"
    }, null, 8, aF), [[Vn, L.additional_information.description.value]])])])]), J("div", lF, [J("div", null, [J("label", null, [Yt("Display Name: "), Bt(J("input", {
        "onUpdate:modelValue": q => L.additional_information.name.value = q,
        placeholder: "name"
    }, null, 8, cF), [[Vn, L.additional_information.name.value]])])])]), J("div", uF, [J("div", null, [J("label", null, [Yt("Path: "), Bt(J("input", {
        "onUpdate:modelValue": q => L.additional_information.path.value = q,
        placeholder: "path"
    }, null, 8, dF), [[Vn, L.additional_information.path.value]])])])]), J("div", hF, [J("div", null, [J("label", null, [Yt("Provider: "), Bt(J("input", {
        "onUpdate:modelValue": q => L.additional_information.provider.value = q,
        placeholder: "provider"
    }, null, 8, fF), [[Vn, L.additional_information.provider.value]])])])]), lt(y, {
        title: "Secure",
        modelValue: L.additional_information.secure.value,
        "onUpdate:modelValue": q => L.additional_information.secure.value = q,
        type: "checkbox",
        isAdvanced: ""
    }, null, 8, ["modelValue", "onUpdate:modelValue"]), lt(y, {
        title: "Is Regex",
        modelValue: L.is_regex,
        "onUpdate:modelValue": q => L.is_regex = q,
        type: "checkbox",
        isAdvanced: ""
    }, null, 8, ["modelValue", "onUpdate:modelValue"])], 512), [[Hs, L.showAdditional]])])]))), 128)), J("div", gF, [lt(D, {
        onClick: k.addCookie,
        icon: "IconPlus"
    }, {
        default: Sr(() => [Yt("add empty Cookie")]),
        _: 1
    }, 8, ["onClick"])])])) : Rt("", !0)], 512), [[Hs, C.activeTab === "block"]]), Bt(J("div", null, [J("div", pF, [mF, J("div", bF, [lt(B, {
        title: "Opt-In-Script",
        modelValue: h.block.opt_in_code,
        "onUpdate:modelValue": c[11] || (c[11] = L => h.block.opt_in_code = L),
        isAdvanced: "",
        errorMessage: "Opt-In-Script is required"
    }, null, 8, ["modelValue"]), lt(B, {
        title: "Opt-Out-Script",
        modelValue: h.block.opt_out_code,
        "onUpdate:modelValue": c[12] || (c[12] = L => h.block.opt_out_code = L),
        isAdvanced: "",
        errorMessage: "Opt-Out-Script is required"
    }, null, 8, ["modelValue"])])]), k.variableInputs ? (He(), tt("div", kF, [J("div", vF, [wF, J("div", AF, [(He(!0), tt(ln, null, so(Object.keys(k.variableInputs), L => (He(), tt("div", {
        key: L,
        class: "mb-2"
    }, [J("div", {class: On(["cf-form-group", {error: k.isVariableEmpty(h.block.variables[L])}])}, [J("label", {
        for: "variable-" + L,
        class: "form-label"
    }, Fn(L), 9, CF), Bt(J("input", {
        type: "text",
        class: "cf-variable-input cf-form-field",
        "onUpdate:modelValue": z => h.block.variables[L] = z,
        id: "variable-" + L,
        required: ""
    }, null, 8, _F), [[Vn, h.block.variables[L]]])], 2)]))), 128))])])])) : Rt("", !0)], 512), [[Hs, C.activeTab === "scriptManager"]]), Bt(J("div", null, [J("div", yF, [DF, J("div", xF, [lt(y, {
        title: "Iframe Allow",
        modelValue: h.iframeManager.iframe.allow,
        "onUpdate:modelValue": c[13] || (c[13] = L => h.iframeManager.iframe.allow = L),
        error: b.v$.iframeManager.iframe.allow.$error,
        errorMessage: "Iframe allow is required"
    }, null, 8, ["modelValue", "error"]), lt(w, {
        title: "Notice",
        modelValue: h.iframeManager.languages.en.notice,
        "onUpdate:modelValue": c[14] || (c[14] = L => h.iframeManager.languages.en.notice = L),
        error: b.v$.iframeManager.languages.en.notice.$error,
        errorMessage: "Notice is required"
    }, null, 8, ["modelValue", "error"]), lt(y, {
        title: "Load Button",
        modelValue: h.iframeManager.languages.en.loadBtn,
        "onUpdate:modelValue": c[15] || (c[15] = L => h.iframeManager.languages.en.loadBtn = L),
        error: b.v$.iframeManager.languages.en.loadBtn.$error,
        errorMessage: "Load Button is required"
    }, null, 8, ["modelValue", "error"]), lt(y, {
        title: "Load All Button",
        modelValue: h.iframeManager.languages.en.loadAllBtn,
        "onUpdate:modelValue": c[16] || (c[16] = L => h.iframeManager.languages.en.loadAllBtn = L),
        error: b.v$.iframeManager.languages.en.loadAllBtn.$error,
        errorMessage: "Load All Button is required"
    }, null, 8, ["modelValue", "error"])])])], 512), [[Hs, C.activeTab === "iframeManager"]]), J("div", EF, [SF, lt(D, {
        onClick: k.saveChanges,
        icon: "IconArrow",
        "btn-class": "cf-color-dark-green"
    }, {default: Sr(() => [Yt("save changes ")]), _: 1}, 8, ["onClick"])])])])])
}

const IF = Tr(L7, [["render", TF]]);

class MF {
    constructor(c, h, b) {
        this.apiKey = c, this.projectID = h, this.endPoint = b
    }

    _createHeaders() {
        var c = new Headers;
        return c.append("x-api-key", this.apiKey), c
    }

    getApiKey() {
        return this.apiKey
    }

    getProjectID() {
        return this.projectID
    }

    setEndPoint(c) {
        this.endPoint = c
    }

    getEndPoint() {
        return this.endPoint.replace(/\/$/, "")
    }

    setProjectID(c) {
        this.projectID = c
    }

    getBaseDomain() {
        return BASE_DOMAIN
    }

    setApiKey(c) {
        this.apiKey = c
    }

    async _sendRequest(c, h) {
        console.log(this.getEndPoint());
        console.log(this.projectID);
        const b = `${this.getEndPoint()}${c}`, C = await fetch(b, h);
        if (!C.ok) throw new Error(`HTTP error! status: ${C.status}`);
        return C.json()
    }

    async publish() {
        const c = `/api/manage/ajax/publish/${this.projectID}`,
            h = {method: "POST", headers: this._createHeaders(), redirect: "follow"};
        return this._sendRequest(c, h)
    }

    async loadData(c, h) {
        const b = `/api/manage/ajax/base-theme/${this.projectID}/${c}/${h}`,
            C = {method: "GET", headers: this._createHeaders(), redirect: "follow"};
        return this._sendRequest(b, C)
    }

    async saveData(c) {
        const h = `/api/manage/ajax/save-theme/${this.projectID}`,
            b = {method: "POST", headers: this._createHeaders(), redirect: "follow", body: c};
        return this._sendRequest(h, b)
    }

    async getServices() {
        const c = `/api/manage/ajax/get-services/${this.projectID}`,
            h = {method: "GET", headers: this._createHeaders(), redirect: "follow"};
        return this._sendRequest(c, h)
    }

    async getStartInfo() {
        const c = `/api/manage/ajax/start-info/${this.projectID}`,
            h = {method: "GET", headers: this._createHeaders(), redirect: "follow"};
        return this._sendRequest(c, h)
    }

    async getScans() {
        const c = `/api/manage/ajax/get-current-scans/${this.projectID}`,
            h = {method: "GET", headers: this._createHeaders(), redirect: "follow"};
        return this._sendRequest(c, h)
    }
}

const ei = new MF("7TnHsojnio0hrAdX5rujt9MfFFYJJy3pjejvpcxiEqxu1", "7c9cb6-014e12-e8d047-14f9d7-f95f17", "https://cookieapi.ddev.site"),
    BF = {}, NF = {xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24"},
    LF = J("path", {d: "M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"}, null, -1), PF = [LF];

function OF(a, c) {
    return He(), tt("svg", NF, PF)
}

const F5 = Tr(BF, [["render", OF]]), FF = {
        components: {Buttonwithicon: Ws, IconSuccess: F5},
        props: ["showModal", "config", "saveChanges"],
        emits: ["close", "save"],
        setup(a, {emit: c}) {
            const h = yt([]), b = yt("");
            yt([]);
            const C = yt("");
            Oi(async () => {
                try {
                    h.value = await ei.getServices()
                } catch (D) {
                    console.error("Error fetching services:", D)
                }
            });
            const k = yt([]), A = D => {
                const B = k.value.findIndex(L => L.id === D.id);
                B === -1 ? k.value.push(D) : k.value.splice(B, 1)
            }, y = () => {
                c("close")
            }, w = tn(() => {
                const D = {};
                return h.value.forEach(B => {
                    const L = a.config.languages.en.categories_all[B.category_suggestion], z = L ? L.title : "N/A";
                    D[B.category_suggestion] = z
                }), D
            }), S = () => {
                k.value.forEach(D => {
                    I(D)
                }), k.value = [], y()
            }, I = D => {
                const B = [];
                for (let q = 0; q < D.cookie_table.length; q++) {
                    const Q = D.cookie_table[q], G = {
                        additional_information: {
                            description: {title: "placeholder", value: Q.description},
                            domain: {title: "placeholder", value: Q.domain},
                            expiry: {title: "placeholder", value: Q.expiry},
                            name: {title: "placeholder", value: Q.name},
                            path: {title: "placeholder", value: Q.path},
                            provider: {title: "placeholder", value: "placeholder"},
                            secure: {title: "placeholder", value: Q.secure}
                        },
                        col1: Q.name,
                        col2: '<a target="_blank" href="https://developers.google.com/recaptcha/docs/faq">Provider</a>',
                        col3: Q.description,
                        is_regex: Q.is_regex
                    };
                    B.push(G)
                }
                const L = {
                    title: D.name,
                    description: D.description,
                    toggle: {value: D.identifier, readonly: D.readonly, enabled: D.enabled},
                    cookie_table: B || [{}],
                    category: D.category_suggestion,
                    provider: D.provider,
                    dsgvo_link: D.dsgvo_link,
                    opt_in_code: D.opt_in_code,
                    opt_out_code: D.opt_out_code
                }, z = {
                    embedUrl: "{data-id}",
                    thumbnailUrl: D.iframe_thumbnail_url,
                    iframe: {allow: ""},
                    cookie: {name: D.identifier, path: "/"},
                    languages: {
                        en: {
                            notice: D.iframe_notice,
                            loadBtn: D.iframe_load_btn,
                            loadAllBtn: D.iframe_load_all_btn
                        }
                    }
                };
                a.saveChanges(L, z)
            }, T = tn(() => {
                let D = h.value;
                b.value && (D = D.filter(L => L.category_suggestion && L.category_suggestion.includes(b.value))), C.value && (D = D.filter(L => L.name.toLowerCase().includes(C.value.toLowerCase())));
                const B = a.config.languages.en.settings_modal.blocks.map(L => L.title);
                return D = D.filter(L => !B.includes(L.name)), D
            });
            return {
                services: h,
                toggleService: A,
                saveSelectedServices: S,
                selectedServices: k,
                filter: b,
                titleFilter: C,
                filteredServices: T,
                getCategories: w,
                closeModal: y
            }
        }
    }, RF = {key: 0, class: "cf-configurator-modal"}, zF = {class: "cf-configurator-modal-content"},
    jF = J("h2", null, "Services", -1), VF = {class: "cf-configurator-modal-filter"},
    HF = J("option", {value: ""}, "Select a Category", -1), UF = ["value"], qF = {class: "service-list"},
    WF = ["onClick"], $F = {class: "cf-category-circle-wrapper"};

function GF(a, c, h, b, C, k) {
    const A = Nn("icon-success"), y = Nn("buttonwithicon");
    return h.showModal ? (He(), tt("div", RF, [J("div", zF, [J("span", {
        class: "cf-configurator-close",
        onClick: c[0] || (c[0] = (...w) => b.closeModal && b.closeModal(...w))
    }, "×"), jF, J("div", VF, [Bt(J("select", {"onUpdate:modelValue": c[1] || (c[1] = w => b.filter = w)}, [HF, (He(!0), tt(ln, null, so(b.getCategories, (w, S) => (He(), tt("option", {
        key: S,
        value: S
    }, Fn(w), 9, UF))), 128))], 512), [[xr, b.filter]]), Bt(J("input", {
        type: "text",
        "onUpdate:modelValue": c[2] || (c[2] = w => b.titleFilter = w),
        placeholder: "Filter by title"
    }, null, 512), [[Vn, b.titleFilter]])]), J("div", qF, [(He(!0), tt(ln, null, so(b.filteredServices, (w, S) => (He(), tt("div", {
        key: S,
        onClick: I => b.toggleService(w),
        class: On({active: b.selectedServices.includes(w)})
    }, [J("div", $F, [J("div", {class: On(["cf-category-circle", b.selectedServices.includes(w) ? "" : "empty"])}, [b.selectedServices.includes(w) ? (He(), gr(A, {key: 0})) : Rt("", !0)], 2), Yt(" " + Fn(w.name), 1)])], 10, WF))), 128))]), lt(y, {
        onClick: b.saveSelectedServices,
        icon: "IconArrow"
    }, {default: Sr(() => [Yt("Add selected services")]), _: 1}, 8, ["onClick"])])])) : Rt("", !0)
}

const KF = Tr(FF, [["render", GF]]), ZF = {
        components: {Buttonwithicon: Ws, cfckeditor: Cv, cfinput: wv},
        props: {category: Object},
        emits: ["save", "close"],
        setup(a, {emit: c}) {
            const h = M5();
            return {
                closeModal: () => {
                    c("close")
                }, saveChanges: () => {
                    h.value.$touch(), h.value.$error ? console.log("error") : c("save", a.category)
                }, v$: h
            }
        },
        validations() {
            return {category: {title: {required: to}, description: {required: to}, toggle: {value: {required: to}}}}
        }
    }, R5 = a => ($u("data-v-850c690f"), a = a(), Gu(), a), YF = {key: 0, class: "cf-configurator-modal"},
    QF = {class: "cf-configurator-modal-content"},
    JF = R5(() => J("div", {class: "cf-configurator-modal-form-block-header"}, [J("h2", null, "Edit Category")], -1)),
    XF = {class: "cf-configurator-modal-form-block"}, eR = {class: "cf-btn-bar"},
    tR = R5(() => J("div", null, null, -1));

function nR(a, c, h, b, C, k) {
    const A = Nn("cfinput"), y = Nn("cfckeditor"), w = Nn("buttonwithicon");
    return h.category ? (He(), tt("div", YF, [J("div", QF, [J("div", null, [J("span", {
        class: "cf-configurator-close",
        onClick: c[0] || (c[0] = (...S) => b.closeModal && b.closeModal(...S))
    }, "×")]), JF, J("div", XF, [J("form", {onSubmit: c[6] || (c[6] = vm((...S) => b.saveChanges && b.saveChanges(...S), ["prevent"]))}, [h.category ? (He(), gr(A, {
        key: 0,
        title: "Title",
        description: "Title of the category.",
        modelValue: h.category.title,
        "onUpdate:modelValue": c[1] || (c[1] = S => h.category.title = S),
        error: b.v$.category.title.$error,
        errorMessage: "Title is required"
    }, null, 8, ["modelValue", "error"])) : Rt("", !0), h.category ? (He(), gr(y, {
        key: 1,
        title: "Description",
        description: "Description of the category.",
        modelValue: h.category.description,
        "onUpdate:modelValue": c[2] || (c[2] = S => h.category.description = S),
        error: b.v$.category.description.$error,
        errorMessage: "Description is required"
    }, null, 8, ["modelValue", "error"])) : Rt("", !0), h.category ? (He(), gr(A, {
        key: 2,
        title: "is Required",
        description: "Allows continuation, confirming selected services as required. User acknowledges that these cookies are necessary and will be consistently used.",
        modelValue: h.category.toggle.enabled,
        "onUpdate:modelValue": c[3] || (c[3] = S => h.category.toggle.enabled = S),
        type: "checkbox",
        errorMessage: "Enabled Value is required"
    }, null, 8, ["modelValue"])) : Rt("", !0), h.category ? (He(), gr(A, {
        key: 3,
        title: "Readonly",
        description: "Confirms pre-selected options, making them the default. All cookies marked as readonly can not be changed by his original value.",
        modelValue: h.category.toggle.readonly,
        "onUpdate:modelValue": c[4] || (c[4] = S => h.category.toggle.readonly = S),
        type: "checkbox",
        errorMessage: "Readonly Value is required"
    }, null, 8, ["modelValue"])) : Rt("", !0), h.category ? (He(), gr(A, {
        key: 4,
        title: "Identifier",
        description: "Do not change this value unless you know what you are doing.",
        modelValue: h.category.toggle.value,
        "onUpdate:modelValue": c[5] || (c[5] = S => h.category.toggle.value = S),
        isAdvanced: "",
        error: b.v$.category.toggle.value.$error,
        errorMessage: "Toggle Value is required"
    }, null, 8, ["modelValue", "error"])) : Rt("", !0)], 32)]), J("div", eR, [tR, lt(w, {
        btnClass: "cf-color-dark-green",
        icon: "IconArrow",
        onClick: b.saveChanges
    }, {default: Sr(() => [Yt("Save")]), _: 1}, 8, ["onClick"])])])])) : Rt("", !0)
}

const rR = Tr(ZF, [["render", nR], ["__scopeId", "data-v-850c690f"]]), iR = {key: 0, class: "cf-bg-gray"},
    oR = {class: "cf-category-toolbar"}, sR = {class: "cf-category-items"}, aR = {class: "cf-category-info"},
    lR = ["onClick"], cR = {style: {display: "flex", "align-items": "center"}},
    uR = {key: 0, class: "cf-category-circle-wrapper"}, dR = {class: "cf-category-circle"},
    hR = {class: "cf-category-action-bar"}, fR = ["onClick"], gR = ["onClick"], pR = J("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        height: "24",
        viewBox: "0 -960 960 960",
        width: "24"
    }, [J("path", {d: "m296-345-56-56 240-240 240 240-56 56-184-184-184 184Z"})], -1), mR = [pR],
    bR = {key: 0, class: "cf-category-blocks"}, kR = {style: {display: "flex"}},
    vR = {class: "cf-category-circle-wrapper"}, wR = {key: 0, class: "cf-category-circle"},
    AR = {key: 1, class: "cf-category-circle success"}, CR = {key: 0, class: "cf-small-text cf-text-red"},
    _R = {class: "cf-category-action-bar"}, yR = ["onClick"], DR = ["onClick"], xR = {class: "cf-btn-bar"},
    ER = J("div", null, " ", -1), SR = {
        __name: "ServiceConfigurator",
        props: {config: Object, iframemanagerconfig: Object},
        emits: ["next", "back"],
        setup(a, {emit: c}) {
            const h = a;
            Oi(() => {
            });
            const b = c, C = () => {
                    if (!D5(h.config)) {
                        console.error("Cannot proceed to the next step due to invalid services.");
                        return
                    }
                    Q(), b("next")
                }, k = yt(null), A = jr({state: !1}), y = jr({state: !1}), w = yt(null), S = yt(null), I = jr([]), T = yt(!1),
                D = jr({}), B = yt(null), L = ue => {
                    B.value = ue, y.state = !0
                }, z = ue => {
                    D[ue.category] ? delete D[ue.category] : D[ue.category] = !0
                }, q = () => {
                    A.state = !1, y.state = !1
                }, Q = async () => {
                    const ue = JSON.stringify({iframeManagerConfig: h.iframemanagerconfig, config: h.config});
                    await ei.saveData(ue)
                }, G = ue => {
                    k.value = h.config.languages.en.settings_modal.categories.findIndex(ve => ve.category === ue.category), k.value !== -1 ? h.config.languages.en.settings_modal.categories[k.value] = ue : h.config.languages.en.settings_modal.categories.push(ue), Q(), q()
                }, Z = (ue, ve) => {
                    h.config.languages.en.settings_modal.categories.find(le => le.category === ue.category) || (console.log(ue), console.log(h.config.languages.en.categories_all[ue.category]), h.config.languages.en.settings_modal.categories.push({
                        title: h.config.languages.en.categories_all[ue.category].title,
                        description: h.config.languages.en.categories_all[ue.category].description,
                        toggle: {
                            value: ue.category,
                            readonly: h.config.languages.en.categories_all[ue.category].toggle.readonly,
                            enabled: h.config.languages.en.categories_all[ue.category].toggle.enabled
                        },
                        category: ue.category
                    })), k.value !== null ? (h.config.languages.en.settings_modal.blocks[k.value] = ue, h.iframemanagerconfig.services[ue.toggle.value] = ve) : (h.config.languages.en.settings_modal.blocks.push(ue), h.iframemanagerconfig.services[ue.toggle.value] = ve), Q(), q()
                }, Y = ue => h.config.languages.en.settings_modal.blocks.filter(ve => ve.category === ue), ce = ue => {
                    if (!window.confirm("Do you really want to remove the service?")) return;
                    const ke = h.config.languages.en.settings_modal.blocks.findIndex(ye => ye === ue);
                    if (ke !== -1 && h.config.languages.en.settings_modal.blocks.splice(ke, 1), h.config.languages.en.settings_modal.blocks.filter(ye => ye.category === ue.category).length === 0) {
                        const ye = h.config.languages.en.settings_modal.categories.findIndex(ee => ee.category === ue.category);
                        ye !== -1 && h.config.languages.en.settings_modal.categories.splice(ye, 1)
                    }
                    Q()
                }, Ce = () => {
                    k.value = null, w.value = {
                        title: "",
                        description: "",
                        toggle: {value: "", readonly: !0, enabled: !0},
                        cookie_table: [{
                            additional_information: {
                                description: {title: "Beschreibung", value: ""},
                                domain: {title: "Domain", value: ""},
                                expiry: {title: "Ablauf", value: 0},
                                name: {title: "Name", value: ""},
                                path: {title: "Pfad", value: "/"},
                                provider: {title: "Anbieter", value: "Anbieter"},
                                secure: {title: "Sicher", value: 0}
                            }, col1: "", col2: "", col3: "", is_regex: 0
                        }],
                        category: ""
                    }, S.value = {
                        embedUrl: "{data-id}",
                        thumbnailUrl: "",
                        iframe: {allow: "accelerometer; encrypted-media; gyroscope; picture-in-picture; fullscreen; "},
                        cookie: {name: "", path: "/"},
                        languages: {en: {notice: "", loadBtn: "", loadAllBtn: ""}}
                    }, A.state = !0
                }, me = ue => {
                    k.value = h.config.languages.en.settings_modal.blocks.findIndex(ve => ve.title === ue.title), w.value = {
                        ...ue,
                        toggle: {...ue.toggle},
                        cookie_table: [...ue.cookie_table]
                    }, S.value = {...h.iframemanagerconfig.services[ue.toggle.value]}, A.state = !0
                }, R = async () => {
                    try {
                        const ue = await ei.getServices();
                        I.value = ue, T.value = !0
                    } catch (ue) {
                        console.error("Error fetching services:", ue)
                    }
                }, ae = () => {
                    T.value = !1
                };
            return (ue, ve) => (He(), tt(ln, null, [a.config ? (He(), tt("div", iR, [J("div", oR, [lt(Ws, {
                onClick: R,
                icon: "IconPlus"
            }, {default: Sr(() => [Yt("Add preconfigured Service")]), _: 1}), lt(Ws, {
                onClick: Ce,
                icon: "IconPlus"
            }, {
                default: Sr(() => [Yt("Add custom Service")]),
                _: 1
            })]), J("div", sR, [(He(!0), tt(ln, null, so(a.config.languages.en.settings_modal.categories, (ke, le) => (He(), tt("div", {
                key: "category-" + le,
                class: "cf-category"
            }, [J("div", aR, [J("h3", {onClick: ye => z(ke)}, Fn(ke.title), 9, lR), J("div", cR, [xt(E9)(ke, h) ? (He(), tt("div", uR, [J("div", dR, [lt(o0)])])) : Rt("", !0), J("div", hR, [J("div", {
                class: "cf-category-circle cf-category-circle-bg",
                onClick: ye => L(ke),
                title: "Edit"
            }, [lt(r0)], 8, fR)]), J("span", {
                onClick: ye => z(ke),
                class: On({"rotate-icon": D[ke.category]})
            }, mR, 10, gR)])]), D[ke.category] ? Rt("", !0) : (He(), tt("div", bR, [(He(!0), tt(ln, null, so(Y(ke.category), (ye, ee) => (He(), tt("div", {
                class: On(["cf-service-block", {
                    "invalid-service": xt($h).has(ye),
                    "valid-service": !xt($h).has(ye)
                }]), key: ye.title
            }, [J("div", kR, [J("div", vR, [xt(Gh)(ye) ? (He(), tt("div", wR, [lt(o0)])) : (He(), tt("div", AR, [lt(F5)]))]), J("p", null, [Yt(Fn(ye.title) + " ", 1), xt(Gh)(ye) ? (He(), tt("span", CR, "Empty Variables in Script")) : Rt("", !0)])]), J("div", _R, [J("div", {
                class: "cf-category-circle",
                onClick: qe => me(ye),
                title: "Edit"
            }, [lt(r0)], 8, yR), J("div", {
                class: "cf-category-circle",
                onClick: qe => ce(ye),
                title: "Delete"
            }, [lt(B5)], 8, DR)])], 2))), 128))]))]))), 128))]), J("div", xR, [ER, lt(Ws, {
                onClick: C,
                btnClass: "cf-color-dark-green",
                icon: "IconArrow"
            }, {default: Sr(() => [Yt("next step")]), _: 1})])])) : Rt("", !0), A.state ? (He(), gr(IF, {
                key: 1,
                block: w.value,
                iframeManager: S.value,
                config: a.config,
                onSave: Z,
                onClose: q
            }, null, 8, ["block", "iframeManager", "config"])) : Rt("", !0), lt(KF, {
                showModal: T.value,
                config: a.config,
                services: I,
                saveChanges: Z,
                onClose: ae
            }, null, 8, ["showModal", "config", "services"]), y.state ? (He(), gr(rR, {
                key: 2,
                config: a.config,
                category: B.value,
                onClose: q,
                onSave: G
            }, null, 8, ["config", "category"])) : Rt("", !0)], 64))
        }
    }, TR = {
        emits: ["next"],
        components: {Buttonwithicon: Ws},
        props: {userDomain: String, apiService: Object},
        async mounted(a) {
            try {
                const c = await this.apiService.getScans();
                this.templates = c
            } catch (c) {
                console.error("Failed to load templates:", c)
            }
        },
        data() {
            return {selectedLanguage: "en", selectedTemplate: "", templates: [], isBox1Open: !1, isBox2Open: !1}
        },
        methods: {
            hasScans() {
                return this.templates.length > 0
            }, toggleBox(a) {
                a === 1 ? (this.isBox1Open = !this.isBox1Open, this.isBox2Open = !1) : a === 2 && (this.isBox2Open = !this.isBox2Open, this.isBox1Open = !1)
            }, nextStep() {
                this.$emit("next", this.selectedTemplate)
            }, startCustomConfiguration() {
                this.selectedTemplate = 0, this.$emit("next", this.selectedTemplate, this.selectedLanguage)
            }, useTemplate() {
                this.selectedTemplate = this.templates.find(a => a.identifier === this.selectedTemplate), this.$emit("next", this.selectedTemplate.identifier, this.selectedLanguage)
            }
        }
    }, Kr = a => ($u("data-v-f3a037fa"), a = a(), Gu(), a),
    IR = Kr(() => J("div", {class: "cf-headline"}, [J("h2", null, "Step 1: Selection"), J("p", null, " Select a template or start with a custom configuration. ")], -1)),
    MR = {class: "cf-bg-gray"}, BR = {class: "start-wrapper"}, NR = {class: "cf-box"},
    LR = Kr(() => J("span", {class: "cf-category-circle"}, "1", -1)),
    PR = Kr(() => J("p", null, "Scan your Website as startup template", -1)),
    OR = Kr(() => J("span", {class: "cf-alert"}, "perfect for beginners", -1)), FR = [LR, PR, OR],
    RR = {class: "cf-box-body"}, zR = {key: 0}, jR = {class: ""}, VR = {class: "cf-box-body-section"},
    HR = {class: "cf-box-body-select"}, UR = {class: "cf-select"},
    qR = Kr(() => J("label", null, "Select a template from the liste", -1)), WR = ["value", "disabled"],
    $R = {class: "cf-select"}, GR = Kr(() => J("label", null, "Select your Website frontend language", -1)),
    KR = Kr(() => J("option", {value: "en"}, "English", -1)), ZR = Kr(() => J("option", {value: "de"}, "German", -1)),
    YR = [KR, ZR], QR = {class: "cf-btn-bar"}, JR = Kr(() => J("div", null, null, -1)), XR = {key: 1},
    ez = {class: "cf-box-body-section"}, tz = ["href"], nz = {class: "cf-box"},
    rz = Kr(() => J("span", {class: "cf-category-circle"}, "2", -1)),
    iz = Kr(() => J("p", null, "Custom Configuration", -1)),
    oz = Kr(() => J("span", {class: "cf-alert"}, "for advanced users", -1)), sz = [rz, iz, oz],
    az = {class: "cf-box-body"},
    lz = Kr(() => J("p", null, "You get a blank cookie configuration, to configure your website.", -1)),
    cz = {class: "cf-select"}, uz = Kr(() => J("label", null, "Select your Website frontend language", -1)),
    dz = Kr(() => J("option", {value: "en"}, "English", -1)), hz = Kr(() => J("option", {value: "de"}, "German", -1)),
    fz = [dz, hz], gz = {class: "cf-btn-bar"};

function pz(a, c, h, b, C, k) {
    const A = Nn("buttonwithicon");
    return He(), tt(ln, null, [IR, J("div", MR, [J("div", BR, [J("div", NR, [J("div", {
        class: "cf-box-header",
        onClick: c[0] || (c[0] = y => k.toggleBox(1))
    }, FR), Bt(J("div", RR, [k.hasScans() ? (He(), tt("div", zR, [J("div", jR, [J("div", VR, [J("div", HR, [J("div", UR, [qR, Bt(J("select", {"onUpdate:modelValue": c[1] || (c[1] = y => C.selectedTemplate = y)}, [(He(!0), tt(ln, null, so(C.templates, y => (He(), tt("option", {
        value: y.identifier,
        key: y.identifier,
        disabled: y.status !== "done"
    }, [Yt(Fn(y.name) + " / ", 1), J("span", null, Fn(y.status), 1)], 8, WR))), 128))], 512), [[xr, C.selectedTemplate]])]), J("div", $R, [GR, Bt(J("select", {"onUpdate:modelValue": c[2] || (c[2] = y => C.selectedLanguage = y)}, YR, 512), [[xr, C.selectedLanguage]])]), J("div", QR, [lt(A, {
        onClick: k.useTemplate,
        btnClass: "cf-color-dark-green",
        icon: "IconArrow"
    }, {
        default: Sr(() => [Yt("Start Configuration")]),
        _: 1
    }, 8, ["onClick"])])]), JR])])])) : (He(), tt("div", XR, [J("div", null, [J("p", null, [Yt("Start a new Scan and come back if done, "), J("span", null, Fn(h.userDomain), 1)]), J("div", ez, [J("a", {
        target: "_blank",
        href: `${h.apiService.getEndPoint()}/administration/manage/${h.apiService.getProjectID()}`
    }, [lt(A, {btnClass: "cf-color-secondary-hover", icon: "IconArrow"}, {
        default: Sr(() => [Yt("start a new Scan")]),
        _: 1
    })], 8, tz)])])]))], 512), [[Hs, C.isBox1Open]])]), J("div", nz, [J("div", {
        class: "cf-box-header",
        onClick: c[3] || (c[3] = y => k.toggleBox(2))
    }, sz), Bt(J("div", az, [lz, J("div", cz, [uz, Bt(J("select", {"onUpdate:modelValue": c[4] || (c[4] = y => C.selectedLanguage = y)}, fz, 512), [[xr, C.selectedLanguage]])]), J("div", gz, [lt(A, {
        onClick: k.startCustomConfiguration,
        btnClass: "cf-color-dark-green",
        icon: "IconArrow"
    }, {
        default: Sr(() => [Yt("Start new custom configuration")]),
        _: 1
    }, 8, ["onClick"])])], 512), [[Hs, C.isBox2Open]])])])])], 64)
}

const mz = Tr(TR, [["render", pz], ["__scopeId", "data-v-f3a037fa"]]), bz = {},
    kz = {xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24"},
    vz = J("path", {d: "M480-160q-134 0-227-93t-93-227q0-134 93-227t227-93q69 0 132 28.5T720-690v-110h80v280H520v-80h168q-32-56-87.5-88T480-720q-100 0-170 70t-70 170q0 100 70 170t170 70q77 0 139-44t87-116h84q-28 106-114 173t-196 67Z"}, null, -1),
    wz = [vz];

function Az(a, c) {
    return He(), tt("svg", kz, wz)
}

const Cz = Tr(bz, [["render", Az]]), _z = {}, yz = a => ($u("data-v-78f2c955"), a = a(), Gu(), a), Dz = {
        xmlns: "http://www.w3.org/2000/svg",
        class: "icon-loading-svg",
        height: "24",
        viewBox: "0 -960 960 960",
        width: "24"
    },
    xz = yz(() => J("path", {d: "M204-318q-22-38-33-78t-11-82q0-134 93-228t227-94h7l-64-64 56-56 160 160-160 160-56-56 64-64h-7q-100 0-170 70.5T240-478q0 26 6 51t18 49l-60 60ZM481-40 321-200l160-160 56 56-64 64h7q100 0 170-70.5T720-482q0-26-6-51t-18-49l60-60q22 38 33 78t11 82q0 134-93 228t-227 94h-7l64 64-56 56Z"}, null, -1)),
    Ez = [xz];

function Sz(a, c) {
    return He(), tt("svg", Dz, Ez)
}

const Tz = Tr(_z, [["render", Sz], ["__scopeId", "data-v-78f2c955"]]), Iz = {
        components: {cfckeditor: Cv, Buttonwithicon: Ws, Cfinput: wv, iconRefresh: Cz, iconLoading: Tz, LinkComponent: s0},
        props: {config: Object, iframemanagerconfig: Object, userDomain: String},
        setup(a) {
            const c = jr({type: "", additionalScript: "", additionalHtml: "", html: ""}), h = yt("consent"), b = yt(!0);
            let C = null;
            const k = yt(null), A = yt(!1);
            let y = {
                "--cc-bg": {
                    name: "--cc-bg",
                    code: "#f9faff",
                    displayName: "Background Color",
                    description: "The background color of the application modal.",
                    group: "General Colors"
                },
                "--cc-text": {
                    name: "--cc-text",
                    code: "#112954",
                    displayName: "Text Color",
                    description: "The color of the text in the application.",
                    group: "General Colors"
                },
                "--cc-btn-primary-bg": {
                    name: "--cc-btn-primary-bg",
                    code: "#3859d0",
                    displayName: "Primary Button Background Color",
                    description: "The background color of primary buttons.",
                    group: "Button Colors"
                },
                "--cc-btn-primary-hover-bg": {
                    name: "--cc-btn-primary-hover-bg",
                    code: "#1d2e38",
                    displayName: "Primary Button Hover Background Color",
                    description: "The background color of primary buttons when hovered.",
                    group: "Button Colors"
                },
                "--cc-btn-secondary-bg": {
                    name: "--cc-btn-secondary-bg",
                    code: "#dfe7f9",
                    displayName: "Secondary Button Background Color",
                    description: "The background color of secondary buttons.",
                    group: "Button Colors"
                },
                "--cc-btn-secondary-hover-bg": {
                    name: "--cc-btn-secondary-hover-bg",
                    code: "#c6d1ea",
                    displayName: "Secondary Button Hover Background Color",
                    description: "The background color of secondary buttons when hovered.",
                    group: "Button Colors"
                },
                "--cc-toggle-bg-off": {
                    name: "--cc-toggle-bg-off",
                    code: "#8fa8d6",
                    displayName: "Toggle Off Background Color",
                    description: "The background color of the toggle when it is off.",
                    group: "Toggle Colors"
                },
                "--cc-toggle-bg-on": {
                    name: "--cc-toggle-bg-on",
                    code: "#3859d0",
                    displayName: "Toggle On Background Color",
                    description: "The background color of the toggle when it is on.",
                    group: "Toggle Colors"
                },
                "--cc-toggle-bg-readonly": {
                    name: "--cc-toggle-bg-readonly",
                    code: "#cbd8f1",
                    displayName: "Toggle Readonly Background Color",
                    description: "The background color of the toggle when it is readonly.",
                    group: "Toggle Colors"
                },
                "--cc-toggle-knob-bg": {
                    name: "--cc-toggle-knob-bg",
                    code: "#fff",
                    displayName: "Toggle Knob Background Color",
                    description: "The background color of the toggle knob.",
                    group: "Toggle Colors"
                },
                "--cc-toggle-knob-icon-color": {
                    name: "--cc-toggle-knob-icon-color",
                    code: "#ecf2fa",
                    displayName: "Toggle Knob Icon Color",
                    description: "The color of the toggle knob icon.",
                    group: "Toggle Colors"
                },
                "--cc-cookie-category-block-bg": {
                    name: "--cc-cookie-category-block-bg",
                    code: "#ebeff9",
                    displayName: "Cookie Category Block Background Color",
                    description: "The background color of the cookie category block.",
                    group: "Block Colors"
                },
                "--cc-cookie-category-block-bg-hover": {
                    name: "--cc-cookie-category-block-bg-hover",
                    code: "#dbe5f9",
                    displayName: "Cookie Category Block Hover Background Color",
                    description: "The background color of the cookie category block when hovered.",
                    group: "Block Colors"
                },
                "--cc-section-border": {
                    name: "--cc-section-border",
                    code: "#f1f3f5",
                    displayName: "Section Border Color",
                    description: "The color of the section borders.",
                    group: "Border Colors"
                },
                "--cc-cookie-table-border": {
                    name: "--cc-cookie-table-border",
                    code: "#e1e7f3",
                    displayName: "Cookie Table Border Color",
                    description: "The color of the borders on the cookie table.",
                    group: "Border Colors"
                },
                "--cc-overlay-bg": {
                    name: "--cc-overlay-bg",
                    code: "rgba(230, 235, 255, .85)",
                    displayName: "Overlay Background Color",
                    description: "The background color of the overlay.",
                    group: "Overlay Colors"
                },
                "--cc-webkit-scrollbar-bg": {
                    name: "--cc-webkit-scrollbar-bg",
                    code: "#ebeff9",
                    displayName: "Scrollbar Background Color",
                    description: "The background color of the scrollbar.",
                    group: "Scrollbar Colors"
                },
                "--cc-webkit-scrollbar-bg-hover": {
                    name: "--cc-webkit-scrollbar-bg-hover",
                    code: "#3859d0",
                    displayName: "Scrollbar Hover Background Color",
                    description: "The background color of the scrollbar when hovered.",
                    group: "Scrollbar Colors"
                }
            };
            const w = tn(() => {
                const G = {};
                for (const Z of Object.values(y)) G[Z.group] || (G[Z.group] = []), G[Z.group].push(Z);
                return G
            }), S = () => {
                C && clearTimeout(C), A.value = !0, b.value = !1, C = setTimeout(() => {
                    z(), A.value = !1
                }, 1e3)
            };
            or(() => a.config, () => {
                S()
            }, {deep: !0}), or(() => h.value, () => {
                B()
            }), Oi(() => {
                B()
            });
            const I = () => Math.random().toString(36).substring(2, 15), T = () => {
                const G = document.getElementById("configurator-iframe");
                G && G.remove()
            }, D = () => {
                const G = document.createElement("iframe"), Z = ei.getEndPoint(), Y = ei.getProjectID(),
                    ce = `${Z}/manage/ajax/fetch-frame/${Y}`;
                G.id = "configurator-iframe", G.srcdoc = `
        ${c.additionalHtml}
        <iframe class="cf-iframe" src="${ce}" width="1200" height="700" frameborder="0">
          <style>
            body {
              margin: 0;
            }
            .cf-iframe{
              border: none;
            }
            #cc--main{
              display: none !important;
            }
          </style>
        </iframe>
        <script src="${Z}/manage/ajax/render-config/${Y}"><\/script>
        <script>${c.additionalScript}<\/script>
      `, G.height = 500, G.width = "100%", G.style = `
        width: 167%;
        height: 170%;
        transform: translate3d(0%, 0%, 0px) scale(0.6);
        transform-origin: left top;
        border: none;
        border-radius: 25px;
      `, k.value.appendChild(G)
            }, B = () => {
                T(), document.cookie = "cf_cookie=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;", h.value === "settings" ? (c.additionalScript = "cc.showSettings(); cc.hide();", c.additionalHtml = "<style>#cc--main #cc_div #cm{ display:none !important;}</style>") : (c.additionalScript = "cc.hideSettings(); cc.show();", c.additionalHtml = ""), D()
            }, L = async () => {
                const G = JSON.stringify({iframeManagerConfig: a.iframemanagerconfig, config: a.config});
                await ei.saveData(G)
            }, z = () => {
                L(), setTimeout(() => {
                    B(), b.value = !0
                }, 1e3)
            };
            return {
                iframeHolder: k,
                iframeData: c,
                updateIframe: B,
                debouncedUpdateData: S,
                activeTab: h,
                updateStatus: b,
                generateUniqueId: I,
                removeExistingIframe: T,
                createIframe: D,
                saveData: L,
                updateData: z,
                updateDataPolicyLink: G => {
                    a.config.languages.en.consent_modal.data_policy_link = G
                },
                generateCSS: () => {
                    let G = `:root:root {
`;
                    for (const Z of Object.values(y)) G += `  ${Z.name}: ${Z.code};
`;
                    G += `}
`, a.config.customStyle = G
                },
                groupedColors: w,
                colors: y
            }
        },
        data() {
            return {iframeSrc: "", editor: Av, editorConfig: {toolbar: ["bold", "italic", "link"], language: "en"}}
        },
        methods: {
            nextStep() {
                this.$emit("next")
            }, previousStep() {
                this.$emit("back")
            }
        }
    }, kt = a => ($u("data-v-17624c1c"), a = a(), Gu(), a),
    Mz = kt(() => J("div", {class: "cf-stepheader"}, [J("h2", null, "Step 3: Configure Your Theme"), J("p", null, "Here you can customize the appearance and texts and styles of your cookie application.")], -1)),
    Bz = {class: "cf-configurator-tab-menu"}, Nz = {class: "cf-container"}, Lz = {key: 0},
    Pz = {class: "cf-form-container", style: {"margin-top": "70px", height: "600px", "overflow-y": "scroll"}},
    Oz = kt(() => J("label", {for: "title"}, "Title", -1)),
    Fz = kt(() => J("label", {for: "description"}, "Description", -1)), Rz = kt(() => J("hr", null, null, -1)),
    zz = kt(() => J("br", null, null, -1)),
    jz = kt(() => J("label", {for: "primary_btn_text"}, "Primary Button Text", -1)),
    Vz = kt(() => J("label", {for: "primary_btn_role"}, "Primary Button Role", -1)),
    Hz = kt(() => J("option", {value: "settings"}, "Settings", -1)),
    Uz = kt(() => J("option", {value: "accept_all"}, "Accept All", -1)),
    qz = kt(() => J("option", {value: "display_none"}, "Display None", -1)),
    Wz = kt(() => J("option", {value: "accept_necessary"}, "Accept Necessary", -1)), $z = [Hz, Uz, qz, Wz],
    Gz = kt(() => J("br", null, null, -1)), Kz = kt(() => J("hr", null, null, -1)),
    Zz = kt(() => J("br", null, null, -1)),
    Yz = kt(() => J("label", {for: "secondary_btn_text"}, "Secondary Button Text", -1)),
    Qz = kt(() => J("label", {for: "secondary_btn_role"}, "Secondary Button Role", -1)),
    Jz = kt(() => J("option", {value: "settings"}, "Settings", -1)),
    Xz = kt(() => J("option", {value: "accept_all"}, "Accept All", -1)),
    ej = kt(() => J("option", {value: "display_none"}, "Display None", -1)),
    tj = kt(() => J("option", {value: "accept_necessary"}, "Accept Necessary", -1)), nj = [Jz, Xz, ej, tj],
    rj = kt(() => J("br", null, null, -1)), ij = kt(() => J("hr", null, null, -1)),
    oj = kt(() => J("br", null, null, -1)),
    sj = kt(() => J("label", {for: "tertiary_btn_text"}, "Tertiary Button Text", -1)),
    aj = kt(() => J("label", {for: "tertiary_btn_role"}, "Tertiary Button Role", -1)),
    lj = kt(() => J("option", {value: "settings"}, "Settings", -1)),
    cj = kt(() => J("option", {value: "accept_all"}, "Accept All", -1)),
    uj = kt(() => J("option", {value: "display_none"}, "Display None", -1)),
    dj = kt(() => J("option", {value: "accept_necessary"}, "Accept Necessary", -1)), hj = [lj, cj, uj, dj],
    fj = kt(() => J("br", null, null, -1)), gj = kt(() => J("hr", null, null, -1)),
    pj = kt(() => J("br", null, null, -1)),
    mj = kt(() => J("label", {for: "data_policy_link"}, "Data Policy Link", -1)),
    bj = kt(() => J("label", {for: "impress_link"}, "Impress Link", -1)),
    kj = kt(() => J("label", {for: "revision_message"}, "Revision Message", -1)), vj = {key: 1},
    wj = {class: "cf-form-container", style: {"margin-top": "70px"}},
    Aj = kt(() => J("label", {for: "accept_all_btn"}, "Accept All Button Text", -1)),
    Cj = kt(() => J("label", {for: "reject_all_btn"}, "Reject All Button Text", -1)),
    _j = kt(() => J("label", {for: "save_settings_btn"}, "Save Settings Button Text", -1)),
    yj = kt(() => J("label", {for: "settings_title"}, "Title", -1)),
    Dj = kt(() => J("label", {for: "settings_title"}, "Info-Title", -1)), xj = {key: 2}, Ej = {
        class: "",
        style: {
            flex: "0 0 40%",
            padding: "20px",
            "box-sizing": "border-box",
            "margin-top": "70px",
            height: "600px",
            "overflow-y": "scroll"
        }
    }, Sj = ["id", "onUpdate:modelValue"], Tj = ["for"], Ij = kt(() => J("br", null, null, -1)),
    Mj = {class: "iframe-container"}, Bj = {class: "cf-automatic-reload"}, Nj = {class: "cf-automatic-reload-inner"},
    Lj = {key: 0, class: "cf-category-circle"}, Pj = {key: 1, class: "cf-category-circle"},
    Oj = {class: "cf-form-container", style: {"padding-bottom": "0"}}, Fj = {key: 0, style: {display: "flex"}},
    Rj = {class: "cf-configurator-modal-form-block"}, zj = kt(() => J("label", {for: "consent_layout"}, "Layout", -1)),
    jj = kt(() => J("option", {value: "box"}, "Box", -1)), Vj = kt(() => J("option", {value: "bar"}, "Bar", -1)),
    Hj = kt(() => J("option", {value: "cloud"}, "Cloud", -1)), Uj = [jj, Vj, Hj],
    qj = {class: "cf-configurator-modal-form-block"},
    Wj = kt(() => J("label", {for: "consent_position"}, "Position", -1)),
    $j = j0('<option value="middle center" data-v-17624c1c>middle center</option><option value="middle left" data-v-17624c1c>middle left</option><option value="middle right" data-v-17624c1c>middle right</option><option value="top left" data-v-17624c1c>top left</option><option value="top right" data-v-17624c1c>top right</option><option value="top center" data-v-17624c1c>top center</option><option value="bottom left" data-v-17624c1c>bottom left</option><option value="bottom right" data-v-17624c1c>bottom right</option><option value="bottom center" data-v-17624c1c>bottom center</option>', 9),
    Gj = [$j], Kj = {class: "cf-configurator-modal-form-block"},
    Zj = kt(() => J("label", {for: "consent_transition"}, "Transition", -1)),
    Yj = kt(() => J("option", {value: "slide"}, "Slide", -1)), Qj = kt(() => J("option", {value: "fade"}, "Fade", -1)),
    Jj = [Yj, Qj], Xj = {key: 1}, eV = {style: {display: "flex"}}, tV = {class: "cf-configurator-modal-form-block"},
    nV = kt(() => J("label", {for: "settings_layout"}, "Layout", -1)),
    rV = kt(() => J("option", {value: "box"}, "Box", -1)), iV = kt(() => J("option", {value: "bar"}, "Bar", -1)),
    oV = [rV, iV], sV = {class: "cf-configurator-modal-form-block"},
    aV = kt(() => J("label", {for: "settings_position"}, "Position", -1)),
    lV = kt(() => J("option", {value: ""}, "None", -1)), cV = kt(() => J("option", {value: "right"}, "Right", -1)),
    uV = kt(() => J("option", {value: "left"}, "Left", -1)), dV = [lV, cV, uV],
    hV = {class: "cf-configurator-modal-form-block"},
    fV = kt(() => J("label", {for: "settings_transition"}, "Transition", -1)),
    gV = kt(() => J("option", {value: "slide"}, "Slide", -1)), pV = kt(() => J("option", {value: "fade"}, "Fade", -1)),
    mV = [gV, pV], bV = {class: "iframe-container-inner iframeHolder", ref: "iframeHolder"},
    kV = {key: 0, class: "cf-loading-overlay"}, vV = {class: "cf-loading-icon"}, wV = {class: "cf-btn-bar"};

function AV(a, c, h, b, C, k) {
    const A = Nn("ckeditor"), y = Nn("LinkComponent"), w = Nn("cfckeditor"), S = Nn("iconRefresh"),
        I = Nn("iconLoading"), T = Nn("buttonwithicon");
    return He(), tt("div", null, [Mz, J("div", Bz, [J("div", {
        onClick: c[0] || (c[0] = D => b.activeTab = "consent"),
        class: On({active: b.activeTab === "consent"})
    }, "Consent Modal", 2), J("div", {
        onClick: c[1] || (c[1] = D => b.activeTab = "settings"),
        class: On({active: b.activeTab === "settings"})
    }, "Settings Modal", 2), J("div", {
        onClick: c[2] || (c[2] = D => b.activeTab = "style"),
        class: On({active: b.activeTab === "style"})
    }, "Style", 2)]), J("div", Nz, [b.activeTab === "consent" ? (He(), tt("div", Lz, [J("div", Pz, [Oz, Bt(J("input", {
        id: "title",
        "onUpdate:modelValue": c[3] || (c[3] = D => h.config.languages.en.consent_modal.title = D)
    }, null, 512), [[Vn, h.config.languages.en.consent_modal.title]]), Fz, lt(A, {
        editor: C.editor,
        modelValue: h.config.languages.en.consent_modal.description,
        "onUpdate:modelValue": c[4] || (c[4] = D => h.config.languages.en.consent_modal.description = D),
        config: C.editorConfig
    }, null, 8, ["editor", "modelValue", "config"]), Rz, zz, jz, Bt(J("input", {
        id: "primary_btn_text",
        "onUpdate:modelValue": c[5] || (c[5] = D => h.config.languages.en.consent_modal.primary_btn.text = D)
    }, null, 512), [[Vn, h.config.languages.en.consent_modal.primary_btn.text]]), Vz, Bt(J("select", {
        id: "primary_btn_role",
        "onUpdate:modelValue": c[6] || (c[6] = D => h.config.languages.en.consent_modal.primary_btn.role = D)
    }, $z, 512), [[xr, h.config.languages.en.consent_modal.primary_btn.role]]), Gz, Kz, Zz, Yz, Bt(J("input", {
        id: "secondary_btn_text",
        "onUpdate:modelValue": c[7] || (c[7] = D => h.config.languages.en.consent_modal.secondary_btn.text = D)
    }, null, 512), [[Vn, h.config.languages.en.consent_modal.secondary_btn.text]]), Qz, Bt(J("select", {
        id: "secondary_btn_role",
        "onUpdate:modelValue": c[8] || (c[8] = D => h.config.languages.en.consent_modal.secondary_btn.role = D)
    }, nj, 512), [[xr, h.config.languages.en.consent_modal.secondary_btn.role]]), rj, ij, oj, sj, Bt(J("input", {
        id: "tertiary_btn_text",
        "onUpdate:modelValue": c[9] || (c[9] = D => h.config.languages.en.consent_modal.tertiary_btn.text = D)
    }, null, 512), [[Vn, h.config.languages.en.consent_modal.tertiary_btn.text]]), aj, Bt(J("select", {
        id: "tertiary_btn_role",
        "onUpdate:modelValue": c[10] || (c[10] = D => h.config.languages.en.consent_modal.tertiary_btn.role = D)
    }, hj, 512), [[xr, h.config.languages.en.consent_modal.tertiary_btn.role]]), fj, gj, pj, mj, lt(y, {
        modelValue: h.config.languages.en.consent_modal.data_policy_link,
        "onUpdate:modelValue": c[11] || (c[11] = D => h.config.languages.en.consent_modal.data_policy_link = D)
    }, null, 8, ["modelValue"]), bj, lt(y, {
        modelValue: h.config.languages.en.consent_modal.impress_link,
        "onUpdate:modelValue": c[12] || (c[12] = D => h.config.languages.en.consent_modal.impress_link = D)
    }, null, 8, ["modelValue"]), kj, lt(A, {
        editor: C.editor,
        modelValue: h.config.languages.en.consent_modal.revision_message,
        "onUpdate:modelValue": c[13] || (c[13] = D => h.config.languages.en.consent_modal.revision_message = D),
        config: C.editorConfig
    }, null, 8, ["editor", "modelValue", "config"])])])) : Rt("", !0), b.activeTab === "settings" ? (He(), tt("div", vj, [J("div", wj, [Aj, Bt(J("input", {
        id: "accept_all_btn",
        "onUpdate:modelValue": c[14] || (c[14] = D => h.config.languages.en.settings_modal.accept_all_btn = D)
    }, null, 512), [[Vn, h.config.languages.en.settings_modal.accept_all_btn]]), Cj, Bt(J("input", {
        id: "reject_all_btn",
        "onUpdate:modelValue": c[15] || (c[15] = D => h.config.languages.en.settings_modal.reject_all_btn = D)
    }, null, 512), [[Vn, h.config.languages.en.settings_modal.reject_all_btn]]), _j, Bt(J("input", {
        id: "save_settings_btn",
        "onUpdate:modelValue": c[16] || (c[16] = D => h.config.languages.en.settings_modal.save_settings_btn = D)
    }, null, 512), [[Vn, h.config.languages.en.settings_modal.save_settings_btn]]), yj, Bt(J("input", {
        id: "settings_title",
        "onUpdate:modelValue": c[17] || (c[17] = D => h.config.languages.en.settings_modal.title = D)
    }, null, 512), [[Vn, h.config.languages.en.settings_modal.title]]), Dj, Bt(J("input", {
        id: "settings_title",
        "onUpdate:modelValue": c[18] || (c[18] = D => h.config.languages.en.settings_modal.blocks[0].title = D)
    }, null, 512), [[Vn, h.config.languages.en.settings_modal.blocks[0].title]]), h.config.languages.en.settings_modal.blocks[0].description ? (He(), gr(w, {
        key: 0,
        title: "Info-Description",
        description: "Description of the category.",
        modelValue: h.config.languages.en.settings_modal.blocks[0].description,
        "onUpdate:modelValue": c[19] || (c[19] = D => h.config.languages.en.settings_modal.blocks[0].description = D)
    }, null, 8, ["modelValue"])) : Rt("", !0)])])) : Rt("", !0), b.activeTab === "style" ? (He(), tt("div", xj, [J("div", Ej, [J("div", null, [(He(!0), tt(ln, null, so(b.groupedColors, (D, B) => (He(), tt("div", {
        key: B,
        style: {"margin-bottom": "20px"}
    }, [J("h2", null, Fn(B), 1), (He(!0), tt(ln, null, so(D, (L, z) => (He(), tt("div", {
        key: z,
        style: {"margin-bottom": "10px", "border-bottom": "solid 1px"}
    }, [Bt(J("input", {
        style: {width: "25px", height: "25px", "margin-right": "10px"},
        class: "cfcolorinput",
        type: "color",
        id: z,
        "onUpdate:modelValue": q => L.code = q,
        onInput: c[20] || (c[20] = (...q) => b.generateCSS && b.generateCSS(...q))
    }, null, 40, Sj), [[Vn, L.code]]), J("label", {for: z}, Fn(L.displayName), 9, Tj), Ij, J("small", null, Fn(L.description), 1)]))), 128))]))), 128))])])])) : Rt("", !0), J("div", Mj, [J("div", Bj, [J("div", {
        class: "cf-loading-bar",
        onClick: c[21] || (c[21] = (...D) => b.debouncedUpdateData && b.debouncedUpdateData(...D))
    }, [J("div", Nj, [b.updateStatus === !0 ? (He(), tt("div", Lj, [lt(S)])) : (He(), tt("div", Pj, [lt(I)])), Yt(" Refresh preview ")])])]), J("div", Oj, [b.activeTab === "consent" ? (He(), tt("div", Fj, [J("div", Rj, [zj, Bt(J("select", {
        id: "consent_layout",
        "onUpdate:modelValue": c[22] || (c[22] = D => h.config.gui_options.consent_modal.layout = D)
    }, Uj, 512), [[xr, h.config.gui_options.consent_modal.layout]])]), J("div", qj, [Wj, Bt(J("select", {
        id: "consent_position",
        "onUpdate:modelValue": c[23] || (c[23] = D => h.config.gui_options.consent_modal.position = D)
    }, Gj, 512), [[xr, h.config.gui_options.consent_modal.position]])]), J("div", Kj, [Zj, Bt(J("select", {
        id: "consent_transition",
        "onUpdate:modelValue": c[24] || (c[24] = D => h.config.gui_options.consent_modal.transition = D)
    }, Jj, 512), [[xr, h.config.gui_options.consent_modal.transition]])])])) : Rt("", !0), b.activeTab === "settings" ? (He(), tt("div", Xj, [J("div", eV, [J("div", tV, [nV, Bt(J("select", {
        id: "settings_layout",
        "onUpdate:modelValue": c[25] || (c[25] = D => h.config.gui_options.settings_modal.layout = D)
    }, oV, 512), [[xr, h.config.gui_options.settings_modal.layout]])]), J("div", sV, [aV, Bt(J("select", {
        id: "settings_position",
        "onUpdate:modelValue": c[26] || (c[26] = D => h.config.gui_options.settings_modal.position = D)
    }, dV, 512), [[xr, h.config.gui_options.settings_modal.position]])]), J("div", hV, [fV, Bt(J("select", {
        id: "settings_transition",
        "onUpdate:modelValue": c[27] || (c[27] = D => h.config.gui_options.settings_modal.transition = D)
    }, mV, 512), [[xr, h.config.gui_options.settings_modal.transition]])])])])) : Rt("", !0)]), J("div", bV, [b.updateStatus ? Rt("", !0) : (He(), tt("div", kV, [J("div", vV, [lt(I)])]))], 512)])]), J("div", wV, [lt(T, {
        position: "left",
        icon: "IconArrow",
        onClick: k.previousStep
    }, {default: Sr(() => [Yt("back")]), _: 1}, 8, ["onClick"]), lt(T, {
        btnClass: "cf-color-dark-green",
        icon: "IconArrow",
        onClick: k.nextStep
    }, {default: Sr(() => [Yt("next Step")]), _: 1}, 8, ["onClick"])])])
}

const CV = Tr(Iz, [["render", AV], ["__scopeId", "data-v-17624c1c"]]), _V = {
        components: {Buttonwithicon: Ws}, data() {
            return {}
        }, methods: {
            async publishConfiguration() {
                try {
                    const a = await ei.publish();
                    console.log(a);
                    let c = new URL(window.location.href);
                    c.searchParams.set("cfcookiemanager-published", "true"), window.location.href = c.toString()
                } catch {
                }
            }
        }, mounted() {
        }
    },
    yV = J("div", {class: "cf-headline"}, [J("h2", null, "Step 4: Publish"), J("p", null, " Publish your configuration live, or go back to edit. ")], -1),
    DV = {class: "cf-bg-gray"}, xV = J("br", null, null, -1), EV = J("br", null, null, -1),
    SV = J("br", null, null, -1), TV = {class: "cf-btn-bar"};

function IV(a, c, h, b, C, k) {
    const A = Nn("buttonwithicon");
    return He(), tt(ln, null, [yV, J("div", DV, [Yt(" You're one step away from deploying your Cookie Manager to your production embed."), xV, Yt(' By clicking "Publish", your Cookie Manager configuration will go live on your website. (If embbeded by CDN) '), EV, SV, Yt(" Until you publish, your configuration remains in draft mode and won't be visible to your website visitors. "), J("div", TV, [lt(A, {
        onClick: c[0] || (c[0] = y => a.$emit("backToEdit")),
        btnClass: "cf-color-dark-green",
        icon: "IconArrow",
        position: "left"
    }, {default: Sr(() => [Yt("Back to edit")]), _: 1}), lt(A, {
        onClick: k.publishConfiguration,
        btnClass: "cf-color-dark-green",
        icon: "IconArrow"
    }, {default: Sr(() => [Yt("Publish")]), _: 1}, 8, ["onClick"])])])], 64)
}

const MV = Tr(_V, [["render", IV]]), BV = {class: "cf-cookiemanager-headless"}, NV = {key: 0}, LV = {key: 1},
    PV = {key: 2, class: "cf-wrapper"}, OV = {
        __name: "App", setup(a) {
            const c = yt(null), h = yt(null), b = yt(null), C = yt(1), k = yt(null), A = yt(null), y = yt(null),
                w = yt(null), S = yt(!0), I = yt(null);
            hc("invalidServices", $h), hc("validateServices", D5);
            const T = async (B = 0, L = "en") => {
                k.value = B;
                const z = await ei.loadData(k.value, L);
                h.value = jr(z.config), b.value = jr(z.iframeManagerConfig), C.value++
            }, D = async () => {
                const B = document.getElementById("app");
                A.value = B.getAttribute("data-cf-apikey"), y.value = B.getAttribute("data-cf-secret"), w.value = B.getAttribute("data-cf-endpoint"), (A.value || w.value) && (ei.setApiKey(y.value), ei.setProjectID(A.value), ei.setEndPoint(w.value), console.log(ei.getEndPoint()), console.log(ei.getProjectID()))
            };
            return Oi(async () => {
                await D();
                try {
                    const B = await ei.getStartInfo();
                    typeof B.error < "u" ? I.value = B.error : (c.value = B.domain, S.value = !1, B.hasConfig && T(0))
                } catch (B) {
                    I.value = B.message
                }
            }), (B, L) => (He(), tt("div", BV, [S.value ? (He(), tt("div", NV, "Loading...")) : Rt("", !0), I.value ? (He(), tt("div", LV, Fn(I.value), 1)) : (He(), tt("div", PV, [C.value === 1 && !S.value ? (He(), gr(mz, {
                key: 0,
                onNext: T,
                userDomain: c.value,
                apiService: xt(ei)
            }, null, 8, ["userDomain", "apiService"])) : Rt("", !0), C.value === 2 ? (He(), gr(SR, {
                key: 1,
                config: h.value,
                iframemanagerconfig: b.value,
                onNext: T,
                onBack: L[0] || (L[0] = z => C.value--)
            }, null, 8, ["config", "iframemanagerconfig"])) : Rt("", !0), C.value === 3 ? (He(), gr(CV, {
                key: 2,
                onNext: L[1] || (L[1] = z => C.value++),
                userDomain: c.value,
                config: h.value,
                iframemanagerconfig: b.value,
                onBack: L[2] || (L[2] = z => C.value--)
            }, null, 8, ["userDomain", "config", "iframemanagerconfig"])) : Rt("", !0), C.value === 4 ? (He(), gr(MV, {
                key: 3,
                config: h.value,
                iframemanagerconfig: b.value,
                userDomain: c.value,
                onBackToEdit: L[3] || (L[3] = z => C.value = 3)
            }, null, 8, ["config", "iframemanagerconfig", "userDomain"])) : Rt("", !0)]))]))
        }
    };
var z5 = {exports: {}};
const FV = g8(x9);/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function (a, c) {
    (function (h, b) {
        a.exports = b(FV)
    })(self, h => (() => {
        var b = {
            976: y => {
                y.exports = h
            }
        }, C = {};

        function k(y) {
            var w = C[y];
            if (w !== void 0) return w.exports;
            var S = C[y] = {exports: {}};
            return b[y](S, S.exports, k), S.exports
        }

        k.d = (y, w) => {
            for (var S in w) k.o(w, S) && !k.o(y, S) && Object.defineProperty(y, S, {enumerable: !0, get: w[S]})
        }, k.o = (y, w) => Object.prototype.hasOwnProperty.call(y, w);
        var A = {};
        return (() => {
            k.d(A, {default: () => Tt});
            var y = k(976);
            const w = function (Pe) {
                var At = typeof Pe;
                return Pe != null && (At == "object" || At == "function")
            }, S = typeof oo == "object" && oo && oo.Object === Object && oo;
            var I = typeof self == "object" && self && self.Object === Object && self;
            const T = S || I || Function("return this")(), D = function () {
                return T.Date.now()
            };
            var B = /\s/;
            const L = function (Pe) {
                for (var At = Pe.length; At-- && B.test(Pe.charAt(At));) ;
                return At
            };
            var z = /^\s+/;
            const q = function (Pe) {
                return Pe && Pe.slice(0, L(Pe) + 1).replace(z, "")
            }, Q = T.Symbol;
            var G = Object.prototype, Z = G.hasOwnProperty, Y = G.toString, ce = Q ? Q.toStringTag : void 0;
            const Ce = function (Pe) {
                var At = Z.call(Pe, ce), mt = Pe[ce];
                try {
                    Pe[ce] = void 0;
                    var Ye = !0
                } catch {
                }
                var Oe = Y.call(Pe);
                return Ye && (At ? Pe[ce] = mt : delete Pe[ce]), Oe
            };
            var me = Object.prototype.toString;
            const R = function (Pe) {
                return me.call(Pe)
            };
            var ae = Q ? Q.toStringTag : void 0;
            const ue = function (Pe) {
                return Pe == null ? Pe === void 0 ? "[object Undefined]" : "[object Null]" : ae && ae in Object(Pe) ? Ce(Pe) : R(Pe)
            }, ve = function (Pe) {
                return Pe != null && typeof Pe == "object"
            }, ke = function (Pe) {
                return typeof Pe == "symbol" || ve(Pe) && ue(Pe) == "[object Symbol]"
            };
            var le = /^[-+]0x[0-9a-f]+$/i, ye = /^0b[01]+$/i, ee = /^0o[0-7]+$/i, qe = parseInt;
            const Ze = function (Pe) {
                if (typeof Pe == "number") return Pe;
                if (ke(Pe)) return NaN;
                if (w(Pe)) {
                    var At = typeof Pe.valueOf == "function" ? Pe.valueOf() : Pe;
                    Pe = w(At) ? At + "" : At
                }
                if (typeof Pe != "string") return Pe === 0 ? Pe : +Pe;
                Pe = q(Pe);
                var mt = ye.test(Pe);
                return mt || ee.test(Pe) ? qe(Pe.slice(2), mt ? 2 : 8) : le.test(Pe) ? NaN : +Pe
            };
            var Xe = Math.max, Le = Math.min;
            const it = function (Pe, At, mt) {
                var Ye, Oe, ht, vt, Vt, ct, se = 0, ge = !1, we = !1, Me = !0;
                if (typeof Pe != "function") throw new TypeError("Expected a function");

                function Be(te) {
                    var oe = Ye, de = Oe;
                    return Ye = Oe = void 0, se = te, vt = Pe.apply(de, oe)
                }

                function Ue(te) {
                    return se = te, Vt = setTimeout(ze, At), ge ? Be(te) : vt
                }

                function Ge(te) {
                    var oe = te - ct;
                    return ct === void 0 || oe >= At || oe < 0 || we && te - se >= ht
                }

                function ze() {
                    var te = D();
                    if (Ge(te)) return V(te);
                    Vt = setTimeout(ze, function (oe) {
                        var de = At - (oe - ct);
                        return we ? Le(de, ht - (oe - se)) : de
                    }(te))
                }

                function V(te) {
                    return Vt = void 0, Me && Ye ? Be(te) : (Ye = Oe = void 0, vt)
                }

                function $() {
                    var te = D(), oe = Ge(te);
                    if (Ye = arguments, Oe = this, ct = te, oe) {
                        if (Vt === void 0) return Ue(ct);
                        if (we) return clearTimeout(Vt), Vt = setTimeout(ze, At), Be(ct)
                    }
                    return Vt === void 0 && (Vt = setTimeout(ze, At)), vt
                }

                return At = Ze(At) || 0, w(mt) && (ge = !!mt.leading, ht = (we = "maxWait" in mt) ? Xe(Ze(mt.maxWait) || 0, At) : ht, Me = "trailing" in mt ? !!mt.trailing : Me), $.cancel = function () {
                    Vt !== void 0 && clearTimeout(Vt), se = 0, Ye = ct = Oe = Vt = void 0
                }, $.flush = function () {
                    return Vt === void 0 ? vt : V(D())
                }, $
            }, _t = (0, y.defineComponent)({
                name: "Ckeditor",
                model: {prop: "modelValue", event: "update:modelValue"},
                props: {
                    editor: {type: Function, required: !0},
                    config: {type: Object, default: () => ({})},
                    modelValue: {type: String, default: ""},
                    tagName: {type: String, default: "div"},
                    disabled: {type: Boolean, default: !1},
                    disableTwoWayDataBinding: {type: Boolean, default: !1}
                },
                emits: ["ready", "destroy", "blur", "focus", "input", "update:modelValue"],
                data: () => ({instance: null, lastEditorData: null}),
                watch: {
                    modelValue(Pe) {
                        this.instance && Pe !== this.lastEditorData && this.instance.data.set(Pe)
                    }, disabled(Pe) {
                        Pe ? this.instance.enableReadOnlyMode("Integration Sample") : this.instance.disableReadOnlyMode("Integration Sample")
                    }
                },
                created() {
                    const {CKEDITOR_VERSION: Pe} = window;
                    if (Pe) {
                        const [At] = Pe.split(".").map(Number);
                        At < 37 && console.warn("The <CKEditor> component requires using CKEditor 5 in version 37 or higher.")
                    } else console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.')
                },
                mounted() {
                    const Pe = Object.assign({}, this.config);
                    this.modelValue && (Pe.initialData = this.modelValue), this.editor.create(this.$el, Pe).then(At => {
                        this.instance = (0, y.markRaw)(At), this.setUpEditorEvents(), this.modelValue !== Pe.initialData && At.data.set(this.modelValue), this.disabled && At.enableReadOnlyMode("Integration Sample"), this.$emit("ready", At)
                    }).catch(At => {
                        console.error(At)
                    })
                },
                beforeUnmount() {
                    this.instance && (this.instance.destroy(), this.instance = null), this.$emit("destroy", this.instance)
                },
                methods: {
                    setUpEditorEvents() {
                        const Pe = this.instance, At = it(mt => {
                            if (this.disableTwoWayDataBinding) return;
                            const Ye = this.lastEditorData = Pe.data.get();
                            this.$emit("update:modelValue", Ye, mt, Pe), this.$emit("input", Ye, mt, Pe)
                        }, 300, {leading: !0});
                        Pe.model.document.on("change:data", At), Pe.editing.view.document.on("focus", mt => {
                            this.$emit("focus", mt, Pe)
                        }), Pe.editing.view.document.on("blur", mt => {
                            this.$emit("blur", mt, Pe)
                        })
                    }
                },
                render() {
                    return (0, y.h)(this.tagName)
                }
            });
            if (!y.version || !y.version.startsWith("3.")) throw new Error("The CKEditor plugin works only with Vue 3+. For more information, please refer to https://ckeditor.com/docs/ckeditor5/latest/builds/guides/integration/frameworks/vuejs-v3.html");
            const Tt = {
                install(Pe) {
                    Pe.component("Ckeditor", _t)
                }, component: _t
            }
        })(), A = A.default
    })())
})(z5);
var RV = z5.exports;
const zV = of(RV), _v = X0(OV);
_v.use(F8);
_v.use(zV);
_v.mount("#app");
